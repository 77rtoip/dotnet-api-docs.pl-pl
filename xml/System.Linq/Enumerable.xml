<Type Name="Enumerable" FullName="System.Linq.Enumerable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7a3de6f112ceeca9164631f03f1f84455a634d52" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51925423" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Enumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Enumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Enumerable" />
  <TypeSignature Language="VB.NET" Value="Public Module Enumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Enumerable abstract sealed" />
  <TypeSignature Language="F#" Value="type Enumerable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera zestaw <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metody do tworzenia zapytań o obiekty, które implementują <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody tej klasy dostarczać implementację standardowych operatorów zapytań dla kwerendy danych źródła, które implementują <xref:System.Collections.Generic.IEnumerable%601>. Standardowe operatory zapytań są metodami ogólnego przeznaczenia, które należy wykonać [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] wzorca i umożliwiają express operacji przechodzenia, filtru i projekcji danych we wszystkich. Języka programowania opartego na sieci.  
  
 Większość metod w tej klasie są zdefiniowane jako metody rozszerzenia, które rozszerzają <xref:System.Collections.Generic.IEnumerable%601>. Oznacza to, może być wywoływana takich jak metoda wystąpienia dla dowolnego obiektu, który implementuje <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Metody, które są używane w zapytaniu, które zwraca sekwencję wartości nie korzystają z danych docelowego, dopóki obiekt zapytania jest zostanie wyliczonly. Jest to nazywane odroczonego wykonania. Metody, które są używane w zapytaniu, która zwraca wartość pojedynczych wykonywania i natychmiast korzystają z danych docelowych.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2">Standardowe operatory zapytań — Omówienie</related>
    <related type="Article" href="https://msdn.microsoft.com/library/175ce3ff-9bbf-4e64-8421-faeb81a0bb51">Metody rozszerzeń (Przewodnik programowania w języku C#)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b8020aae-374d-46a9-bcb7-8cc2390b93b6">Metody rozszerzeń (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As IEnumerable(Of TSource), func As Func(Of TSource, TSource, TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TSource, TSource&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * Func&lt;'Source, 'Source, 'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do agregacji over.</param>
        <param name="func">Funkcję akumulatora po do wywołania dla każdego elementu.</param>
        <summary>Stosuje funkcję akumulatora po sekwencji.</summary>
        <returns>Wartość akumulatora końcowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> Metoda pozwala w prosty sposób wykonują obliczenie za pośrednictwem je sekvence hodnot. Ta metoda działa przez wywołanie metody `func` jeden raz dla każdego elementu w `source` z wyjątkiem pierwszej. Każdorazowo `func` jest wywoływana, <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> przekazuje zarówno element z sekwencji i zagregowane wartości (jako pierwszy argument `func`). Pierwszy element `source` jest używana jako początkowa zagregowanej wartości. Wynik `func` zastępuje poprzednią wartość zagregowaną. <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> Zwraca wynik końcowy `func`.  
  
 To przeciążenie <xref:System.Linq.Enumerable.Aggregate%2A> metoda nie jest odpowiednia dla wszystkich przypadków, ponieważ używa ona pierwszy element `source` jako początkowej zagregowanej wartości. Należy wybrać innego przeciążenia metody, jeśli wartość zwracaną powinna zawierać tylko elementy `source` spełniające określony warunek. Na przykład tego przeciążenia nie jest niezawodne, jeśli chcesz obliczyć sumę liczb parzystych w `source`. Wynik będzie nieprawidłowa, jeśli pierwszy element jest nieparzysta zamiast nawet.  
  
 Aby uprościć typowych operacji agregacji, standardowych operatorów zapytań także metodę liczba ogólnego przeznaczenia <xref:System.Linq.Enumerable.Count%2A>i cztery metody agregacji liczbowe, a mianowicie <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, i <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak odwrócić kolejność słów w ciągu przy użyciu <xref:System.Linq.Enumerable.Aggregate%2A>.  
  
 [!code-csharp[System.Linq.Enumerable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#1)]
 [!code-vb[System.Linq.Enumerable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="func" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As IEnumerable(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate)) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; -&gt; 'Accumulate" Usage="System.Linq.Enumerable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TAccumulate">Typ wartości akumulatora.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do agregacji over.</param>
        <param name="seed">Wartość akumulatora początkowe.</param>
        <param name="func">Funkcję akumulatora po do wywołania dla każdego elementu.</param>
        <summary>Stosuje funkcję akumulatora po sekwencji. Wartość inicjatora określona jest używana jako wartość akumulatora początkowe.</summary>
        <returns>Wartość akumulatora końcowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> Metoda pozwala w prosty sposób wykonują obliczenie za pośrednictwem je sekvence hodnot. Ta metoda działa przez wywołanie metody `func` jeden raz dla każdego elementu w `source`. Każdorazowo `func` jest wywoływana, <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> przekazuje zarówno element z sekwencji i zagregowane wartości (jako pierwszy argument `func`). Wartość `seed` parametr jest używany jako początkowa zagregowanej wartości. Wynik `func` zastępuje poprzednią wartość zagregowaną. <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> Zwraca wynik końcowy `func`.  
  
 Aby uprościć typowych operacji agregacji, standardowych operatorów zapytań także metodę liczba ogólnego przeznaczenia <xref:System.Linq.Enumerable.Count%2A>i cztery metody agregacji liczbowe, a mianowicie <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, i <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Aggregate%2A> Aby zastosować funkcję akumulatora po i za pomocą wartości początkowej.  
  
 [!code-csharp[System.Linq.Enumerable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#2)]
 [!code-vb[System.Linq.Enumerable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="func" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As IEnumerable(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Aggregate (source, seed, func, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TAccumulate">Typ wartości akumulatora.</typeparam>
        <typeparam name="TResult">Typ wartości wynikowej.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do agregacji over.</param>
        <param name="seed">Wartość akumulatora początkowe.</param>
        <param name="func">Funkcję akumulatora po do wywołania dla każdego elementu.</param>
        <param name="resultSelector">Funkcja do przekształcania wartości końcowej akumulatora po wartości wyniku.</param>
        <summary>Stosuje funkcję akumulatora po sekwencji. Wartość inicjatora określona jest używana jako wartość akumulatora początkowe i określona funkcja jest używany do wybierania wartości wyniku.</summary>
        <returns>Wartość po przekształceniu akumulatora końcowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> Metoda pozwala w prosty sposób wykonują obliczenie za pośrednictwem je sekvence hodnot. Ta metoda działa przez wywołanie metody `func` jeden raz dla każdego elementu w `source`. Każdorazowo `func` jest wywoływana, <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> przekazuje zarówno element z sekwencji i zagregowane wartości (jako pierwszy argument `func`). Wartość `seed` parametr jest używany jako początkowa zagregowanej wartości. Wynik `func` zastępuje poprzednią wartość zagregowaną. Wynik końcowy `func` jest przekazywany do `resultSelector` można uzyskać wynik końcowy <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>.  
  
 Aby uprościć typowych operacji agregacji, standardowych operatorów zapytań także metodę liczba ogólnego przeznaczenia <xref:System.Linq.Enumerable.Count%2A>i cztery metody agregacji liczbowe, a mianowicie <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, i <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Aggregate%2A> stosować funkcję akumulatora po i selektor wynik.  
  
 [!code-csharp[System.Linq.Enumerable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#3)]
 [!code-vb[System.Linq.Enumerable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="func" /> lub <paramref name="resultSelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.Enumerable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawiera elementy do predykatu do zastosowania.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Określa, czy wszystkie elementy w sekwencji spełniają warunek.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie elementy sekwencji źródłowej przejdzie test w określony predykat lub sekwencji jest pusta. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda nie zwraca elementów kolekcji. Zamiast tego Określa, czy wszystkie elementy kolekcji spełniają warunek.  
  
 Wyliczanie `source` zostanie zatrzymana, tak szybko, jak można ustalić wyniku.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into All()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.All%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.All%2A> do określenia, czy wszystkie elementy w sekwencji spełniają warunek. Zmienna `allStartWithB` ma wartość true, jeśli wszystkie nazwy pet rozpoczynać się od "B" lub `pets` tablica jest pusta.  
  
 [!code-csharp[System.Linq.Enumerable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#4)]
 [!code-vb[System.Linq.Enumerable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#4)]  
  
 Wartość logiczna, która <xref:System.Linq.Enumerable.All%2A> metoda zwróci wartość jest zazwyczaj używany w predykacie `where` — klauzula (`Where` klauzuli w języku Visual Basic) lub bezpośrednie wywołanie <xref:System.Linq.Enumerable.Where%2A> metody. W poniższym przykładzie pokazano użycie tego `All` metody.  
  
 [!code-csharp[System.Linq.Enumerable#129](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#129)]
 [!code-vb[System.Linq.Enumerable#129](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#129)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy jakiegokolwiek elementu w sekwencji istnieje, czy spełnia warunek.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Pod kątem emptiness.</param>
        <summary>Określa, czy sekwencja zawiera żadnych elementów.</summary>
        <returns>
          <see langword="true" /> Jeśli sekwencja źródłowa zawiera wszystkie elementy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda nie zwraca dowolny jeden element w kolekcji. Zamiast tego Określa, czy kolekcja zawiera żadnych elementów.  
  
 Wyliczanie `source` zostanie zatrzymana, tak szybko, jak można ustalić wyniku.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Any()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Any%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Any%2A> do określenia, czy sekwencja zawiera żadnych elementów.  
  
 [!code-csharp[System.Linq.Enumerable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#5)]
 [!code-vb[System.Linq.Enumerable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#5)]  
  
 Wartość logiczna, która <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> metoda zwróci wartość jest zazwyczaj używany w predykacie `where` — klauzula (`Where` klauzuli w języku Visual Basic) lub bezpośrednie wywołanie <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> metody. W poniższym przykładzie pokazano użycie tego `Any` metody.  
  
 [!code-csharp[System.Linq.Enumerable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#130)]
 [!code-vb[System.Linq.Enumerable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.Enumerable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do stosowania predykatu, do której elementy.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Określa, czy jakiegokolwiek elementu w sekwencji spełniają warunek.</summary>
        <returns>
          <see langword="true" /> Jeśli dowolne elementy w sekwencji źródłowej Przekaż test określony predykat; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda nie zwraca dowolny jeden element w kolekcji. Zamiast tego Określa, czy wszystkie elementy kolekcji spełniają warunek.  
  
 Wyliczanie `source` zostanie zatrzymana, tak szybko, jak można ustalić wyniku.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Any()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Any%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Any%2A> do określenia, czy dowolnego elementu w sekwencji spełniają warunek.  
  
 [!code-csharp[System.Linq.Enumerable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#6)]
 [!code-vb[System.Linq.Enumerable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource) (source As IEnumerable(Of TSource), element As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Append(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Append : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Append (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości.</param>
        <param name="element">Wartość do dołączenia do <paramref name="source" />.</param>
        <summary>Dołącza wartość do końca sekwencji.</summary>
        <returns>Nową sekwencję, która kończy się <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda nie powoduje modyfikacji elementów kolekcji. Zamiast tego tworzy kopię kolekcji za pomocą nowego elementu.
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Append%2A> można dołączyć wartość do końca sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#201](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#201)]
 [!code-vb[System.Linq.Enumerable#201](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#201)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsEnumerable(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsEnumerable(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsEnumerable : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.AsEnumerable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja na typ jako <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Zwraca dane wejściowe wpisanych w formie <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Sekwencji wejściowych wpisanych w formie <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Metoda nie ma wpływu innych niż zmiany typu kompilacji `source` z typu, który implementuje <xref:System.Collections.Generic.IEnumerable%601> do <xref:System.Collections.Generic.IEnumerable%601> sam.  
  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> można wybrać między implementacjami zapytania, gdy sekwencja implementuje <xref:System.Collections.Generic.IEnumerable%601> , ale również ma inny zestaw dostępnych metod publicznych zapytania. Na przykład, biorąc klasy ogólnej `Table` implementującej <xref:System.Collections.Generic.IEnumerable%601> i ma swoje własne metody, na przykład `Where`, `Select`, i `SelectMany`, wywołanie `Where` powodowałoby wywołanie pliku wykonywalnego publicznie `Where` metoda `Table`. A `Table` typ, który reprezentuje tabelę bazy danych może mieć `Where` metodę, która przyjmuje argument predykatu, jako drzewo wyrażenia i konwertuje drzewa do bazy danych SQL w zakresie wykonywania zdalnego. Jeśli zdalne wykonywanie kodu jest niepożądany, na przykład ponieważ predykat wywołuje metodę lokalnego <xref:System.Linq.Enumerable.AsEnumerable%2A> metoda może służyć do ukrywania niestandardowych metod i zamiast tego Udostępnij standardowych operatorów zapytań.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> ukryć typu użytkownika niestandardowego `Where` metody, gdy wymagane jest wykonanie operator standardowego zapytania.  
  
 [!code-csharp[System.Linq.Enumerable#108](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#108)]
 [!code-vb[System.Linq.Enumerable#108](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza średnią sekwencję wartości liczbowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Decimal" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> do obliczenia średniej je sekvence hodnot.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Double" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Double" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli suma liczby elementów jest zbyt duży, aby przedstawić jako <xref:System.Double>, ta metoda zwraca wartość dodatnia lub ujemna nieskończoność.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;int&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int32" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> do obliczenia średniej.  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;int64&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int64" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Decimal" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma elementów w sekwencji jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Double" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Double" /> wartości.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli suma liczby elementów jest zbyt duży, aby przedstawić jako <xref:System.Double>, ta metoda zwraca wartość dodatnia lub ujemna nieskończoność.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Int32" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma elementów w sekwencji jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Int64" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej.  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma elementów w sekwencji jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Single" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Single" /> wartości.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Single" /> wartości do obliczenia średniej.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Single" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Decimal" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <exception cref="T:System.OverflowException">Suma elementów w sekwencji jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Double" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Int32" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> do obliczenia średniej.  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <exception cref="T:System.OverflowException">Suma elementów w sekwencji jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów źródła.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Int64" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> do obliczenia średniej.  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <exception cref="T:System.OverflowException">Suma elementów w sekwencji jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Decimal" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma elementów w sekwencji jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Double" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Int32" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma elementów w sekwencji jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Int64" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji dopuszczającego wartość null <see cref="T:System.Single" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencja wartości lub <see langword="null" /> Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Single" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Average()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> do obliczenia średniej.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As IEnumerable) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Cast(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Collections.IEnumerable -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ rzutowania elementy <c>źródła</c> do.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.IEnumerable" /> Zawiera elementy, można rzutować na typ <c>TResult</c>.</param>
        <summary>Rzutuje elementy <see cref="T:System.Collections.IEnumerable" /> do określonego typu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający każdego elementu w sekwencji źródłowej rzutowanie do określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> Metoda umożliwia standardowych operatorów zapytań do wywołania w kolekcjach nieogólnego, podając informacje o typie niezbędne. Na przykład <xref:System.Collections.ArrayList> nie implementuje <xref:System.Collections.Generic.IEnumerable%601>, ale przez wywołanie metody <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> na <xref:System.Collections.ArrayList> obiektu standardowych operatorów zapytań mogą następnie służyć do kwerendy sekwencji.  
  
 Jeśli element nie można przekonwertować na typ `TResult`, ta metoda wyrzuca <xref:System.InvalidCastException>.

 Sekwencja źródłowa dla tej metody jest <xref:System.Collections.IEnumerable>, co oznacza, że elementy mają kompilacji typu statycznego `object`. Tylko konwersje typów, które są wykonywane przez tę metodę są konwersje odwołań i konwersji unboxing. Typ środowiska uruchomieniowego elementów w kolekcji musi być zgodny typ docelowy lub w przypadku typów wartości, typ środowiska uruchomieniowego elementów musi być wynikiem opakowywanie konwersji na typ docelowy. Inne typy konwersji, takich jak między różne typy liczbowe, nie są dozwolone. 
 
 Aby uzyskać tylko te elementy, które mogą być konwertowane na typ `TResult`, użyj <xref:System.Linq.Enumerable.OfType%2A> zamiast metody <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 W wyrażeniu zapytania Zmienna iteracji jawnie wpisanych przekłada się na wywołanie <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>. Ten przykład przedstawia składnię dla zakresu jawnie wpisanych zmiennych.  
  
```csharp  
from int i in objects  
```  
  
```vb  
From i As Integer In objects  
```  

Użyj `select` klauzuli kwerendy do wykonania innych typów konwersji, takich jak niejawnych konwersji liczbowych. W poniższym przykładzie użyto obu `Cast` metody i `select` instrukcję w celu konwersji sekwencji liczb całkowitych spakowany sekwencję wartości podwójnej precyzji.

```csharp
IEnumerable sequence = Enumerable.Range(0, 10);
var doubles = from int item in sequence
                select (double)item;
``` 

```vb
Dim sequence As IEnumerable = Enumerable.Range(0, 10)
Dim doubles = From item As Integer In sequence
                Select CType(item, Double)
```

## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> umożliwia użycie standardowych operatorów zapytań w <xref:System.Collections.ArrayList>.  
  
 [!code-csharp[System.Linq.Enumerable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#19)]
 [!code-vb[System.Linq.Enumerable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Nie można rzutować elementu w sekwencji na typ <paramref name="TResult" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1aefd18c-1314-47f8-99ec-9bcefb09e699">Klauzula From (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/83e3665e-68a0-4540-a3a3-3d777a0f95d5">From — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Concat(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="first">Pierwsza sekwencja do łączenia.</param>
        <param name="second">Sekwencja do łączenia się do pierwszej sekwencji.</param>
        <summary>Łączy dwie sekwencje.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierającą połączone elementy dwóch sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Metoda różni się od <xref:System.Linq.Enumerable.Union%2A> metody ponieważ <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metoda zwraca wszystkie elementy z oryginalnej sekwencji wejściowych. <xref:System.Linq.Enumerable.Union%2A> Metoda zwraca tylko unikatowych elementów.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> do łączenia dwóch sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#20)]
 [!code-vb[System.Linq.Enumerable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#20)]  
  
 Alternatywny sposób łączenia dwóch sekwencji jest konstruuje kolekcję, na przykład tablicy, sekwencji, a następnie zastosować <xref:System.Linq.Enumerable.SelectMany%2A> metody i przekazanie do niej funkcji Selektor tożsamości. W poniższym przykładzie pokazano użycie tego <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
 [!code-csharp[System.Linq.Enumerable#112](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#112)]
 [!code-vb[System.Linq.Enumerable#112](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy sekwencja zawiera określony element.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IEnumerable(Of TSource), value As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource value);" />
      <MemberSignature Language="F#" Value="static member Contains : seq&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.Enumerable.Contains (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja, w której chcesz zlokalizować wartość.</param>
        <param name="value">Wartość do zlokalizowania w sekwencji.</param>
        <summary>Określa, czy sekwencja zawiera określony element przy użyciu domyślny moduł porównujący równość.</summary>
        <returns>
          <see langword="true" /> Jeśli sekwencja źródłowa zawiera element, który ma określoną wartość, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `source` implementuje <xref:System.Collections.Generic.ICollection%601>, `Contains` wywoływana jest metoda w tej implementacji w celu uzyskania wyniku. W przeciwnym razie ta metoda określa, czy `source` zawiera określony element.  
  
 Wyliczenie zostanie zakończony, gdy tylko zostanie znaleziony pasujący element.  
  
 Elementy są porównywane z podaną wartością za pomocą domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Contains%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> do określenia, czy tablica zawiera określony element.  
  
 [!code-csharp[System.Linq.Enumerable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#21)]
 [!code-vb[System.Linq.Enumerable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IEnumerable(Of TSource), value As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource value, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : seq&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.Contains (source, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja, w której chcesz zlokalizować wartość.</param>
        <param name="value">Wartość do zlokalizowania w sekwencji.</param>
        <param name="comparer">Moduł porównujący równość do porównywania wartości.</param>
        <summary>Określa, czy sekwencja zawiera określony element przy użyciu określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli sekwencja źródłowa zawiera element, który ma określoną wartość, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczenie zostanie zakończony, gdy tylko zostanie znaleziony pasujący element.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania elementów na określoną wartość.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zaimplementować moduł porównujący równość mogą być używane w <xref:System.Linq.Enumerable.Contains%2A> metody.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Po zaimplementowaniu tej porównania można użyć sekwencji `Product` obiekty w <xref:System.Linq.Enumerable.Contains%2A> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQCustomComparer#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#6)]
 [!code-vb[CSLINQCustomComparer#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca liczbę elementów w sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IEnumerable(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : seq&lt;'Source&gt; -&gt; int" Usage="System.Linq.Enumerable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencji, który zawiera elementy do zliczenia.</param>
        <summary>Zwraca liczbę elementów w sekwencji.</summary>
        <returns>Liczba elementów w sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `source` implementuje <xref:System.Collections.Generic.ICollection%601>, tę implementację zostaje użyty do uzyskania łącznej liczby elementów. W przeciwnym razie ta metoda określa liczbę.  
  
 Użyj <xref:System.Linq.Enumerable.LongCount%2A> metody, gdy oczekiwane i chcesz dać wynik, który ma być większa niż <xref:System.Int32.MaxValue>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Count()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zliczania elementów w tablicy.  
  
 [!code-csharp[System.Linq.Enumerable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#22)]
 [!code-vb[System.Linq.Enumerable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Liczba elementów w <paramref name="source" /> jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int" Usage="System.Linq.Enumerable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja zawiera elementy do ich przetestowanie i uwzględniane.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca liczbę reprezentującą liczbę elementów w określonej sekwencji spełniają warunek.</summary>
        <returns>Liczba, która przedstawia, jak wiele elementów w sekwencji spełniają warunek w funkcji predykatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `source` implementuje <xref:System.Collections.Generic.ICollection%601>, tę implementację zostaje użyty do uzyskania łącznej liczby elementów. W przeciwnym razie ta metoda określa liczbę.  
  
 Należy używać <xref:System.Linq.Enumerable.LongCount%2A> metody, gdy oczekiwane i chcesz dać wynik, który ma być większa niż <xref:System.Int32.MaxValue>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Count()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> zliczania elementów w tablicy, które spełniają warunek.  
  
 [!code-csharp[System.Linq.Enumerable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#23)]
 [!code-vb[System.Linq.Enumerable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Liczba elementów w <paramref name="source" /> jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca elementy <see cref="T:System.Collections.Generic.IEnumerable`1" />, lub domyślny zwracającej zbierania singleton, jeśli sekwencja jest pusta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ DefaultIfEmpty(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja do zwrócenia wartości domyślnej, jeśli jest on pusty.</param>
        <summary>Zwraca elementy w określonej sekwencji lub wartość domyślną parametru typu w zbierania singleton, jeśli sekwencja jest pusty.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Obiekt, który zawiera wartość domyślną dla <paramref name="TSource" /> wpisz Jeśli <paramref name="source" /> jest pusty; w przeciwnym razie <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Wartością domyślną dla odwołania i typów zerowalnych jest `null`.  
  
 Ta metoda może służyć do tworzenia lewe sprzężenie zewnętrzne w połączeniu z <xref:System.Linq.Enumerable.GroupJoin%2A>) metody.  
  
   
  
## Examples  
 Poniższe przykłady kodu przedstawiają sposoby użycia <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> podać wartość domyślna w przypadku, gdy sekwencja źródłowa jest pusta.  
  
 W tym przykładzie użyto niepustej sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#24)]
 [!code-vb[System.Linq.Enumerable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#24)]  
  
 W tym przykładzie użyto pustą sekwencją.  
  
 [!code-csharp[System.Linq.Enumerable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#25)]
 [!code-vb[System.Linq.Enumerable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Łączenie</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IEnumerable(Of TSource), defaultValue As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ DefaultIfEmpty(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja zwracana wartość określona dla, gdy jest on pusty.</param>
        <param name="defaultValue">Wartość zwracana, jeśli sekwencja jest pusty.</param>
        <summary>Zwraca elementy w określonej sekwencji lub określoną wartość w zbierania singleton, jeśli sekwencja jest pusty.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <paramref name="defaultValue" /> Jeśli <paramref name="source" /> jest pusty; w przeciwnym razie <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Ta metoda może służyć do tworzenia lewe sprzężenie zewnętrzne w połączeniu z <xref:System.Linq.Enumerable.GroupJoin%2A>) metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> metodę i określić wartości domyślnej. Pierwszej sekwencji nie jest pusty, a drugiej sekwencji jest pusty.  
  
 [!code-csharp[System.Linq.Enumerable#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#26)]
 [!code-vb[System.Linq.Enumerable#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#26)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Łączenie</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca odrębne elementy z sekwencji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sekwencja wynik to nieuporządkowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Distinct(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja, aby usunąć zduplikowane elementy z.</param>
        <summary>Zwraca odrębne elementy z sekwencji za pomocą domyślny moduł porównujący równość do porównywania wartości.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający odrębne elementy z sekwencji źródłowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Metoda zwraca nieuporządkowaną sekwencji, która nie zawiera zduplikowane wartości. Używa ona domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, aby porównać wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Distinct` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Distinct%2A>.  
  
 Domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania wartości typów implementujących <xref:System.IEquatable%601> interfejs generyczny. Aby porównać niestandardowy typ danych, należy zaimplementować niniejszy interfejs i podać własne <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metod dla typu.  
  
 Aby uzyskać przykład, który używa <xref:System.Collections.Generic.IEqualityComparer%601> do definiowania niestandardowej funkcji porównującej, zobacz <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> do zwrócenia odrębnych elementach z sekwencją liczb całkowitych.  
  
 [!code-csharp[System.Linq.Enumerable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#27)]
 [!code-vb[System.Linq.Enumerable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#27)]  
  
 Jeśli chcesz przywrócić odrębnych elementach z sekwencji obiektów określonego typu danych niestandardowych, należy zaimplementować <xref:System.IEquatable%601> ogólny interfejs w klasie. Poniższy przykład kodu pokazuje sposób implementacji niniejszego interfejsu do niestandardowego typu danych i zapewniają <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metody.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#1)]
 [!code-vb[CSLINQEncapsulatedComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#1)]  
  
 Po zaimplementowaniu ten interfejs może skorzystać z sekwencji `Product` obiekty w <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#5)]
 [!code-vb[CSLINQEncapsulatedComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/86f42614-0d8f-4ffc-b888-ce8a37a8d36a">Distinct — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Distinct(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja, aby usunąć zduplikowane elementy z.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania wartości.</param>
        <summary>Zwraca odrębne elementy z sekwencji przy użyciu określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> do porównywania wartości.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający odrębne elementy z sekwencji źródłowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Metoda zwraca nieuporządkowaną sekwencji, która nie zawiera zduplikowane wartości. Jeśli `comparer` jest `null`, domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania wartości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zaimplementować moduł porównujący równość mogą być używane w <xref:System.Linq.Enumerable.Distinct%2A> metody.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Po zaimplementowaniu tej porównania można użyć sekwencji `Product` obiekty w <xref:System.Linq.Enumerable.Distinct%2A> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQCustomComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#5)]
 [!code-vb[CSLINQCustomComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As IEnumerable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : seq&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Enumerable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrotu elementu.</param>
        <param name="index">Liczony od zera indeks elementu do pobrania.</param>
        <summary>Zwraca element z określonym indeksem w sekwencji.</summary>
        <returns>Element w określonej pozycji w sekwencji źródłowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `source` implementuje <xref:System.Collections.Generic.IList%601>, tę implementację służy do uzyskiwania element pod określonym indeksem. W przeciwnym razie ta metoda pobiera określony element.  
  
 Ta metoda zgłasza wyjątek, jeśli `index` znajduje się poza zakresem. Aby zamiast tego należy zwrócić wartość domyślną, gdy określony indeks jest poza zakresem, użyj <xref:System.Linq.Enumerable.ElementAtOrDefault%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.ElementAt%2A> do zwrotu elementu na określonej pozycji.  
  
 [!code-csharp[System.Linq.Enumerable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#28)]
 [!code-vb[System.Linq.Enumerable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0 lub większa niż lub równa liczbie elementów w <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As IEnumerable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : seq&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Enumerable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrotu elementu.</param>
        <param name="index">Liczony od zera indeks elementu do pobrania.</param>
        <summary>Zwraca element pod określonym indeksem w sekwencji lub wartość domyślną, jeśli indeks jest poza zakresem.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) Jeśli indeks jest poza granicami sekwencji źródłowej; w przeciwnym razie element w określonej pozycji w sekwencji źródłowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `source` implementuje <xref:System.Collections.Generic.IList%601>, tę implementację służy do uzyskiwania element pod określonym indeksem. W przeciwnym razie ta metoda pobiera określony element.  
  
 Wartością domyślną dla odwołania i typów zerowalnych jest `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.ElementAtOrDefault%2A>. W tym przykładzie użyto indeksu, który znajduje się poza granicami tablicy.  
  
 [!code-csharp[System.Linq.Enumerable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#29)]
 [!code-vb[System.Linq.Enumerable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Empty(Of TResult) () As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">Typ do przypisania do parametru typu ogólnego zwrócone <see cref="T:System.Collections.Generic.IEnumerable`1" />.</typeparam>
        <summary>Zwraca pustą <see cref="T:System.Collections.Generic.IEnumerable`1" /> zawierający argumentu określonego typu.</summary>
        <returns>Pusta <see cref="T:System.Collections.Generic.IEnumerable`1" /> którego argument typu jest <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Empty%60%601> Metoda buforuje pustą sekwencją typu `TResult`. Gdy obiekt, zwracana jest zostanie wyliczonly, daje żadnych elementów.  
  
 W niektórych przypadkach ta metoda jest przydatne w przypadku przekazywania pustą sekwencją do metody zdefiniowanej przez użytkownika zajmuje <xref:System.Collections.Generic.IEnumerable%601>. Może również służyć do generowania elementu neutralnej dla metod, takich jak <xref:System.Linq.Enumerable.Union%2A>. Przykładem użycia tego w sekcji przykład <xref:System.Linq.Enumerable.Empty%60%601>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Empty%60%601> do generowania pustego <xref:System.Collections.Generic.IEnumerable%601>.  
  
 [!code-csharp[System.Linq.Enumerable#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#30)]
 [!code-vb[System.Linq.Enumerable#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#30)]  
  
 Poniższy przykład kodu demonstruje możliwości stosowania <xref:System.Linq.Enumerable.Empty%60%601> metody. <xref:System.Linq.Enumerable.Aggregate%2A> Metoda jest stosowana do kolekcji tablic ciągów. Elementy w kolekcji tablic są dodawane do wynikowy <xref:System.Collections.Generic.IEnumerable%601> tylko wtedy, gdy ta tablica zawiera cztery lub więcej elementów. <xref:System.Linq.Enumerable.Empty%2A> Służy do generowania wartości początkowej dla <xref:System.Linq.Enumerable.Aggregate%2A> ponieważ jeśli żadna macierz w kolekcji zawiera co najmniej cztery elementy, zwracany jest tylko pustą sekwencją.  
  
 [!code-csharp[System.Linq.Enumerable#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#31)]
 [!code-vb[System.Linq.Enumerable#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy różnicy dwóch sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy, które nie znajdują się również w <c>drugi</c> zostaną zwrócone.</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Którego elementy, które również wystąpić w pierwszej kolejności spowoduje, że te elementy były usuwane z zwracanej sekwencji.</param>
        <summary>Tworzy różnicy dwóch sekwencji za pomocą domyślny moduł porównujący równość do porównywania wartości.</summary>
        <returns>Sekwencja, który zawiera zestawu różnic elementy dwóch sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Różnicy dwóch zestawów jest zdefiniowany jako elementy członkowskie pierwszy zestaw, które nie pojawiają się w drugim zbiorze.  
  
> [!NOTE]
>  Ta metoda zwraca te elementy w `first` , nie występują na liście `second`. Nie zwraca również te elementy w `second` , nie występują na liście `first`.  
  
 Domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania wartości typów implementujących <xref:System.Collections.Generic.IEqualityComparer%601> interfejs generyczny. Aby porównać niestandardowy typ danych, należy zaimplementować niniejszy interfejs i podać własne <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metod dla typu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodę, aby porównać dwie sekwencje liczb i zwracają elementy, które są wyświetlane tylko w pierwszej sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#34)]
 [!code-vb[System.Linq.Enumerable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#34)]  
  
 Jeśli chcesz porównać sekwencji obiektów określonego typu danych niestandardowych, należy zaimplementować <xref:System.Collections.Generic.IEqualityComparer%601> ogólny interfejs w helperclass. Poniższy przykład kodu pokazuje sposób implementacji niniejszego interfejsu do niestandardowego typu danych i zapewniają <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metody.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Po zaimplementowaniu ten interfejs, można użyć sekwencji `ProductA` obiekty w <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#7)]
 [!code-vb[CSLINQEncapsulatedComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy, które nie znajdują się również w <c>drugi</c> zostaną zwrócone.</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Którego elementy, które również wystąpić w pierwszej kolejności spowoduje, że te elementy były usuwane z zwracanej sekwencji.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania wartości.</param>
        <summary>Tworzy różnicy dwóch sekwencji przy użyciu określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> do porównywania wartości.</summary>
        <returns>Sekwencja, który zawiera zestawu różnic elementy dwóch sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania wartości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zaimplementować moduł porównujący równość mogą być używane w <xref:System.Linq.Enumerable.Except%2A> metody.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Po zaimplementowaniu tej porównania można użyć sekwencji `Product` obiekty w <xref:System.Linq.Enumerable.Except%2A> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQCustomComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#7)]
 [!code-vb[CSLINQCustomComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca pierwszy element w sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrócenia pierwszego elementu.</param>
        <summary>Zwraca pierwszy element w sekwencji.</summary>
        <returns>Pierwszy element w określonej sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Metoda zgłasza wyjątek, jeśli `source` nie zawiera żadnych elementów. Aby zamiast tego należy przywrócić wartość domyślną, jeśli sekwencja źródłowa jest pusta, należy użyć <xref:System.Linq.Enumerable.FirstOrDefault%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> do zwrócenia pierwszego elementu w tablicy.  
  
 [!code-csharp[System.Linq.Enumerable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#35)]
 [!code-vb[System.Linq.Enumerable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrotu elementu.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca pierwszy element w sekwencji, który spełnia określony warunek.</summary>
        <returns>Pierwszy element w sekwencji, do której przejdzie test w określonej funkcji predykatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Metoda zgłasza wyjątek, jeśli nie znaleziono w `source`. Zamiast tego należy zwrócić wartość domyślną, gdy zostanie znaleziony żaden element dopasowania, <xref:System.Linq.Enumerable.FirstOrDefault%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> do zwrócenia pierwszego elementu w tablicy, która spełnia warunek.  
  
 [!code-csharp[System.Linq.Enumerable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#36)]
 [!code-vb[System.Linq.Enumerable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Element nie spełnia warunku w <paramref name="predicate" />.  
  
—lub— 
Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca pierwszy element sekwencji lub wartość domyślną, jeśli zostanie znaleziony żaden element.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrócenia pierwszego elementu.</param>
        <summary>Zwraca pierwszy element sekwencji lub wartość domyślną, jeśli sekwencja nie zawiera żadnych elementów.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) Jeśli <paramref name="source" /> jest pusty; w przeciwnym razie pierwszy element w <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartością domyślną dla odwołania i typów zerowalnych jest `null`.  
  
 <xref:System.Linq.Enumerable.FirstOrDefault%2A> Metody nie umożliwiają określenie wartości domyślnej. Jeśli chcesz określić inne niż wartości domyślnej `default(TSource)`, użyj <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> metoda zgodnie z opisem w sekcji przykład.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> na pustą tablicę.  
  
 [!code-csharp[System.Linq.Enumerable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#37)]
 [!code-vb[System.Linq.Enumerable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#37)]  
  
 Czasami wartość `default(TSource)` nie jest wartością domyślną, którego chcesz użyć, jeśli kolekcja zawiera żadnych elementów. Zamiast sprawdzania wyników dla wartości domyślnej niepożądane, a następnie zmieniając go, jeśli to konieczne, możesz użyć <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> metodę, aby określić wartość domyślną, którą chcesz użyć, jeśli kolekcja jest pusta. Następnie wywołaj <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> można uzyskać pierwszego elementu. Poniższy przykład kodu korzysta z obu tych technik uzyskanie domyślną wartość 1, jeśli kolekcja miesięcy liczbowych jest pusta. Całkowitą wartość domyślna to 0, co odpowiada miesiącu, wartość domyślna musi zostać określony jako 1 zamiast tego. Pierwszy zmiennej wynikowej są sprawdzane pod kątem wartość domyślną niepożądane, po zakończeniu zapytania podczas wykonywania. Druga zmienna wyniku uzyskuje się za pomocą <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> można określić wartość domyślną 1.  
  
 [!code-csharp[System.Linq.Enumerable#126](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#126)]
 [!code-vb[System.Linq.Enumerable#126](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#126)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrotu elementu.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca pierwszy element w sekwencji, która spełnia warunek, lub wartość domyślną, jeśli taki element nie zostanie znaleziony.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) Jeśli <paramref name="source" /> są puste lub jeśli element nie przekazuje testu określonego przez <paramref name="predicate" />; w przeciwnym razie pierwszy element w <paramref name="source" /> , który przekazuje testu określonego przez <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartością domyślną dla odwołania i typów zerowalnych jest `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> , przekazując w predykacie. W drugim wywołaniu do metody nie ma żadnego elementu w tablicy, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Enumerable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#38)]
 [!code-vb[System.Linq.Enumerable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grupuje elementy sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IEnumerable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy należy pogrupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <summary>Grupuje elementy sekwencji zgodnie z funkcją określonego selektora kluczy.</summary>
        <returns>
          <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt; &gt;</c> w języku C# lub <c>IEnumerable (Of IGrouping (Of TKey, TSource))</c> w Visual Basic gdzie każdy <see cref="T:System.Linq.IGrouping`2" /> obiektu zawiera sekwencję obiektów, jak i klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
> [!NOTE]
>  Przykłady `GroupBy`, zobacz następujące tematy.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> Metoda zwraca kolekcję <xref:System.Linq.IGrouping%602> obiektów, po jednym dla każdego klucza distinct, który wystąpił. <xref:System.Linq.IGrouping%602> Jest <xref:System.Collections.Generic.IEnumerable%601> która także ma klucz skojarzony ze swoimi elementami.  
  
 <xref:System.Linq.IGrouping%602> Obiekty są uzyskane na podstawie kolejności elementów w `source` który wytworzył pierwszy klucz <xref:System.Linq.IGrouping%602>. Elementy w metodzie grupowania są uzyskane w kolejności, pojawiają się na `source`.  
  
 Domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
 W składni wyrażeń zapytania `group by` (Visual C#) lub `Group By Into` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.GroupBy%2A>. Aby uzyskać więcej informacji i przykłady użycia, zobacz [group — klauzula](~/docs/csharp/language-reference/keywords/group-clause.md) i [grupy przez klauzulę](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group — Klauzula (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy należy pogrupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Grupuje elementy sekwencji zgodnie z funkcją określonego selektora kluczy i porównuje klucze za pomocą określona funkcja porównująca.</summary>
        <returns>
          <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt; &gt;</c> w języku C# lub <c>IEnumerable (Of IGrouping (Of TKey, TSource))</c> w Visual Basic gdzie każdy <see cref="T:System.Linq.IGrouping`2" /> obiekt zawiera zbiór obiektów, jak i klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
> [!NOTE]
>  Przykłady `GroupBy`, zobacz następujące tematy.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Metoda zwraca kolekcję <xref:System.Linq.IGrouping%602> obiektów, po jednym dla każdego klucza distinct, który wystąpił. <xref:System.Linq.IGrouping%602> Jest <xref:System.Collections.Generic.IEnumerable%601> która także ma klucz skojarzony ze swoimi elementami.  
  
 <xref:System.Linq.IGrouping%602> Obiekty są uzyskane na podstawie kolejności elementów w `source` który wytworzył pierwszy klucz <xref:System.Linq.IGrouping%602>. Elementy w metodzie grupowania są uzyskane w kolejności, pojawiają się na `source`.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
 Jeśli dwa klucze są traktowane jako równe zgodnie z opisem w `comparer`, pierwszy klucz został wybrany jako klucz dla tej grupy.  
  
 W składni wyrażeń zapytania `group by` (Visual C#) lub `Group By Into` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.GroupBy%2A>. Aby uzyskać więcej informacji i przykłady użycia, zobacz [group — klauzula](~/docs/csharp/language-reference/keywords/group-clause.md) i [grupy przez klauzulę](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group — Klauzula (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As IEnumerable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Typ elementów w <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy należy pogrupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="elementSelector">Funkcja mapy każdego elementu źródłowego do elementu w <see cref="T:System.Linq.IGrouping`2" />.</param>
        <summary>Grupuje elementy sekwencji zgodnie z projektów elementów dla każdej grupy przy użyciu określonej funkcji i funkcji określonej selektora kluczy.</summary>
        <returns>
          <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt; &gt;</c> w języku C# lub <c>IEnumerable (Of IGrouping (Of TKey, TElement))</c> w Visual Basic gdzie każdy <see cref="T:System.Linq.IGrouping`2" /> obiekt zawiera zbiór obiektów typu <paramref name="TElement" /> i klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> Metoda zwraca kolekcję <xref:System.Linq.IGrouping%602> obiektów, po jednym dla każdego klucza distinct, który wystąpił. <xref:System.Linq.IGrouping%602> Jest <xref:System.Collections.Generic.IEnumerable%601> która także ma klucz skojarzony ze swoimi elementami.  
  
 <xref:System.Linq.IGrouping%602> Obiekty są uzyskane na podstawie kolejności elementów w `source` który wytworzył pierwszy klucz <xref:System.Linq.IGrouping%602>. Elementy w metodzie grupowania są uzyskane w kolejności elementów, które je wygenerowały są wyświetlane w `source`.  
  
 Domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> do grupowania elementów w sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#39)]
 [!code-vb[System.Linq.Enumerable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#39)]  
  
 W składni wyrażeń zapytania `group by` (Visual C#) lub `Group By Into` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.GroupBy%2A>. Tłumaczenie wyrażenia zapytania w poniższym przykładzie jest odpowiednikiem zapytania w powyższym przykładzie.  
  
 [!code-csharp[System.Linq.Enumerable#122](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#122)]
 [!code-vb[System.Linq.Enumerable#122](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#122)]  
  
> [!NOTE]
>  W wyrażeniu zapytania języka Visual C# lub Visual Basic wyrażeń wyboru elementów i klucz występują w odwrotnej kolejności niż kolejność od ich pozycji argumentów w wywołaniu <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> lub <paramref name="elementSelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group — Klauzula (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Typ elementów w <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy należy pogrupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="elementSelector">Funkcja mapy każdego elementu źródłowego do elementu w <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Grupuje elementy sekwencji zgodnie z funkcją selektora kluczy. Klucze są porównywane za pomocą modułu porównującego i elementów każdej grupy są pokazane przy użyciu określonej funkcji.</summary>
        <returns>
          <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt; &gt;</c> w języku C# lub <c>IEnumerable (Of IGrouping (Of TKey, TElement))</c> w Visual Basic gdzie każdy <see cref="T:System.Linq.IGrouping`2" /> obiekt zawiera zbiór obiektów typu <paramref name="TElement" /> i klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
> [!NOTE]
>  Przykłady `GroupBy`, zobacz następujące tematy.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Metoda zwraca kolekcję <xref:System.Linq.IGrouping%602> obiektów, po jednym dla każdego klucza distinct, który wystąpił. <xref:System.Linq.IGrouping%602> Jest <xref:System.Collections.Generic.IEnumerable%601> która także ma klucz skojarzony ze swoimi elementami.  
  
 <xref:System.Linq.IGrouping%602> Obiekty są uzyskane na podstawie kolejności elementów w `source` który wytworzył pierwszy klucz <xref:System.Linq.IGrouping%602>. Elementy w metodzie grupowania są uzyskane w kolejności elementów, które je wygenerowały są wyświetlane w `source`.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
 Jeśli dwa klucze są traktowane jako równe zgodnie z opisem w `comparer`, pierwszy klucz został wybrany jako klucz dla tej grupy.  
  
 W składni wyrażeń zapytania `group by` (Visual C#) lub `Group By Into` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.GroupBy%2A>. Aby uzyskać więcej informacji i przykłady użycia, zobacz [group — klauzula](~/docs/csharp/language-reference/keywords/group-clause.md) i [grupy przez klauzulę](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> lub <paramref name="elementSelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group — Klauzula (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TResult">Typ wartości wyników zwróconych przez <c>resultSelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy należy pogrupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="resultSelector">Funkcja tworzenia wartości wyniku z każdej grupy.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną kluczową funkcją wyboru i tworzy wartość wyniku z każdej grupy i klucza.</summary>
        <returns>Kolekcja elementów typu <paramref name="TResult" /> gdzie każdy element przedstawia projekcję nad grupą i jego kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania `group by` (Visual C#) lub `Group By Into` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.GroupBy%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29> Grupuj elementy sekwencji do projektu kolejności wyników typu `TResult`.  
  
 [!code-csharp[System.Linq.Enumerable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#15)]
 [!code-vb[System.Linq.Enumerable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group — Klauzula (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TResult">Typ wartości wyników zwróconych przez <c>resultSelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy należy pogrupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="resultSelector">Funkcja tworzenia wartości wyniku z każdej grupy.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy przy użyciu.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną kluczową funkcją wyboru i tworzy wartość wyniku z każdej grupy i klucza. Klucze są porównywane za pomocą określona funkcja porównująca.</summary>
        <returns>Kolekcja elementów typu <paramref name="TResult" /> gdzie każdy element przedstawia projekcję nad grupą i jego kluczem.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group — Klauzula (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Typ elementów w każdej <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Typ wartości wyników zwróconych przez <c>resultSelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy należy pogrupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="elementSelector">Funkcja mapy każdego elementu źródłowego do elementu w <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Funkcja tworzenia wartości wyniku z każdej grupy.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną kluczową funkcją wyboru i tworzy wartość wyniku z każdej grupy i klucza. Elementów każdej grupy są pokazane przy użyciu określonej funkcji.</summary>
        <returns>Kolekcja elementów typu <paramref name="TResult" /> gdzie każdy element przedstawia projekcję nad grupą i jego kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W składni wyrażeń zapytania `group by` (Visual C#) lub `Group By Into` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.GroupBy%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29> do grupowania przewidywany elementy sekwencji i następnie projektu kolejności wyników typu `TResult`.  
  
 [!code-csharp[System.Linq.Enumerable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#125)]
 [!code-vb[System.Linq.Enumerable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#125)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group — Klauzula (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Typ elementów w każdej <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Typ wartości wyników zwróconych przez <c>resultSelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy należy pogrupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="elementSelector">Funkcja mapy każdego elementu źródłowego do elementu w <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Funkcja tworzenia wartości wyniku z każdej grupy.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy przy użyciu.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną kluczową funkcją wyboru i tworzy wartość wyniku z każdej grupy i klucza. Wartości klucza są porównywane za pomocą określona funkcja porównująca i elementów każdej grupy są pokazane przy użyciu określonej funkcji.</summary>
        <returns>Kolekcja elementów typu <paramref name="TResult" /> gdzie każdy element przedstawia projekcję nad grupą i jego kluczem.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c817242e-b12c-4baa-a57e-73ee138f34d1">group — Klauzula (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b1b5dcea-6654-473b-a2db-01f7e4c265d7">Group By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koreluje elementy dwóch sekwencji, w oparciu o równości kluczy, a następnie grupuje wyniki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupJoin(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Typ elementów pierwszej sekwencji.</typeparam>
        <typeparam name="TInner">Typ elementów drugiej sekwencji.</typeparam>
        <typeparam name="TKey">Typ kluczy zwracanych przez funkcje przełącznika kluczowego.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku.</typeparam>
        <param name="outer">Pierwsza sekwencja do przyłączenia.</param>
        <param name="inner">Sekwencja do przyłączenia do pierwszej sekwencji.</param>
        <param name="outerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu pierwszej sekwencji.</param>
        <param name="innerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu drugiej sekwencji.</param>
        <param name="resultSelector">Funkcja tworzenia elementu wynik z elementu pierwszej sekwencji i zbiorem pasujące elementy z drugiej sekwencji.</param>
        <summary>Koreluje elementy dwóch sekwencji, w oparciu o równość kluczy, a następnie grupuje wyniki. Domyślny moduł porównujący równość służy do porównywania kluczy.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawiera elementy typu <paramref name="TResult" /> , są pobierane, wykonując sprzężenie pogrupowanych w dwóch sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do wyznaczania wartości skrótu i porównywania kluczy.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> generuje hierarchiczne wyniki, w których elementy z `outer` są skojarzone z kolekcjami zgodnych elementów z `inner`. `GroupJoin` Umożliwia zastosowanie wyniki na cały zestaw dopasowań dla każdego elementu `outer`.  
  
> [!NOTE]
>  Jeśli nie ma elementów skorelowane w `inner` dla danego elementu `outer`, sekwencja dopasowań dla tego elementu jest pusta, ale wciąż będą wyświetlane w wynikach.  
  
 `resultSelector` Funkcja jest wywoływana tylko raz dla każdego `outer` element wraz z kolekcją wszystkich `inner` elementy, które odpowiadają `outer` elementu. To różni się od <xref:System.Linq.Enumerable.Join%2A> metody, w którym funkcja selektor wynik jest wywoływana pary, które zawierają jeden element z `outer` i jednego elementu z `inner`.  
  
 `GroupJoin` zachowuje kolejność elementów `outer`i dla każdego elementu `outer`, kolejność elementów zgodnych z `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> nie ma bezpośredniego odpowiednika w warunkach tradycyjnych relacyjnych baz danych. Jednak ta metoda implementuje nadzbiorem sprzężenia wewnętrzne lewych sprzężeń zewnętrznych. Oba te operacje mogą być napisane pod kątem pogrupowanych sprzężenia. Zobacz [operacje połączone](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 W składni wyrażeń zapytania `join … into` (Visual C#) lub `Group Join` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.GroupJoin%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.GroupJoin%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%29> do wykonania sprzężenia zgrupowane w dwóch sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#40)]
 [!code-vb[System.Linq.Enumerable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> lub <paramref name="inner" /> lub <paramref name="outerKeySelector" /> lub <paramref name="innerKeySelector" /> lub <paramref name="resultSelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Operacje połączone</related>
        <related type="Article" href="https://msdn.microsoft.com/library/76e9df84-092c-41a6-9537-c3f1cbd7f0fb">Klauzula join (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/37dbf79c-7b5c-421b-bbb7-dadfd2b92a1c">Group Join — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupJoin(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Typ elementów pierwszej sekwencji.</typeparam>
        <typeparam name="TInner">Typ elementów drugiej sekwencji.</typeparam>
        <typeparam name="TKey">Typ kluczy zwracanych przez funkcje przełącznika kluczowego.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku.</typeparam>
        <param name="outer">Pierwsza sekwencja do przyłączenia.</param>
        <param name="inner">Sekwencja do przyłączenia do pierwszej sekwencji.</param>
        <param name="outerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu pierwszej sekwencji.</param>
        <param name="innerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu drugiej sekwencji.</param>
        <param name="resultSelector">Funkcja tworzenia elementu wynik z elementu pierwszej sekwencji i zbiorem pasujące elementy z drugiej sekwencji.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Wyznaczania wartości skrótu do porównywania kluczy.</param>
        <summary>Koreluje elementy dwóch sekwencji, w oparciu o równości kluczy, a następnie grupuje wyniki. Określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> służy do porównywania kluczy.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawiera elementy typu <paramref name="TResult" /> , są pobierane, wykonując sprzężenie pogrupowanych w dwóch sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do wyznaczania wartości skrótu i porównywania kluczy.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> generuje hierarchiczne wyniki, w których elementy z `outer` są skojarzone z kolekcjami zgodnych elementów z `inner`. `GroupJoin` Umożliwia zastosowanie wyniki na cały zestaw dopasowań dla każdego elementu `outer`.  
  
> [!NOTE]
>  Jeśli nie ma elementów skorelowane w `inner` dla danego elementu `outer`, sekwencja dopasowań dla tego elementu jest pusta, ale wciąż będą wyświetlane w wynikach.  
  
 `resultSelector` Funkcja jest wywoływana tylko raz dla każdego `outer` element wraz z kolekcją wszystkich `inner` elementy, które odpowiadają `outer` elementu. To różni się od <xref:System.Linq.Enumerable.Join%2A> metoda jest wywoływana funkcja selektor wyników, na pary, które zawierają jeden element z `outer` i jednego elementu z `inner`.  
  
 `GroupJoin` zachowuje kolejność elementów `outer`i dla każdego elementu `outer`, kolejność elementów zgodnych z `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> nie ma bezpośredniego odpowiednika w warunkach tradycyjnych relacyjnych baz danych. Jednak ta metoda implementuje nadzbiorem sprzężenia wewnętrzne lewych sprzężeń zewnętrznych. Oba te operacje mogą być napisane pod kątem pogrupowanych sprzężenia. Zobacz [operacje połączone](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> lub <paramref name="inner" /> lub <paramref name="outerKeySelector" /> lub <paramref name="innerKeySelector" /> lub <paramref name="resultSelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Wykonywanie operacji łączenia</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zestawu części wspólnych dwóch sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Którego różne elementy, które są również wyświetlane w <c>drugi</c> zostaną zwrócone.</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Którego różne elementy, które są również wyświetlane w pierwszej kolejności zostaną zwrócone.</param>
        <summary>Tworzy zestawu części wspólnych dwóch sekwencji za pomocą domyślny moduł porównujący równość do porównywania wartości.</summary>
        <returns>Sekwencja, który zawiera elementy, które tworzą zestawu części wspólnych dwóch sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Część wspólną dwóch zestawów, A i B jest definiowany jako zestaw, który zawiera wszystkie elementy, a, który jest również dostępna w B, ale nie inne elementy.  
  
 Gdy obiekt zwracany przez tę metodę jest zostanie wyliczonly, <xref:System.Linq.Enumerable.Intersect%2A> daje różne elementy, które pojawiają się w obu sekwencji w kolejności, w jakiej występują w `first`.  
  
 Domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania wartości typów implementujących <xref:System.Collections.Generic.IEqualityComparer%601> interfejs generyczny. Aby porównać niestandardowy typ danych, należy zaimplementować niniejszy interfejs i podać własne <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metod dla typu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Intersect%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> zwracanych elementów, które pojawiają się na każdej dwóch sekwencji liczb całkowitych.  
  
 [!code-csharp[System.Linq.Enumerable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#41)]
 [!code-vb[System.Linq.Enumerable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#41)]  
  
 Jeśli chcesz porównać sekwencji obiektów niestandardowego typu danych, musisz zaimplementować <xref:System.Collections.Generic.IEqualityComparer%601> ogólny interfejs w klasie pomocy. Poniższy przykład kodu pokazuje sposób implementacji niniejszego interfejsu do niestandardowego typu danych i zapewniają <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metody.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Po zaimplementowaniu ten interfejs, można użyć sekwencji `ProductA` obiekty w <xref:System.Linq.Enumerable.Intersect%2A> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#3)]
[!code-vb[CSLINQEncapsulatedComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Którego różne elementy, które są również wyświetlane w <c>drugi</c> zostaną zwrócone.</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Którego różne elementy, które są również wyświetlane w pierwszej kolejności zostaną zwrócone.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania wartości.</param>
        <summary>Tworzy zestawu części wspólnych dwóch sekwencji przy użyciu określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> do porównywania wartości.</summary>
        <returns>Sekwencja, który zawiera elementy, które tworzą zestawu części wspólnych dwóch sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Część wspólną dwóch zestawów, A i B jest definiowany jako zestaw, który zawiera wszystkie elementy, a, który jest również dostępna w B, ale nie inne elementy.  
  
 Gdy obiekt zwracany przez tę metodę jest zostanie wyliczonly, <xref:System.Linq.Enumerable.Intersect%2A> daje różne elementy, które pojawiają się w obu sekwencji w kolejności, w jakiej występują w `first`.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania wartości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zaimplementować moduł porównujący równość mogą być używane w <xref:System.Linq.Enumerable.Intersect%2A> metody.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Po zaimplementowaniu tej porównania można użyć sekwencji `Product` obiekty w <xref:System.Linq.Enumerable.Intersect%2A> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#3)]
[!code-vb[CSLINQCustomComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koreluje elementy dwóch sekwencji na podstawie kluczy dopasowania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Join(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Typ elementów pierwszej sekwencji.</typeparam>
        <typeparam name="TInner">Typ elementów drugiej sekwencji.</typeparam>
        <typeparam name="TKey">Typ kluczy zwracanych przez funkcje przełącznika kluczowego.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku.</typeparam>
        <param name="outer">Pierwsza sekwencja do przyłączenia.</param>
        <param name="inner">Sekwencja do przyłączenia do pierwszej sekwencji.</param>
        <param name="outerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu pierwszej sekwencji.</param>
        <param name="innerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu drugiej sekwencji.</param>
        <param name="resultSelector">Funkcja tworzenia elementu wynik z dwóch zgodnych elementów.</param>
        <summary>Koreluje elementy dwóch sekwencji na podstawie kluczy dopasowania. Domyślny moduł porównujący równość służy do porównywania kluczy.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy typu <paramref name="TResult" /> , są pobierane, wykonując sprzężenie wewnętrzne na dwóch sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do wyznaczania wartości skrótu i porównywania kluczy.  
  
 Sprzężenia odnosi się do operacji korelacji elementy z dwóch źródeł danych na podstawie klucza wspólnego. <xref:System.Linq.Enumerable.Join%2A> łączy dwa źródeł informacji i kluczy, według których są pasujące ze sobą w jednego wywołania metody. To różni się od stosowania `SelectMany`, co wymaga więcej niż jedno wywołanie metody do wykonania tej samej operacji.  
  
 <xref:System.Linq.Enumerable.Join%2A> zachowuje kolejność elementów `outer`i dla każdego z tych elementów, kolejność elementów zgodnych z `inner`.  
  
 W składni wyrażeń zapytania `join` (Visual C#) lub `Join` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.Join%2A>.  
  
 W warunkach relacyjnej bazy danych <xref:System.Linq.Enumerable.Join%2A> metoda implementuje sprzężenie wewnętrzne. "Wewnętrzny" oznacza, że tylko te elementy, które mają pasujących w innych kolejności są uwzględniane w wynikach. "Equijoin" jest elementem sprzężenia w którym klucze są porównywane pod kątem równości. Lewe sprzężenie zewnętrzne operacja ma nie dedykowanych standardowego operatora zapytania, ale może przeprowadzić za pomocą <xref:System.Linq.Enumerable.GroupJoin%2A> metody. Zobacz [operacje połączone](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Join%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%29> przeprowadzić sprzężenie wewnętrzne dwóch sekwencji na podstawie klucza wspólnego.  
  
 [!code-csharp[System.Linq.Enumerable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#42)]
 [!code-vb[System.Linq.Enumerable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> lub <paramref name="inner" /> lub <paramref name="outerKeySelector" /> lub <paramref name="innerKeySelector" /> lub <paramref name="resultSelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Łączenie</related>
        <related type="Article" href="https://msdn.microsoft.com/library/76e9df84-092c-41a6-9537-c3f1cbd7f0fb">Klauzula join (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6dd37936-b27c-4e00-98ad-154b23f4de64">Join — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Join(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Typ elementów pierwszej sekwencji.</typeparam>
        <typeparam name="TInner">Typ elementów drugiej sekwencji.</typeparam>
        <typeparam name="TKey">Typ kluczy zwracanych przez funkcje przełącznika kluczowego.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku.</typeparam>
        <param name="outer">Pierwsza sekwencja do przyłączenia.</param>
        <param name="inner">Sekwencja do przyłączenia do pierwszej sekwencji.</param>
        <param name="outerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu pierwszej sekwencji.</param>
        <param name="innerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu drugiej sekwencji.</param>
        <param name="resultSelector">Funkcja tworzenia elementu wynik z dwóch zgodnych elementów.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Wyznaczania wartości skrótu do porównywania kluczy.</param>
        <summary>Koreluje elementy dwóch sekwencji na podstawie kluczy dopasowania. Określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> służy do porównywania kluczy.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy typu <paramref name="TResult" /> , są pobierane, wykonując sprzężenie wewnętrzne na dwóch sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do wyznaczania wartości skrótu i porównywania kluczy.  
  
 Sprzężenia odnosi się do operacji korelacji elementy z dwóch źródeł danych na podstawie klucza wspólnego. <xref:System.Linq.Enumerable.Join%2A> łączy dwa źródeł informacji i kluczy, według których są pasujące ze sobą w jednego wywołania metody. To różni się od stosowania `SelectMany`, co wymaga więcej niż jedno wywołanie metody do wykonania tej samej operacji.  
  
 <xref:System.Linq.Enumerable.Join%2A> zachowuje kolejność elementów `outer`i dla każdego z tych elementów, kolejność elementów zgodnych z `inner`.  
  
 W warunkach relacyjnej bazy danych <xref:System.Linq.Enumerable.Join%2A> metoda implementuje sprzężenie wewnętrzne. "Wewnętrzny" oznacza, że tylko te elementy, które mają pasujących w innych kolejności są uwzględniane w wynikach. "Equijoin" jest elementem sprzężenia w którym klucze są porównywane pod kątem równości. Lewe sprzężenie zewnętrzne operacja ma nie dedykowanych standardowego operatora zapytania, ale może przeprowadzić za pomocą <xref:System.Linq.Enumerable.GroupJoin%2A> metody. Zobacz [operacje połączone](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> lub <paramref name="inner" /> lub <paramref name="outerKeySelector" /> lub <paramref name="innerKeySelector" /> lub <paramref name="resultSelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Łączenie</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ostatni element sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do ostatniego elementu do zwrócenia.</param>
        <summary>Zwraca ostatni element sekwencji.</summary>
        <returns>Wartość na ostatniej pozycji w sekwencji źródłowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Metoda zgłasza wyjątek, jeśli `source` nie zawiera żadnych elementów. Aby zamiast tego należy przywrócić wartość domyślną, jeśli sekwencja źródłowa jest pusta, należy użyć <xref:System.Linq.Enumerable.LastOrDefault%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> do ostatniego elementu w tablicy do zwrócenia.  
  
 [!code-csharp[System.Linq.Enumerable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#43)]
 [!code-vb[System.Linq.Enumerable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrotu elementu.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca ostatni element sekwencji która spełnia określony warunek.</summary>
        <returns>Ostatniego elementu w sekwencji, do której przejdzie test w określonej funkcji predykatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Metoda zgłasza wyjątek, jeśli nie znaleziono w `source`. Zamiast tego należy zwrócić wartość domyślną, gdy zostanie znaleziony żaden element dopasowania, <xref:System.Linq.Enumerable.LastOrDefault%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> do zwrócenia ostatniego elementu w tablicy, która spełnia warunek.  
  
 [!code-csharp[System.Linq.Enumerable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#44)]
 [!code-vb[System.Linq.Enumerable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Element nie spełnia warunku w <paramref name="predicate" />.  
  
—lub— 
Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ostatni element sekwencji lub wartość domyślną, jeśli zostanie znaleziony żaden element.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do ostatniego elementu do zwrócenia.</param>
        <summary>Zwraca ostatni element sekwencji lub wartość domyślną, jeśli sekwencja nie zawiera żadnych elementów.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) Jeśli sekwencja źródłowa jest pusta; w przeciwnym razie po ostatnim elemencie w <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartością domyślną dla odwołania i typów zerowalnych jest `null`.  
  
 <xref:System.Linq.Enumerable.LastOrDefault%2A> Metody nie umożliwiają określenie wartości domyślnej. Jeśli chcesz określić inne niż wartości domyślnej `default(TSource)`, użyj <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> metoda zgodnie z opisem w sekcji przykład.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> na pustą tablicę.  
  
 [!code-csharp[System.Linq.Enumerable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#45)]
 [!code-vb[System.Linq.Enumerable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#45)]  
  
 Czasami wartość `default(TSource)` nie jest wartością domyślną, którego chcesz użyć, jeśli kolekcja zawiera żadnych elementów. Zamiast sprawdzania wyników dla wartości domyślnej niepożądane, a następnie zmieniając go, jeśli to konieczne, możesz użyć <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> metodę, aby określić wartość domyślną, którą chcesz użyć, jeśli kolekcja jest pusta. Następnie wywołaj <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> można uzyskać po ostatnim elemencie. W poniższym przykładzie kodu użyto obu tych technik uzyskanie domyślną wartość 1, jeśli kolekcja liczbowych dni miesiąca jest pusta. Całkowitą wartość domyślna to 0, co nie odpowiada każdego dnia, miesiąca, wartość domyślna musi zostać określony jako 1 zamiast tego. Pierwszy zmiennej wynikowej są sprawdzane pod kątem wartość domyślną niepożądane, po zakończeniu zapytania podczas wykonywania. Druga zmienna wyniku uzyskuje się za pomocą <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> można określić wartość domyślną 1.  
  
 [!code-csharp[System.Linq.Enumerable#127](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#127)]
 [!code-vb[System.Linq.Enumerable#127](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#127)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrotu elementu.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca ostatni element sekwencji która spełnia warunek, lub wartość domyślną, jeśli taki element nie zostanie znaleziony.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) Jeśli sekwencji jest pusta lub jeśli żadne elementy przeszedł test w funkcji predykatu; w przeciwnym razie po ostatnim elemencie, który przekazuje testu w funkcji predykatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartością domyślną dla odwołania i typów zerowalnych jest `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> , przekazując w predykacie. W drugim wywołaniu do metody nie ma żadnego elementu w sekwencji, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Enumerable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#46)]
 [!code-vb[System.Linq.Enumerable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Int64" /> reprezentujący liczbę elementów w sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IEnumerable(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : seq&lt;'Source&gt; -&gt; int64" Usage="System.Linq.Enumerable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawiera elementy do zliczenia.</param>
        <summary>Zwraca <see cref="T:System.Int64" /> reprezentujący całkowitą liczbę elementów w sekwencji.</summary>
        <returns>Liczba elementów w sekwencji źródłowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, zamiast <xref:System.Linq.Enumerable.Count%2A> jeśli oczekujesz, że wynik, który ma być większa niż <xref:System.Int32.MaxValue>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into LongCount()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.LongCount%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zliczania elementów w tablicy.  
  
 [!code-csharp[System.Linq.Enumerable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#47)]
 [!code-vb[System.Linq.Enumerable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Liczba elementów przekracza <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int64" Usage="System.Linq.Enumerable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawiera elementy do zliczenia.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca <see cref="T:System.Int64" /> reprezentujący liczbę elementów w sekwencji spełniają warunek.</summary>
        <returns>Liczba, która przedstawia, jak wiele elementów w sekwencji spełniają warunek w funkcji predykatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, zamiast <xref:System.Linq.Enumerable.Count%2A> jeśli oczekujesz, że wynik, który ma być większa niż <xref:System.Int32.MaxValue>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into LongCount()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.LongCount%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> zliczania elementów w tablicy, które spełniają warunek.  
  
 [!code-csharp[System.Linq.Enumerable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#48)]
 [!code-vb[System.Linq.Enumerable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Liczba zgodnych elementów przekracza <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca maksymalną wartość w sekwencji wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Decimal" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> Metoda używa <xref:System.Decimal> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Double" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji <see cref="T:System.Double" /> wartości.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> Metoda używa <xref:System.Double> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int32" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> Metoda używa <xref:System.Int32> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int64" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> Metoda używa <xref:System.Int64> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Decimal" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji nullable <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;dziesiętna&gt;</c> w języku C# lub <c>Nullable (z dziesiętna)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> Metoda używa <xref:System.Decimal> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Double" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji nullable <see cref="T:System.Double" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;Double&gt;</c> w języku C# lub <c>Nullable (z Double)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> Metoda używa <xref:System.Double> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Int32" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji nullable <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;Int32&gt;</c> w języku C# lub <c>Nullable (typu Int32)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> Metoda używa <xref:System.Int32> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Int64" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji nullable <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;Int64&gt;</c> w języku C# lub <c>Nullable (z Int64)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> Metoda używa <xref:System.Int64> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Single" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji nullable <see cref="T:System.Single" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;pojedynczego&gt;</c> w języku C# lub <c>Nullable (z pojedynczą)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Metoda używa <xref:System.Single> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Single" /> wartości do określenia maksymalnej wartości.</param>
        <summary>Zwraca maksymalną wartość w sekwencji <see cref="T:System.Single" /> wartości.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> Metoda używa <xref:System.Single> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> można określić maksymalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <summary>Zwraca maksymalną wartość w sekwencji ogólnego.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `TSource` implementuje <xref:System.IComparable%601>, <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> metoda wykorzystuje tę implementację, aby porównać wartości. W przeciwnym razie, jeśli typ `TSource` implementuje <xref:System.IComparable>, że wykonanie służy do porównywania wartości.  
  
 Jeśli `TSource` jest typem odwołania, a sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, Metoda ta zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> można określić maksymalną wartość w sekwencji <xref:System.IComparable%601> obiektów.  
  
 [!code-csharp[System.Linq.Enumerable#57](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#57)]
 [!code-vb[System.Linq.Enumerable#57](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość maksymalną <see cref="T:System.Decimal" /> wartość.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> Metoda używa <xref:System.Decimal> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Decimal>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość maksymalną <see cref="T:System.Double" /> wartość.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Metoda używa <xref:System.Double> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Double>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość maksymalną <see cref="T:System.Int32" /> wartość.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Metoda używa <xref:System.Int32> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Int32>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość maksymalną <see cref="T:System.Int64" /> wartość.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> Metoda używa <xref:System.Int64> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Int64>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca maksymalną wartość null <see cref="T:System.Decimal" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;dziesiętna&gt;</c> w języku C# lub <c>Nullable (z dziesiętna)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> Metoda używa <xref:System.Decimal> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Decimal>` w języku C# lub `Nullable(Of Decimal)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca maksymalną wartość null <see cref="T:System.Double" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;Double&gt;</c> w języku C# lub <c>Nullable (z Double)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> Metoda używa <xref:System.Double> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Double>` w języku C# lub `Nullable(Of Double)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca maksymalną wartość null <see cref="T:System.Int32" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;Int32&gt;</c> w języku C# lub <c>Nullable (typu Int32)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> Metoda używa <xref:System.Int32> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Int32>` w języku C# lub `Nullable(Of Int32)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca maksymalną wartość null <see cref="T:System.Int64" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;Int64&gt;</c> w języku C# lub <c>Nullable (z Int64)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> Metoda używa <xref:System.Int64> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Int64>` w języku C# lub `Nullable(Of Int64)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca maksymalną wartość null <see cref="T:System.Single" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;pojedynczego&gt;</c> w języku C# lub <c>Nullable (z pojedynczą)</c> w języku Visual Basic, który odpowiada maksymalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> Metoda używa <xref:System.Single> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Single>` w języku C# lub `Nullable(Of Single)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość maksymalną <see cref="T:System.Single" /> wartość.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> Metoda używa <xref:System.Single> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Single>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TResult">Typ wartości zwracanej przez <c>selektor</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości maksymalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji ogólny i zwraca maksymalną wartość wynikową.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `TResult` implementuje <xref:System.IComparable%601>, Metoda ta wykorzystuje tę implementację, aby porównać wartości. W przeciwnym razie, jeśli typ `TResult` implementuje <xref:System.IComparable>, że wykonanie służy do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Max()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> można określić maksymalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca minimalną wartość w sekwencji wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Decimal" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> Metoda używa <xref:System.Decimal> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Double" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji <see cref="T:System.Double" /> wartości.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> Metoda używa <xref:System.Double> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int32" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> Metoda używa <xref:System.Int32> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int64" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> Metoda używa <xref:System.Int64> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Decimal" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji nullable <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;dziesiętna&gt;</c> w języku C# lub <c>Nullable (z dziesiętna)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> Metoda używa <xref:System.Decimal> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Double" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji nullable <see cref="T:System.Double" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;Double&gt;</c> w języku C# lub <c>Nullable (z Double)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> Metoda używa <xref:System.Double> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Int32" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji nullable <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;Int32&gt;</c> w języku C# lub <c>Nullable (typu Int32)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> Metoda używa <xref:System.Int32> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Int64" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji nullable <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;Int64&gt;</c> w języku C# lub <c>Nullable (z Int64)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> Metoda używa <xref:System.Int64> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Single" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji nullable <see cref="T:System.Single" /> wartości.</summary>
        <returns>Wartości typu <c>Nullable&lt;pojedynczego&gt;</c> w języku C# lub <c>Nullable (z pojedynczą)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Metoda używa <xref:System.Single> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Jeśli sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Single" /> wartości do określenia minimalnej wartości.</param>
        <summary>Zwraca minimalną wartość w sekwencji <see cref="T:System.Single" /> wartości.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> Metoda używa <xref:System.Single> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> można określić minimalną wartość w sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <summary>Zwraca minimalną wartość w sekwencji ogólnego.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `TSource` implementuje <xref:System.IComparable%601>, Metoda ta wykorzystuje tę implementację, aby porównać wartości. W przeciwnym razie, jeśli typ `TSource` implementuje <xref:System.IComparable>, że wykonanie służy do porównywania wartości.  
  
 Jeśli `TSource` jest typem odwołania, a sekwencja źródłowa jest pusta lub zawiera tylko wartości, które są `null`, ta funkcja zwraca `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> można określić minimalną wartość w sekwencji <xref:System.IComparable%601> obiektów.  
  
 [!code-csharp[System.Linq.Enumerable#67](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#67)]
 [!code-vb[System.Linq.Enumerable#67](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną <see cref="T:System.Decimal" /> wartość.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> Metoda używa <xref:System.Decimal> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Decimal>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną <see cref="T:System.Double" /> wartość.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Metoda używa <xref:System.Double> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Double>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną <see cref="T:System.Int32" /> wartość.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Metoda używa <xref:System.Int32> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Int32>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną <see cref="T:System.Int64" /> wartość.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> Metoda używa <xref:System.Int64> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Int64>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną wartość null <see cref="T:System.Decimal" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;dziesiętna&gt;</c> w języku C# lub <c>Nullable (z dziesiętna)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> Metoda używa <xref:System.Decimal> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Decimal>` w języku C# lub `Nullable(Of Decimal)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną wartość null <see cref="T:System.Double" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;Double&gt;</c> w języku C# lub <c>Nullable (z Double)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> Metoda używa <xref:System.Double> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Double>` w języku C# lub `Nullable(Of Double)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną wartość null <see cref="T:System.Int32" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;Int32&gt;</c> w języku C# lub <c>Nullable (typu Int32)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> Metoda używa <xref:System.Int32> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego Jeśli podasz funkcję `selector`, specjalnie do typu liczbowego, który projekty elementy członkowskie źródła `Nullable<Int32>` w języku C# lub `Nullable(Of Int32)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną wartość null <see cref="T:System.Int64" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;Int64&gt;</c> w języku C# lub <c>Nullable (z Int64)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> Metoda używa <xref:System.Int64> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Int64>` w języku C# lub `Nullable(Of Int64)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną wartość null <see cref="T:System.Single" /> wartość.</summary>
        <returns>Wartość typu <c>Nullable&lt;pojedynczego&gt;</c> w języku C# lub <c>Nullable (z pojedynczą)</c> w języku Visual Basic, który odpowiada na minimalną wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> Metoda używa <xref:System.Single> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Single>` w języku C# lub `Nullable(Of Single)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji i zwraca wartość minimalną <see cref="T:System.Single" /> wartość.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> Metoda używa <xref:System.Single> implementacji <xref:System.IComparable%601> do porównywania wartości.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Single>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> nie zawiera żadnych elementów.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TResult">Typ wartości zwracanej przez <c>selektor</c>.</typeparam>
        <param name="source">Kolejność wartości do określenia wartości minimalnej.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję przekształcenia dla każdego elementu w sekwencji ogólny i zwraca minimalną wartość wynikową.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `TResult` implementuje <xref:System.IComparable%601>, Metoda ta wykorzystuje tę implementację, aby porównać wartości. W przeciwnym razie, jeśli typ `TResult` implementuje <xref:System.IComparable>, że wykonanie służy do porównywania wartości.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Min()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> Aby określić minimalną wartość w sekwencji przewidywanych wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As IEnumerable) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ OfType(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Collections.IEnumerable -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ do filtrowania elementów sekwencji.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.IEnumerable" /> Której elementy do filtrowania.</param>
        <summary>Filtruje elementy <see cref="T:System.Collections.IEnumerable" /> na podstawie określonego typu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy z sekwencji wejściowych typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.OfType%60%601%28System.Collections.IEnumerable%29> Metoda zwraca tylko te elementy w `source` mogą być rzutowane na typ `TResult`. Zamiast tego uzyskania wyjątek, jeśli element nie można rzutować na typ `TResult`, użyj <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 Ta metoda jest jednym z kilku metod standardowych operatorów zapytań, które mogą być stosowane do kolekcji, która ma typ bez parametrów, takich jak <xref:System.Collections.ArrayList>. Jest to spowodowane <xref:System.Linq.Enumerable.OfType%2A> rozszerza typ <xref:System.Collections.IEnumerable>. <xref:System.Linq.Enumerable.OfType%2A> Nie można zastosować tylko do kolekcji, które są oparte na sparametryzowane <xref:System.Collections.Generic.IEnumerable%601> typu, ale kolekcje, które są oparte na zdefiniowanych <xref:System.Collections.IEnumerable> również wpisać.  
  
 Stosując <xref:System.Linq.Enumerable.OfType%2A> do kolekcji, która implementuje <xref:System.Collections.IEnumerable>, zyskasz możliwość zapytanie do kolekcji przy użyciu standardowych operatorów zapytań. Na przykład określić argument typu <xref:System.Object> do <xref:System.Linq.Enumerable.OfType%2A> zwróci obiekt typu `IEnumerable<Object>` w języku C# lub `IEnumerable(Of Object)` w języku Visual Basic, do którego można zastosować standardowych operatorów zapytań.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.OfType%2A> do filtrowania elementów <xref:System.Collections.IEnumerable>.  
  
 [!code-csharp[System.Linq.Enumerable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#69)]
 [!code-vb[System.Linq.Enumerable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementy sekwencji w kolejności rosnącej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">Sekwencja wartości do ustawienia w kolejności.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z elementu.</param>
        <summary>Sortuje elementy sekwencji rosnąco, zgodnie z kluczem.</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Której elementy są sortowane według klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Sekwencję w kolejności według wartości samych elementów, należy określić funkcję tożsamości (`x => x` w języku Visual C# lub `Function(x) x` w języku Visual Basic) dla `keySelector`.  
  
 Dwie metody zostały zdefiniowane w celu rozszerzenia typu <xref:System.Linq.IOrderedEnumerable%601>, który jest typem zwracanym tej metody. Te dwie metody, a mianowicie `ThenBy` i `ThenByDescending`, pozwalają na określenie dodatkowych kryteriów sortowania do sortowania sekwencji. `ThenBy` i `ThenByDescending` również zwracać <xref:System.Linq.IOrderedEnumerable%601>, co oznacza dowolną liczbę kolejnych wywołań `ThenBy` lub `ThenByDescending` jest możliwe.  
  
> [!NOTE]
>  Ponieważ <xref:System.Linq.IOrderedEnumerable%601> dziedziczy <xref:System.Collections.Generic.IEnumerable%601>, można wywołać <xref:System.Linq.Enumerable.OrderBy%2A> lub <xref:System.Linq.Enumerable.OrderByDescending%2A> na wynikach wywołania <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A>. Ten sposób wprowadza nowe podstawowe ustawianie kolejności, które ignoruje ustanowiony wcześniej sposób ustawiania.  
  
 Ta metoda porównuje klucze przy użyciu domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Ta metoda wykonuje stabilne sortowanie; oznacza to, że jeśli klawisze dwóch elementów są równe, kolejność elementów jest zachowywana. Z drugiej strony, niestabilne sortowanie nie pozwala zachować kolejności elementów, które mają ten sam klucz.  
  
 W składni wyrażeń zapytania `orderby` (Visual C#) lub `Order By` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.OrderBy%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.OrderBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> elementy sekwencji sortowania.  
  
 [!code-csharp[System.Linq.Enumerable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#70)]
 [!code-vb[System.Linq.Enumerable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">Klauzula orderby (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Order By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">Sekwencja wartości do ustawienia w kolejności.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z elementu.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Do porównywania kluczy.</param>
        <summary>Sortuje elementy sekwencji w kolejności rosnącej przy użyciu określona funkcja porównująca.</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Której elementy są sortowane według klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Sekwencję w kolejności według wartości samych elementów, należy określić funkcję tożsamości (`x => x` w języku Visual C# lub `Function(x) x` w języku Visual Basic) dla `keySelector`.  
  
 Dwie metody zostały zdefiniowane w celu rozszerzenia typu <xref:System.Linq.IOrderedEnumerable%601>, który jest typem zwracanym tej metody. Te dwie metody, a mianowicie `ThenBy` i `ThenByDescending`, pozwalają na określenie dodatkowych kryteriów sortowania do sortowania sekwencji. `ThenBy` i `ThenByDescending` również zwracać <xref:System.Linq.IOrderedEnumerable%601>, co oznacza dowolną liczbę kolejnych wywołań `ThenBy` lub `ThenByDescending` jest możliwe.  
  
> [!NOTE]
>  Ponieważ <xref:System.Linq.IOrderedEnumerable%601> dziedziczy <xref:System.Collections.Generic.IEnumerable%601>, można wywołać <xref:System.Linq.Enumerable.OrderBy%2A> lub <xref:System.Linq.Enumerable.OrderByDescending%2A> na wynikach wywołania <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A>. Ten sposób wprowadza nowe podstawowe ustawianie kolejności, które ignoruje ustanowiony wcześniej sposób ustawiania.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A> służy do porównywania kluczy.  
  
 Ta metoda wykonuje stabilne sortowanie; oznacza to, że jeśli klawisze dwóch elementów są równe, kolejność elementów jest zachowywana. Z drugiej strony, niestabilne sortowanie nie pozwala zachować kolejności elementów, które mają ten sam klucz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementy sekwencji w kolejności malejącej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderByDescending(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">Sekwencja wartości do ustawienia w kolejności.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z elementu.</param>
        <summary>Sortuje elementy sekwencji w porządku malejącym zgodnie z kluczem.</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Której elementy są sortowane w porządku malejącym zgodnie z kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Sekwencję w kolejności według wartości samych elementów, należy określić funkcję tożsamości (`x => x` w języku Visual C# lub `Function(x) x` w języku Visual Basic) dla `keySelector`.  
  
 Aby uzyskać przykład tej metody, zobacz <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>.  
  
 Dwie metody zostały zdefiniowane w celu rozszerzenia typu <xref:System.Linq.IOrderedEnumerable%601>, który jest typem zwracanym tej metody. Te dwie metody, a mianowicie `ThenBy` i `ThenByDescending`, pozwalają na określenie dodatkowych kryteriów sortowania do sortowania sekwencji. `ThenBy` i `ThenByDescending` również zwracać <xref:System.Linq.IOrderedEnumerable%601>, co oznacza dowolną liczbę kolejnych wywołań `ThenBy` lub `ThenByDescending` jest możliwe.  
  
> [!NOTE]
>  Ponieważ <xref:System.Linq.IOrderedEnumerable%601> dziedziczy <xref:System.Collections.Generic.IEnumerable%601>, można wywołać <xref:System.Linq.Enumerable.OrderBy%2A> lub <xref:System.Linq.Enumerable.OrderByDescending%2A> na wynikach wywołania <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A>. Ten sposób wprowadza nowe podstawowe ustawianie kolejności, które ignoruje ustanowiony wcześniej sposób ustawiania.  
  
 Ta metoda porównuje klucze przy użyciu domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Ta metoda wykonuje stabilne sortowanie; oznacza to, że jeśli klawisze dwóch elementów są równe, kolejność elementów jest zachowywana. Z drugiej strony, niestabilne sortowanie nie pozwala zachować kolejności elementów, które mają ten sam klucz.  
  
 W składni wyrażeń zapytania `orderby descending` (Visual C#) lub `Order By Descending` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.OrderByDescending%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">Klauzula orderby (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Order By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderByDescending(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">Sekwencja wartości do ustawienia w kolejności.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z elementu.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Do porównywania kluczy.</param>
        <summary>Sortuje elementy sekwencji w kolejności malejącej, używając określona funkcja porównująca.</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Której elementy są sortowane w porządku malejącym zgodnie z kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Sekwencję w kolejności według wartości samych elementów, należy określić funkcję tożsamości (`x => x` w języku Visual C# lub `Function(x) x` w języku Visual Basic) dla `keySelector`.  
  
 Dwie metody zostały zdefiniowane w celu rozszerzenia typu <xref:System.Linq.IOrderedEnumerable%601>, który jest typem zwracanym tej metody. Te dwie metody, a mianowicie `ThenBy` i `ThenByDescending`, pozwalają na określenie dodatkowych kryteriów sortowania do sortowania sekwencji. `ThenBy` i `ThenByDescending` również zwracać <xref:System.Linq.IOrderedEnumerable%601>, co oznacza dowolną liczbę kolejnych wywołań `ThenBy` lub `ThenByDescending` jest możliwe.  
  
> [!NOTE]
>  Ponieważ <xref:System.Linq.IOrderedEnumerable%601> dziedziczy <xref:System.Collections.Generic.IEnumerable%601>, można wywołać <xref:System.Linq.Enumerable.OrderBy%2A> lub <xref:System.Linq.Enumerable.OrderByDescending%2A> na wynikach wywołania <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A>. Ten sposób wprowadza nowe podstawowe ustawianie kolejności, które ignoruje ustanowiony wcześniej sposób ustawiania.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A> służy do porównywania kluczy.  
  
 Ta metoda wykonuje stabilne sortowanie; oznacza to, że jeśli klawisze dwóch elementów są równe, kolejność elementów jest zachowywana. Z drugiej strony, niestabilne sortowanie nie pozwala zachować kolejności elementów, które mają ten sam klucz.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> sortować elementy sekwencję w kolejności malejącej, używając funkcji przekształcenia i niestandardowego modułu porównującego.  
  
 [!code-csharp[System.Linq.Enumerable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#71)]
 [!code-vb[System.Linq.Enumerable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prepend(Of TSource) (source As IEnumerable(Of TSource), element As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Prepend(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Prepend : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Prepend (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości.</param>
        <param name="element">Wartość być dołączana do <paramref name="source" />.</param>
        <summary>Dodaje wartość do początku sekwencji.</summary>
        <returns>Nową sekwencję, który zaczyna się od <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[    
          
## Remarks  
  
> [!NOTE]
>  Ta metoda nie powoduje modyfikacji elementów kolekcji. Zamiast tego tworzy kopię kolekcji za pomocą nowego elementu.
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Prepend%2A> być dołączana wartość na początku sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#202](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#202)]
 [!code-vb[System.Linq.Enumerable#202](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#202)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Range (start As Integer, count As Integer) As IEnumerable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;int&gt; ^ Range(int start, int count);" />
      <MemberSignature Language="F#" Value="static member Range : int * int -&gt; seq&lt;int&gt;" Usage="System.Linq.Enumerable.Range (start, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Wartość pierwsza liczba całkowita w sekwencji.</param>
        <param name="count">Liczba kolejnych liczb całkowitych do wygenerowania.</param>
        <summary>Generuje sekwencję liczb całkowitych w określonym zakresie.</summary>
        <returns>
          <c>IEnumerable&lt;Int32&gt;</c> w języku C# lub <c>IEnumerable (Of Int32)</c> w języku Visual Basic, który zawiera szeroką gamę kolejnych liczb całkowitych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Range%2A> wygenerować je sekvence hodnot.  
  
 [!code-csharp[System.Linq.Enumerable#72](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#72)]
 [!code-vb[System.Linq.Enumerable#72](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="start" /> + <paramref name="count" /> -1 jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Repeat(Of TResult) (element As TResult, count As Integer) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Repeat(TResult element, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : 'Result * int -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Repeat (element, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości, należy powtórzyć w sekwencji wynik.</typeparam>
        <param name="element">Wartość do powtarzania.</param>
        <param name="count">Liczba powtórzeń wartość w sekwencji wygenerowane.</param>
        <summary>Generuje sekwencję która zawiera jedną wartość powtórzony.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający dopuszczalnych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Repeat%2A> do generowania sekwencji dopuszczalnych wartości.  
  
 [!code-csharp[System.Linq.Enumerable#73](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#73)]
 [!code-vb[System.Linq.Enumerable#73](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Reverse(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości do odwrotnego.</param>
        <summary>Odwraca kolejność elementów w sekwencji.</summary>
        <returns>Sekwencja, w której elementy odpowiadają identyfikatorom sekwencji wejściowych w odwrotnej kolejności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 W odróżnieniu od <xref:System.Linq.Enumerable.OrderBy%2A>, ta metoda sortowania nie należy wziąć pod uwagę same wartości rzeczywiste przy ustalaniu kolejności. Przeciwnie po prostu zwraca elementy w odwrotnej kolejności, z którego są tworzone przez bazowe źródło.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Reverse%2A> Aby odwrócić kolejność elementów w tablicy.  
  
 [!code-csharp[System.Linq.Enumerable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#74)]
 [!code-vb[System.Linq.Enumerable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projektów każdy element obiektu sekwencji do nowego formularza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Select(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : seq&lt;'Source&gt; * Func&lt;'Source, int, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TResult">Typ wartości zwracanej przez <c>selektor</c>.</typeparam>
        <param name="source">Sekwencja wartości do wywołania funkcji przekształcenia na.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu źródłowego; drugi parametr funkcji reprezentuje indeks elementu źródłowego.</param>
        <summary>Projektów każdy element obiektu sekwencji do nowego formularza przez dołączenie indeks elementu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy są wynikiem wywołania funkcji przekształcenia na każdym elemencie <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Pierwszy argument `selector` reprezentuje element do przetworzenia. Drugi argument `selector` reprezentuje liczony od zera indeks elementu w sekwencji źródłowej. Może to być przydatne, jeśli elementy są w kolejności znane, i chcesz zrobić coś z elementu pod określonym indeksem, na przykład. Można również go przydatne, jeśli mają zostać pobrane z indeksu elementów w co najmniej jeden.  
  
 Ta metoda projekcji wymaga funkcji przekształcenia `selector`, aby utworzyć pojedynczą wartość dla każdej wartości w sekwencji źródłowej `source`. Jeśli `selector` zwraca wartość, która sama jest kolekcją, jest konsument przechodzenia podciągów ręcznie. W takiej sytuacji może być lepszym rozwiązaniem dla zapytania do zwrócenia pojedynczego połączonych sekwencji wartości. Aby to osiągnąć, należy użyć <xref:System.Linq.Enumerable.SelectMany%2A> zamiast metody <xref:System.Linq.Enumerable.Select%2A>. Mimo że `SelectMany` działa podobnie jak `Select`, różni się w tym funkcję przekształcenia zwraca kolekcję, która jest rozszerzany przy `SelectMany` przed zwróceniem.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%29> do projektu za pośrednictwem sekwencja wartości, a następnie użyć indeksu każdego elementu.  
  
 [!code-csharp[System.Linq.Enumerable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#76)]
 [!code-vb[System.Linq.Enumerable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Select(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TResult">Typ wartości zwracanej przez <c>selektor</c>.</typeparam>
        <param name="source">Sekwencja wartości do wywołania funkcji przekształcenia na.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Projektów każdy element obiektu sekwencji do nowego formularza.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy są wynikiem wywołania funkcji przekształcenia na każdym elemencie <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Ta metoda projekcji wymaga funkcji przekształcenia `selector`, aby utworzyć pojedynczą wartość dla każdej wartości w sekwencji źródłowej `source`. Jeśli `selector` zwraca wartość, która sama jest kolekcją, jest konsument przechodzenia podciągów ręcznie. W takiej sytuacji może być lepszym rozwiązaniem dla zapytania do zwrócenia pojedynczego połączonych sekwencji wartości. Aby to osiągnąć, należy użyć <xref:System.Linq.Enumerable.SelectMany%2A> zamiast metody <xref:System.Linq.Enumerable.Select%2A>. Mimo że `SelectMany` działa podobnie jak `Select`, różni się w tym funkcję przekształcenia zwraca kolekcję, która jest rozszerzany przy `SelectMany` przed zwróceniem.  
  
 W składni wyrażeń zapytania `select` (Visual C#) lub `Select` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.Select%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> do projektu za pośrednictwem je sekvence hodnot.  
  
 [!code-csharp[System.Linq.Enumerable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#75)]
 [!code-vb[System.Linq.Enumerable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/df01e266-5781-4aaa-80c4-67cf28ea093f">select — Klauzula (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/27a3f61c-5960-4692-9b91-4d0c4b6178fe">Select — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projektów każdy element sekwencji w celu <see cref="T:System.Collections.Generic.IEnumerable`1" /> i spłaszcza wynikowy sekwencje na jednej sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, IEnumerable(Of TResult))) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Result&gt;&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TResult">Typ elementów sekwencji zwrócony przez <c>selektor</c>.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Projektów każdy element sekwencji w celu <see cref="T:System.Collections.Generic.IEnumerable`1" /> i spłaszcza wynikowy sekwencje na jednej sekwencji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy są wynikiem wywołania funkcji przekształcenia jeden do wielu, dla każdego elementu w sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> Metoda wylicza sekwencji wejściowych, funkcja transformacji do mapowania każdego elementu na <xref:System.Collections.Generic.IEnumerable%601>, a następnie wylicza i daje elementów w każdej z tych <xref:System.Collections.Generic.IEnumerable%601> obiektu. Oznacza to, że dla każdego elementu `source`, `selector` jest wywoływany i zostanie zwrócony je sekvence hodnot. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> następnie spłaszcza tej dwuwymiarową kolekcji kolekcji do jednowymiarowego obiektu <xref:System.Collections.Generic.IEnumerable%601> i zwraca go. Na przykład, jeśli zapytanie używa <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> uzyskać zamówienia (typu `Order`) dla każdego klienta w bazie danych, wynik jest typu `IEnumerable<Order>` w języku C# lub `IEnumerable(Of Order)` w języku Visual Basic. Jeśli zamiast tego używa zapytania <xref:System.Linq.Enumerable.Select%2A> uzyskiwania zamówienia, w kolekcji z kolekcji zamówień nie jest połączona, a wynik jest typu `IEnumerable<List<Order>>` w języku C# lub `IEnumerable(Of List(Of Order))` w języku Visual Basic.  
  
 W składni wyrażeń zapytania każdy `from` — klauzula (Visual C#) lub `From` — klauzula (Visual Basic), po początkowej, jeden przekłada się na wywołanie <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> przeprowadzić projekcji jeden do wielu za pośrednictwem tablicy.  
  
 [!code-csharp[System.Linq.Enumerable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#77)]
 [!code-vb[System.Linq.Enumerable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1aefd18c-1314-47f8-99ec-9bcefb09e699">Klauzula From (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/83e3665e-68a0-4540-a3a3-3d777a0f95d5">From — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer, IEnumerable(Of TResult))) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Result&gt;&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TResult">Typ elementów sekwencji zwrócony przez <c>selektor</c>.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu źródłowego; drugi parametr funkcji reprezentuje indeks elementu źródłowego.</param>
        <summary>Projektów każdy element sekwencji w celu <see cref="T:System.Collections.Generic.IEnumerable`1" />i spłaszcza wynikowy sekwencje na jednej sekwencji. Indeks każdego elementu źródłowego jest używana w formularzu przewidywany tego elementu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy są wynikiem wywołania funkcji przekształcenia jeden do wielu, dla każdego elementu w sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> Metoda wylicza sekwencji wejściowych, funkcja transformacji do mapowania każdego elementu na <xref:System.Collections.Generic.IEnumerable%601>, a następnie wylicza i daje elementów w każdej z tych <xref:System.Collections.Generic.IEnumerable%601> obiektu. Oznacza to, że dla każdego elementu `source`, `selector` jest wywoływany i zostanie zwrócony je sekvence hodnot. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> następnie spłaszcza tej dwuwymiarową kolekcji kolekcji do jednowymiarowego obiektu <xref:System.Collections.Generic.IEnumerable%601> i zwraca go. Na przykład, jeśli zapytanie używa <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> uzyskać zamówienia (typu `Order`) dla każdego klienta w bazie danych, wynik jest typu `IEnumerable<Order>` w języku C# lub `IEnumerable(Of Order)` w języku Visual Basic. Jeśli zamiast tego używa zapytania <xref:System.Linq.Enumerable.Select%2A> uzyskiwania zamówienia, w kolekcji z kolekcji zamówień nie jest połączona, a wynik jest typu `IEnumerable<List<Order>>` w języku C# lub `IEnumerable(Of List(Of Order))` w języku Visual Basic.  
  
 Pierwszy argument `selector` reprezentuje element do przetworzenia. Drugi argument `selector` reprezentuje liczony od zera indeks elementu w sekwencji źródłowej. Może to być przydatne, jeśli elementy są w kolejności znane, i chcesz zrobić coś z elementu pod określonym indeksem, na przykład. Można również go przydatne, jeśli mają zostać pobrane z indeksu elementów w co najmniej jeden.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> wykonywania projekcji jeden do wielu za pośrednictwem tablicy i użyć indeksu każdego elementu zewnętrznego.  
  
 [!code-csharp[System.Linq.Enumerable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#78)]
 [!code-vb[System.Linq.Enumerable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IEnumerable(Of TSource), collectionSelector As Func(Of TSource, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TCollection">Typ elementów pośrednich zebrane przez <c>collectionSelector</c>.</typeparam>
        <typeparam name="TResult">Typ elementów sekwencji wynikowe.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="collectionSelector">Funkcja transformacji do zastosowania do każdego elementu obiektu sekwencji wejściowych.</param>
        <param name="resultSelector">Funkcja transformacji do zastosowania do każdego elementu pośrednich sekwencji.</param>
        <summary>Projektów każdy element sekwencji w celu <see cref="T:System.Collections.Generic.IEnumerable`1" />spłaszcza wynikowy sekwencje na jednej sekwencji i wywołuje funkcję selektor wyników dla każdego elementu w nim.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy są wynikiem wywołania funkcji przekształcenia jeden do wielu <paramref name="collectionSelector" /> na każdym elemencie <paramref name="source" /> i mapowanie każdego z tych elementów w sekwencji i ich odpowiedniego elementu źródłowego do elementu wynik.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> Metoda jest przydatna, gdy trzeba zachować elementy `source` w zakresie logiki zapytania, która występuje po wywołaniu <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. W sekcji przykład przykładowy kod. Jeśli istnieje relacja dwukierunkowego między obiektami typu `TSource` i obiekty typu `TCollection`, to znaczy, jeśli obiekt typu `TCollection` udostępnia właściwości, aby pobrać `TSource` obiektu, który go, nie jest to konieczne przeciążenia <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Zamiast tego można użyć <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> i przejdź z powrotem do `TSource` obiektu za pomocą `TCollection` obiektu.  
  
 W składni wyrażeń zapytania każdy `from` — klauzula (Visual C#) lub `From` — klauzula (Visual Basic), po początkowej, jeden przekłada się na wywołanie <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> wykonywania projekcji jeden do wielu za pośrednictwem tablicy i użyj funkcji selektor wynik zapewnienie każdego odpowiedni element z sekwencji źródłowej w zakresie ostatnim wywołaniem do `Select`.  
  
 [!code-csharp[System.Linq.Enumerable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#124)]
 [!code-vb[System.Linq.Enumerable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="collectionSelector" /> lub <paramref name="resultSelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1aefd18c-1314-47f8-99ec-9bcefb09e699">Klauzula From (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/83e3665e-68a0-4540-a3a3-3d777a0f95d5">From — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IEnumerable(Of TSource), collectionSelector As Func(Of TSource, Integer, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TCollection">Typ elementów pośrednich zebrane przez <c>collectionSelector</c>.</typeparam>
        <typeparam name="TResult">Typ elementów sekwencji wynikowe.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="collectionSelector">Funkcja transformacji do zastosowania do każdego elementu źródłowego; drugi parametr funkcji reprezentuje indeks elementu źródłowego.</param>
        <param name="resultSelector">Funkcja transformacji do zastosowania do każdego elementu pośrednich sekwencji.</param>
        <summary>Projektów każdy element sekwencji w celu <see cref="T:System.Collections.Generic.IEnumerable`1" />spłaszcza wynikowy sekwencje na jednej sekwencji i wywołuje funkcję selektor wyników dla każdego elementu w nim. Indeks każdego elementu źródłowego jest używana w formularzu przewidywany pośrednich tego elementu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której elementy są wynikiem wywołania funkcji przekształcenia jeden do wielu <paramref name="collectionSelector" /> na każdym elemencie <paramref name="source" /> i mapowanie każdego z tych elementów w sekwencji i ich odpowiedniego elementu źródłowego do elementu wynik.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> Metoda jest przydatna, gdy trzeba zachować elementy `source` w zakresie logiki zapytania, która występuje po wywołaniu <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. W sekcji przykład przykładowy kod. Jeśli istnieje relacja dwukierunkowego między obiektami typu `TSource` i obiekty typu `TCollection`, to znaczy, jeśli obiekt typu `TCollection` udostępnia właściwości, aby pobrać `TSource` obiektu, który go, nie jest to konieczne przeciążenia <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Zamiast tego można użyć <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> i przejdź z powrotem do `TSource` obiektu za pomocą `TCollection` obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="collectionSelector" /> lub <paramref name="resultSelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy dwie sekwencje mają taki sam, zgodnie z moduł porównujący równość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do porównania z <c>drugi</c>.</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do porównania z pierwszej sekwencji.</param>
        <summary>Określa, czy dwie sekwencje są takie same, porównując elementy przy użyciu domyślny moduł porównujący równość dla ich typu.</summary>
        <returns>
          <see langword="true" /> w przypadku dwóch źródłowych sekwencji równej długości i odpowiadające im elementy są równe zgodnie z domyślny moduł porównujący równość ich typ; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Metoda wylicza dwóch źródłowych sekwencji równolegle i porównuje odpowiednie elementy przy użyciu domyślny moduł porównujący równość dla `TSource`, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>. Domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania wartości typów implementujących <xref:System.Collections.Generic.IEqualityComparer%601> interfejs generyczny. Aby porównać niestandardowy typ danych, należy zaimplementować niniejszy interfejs i podać własne <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metod dla typu.  
  
   
  
## Examples  
 Poniższe przykłady kodu przedstawiają sposoby użycia <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> do określenia, czy dwie sekwencje mają taki sam. W pierwszych dwóch przykładach Metoda określa, czy porównaniu sekwencje zawierają odwołania do tych samych obiektów. W przykładach trzecia i czwarta metoda porównuje danych rzeczywistych obiektów w ramach sekwencji.  
  
 W tym przykładzie sekwencji, które są równe.  
  
 [!code-csharp[System.Linq.Enumerable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#32)]
 [!code-vb[System.Linq.Enumerable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#32)]  
  
 Poniższy przykład kodu porównuje dwie sekwencje, które nie są takie same. Należy pamiętać, że sekwencje zawierają identyczne dane, ale ponieważ obiekty, które zawierają różne odwołania, sekwencji, które nie są uznawane za równe.  
  
 [!code-csharp[System.Linq.Enumerable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#33)]
 [!code-vb[System.Linq.Enumerable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#33)]  
  
 Jeśli chcesz porównać danych rzeczywistych obiektów w sekwencji, zamiast tylko porównywania odniesień do nich, musisz zaimplementować <xref:System.Collections.Generic.IEqualityComparer%601> ogólny interfejs w klasie. Poniższy przykład kodu pokazuje sposób implementacji niniejszego interfejsu klasy pomocnika i podaj <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metody.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Po zaimplementowaniu ten interfejs, można użyć sekwencji `ProductA` obiekty w <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#8)]
 [!code-vb[CSLINQEncapsulatedComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do porównania z <c>drugi</c>.</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do porównania z pierwszej sekwencji.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Służące do porównywania elementów.</param>
        <summary>Określa, czy dwie sekwencje mają równe przez porównanie ich elementy przy użyciu określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli dwóch źródłowych sekwencji równej długości i ich odpowiednie elementy są porównywane według <paramref name="comparer" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Metoda wylicza dwóch źródłowych sekwencji równolegle i porównuje odpowiednie elementy przy użyciu określonego <xref:System.Collections.Generic.IEqualityComparer%601>. Jeśli `comparer` jest `null`, domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania elementów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zaimplementować moduł porównujący równość mogą być używane w <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> metody.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Po zaimplementowaniu tej porównania można użyć sekwencji `Product` obiekty w <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQCustomComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#8)]
 [!code-vb[CSLINQCustomComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca element jednej, określonej sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrócenia pojedynczego elementu.</param>
        <summary>Zwraca tylko element sekwencji i zgłasza wyjątek, jeśli nie istnieje dokładnie jednego elementu w sekwencji.</summary>
        <returns>Pojedynczy element sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Metoda zgłasza wyjątek, jeśli sekwencji wejściowych jest pusta. Aby zamiast tego zwracają `null` podczas sekwencji wejściowych jest pusta, użyj <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zaznacz tylko element tablicy.  
  
 [!code-csharp[System.Linq.Enumerable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#79)]
 [!code-vb[System.Linq.Enumerable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#79)]  
  
 Poniższy przykład kodu pokazuje, że <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zgłasza wyjątek, gdy sekwencja nie zawiera dokładnie jeden element.  
  
 [!code-csharp[System.Linq.Enumerable#80](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#80)]
 [!code-vb[System.Linq.Enumerable#80](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wejściowy sekwencja zawiera więcej niż jeden element.  
  
—lub— 
Sekwencji wejściowych jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrócenia pojedynczego elementu z.</param>
        <param name="predicate">Funkcja testowania elementu dla warunku.</param>
        <summary>Zwraca tylko element sekwencji która spełnia określony warunek i zgłasza wyjątek, jeśli istnieje więcej niż jeden taki element.</summary>
        <returns>Pojedynczy element sekwencji wejściowych, który spełnia warunek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Metoda zgłasza wyjątek, jeśli sekwencji wejściowych nie zawiera żadnych pasujący element. Aby zamiast tego zwracają `null` podczas nie pasujący element zostanie znaleziony, użyj <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> zaznacz tylko element w tablicy, która spełnia warunek.  
  
 [!code-csharp[System.Linq.Enumerable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#81)]
 [!code-vb[System.Linq.Enumerable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#81)]  
  
 Poniższy przykład kodu pokazuje, że <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> zgłasza wyjątek, gdy sekwencja nie zawiera dokładnie jeden element, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Enumerable#82](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#82)]
 [!code-vb[System.Linq.Enumerable#82](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Element nie spełnia warunku w <paramref name="predicate" />.  
  
—lub— 
Więcej niż jeden element spełnia warunek w <paramref name="predicate" />.  
  
—lub— 
Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca element jednej, określonej sekwencji lub wartość domyślną, jeśli ten element nie zostanie znaleziony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrócenia pojedynczego elementu.</param>
        <summary>Zwraca tylko element sekwencji lub wartość domyślną, jeśli sekwencja jest pusta. Ta metoda zgłasza wyjątek, jeśli istnieje więcej niż jednego elementu w sekwencji.</summary>
        <returns>Pojedynczy element sekwencji wejściowych lub <see langword="default" />(<paramref name="TSource" />) Jeżeli sekwencja nie zawiera żadnych elementów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartością domyślną dla odwołania i typów zerowalnych jest `null`.  
  
 <xref:System.Linq.Enumerable.SingleOrDefault%2A> Metody nie umożliwiają określenie wartości domyślnej. Jeśli chcesz określić inne niż wartości domyślnej `default(TSource)`, użyj <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> metoda zgodnie z opisem w sekcji przykład.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zaznacz tylko element tablicy.  
  
 [!code-csharp[System.Linq.Enumerable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#83)]
 [!code-vb[System.Linq.Enumerable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#83)]  
  
 Poniższy przykład kodu pokazuje, że <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zwraca wartość domyślną, jeśli sekwencja nie zawiera dokładnie jeden element.  
  
 [!code-csharp[System.Linq.Enumerable#84](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#84)]
 [!code-vb[System.Linq.Enumerable#84](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#84)]  
  
 Czasami wartość `default(TSource)` nie jest wartością domyślną, którego chcesz użyć, jeśli kolekcja zawiera żadnych elementów. Zamiast sprawdzania wyników dla wartości domyślnej niepożądane, a następnie zmieniając go, jeśli to konieczne, możesz użyć <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> metodę, aby określić wartość domyślną, którą chcesz użyć, jeśli kolekcja jest pusta. Następnie wywołaj <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> można uzyskać elementu. Poniższy przykład kodu używa obu tych technik do uzyskania domyślną wartość 1, jeśli kolekcja numery stron jest pusta. Całkowitą wartość domyślna to 0, co nie jest zazwyczaj prawidłowy numer strony, wartość domyślna musi zostać określony jako 1 zamiast tego. Pierwszy zmiennej wynikowej są sprawdzane pod kątem wartość domyślną niepożądane, po zakończeniu zapytania podczas wykonywania. Druga zmienna wyniku uzyskuje się za pomocą <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> można określić wartość domyślną 1.  
  
 [!code-csharp[System.Linq.Enumerable#128](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#128)]
 [!code-vb[System.Linq.Enumerable#128](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#128)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wejściowy sekwencja zawiera więcej niż jeden element.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrócenia pojedynczego elementu z.</param>
        <param name="predicate">Funkcja testowania elementu dla warunku.</param>
        <summary>Zwraca tylko element sekwencji która spełnia określony warunek, lub wartość domyślną, jeśli taki element nie istnieje; Ta metoda zgłasza wyjątek, jeśli więcej niż jeden element spełnia warunek.</summary>
        <returns>Pojedynczy element sekwencji wejściowych, który spełnia warunek, lub <see langword="default" />(<paramref name="TSource" />) Jeśli taki element nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartością domyślną dla odwołania i typów zerowalnych jest `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> zaznacz tylko element w tablicy, która spełnia warunek.  
  
 [!code-csharp[System.Linq.Enumerable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#85)]
 [!code-vb[System.Linq.Enumerable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#85)]  
  
 Poniższy przykład kodu pokazuje, że <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> zwraca wartość domyślną, jeśli sekwencja nie zawiera dokładnie jeden element, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Enumerable#86](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#86)]
 [!code-vb[System.Linq.Enumerable#86](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Więcej niż jeden element spełnia warunek w <paramref name="predicate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Skip(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrócenia elementy.</param>
        <param name="count">Liczba elementów do pominięcia przed zwróceniem pozostałe elementy.</param>
        <summary>Pomija określoną liczbę elementów w sekwencji, a następnie zwraca pozostałe elementy.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawiera elementy, które wystąpiły po określonym indeksem sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Jeśli `source` zawiera mniej niż `count` elementy, pusta <xref:System.Collections.Generic.IEnumerable%601> jest zwracana. Jeśli `count` jest mniejszy niż lub równe zero, wszystkie elementy `source` są.  
  
 <xref:System.Linq.Enumerable.Take%2A> i <xref:System.Linq.Enumerable.Skip%2A> metody są funkcjonalności. Mając podaną sekwencję `coll` oraz integer `n`, złączenie wyników `coll.Take(n)` i `coll.Skip(n)` daje tę samą sekwencję co `coll`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Skip` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Skip%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Skip%2A> pominąć określoną liczbę elementów w posortowaną tablicę i zwraca wszystkie pozostałe elementy.  
  
 [!code-csharp[System.Linq.Enumerable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#87)]
 [!code-vb[System.Linq.Enumerable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f00eb172-3907-4c43-9745-d8546ab86234">Skip — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipLast(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipLast(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member SkipLast : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pomija elementów w sekwencji, tak długo, jak długo określony warunek ma wartość true, a następnie zwraca pozostałe elementy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrócenia elementy.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Pomija elementów w sekwencji, tak długo, jak długo określony warunek ma wartość true, a następnie zwraca pozostałe elementy.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy z sekwencji wejściowych, zaczynając od pierwszego elementu w liniowe serie, które nie zostały spełnione testu określonego przez <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Ta metoda sprawdza każdy element obiektu `source` przy użyciu `predicate` i pomija element, jeśli wynik jest `true`. Po powrocie funkcji predykatu `false` elementu tego elementu, a wszystkie pozostałe elementy `source` są uzyskane i nie ma żadnych więcej wywołań `predicate`.  
  
 Jeśli `predicate` zwraca `true` dla wszystkich elementów w sekwencji, pusta <xref:System.Collections.Generic.IEnumerable%601> jest zwracana.  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A> i <xref:System.Linq.Enumerable.SkipWhile%2A> metody są funkcjonalności. Mając podaną sekwencję `coll` i czystą funkcję `p`, złączenie wyników `coll.TakeWhile(p)` i `coll.SkipWhile(p)` daje tę samą sekwencję co `coll`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Skip While` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.SkipWhile%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> do pominięcia elementy tablicy, jak długo będzie spełniony jest warunek.  
  
 [!code-csharp[System.Linq.Enumerable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#88)]
 [!code-vb[System.Linq.Enumerable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5dee8350-7520-4f1a-b00d-590cacd572d6">Skip While — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do zwrócenia elementy.</param>
        <param name="predicate">Funkcja testowania każdego elementu źródłowego dla warunku; drugi parametr funkcji reprezentuje indeks elementu źródłowego.</param>
        <summary>Pomija elementów w sekwencji, tak długo, jak długo określony warunek ma wartość true, a następnie zwraca pozostałe elementy. Indeks elementu jest używany w logice funkcji predykatu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy z sekwencji wejściowych, zaczynając od pierwszego elementu w liniowe serie, które nie zostały spełnione testu określonego przez <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> Metoda sprawdza każdy element obiektu `source` przy użyciu `predicate` i pomija element, jeśli wynik jest `true`. Po powrocie funkcji predykatu `false` elementu tego elementu, a wszystkie pozostałe elementy `source` są uzyskane i nie ma żadnych więcej wywołań `predicate`.  
  
 Jeśli `predicate` zwraca `true` dla wszystkich elementów w sekwencji, pusta <xref:System.Collections.Generic.IEnumerable%601> jest zwracana.  
  
 Pierwszy argument `predicate` reprezentuje element do przetestowania. Drugi argument reprezentuje liczony od zera indeks elementu w obrębie `source`.  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A> i <xref:System.Linq.Enumerable.SkipWhile%2A> metody są funkcjonalności. Mając podaną sekwencję `coll` i czystą funkcję `p`, złączenie wyników `coll.TakeWhile(p)` i `coll.SkipWhile(p)` daje tę samą sekwencję co `coll`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Skip While` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.SkipWhile%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> do pominięcia elementy tablicy, jak długo będzie spełniony jest warunek, który zależy od indeks elementu.  
  
 [!code-csharp[System.Linq.Enumerable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#89)]
 [!code-vb[System.Linq.Enumerable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5dee8350-7520-4f1a-b00d-590cacd572d6">Skip While — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza sumę sekwencję wartości liczbowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Decimal" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> Metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> aby zsumować wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Double" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Double" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> aby zsumować wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int32" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> aby zsumować wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int64" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> aby zsumować wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Decimal" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Nie ma wyników zawierają wartości, które są `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> aby zsumować wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Double" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Double" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Wynik nie zawiera wartości, które są `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> aby zsumować wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Int32" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Wynik nie zawiera wartości, które są `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> aby zsumować wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Int64" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Wynik nie zawiera wartości, które są `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> aby zsumować wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja nullable <see cref="T:System.Single" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Single" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Wynik nie zawiera wartości, które są `null`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> aby zsumować wartości sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Single" /> wartości, aby obliczyć sumę.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Single" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> aby zsumować wartości sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Decimal" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Decimal>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Double" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Double>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Int32" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Int32>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Int64" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Int64>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Decimal" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Wynik nie uwzględnione wartości, które są `null`.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Decimal>` w języku C# lub `Nullable(Of Decimal)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Double" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Wynik nie zawiera wartości, które są `null`.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Double>` w języku C# lub `Nullable(Of Double)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Int32" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Wynik nie zawiera wartości, które są `null`.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Int32>` w języku C# lub `Nullable(Of Int32)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Int64" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Wynik nie zawiera wartości, które są `null`.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Int64>` w języku C# lub `Nullable(Of Int64)` w języku Visual Basic  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji nullable <see cref="T:System.Single" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Wynik nie zawiera wartości, które są `null`.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie `Nullable<Single>` w języku C# lub `Nullable(Of Single)` w języku Visual Basic.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania sumy.</param>
        <param name="selector">Funkcja transformacji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Single" /> wartości, które są uzyskiwane za pomocą funkcji przekształcenia na każdym elemencie sekwencji wejściowych.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> Metoda zwraca zero, jeśli `source` nie zawiera żadnych elementów.  
  
 Tej metody można zastosować do je sekvence hodnot dowolnego, jeśli podasz funkcji, `selector`, które projekty członkowie `source` do typu liczbowego specjalnie <xref:System.Single>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Aggregate Into Sum()` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> aby zsumować przewidywane wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/1315a814-5db6-4077-b34b-b141e11cc0eb">Aggregate — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Take(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja do zwrócenia elementy.</param>
        <param name="count">Liczba elementów do zwrócenia.</param>
        <summary>Zwraca określoną liczbę elementów sąsiadujących z początku sekwencji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający określoną liczbę elementów od początku sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.Take%2A> Wylicza `source` i daje elementów do momentu `count` elementy mają zostać uzyskane lub `source` nie zawiera więcej elementów. Jeśli `count` przekracza liczbę elementów w `source`, wszystkie elementy `source` są zwracane.  
  
 Jeśli `count` jest mniejsza niż zero, `source` nie jest wyliczany i pusty <xref:System.Collections.Generic.IEnumerable%601> jest zwracana.  
  
 <xref:System.Linq.Enumerable.Take%2A> i <xref:System.Linq.Enumerable.Skip%2A> metody są funkcjonalności. Mając podaną sekwencję `coll` oraz integer `n`, złączenie wyników `coll.Take(n)` i `coll.Skip(n)` daje tę samą sekwencję co `coll`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Take` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.Take%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Take%2A> do zwrócenia elementy od początku sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#99)]
 [!code-vb[System.Linq.Enumerable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/77bf87b2-1476-4456-957f-fee922fbad8c">Take — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeLast(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeLast(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member TakeLast : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca elementy z sekwencji, tak długo, jak długo określony warunek ma wartość true, a następnie pomija pozostałe elementy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja do zwrócenia elementy.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca elementy z sekwencji, tak długo, jak długo określony warunek ma wartość true.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy z sekwencji wejściowych, występujących przed elementem, w którym test nie zakończy się pomyślnie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Metoda sprawdza każdy element obiektu `source` przy użyciu `predicate` i zwraca element, jeśli wynik jest `true`. Wyliczenia zatrzymuje, gdy funkcja predykatu zwraca `false` elementu lub `source` nie zawiera więcej elementów.  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A> i <xref:System.Linq.Enumerable.SkipWhile%2A> metody są funkcjonalności. Mając podaną sekwencję `coll` i czystą funkcję `p`, złączenie wyników `coll.TakeWhile(p)` i `coll.SkipWhile(p)` daje tę samą sekwencję co `coll`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Take While` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.TakeWhile%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> do zwrócenia elementy od początku sekwencji, tak długo, jak warunek jest spełniony.  
  
 [!code-csharp[System.Linq.Enumerable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#100)]
 [!code-vb[System.Linq.Enumerable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db8f9f2f-fc9f-4a6c-b0b8-1bf048147e11">Take While — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">Sekwencja do zwrócenia elementy.</param>
        <param name="predicate">Funkcja testowania każdego elementu źródłowego dla warunku; drugi parametr funkcji reprezentuje indeks elementu źródłowego.</param>
        <summary>Zwraca elementy z sekwencji, tak długo, jak długo określony warunek ma wartość true. Indeks elementu jest używany w logice funkcji predykatu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy z sekwencji wejściowych, występujących przed elementem, w którym test nie zakończy się pomyślnie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> Metoda sprawdza każdy element obiektu `source` przy użyciu `predicate` i zwraca element, jeśli wynik jest `true`. Wyliczenia zatrzymuje, gdy funkcja predykatu zwraca `false` elementu lub `source` nie zawiera więcej elementów.  
  
 Pierwszy argument `predicate` reprezentuje element do przetestowania. Drugi argument reprezentuje liczony od zera indeks elementu w obrębie `source`.  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A> i <xref:System.Linq.Enumerable.SkipWhile%2A> metody są funkcjonalności. Mając podaną sekwencję `coll` i czystą funkcję `p`, złączenie wyników `coll.TakeWhile(p)` i `coll.SkipWhile(p)` daje tę samą sekwencję co `coll`.  
  
 W składni wyrażeń zapytania języka Visual Basic `Take While` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.TakeWhile%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> do zwrócenia elementy od początku sekwencji, dopóki spełniony jest warunek, który używa indeks elementu.  
  
 [!code-csharp[System.Linq.Enumerable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#101)]
 [!code-vb[System.Linq.Enumerable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db8f9f2f-fc9f-4a6c-b0b8-1bf048147e11">Take While — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje kolejne kolejność elementów w sekwencji w kolejności rosnącej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Zawiera elementy do sortowania.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <summary>Wykonuje kolejne kolejność elementów w sekwencji rosnąco, zgodnie z kluczem.</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Której elementy są sortowane według klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Sekwencję w kolejności według wartości samych elementów, należy określić funkcję tożsamości (`x => x` w języku Visual C# lub `Function(x) x` w języku Visual Basic) dla `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> i <xref:System.Linq.Enumerable.ThenByDescending%2A> są zdefiniowane w celu rozszerzenia typu <xref:System.Linq.IOrderedEnumerable%601>, który jest także typem zwracanym tych metod. Ten projekt umożliwia określenie wielu kryteriów sortowania, stosując dowolną liczbę <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A> metody.  
  
> [!NOTE]
>  Ponieważ <xref:System.Linq.IOrderedEnumerable%601> dziedziczy <xref:System.Collections.Generic.IEnumerable%601>, można wywołać <xref:System.Linq.Enumerable.OrderBy%2A> lub <xref:System.Linq.Enumerable.OrderByDescending%2A> na wynikach wywołania <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A>. Ten sposób wprowadza nowe podstawowe ustawianie kolejności, które ignoruje ustanowiony wcześniej sposób ustawiania.  
  
 Ta metoda porównuje klucze przy użyciu domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Ta metoda wykonuje stabilne sortowanie; oznacza to, że jeśli klawisze dwóch elementów są równe, kolejność elementów jest zachowywana. Z drugiej strony, niestabilne sortowanie nie pozwala zachować kolejności elementów, które mają ten sam klucz.  
  
 W składni wyrażeń zapytania `orderby [first criterion], [second criterion]` (Visual C#) lub `Order By [first criterion], [second criterion]` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.ThenBy%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.ThenBy%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> przeprowadzenie dodatkowej kolejność elementów w sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#102)]
 [!code-vb[System.Linq.Enumerable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">Klauzula orderby (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Order By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Zawiera elementy do sortowania.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Do porównywania kluczy.</param>
        <summary>Wykonuje kolejne kolejność elementów w sekwencji w kolejności rosnącej przy użyciu określona funkcja porównująca.</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Której elementy są sortowane według klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Sekwencję w kolejności według wartości samych elementów, należy określić funkcję tożsamości (`x => x` w języku Visual C# lub `Function(x) x` w języku Visual Basic) dla `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> i <xref:System.Linq.Enumerable.ThenByDescending%2A> są zdefiniowane w celu rozszerzenia typu <xref:System.Linq.IOrderedEnumerable%601>, który jest także typem zwracanym tych metod. Ten projekt umożliwia określenie wielu kryteriów sortowania, stosując dowolną liczbę <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A> metody.  
  
> [!NOTE]
>  Ponieważ <xref:System.Linq.IOrderedEnumerable%601> dziedziczy <xref:System.Collections.Generic.IEnumerable%601>, można wywołać <xref:System.Linq.Enumerable.OrderBy%2A> lub <xref:System.Linq.Enumerable.OrderByDescending%2A> na wynikach wywołania <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A>. Ten sposób wprowadza nowe podstawowe ustawianie kolejności, które ignoruje ustanowiony wcześniej sposób ustawiania.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A> służy do porównywania kluczy.  
  
 Ta metoda wykonuje stabilne sortowanie; oznacza to, że jeśli klawisze dwóch elementów są równe, kolejność elementów jest zachowywana. Z drugiej strony, niestabilne sortowanie nie pozwala zachować kolejności elementów, które mają ten sam klucz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje kolejne kolejność elementów w sekwencji w kolejności malejącej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Zawiera elementy do sortowania.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <summary>Wykonuje kolejne kolejność elementów w sekwencji w porządku malejącym zgodnie z kluczem.</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Której elementy są sortowane w porządku malejącym zgodnie z kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Sekwencję w kolejności według wartości samych elementów, należy określić funkcję tożsamości (`x => x` w języku Visual C# lub `Function(x) x` w języku Visual Basic) dla `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> i <xref:System.Linq.Enumerable.ThenByDescending%2A> są zdefiniowane w celu rozszerzenia typu <xref:System.Linq.IOrderedEnumerable%601>, który jest także typem zwracanym tych metod. Ten projekt umożliwia określenie wielu kryteriów sortowania, stosując dowolną liczbę <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A> metody.  
  
> [!NOTE]
>  Ponieważ <xref:System.Linq.IOrderedEnumerable%601> dziedziczy <xref:System.Collections.Generic.IEnumerable%601>, można wywołać <xref:System.Linq.Enumerable.OrderBy%2A> lub <xref:System.Linq.Enumerable.OrderByDescending%2A> na wynikach wywołania <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A>. Ten sposób wprowadza nowe podstawowe ustawianie kolejności, które ignoruje ustanowiony wcześniej sposób ustawiania.  
  
 Ta metoda sortowania porównuje klucze przy użyciu domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Ta metoda wykonuje stabilne sortowanie; oznacza to, że jeśli klawisze dwóch elementów są równe, kolejność elementów jest zachowywana. Z drugiej strony, niestabilne sortowanie nie pozwala zachować kolejności elementów, które mają ten sam klucz.  
  
 W środowisku Visual C# składni wyrażeń zapytania `orderby [first criterion], [second criterion] descending` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.ThenByDescending%2A>.  
  
 W składni wyrażeń zapytania języka Visual Basic `Order By [first criterion], [second criterion] Descending` klauzuli przekłada się na wywołanie <xref:System.Linq.Enumerable.ThenByDescending%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/21f87f48-d69d-4e95-9a52-6fec47b37e1f">Klauzula orderby (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fa911282-6b81-44c7-acfa-46b5bb93df75">Order By — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Zawiera elementy do sortowania.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Do porównywania kluczy.</param>
        <summary>Wykonuje kolejne kolejność elementów w sekwencji w kolejności malejącej, używając określona funkcja porównująca.</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> Której elementy są sortowane w porządku malejącym zgodnie z kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Sekwencję w kolejności według wartości samych elementów, należy określić funkcję tożsamości (`x => x` w języku Visual C# lub `Function(x) x` w języku Visual Basic) dla `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> i <xref:System.Linq.Enumerable.ThenByDescending%2A> są zdefiniowane w celu rozszerzenia typu <xref:System.Linq.IOrderedEnumerable%601>, który jest także typem zwracanym tych metod. Ten projekt umożliwia określenie wielu kryteriów sortowania, stosując dowolną liczbę <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A> metody.  
  
> [!NOTE]
>  Ponieważ <xref:System.Linq.IOrderedEnumerable%601> dziedziczy <xref:System.Collections.Generic.IEnumerable%601>, można wywołać <xref:System.Linq.Enumerable.OrderBy%2A> lub <xref:System.Linq.Enumerable.OrderByDescending%2A> na wynikach wywołania <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> lub <xref:System.Linq.Enumerable.ThenByDescending%2A>. Ten sposób wprowadza nowe podstawowe ustawianie kolejności, które ignoruje ustanowiony wcześniej sposób ustawiania.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A> służy do porównywania kluczy.  
  
 Ta metoda wykonuje stabilne sortowanie; oznacza to, że jeśli klawisze dwóch elementów są równe, kolejność elementów jest zachowywana. Z drugiej strony, niestabilne sortowanie nie pozwala zachować kolejności elementów, które mają ten sam klucz.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.ThenByDescending%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> przeprowadzenie dodatkowej kolejność elementów w sekwencji w kolejności malejącej, korzystając z niestandardowego modułu porównującego.  
  
 [!code-csharp[System.Linq.Enumerable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#103)]
 [!code-vb[System.Linq.Enumerable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray(Of TSource) (source As IEnumerable(Of TSource)) As TSource()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;TSource&gt; ^ ToArray(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : seq&lt;'Source&gt; -&gt; 'Source[]" Usage="System.Linq.Enumerable.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do utworzenia tablicy z.</param>
        <summary>Tworzy tablicę z <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Tablica, która zawiera elementy z sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToArray%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Metoda wymusza oceny zapytania bezpośredniego i zwraca tablicę zawierającą wyniki zapytania. Tej metody można dodać do zapytania w celu uzyskania pamięci podręcznej kopię wyników zapytania.  
  
 <xref:System.Linq.Enumerable.ToList%2A> ma zachowanie podobne, ale zwraca <xref:System.Collections.Generic.List%601> zamiast tablicy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.ToArray%2A> Aby wymusić oceny zapytania bezpośredniego i zwraca tablicę wyników.  
  
 [!code-csharp[System.Linq.Enumerable#104](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#104)]
 [!code-vb[System.Linq.Enumerable#104](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Collections.Generic.Dictionary`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Collections.Generic.Dictionary`2" /> z.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <summary>Tworzy <see cref="T:System.Collections.Generic.Dictionary`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" /> zgodnie z funkcją określonego selektora kluczy.</summary>
        <returns>Element <see cref="T:System.Collections.Generic.Dictionary`2" /> zawierający klucze i wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> Metoda wykorzystuje domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> do porównywania kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> utworzyć <xref:System.Collections.Generic.Dictionary%602> za pomocą selektora kluczy.  
  
 [!code-csharp[System.Linq.Enumerable#105](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#105)]
 [!code-vb[System.Linq.Enumerable#105](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="keySelector" /> tworzy klucz, który jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> tworzy zduplikowane klucze dla dwóch elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Typ kluczy zwracanych przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Collections.Generic.Dictionary`2" /> z.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Tworzy <see cref="T:System.Collections.Generic.Dictionary`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" /> zgodnie z określonym selektora kluczy porównania funkcji i klucza.</summary>
        <returns>Element <see cref="T:System.Collections.Generic.Dictionary`2" /> zawierający klucze i wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="keySelector" /> tworzy klucz, który jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> tworzy zduplikowane klucze dla dwóch elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Typ wartości zwracanej przez <c>elementSelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Collections.Generic.Dictionary`2" /> z.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="elementSelector">Funkcja transformacji do uzyskiwania wartości wyniku elementu z każdego z elementu.</param>
        <summary>Tworzy <see cref="T:System.Collections.Generic.Dictionary`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" /> zgodnie z określonym selektora kluczy i funkcje przełącznika kluczowego elementu.</summary>
        <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> zawiera wartości typu <paramref name="TElement" /> wybrana w zaufanym sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToDictionary%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> Metoda wykorzystuje domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> do porównywania kluczy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> lub <paramref name="elementSelector" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="keySelector" /> tworzy klucz, który jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> tworzy zduplikowane klucze dla dwóch elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Typ wartości zwracanej przez <c>elementSelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Collections.Generic.Dictionary`2" /> z.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="elementSelector">Funkcja transformacji do uzyskiwania wartości wyniku elementu z każdego z elementu.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Tworzy <see cref="T:System.Collections.Generic.Dictionary`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" /> zgodnie z funkcją określonego selektora kluczy, funkcję porównującą i funkcję selektor elementu.</summary>
        <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> zawiera wartości typu <paramref name="TElement" /> wybrana w zaufanym sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> lub <paramref name="elementSelector" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="keySelector" /> tworzy klucz, który jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> tworzy zduplikowane klucze dla dwóch elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToHashSet(Of TSource) (source As IEnumerable(Of TSource)) As HashSet(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::HashSet&lt;TSource&gt; ^ ToHashSet(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToHashSet : seq&lt;'Source&gt; -&gt; System.Collections.Generic.HashSet&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToHashSet source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Collections.Generic.HashSet`1" /> z.</param>
        <summary>Tworzy <see cref="T:System.Collections.Generic.HashSet`1" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Element <see cref="T:System.Collections.Generic.HashSet`1" /> zawiera wartości typu TSource wybrana w zaufanym sekwencji wejściowych.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToHashSet(Of TSource) (source As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As HashSet(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::HashSet&lt;TSource&gt; ^ ToHashSet(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToHashSet : seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Collections.Generic.HashSet&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToHashSet (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Collections.Generic.HashSet`1" /> z.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Tworzy <see cref="T:System.Collections.Generic.HashSet`1" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" /> przy użyciu <paramref name="comparer" /> do porównywania kluczy</summary>
        <returns>A <see cref="T:System.Collections.Generic.HashSet`1" /> zawiera wartości typu <paramref name="TSource" /> wybrana w zaufanym sekwencji wejściowych.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToList(Of TSource) (source As IEnumerable(Of TSource)) As List(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::List&lt;TSource&gt; ^ ToList(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToList : seq&lt;'Source&gt; -&gt; System.Collections.Generic.List&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToList source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Collections.Generic.List`1" /> z.</param>
        <summary>Tworzy <see cref="T:System.Collections.Generic.List`1" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Element <see cref="T:System.Collections.Generic.List`1" /> zawierający elementy z sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToList%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Metoda wymusza oceny zapytania bezpośredniego i zwraca <xref:System.Collections.Generic.List%601> zawierający wyniki zapytania. Tej metody można dodać do zapytania w celu uzyskania pamięci podręcznej kopię wyników zapytania.  
  
 <xref:System.Linq.Enumerable.ToArray%2A> ma zachowanie podobne, ale zwraca tablicę zamiast <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.ToList%2A> Aby wymusić oceny zapytania bezpośredniego, a następnie zwracają <xref:System.Collections.Generic.List%601> zawierający wyniki zapytania.  
  
 [!code-csharp[System.Linq.Enumerable#106](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#106)]
 [!code-vb[System.Linq.Enumerable#106](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLookup&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element ogólny <see cref="T:System.Linq.Lookup`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Linq.Lookup`2" /> z.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <summary>Tworzy <see cref="T:System.Linq.Lookup`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" /> zgodnie z funkcją określonego selektora kluczy.</summary>
        <returns>Element <see cref="T:System.Linq.Lookup`2" /> zawierający klucze i wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> Metoda zwraca <xref:System.Linq.Lookup%602>, słownika jeden do wielu, mapujący klucze do kolekcji wartości. A <xref:System.Linq.Lookup%602> różni się od <xref:System.Collections.Generic.Dictionary%602>, który wykonuje mapowanie jeden do jednego z kluczy do pojedynczej wartości.  
  
 Domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Linq.Lookup`2" /> z.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Lookup`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" /> zgodnie z określonym selektora kluczy porównania funkcji i klucza.</summary>
        <returns>Element <see cref="T:System.Linq.Lookup`2" /> zawierający klucze i wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Metoda zwraca <xref:System.Linq.Lookup%602>, słownika jeden do wielu, mapujący klucze do kolekcji wartości. A <xref:System.Linq.Lookup%602> różni się <xref:System.Collections.Generic.Dictionary%602>, który wykonuje mapowanie jeden do jednego z kluczy do pojedynczej wartości.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Typ wartości zwracanej przez <c>elementSelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Linq.Lookup`2" /> z.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="elementSelector">Funkcja transformacji do uzyskiwania wartości wyniku elementu z każdego z elementu.</param>
        <summary>Tworzy <see cref="T:System.Linq.Lookup`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" /> zgodnie z określonym selektora kluczy i funkcje przełącznika kluczowego elementu.</summary>
        <returns>A <see cref="T:System.Linq.Lookup`2" /> zawiera wartości typu <paramref name="TElement" /> wybrana w zaufanym sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> Metoda zwraca <xref:System.Linq.Lookup%602>, słownika jeden do wielu, mapujący klucze do kolekcji wartości. A <xref:System.Linq.Lookup%602> różni się od <xref:System.Collections.Generic.Dictionary%602>, który wykonuje mapowanie jeden do jednego z kluczy do pojedynczej wartości.  
  
 Domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> utworzyć <xref:System.Linq.Lookup%602> przy użyciu funkcji selektora kluczy i funkcję selektor elementu.  
  
 [!code-csharp[System.Linq.Enumerable#107](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#107)]
 [!code-vb[System.Linq.Enumerable#107](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> lub <paramref name="elementSelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <typeparam name="TKey">Rodzaj klucza zwracany przez <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Typ wartości zwracanej przez <c>elementSelector</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Utworzyć <see cref="T:System.Linq.Lookup`2" /> z.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="elementSelector">Funkcja transformacji do uzyskiwania wartości wyniku elementu z każdego z elementu.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Lookup`2" /> z <see cref="T:System.Collections.Generic.IEnumerable`1" /> zgodnie z funkcją określonego selektora kluczy, funkcję porównującą i funkcję selektor elementu.</summary>
        <returns>A <see cref="T:System.Linq.Lookup`2" /> zawiera wartości typu <paramref name="TElement" /> wybrana w zaufanym sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Metoda zwraca <xref:System.Linq.Lookup%602>, słownika jeden do wielu, mapujący klucze do kolekcji wartości. A <xref:System.Linq.Lookup%602> różni się od <xref:System.Collections.Generic.Dictionary%602>, który wykonuje mapowanie jeden do jednego z kluczy do pojedynczej wartości.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> służy do porównywania kluczy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="keySelector" /> lub <paramref name="elementSelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zbiorów dwóch sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której różne elementy stanowią pierwszy zestaw dla Unii.</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której różne elementy tworzą drugiego zestawu dla Unii.</param>
        <summary>Tworzy zbiorów dwóch sekwencji za pomocą domyślny moduł porównujący równość.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy z obu sekwencji wejściowych, z wyłączeniem duplikaty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Ta metoda nie obejmuje duplikaty z zestawu zwracany. Jest to zachowanie różnych do <xref:System.Linq.Enumerable.Concat%2A> metody, która zwraca wszystkie elementy w sekwencji wejściowych, włącznie z duplikaty.  
  
 Domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania wartości typów implementujących <xref:System.Collections.Generic.IEqualityComparer%601> interfejs generyczny. Aby porównać niestandardowy typ danych, należy zaimplementować niniejszy interfejs i podać własne <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metod dla typu.  
  
 Gdy obiekt zwracany przez tę metodę jest zostanie wyliczonly, <xref:System.Linq.Enumerable.Union%2A> wylicza `first` i `second` w tej kolejności i każdego elementu, który nie ma już uzyskane daje.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> uzyskać sumę dwóch sekwencji liczb całkowitych.  
  
 [!code-csharp[System.Linq.Enumerable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#109)]
 [!code-vb[System.Linq.Enumerable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#109)]  
  
 Jeśli chcesz porównać sekwencji obiektów niestandardowego typu danych, musisz zaimplementować <xref:System.Collections.Generic.IEqualityComparer%601> ogólny interfejs w helperclass. Poniższy przykład kodu pokazuje sposób implementacji niniejszego interfejsu do niestandardowego typu danych i zapewniają <xref:System.Object.GetHashCode%2A> i <xref:System.Object.Equals%2A> metody.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Po zaimplementowaniu ten interfejs, można użyć sekwencji `ProductA` obiekty w <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#4)]
[!code-vb[CSLINQEncapsulatedComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której różne elementy stanowią pierwszy zestaw dla Unii.</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Której różne elementy tworzą drugiego zestawu dla Unii.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania wartości.</param>
        <summary>Tworzy zbiorów dwóch sekwencji przy użyciu określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy z obu sekwencji wejściowych, z wyłączeniem duplikaty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący równość, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, służy do porównywania wartości.  
  
 Gdy obiekt zwracany przez tę metodę jest zostanie wyliczonly, <xref:System.Linq.Enumerable.Union%2A> wylicza `first` i `second` w tej kolejności i każdego elementu, który nie ma już uzyskane daje.  
  
 <xref:System.Linq.Enumerable.Concat%2A> Metoda różni się od <xref:System.Linq.Enumerable.Union%2A> metody ponieważ <xref:System.Linq.Enumerable.Concat%2A> metoda zwraca wszystkie elementy w sekwencji wejściowych, włącznie duplikaty, natomiast <xref:System.Linq.Enumerable.Union%2A> zwraca tylko unikatowe wartości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zaimplementować moduł porównujący równość mogą być używane w <xref:System.Linq.Enumerable.Union%2A> metody.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Po zaimplementowaniu tej porównania można użyć sekwencji `Product` obiekty w <xref:System.Linq.Enumerable.Union%2A> metodzie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#4)]
[!code-vb[CSLINQCustomComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Służy do przefiltrowania kolejność wartości na podstawie predykatu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Where(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do filtrowania.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Służy do przefiltrowania kolejność wartości na podstawie predykatu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy z sekwencji wejściowych, które spełniają warunek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 W składni wyrażeń zapytania `where` (Visual C#) lub `Where` — klauzula (Visual Basic) przekłada się na wywołanie <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> do filtrowania sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#110)]
 [!code-vb[System.Linq.Enumerable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7f9bf952-7744-4f91-b676-cddb55d107c3">Klauzula where (odwołanie w C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/48b5c2c5-3181-429c-8545-894296798c89">Where — Klauzula (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Where(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <c>źródła</c>.</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Do filtrowania.</param>
        <param name="predicate">Funkcja testowania każdego elementu źródłowego dla warunku; drugi parametr funkcji reprezentuje indeks elementu źródłowego.</param>
        <summary>Służy do przefiltrowania kolejność wartości na podstawie predykatu. Indeks każdy element jest używany w logice funkcji predykatu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający elementy z sekwencji wejściowych, które spełniają warunek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Pierwszy argument `predicate` reprezentuje element do przetestowania. Drugi argument reprezentuje liczony od zera indeks elementu w obrębie `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> do filtrowania sekwencji na podstawie predykatu, który obejmuje indeks każdego elementu.  
  
 [!code-csharp[System.Linq.Enumerable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#111)]
 [!code-vb[System.Linq.Enumerable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As IEnumerable(Of TFirst), second As IEnumerable(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Zip(System::Collections::Generic::IEnumerable&lt;TFirst&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : seq&lt;'First&gt; * seq&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Typ elementów pierwszej sekwencji wejściowych.</typeparam>
        <typeparam name="TSecond">Typ elementów drugiej sekwencji wejściowych.</typeparam>
        <typeparam name="TResult">Typ elementów sekwencji wynik.</typeparam>
        <param name="first">Pierwsza sekwencja do scalenia.</param>
        <param name="second">Drugiej sekwencji do scalenia.</param>
        <param name="resultSelector">Funkcja, która określa sposób scalania elementów z dwóch sekwencji.</param>
        <summary>Dotyczy określonej funkcji odpowiadające elementy dwóch sekwencji, produkcji sekwencji wyników.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający scalone elementy dwóch sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementowana za pomocą odroczonego wykonania. Bezpośrednio zwracana wartość jest obiektem, który przechowuje wszystkie informacje wymagane do wykonania akcji. Zapytanie, reprezentowane przez tę metodę nie jest wykonywana do czasu, przez wywołanie obiekt jest zostanie wyliczonly jego `GetEnumerator` metoda bezpośrednio lub za pomocą `foreach` w języku Visual C# lub `For Each` w języku Visual Basic.  
  
 Metoda scala każdego elementu pierwszej sekwencji z elementu, który ma ten sam indeks w drugiej sekwencji. Jeżeli sekwencje mają taką samą liczbę elementów metody scala sekwencji, dopóki nie zostanie osiągnięty koniec jeden z nich. Na przykład jeśli jednej sekwencji ma trzy elementy, a druga ma cztery sekwencji wynik ma tylko trzy elementy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Linq.Enumerable.Zip%2A> metodę, aby scalić dwóch sekwencji.  
  
 [!code-csharp[System.Linq.Enumerable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#200)]
 [!code-vb[System.Linq.Enumerable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> lub <paramref name="second" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="DictionaryBase" FullName="System.Collections.DictionaryBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="78fa07b57216bf74a9bdc572078061320f5ceac8" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69333940" /></Metadata><TypeSignature Language="C#" Value="public abstract class DictionaryBase : System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit DictionaryBase extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.DictionaryBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DictionaryBase&#xA;Implements IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class DictionaryBase abstract : System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type DictionaryBase = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Dostarcza klasę <see langword="abstract" /> bazową dla jednoznacznie wpisanej kolekcji par klucz/wartość.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  Nie zalecamy używania `DictionaryBase` klasy do nowych celów programistycznych. Zamiast tego zaleca się użycie klasy generycznej <xref:System.Collections.Generic.Dictionary%602> lub. <xref:System.Collections.ObjectModel.KeyedCollection%602> Aby uzyskać więcej informacji, zobacz [kolekcje nieogólne nie mogą być używane](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) w serwisie GitHub.

C# Instrukcja [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) i Visual Basic [dla każdej](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) instrukcji zwracają obiekt typu elementów w kolekcji. Ponieważ każdy element <xref:System.Collections.DictionaryBase> jest parą klucz/wartość, typ elementu nie jest typem klucza ani typem wartości. Zamiast tego typ elementu to <xref:System.Collections.DictionaryEntry>.  
  
 `foreach` Instrukcja to otoka wokół modułu wyliczającego, która umożliwia odczyt z kolekcji.  
  
> [!NOTE]
>  Ponieważ klucze mogą być dziedziczone i ich zachowanie zostało zmienione, ich absolutna unikatowość nie może być gwarantowana przez <xref:System.Type.Equals%2A> porównania przy użyciu metody.  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w Visual Basic) członkowie tego typu są bezpieczne wątkowo. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
Ta implementacja nie zapewnia zsynchronizowanej (bezpiecznej wątkowo) otoki dla <see cref="T:System.Collections.DictionaryBase" />, ale klasy pochodne mogą tworzyć własne zsynchronizowane wersje <see cref="T:System.Collections.DictionaryBase" /> <see cref="P:System.Collections.ICollection.SyncRoot" /> właściwości using.  
  
Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</threadsafe>
    <block subset="none" type="overrides"><para>Ta klasa bazowa jest udostępniana w celu ułatwienia implementacji do tworzenia kolekcji niestandardowej o jednoznacznie określonym typie. Zachęcamy do przeciągnięcia tej klasy bazowej zamiast tworzenia własnych.  
  
 Elementy członkowskie tej klasy bazowej są chronione i są przeznaczone do użycia tylko przez klasę pochodną.</para></block>
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="N:System.Collections.Generic" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Wykonywanie niezależnych od kultury operacji na ciągach</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DictionaryBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DictionaryBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.DictionaryBase" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest operacją O (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="dictionaryBase.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści zawartość <see cref="T:System.Collections.DictionaryBase" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.DictionaryBase.Count%2A>jest ustawiona na zero, a odwołania do innych obiektów z elementów kolekcji również są wydane.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.DictionaryBase.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="dictionaryBase.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> , który jest miejscem docelowym <see cref="T:System.Collections.DictionaryEntry" /> obiektów kopiowanych z <see cref="T:System.Collections.DictionaryBase" /> wystąpienia. <see cref="T:System.Array" /> Musi mieć indeksowanie oparte na zero.</param>
        <param name="index">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje elementy do jednowymiarowego <see cref="T:System.Array" /> o określonym indeksie. <see cref="T:System.Collections.DictionaryBase" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane do <xref:System.Array> tabeli w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.DictionaryBase>przez.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.DictionaryBase.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />jest wielowymiarowych.  
  
—lub— 
Liczba elementów w źródle <see cref="T:System.Collections.DictionaryBase" /> jest większa niż dostępne miejsce od <paramref name="index" /> do końca miejsca docelowego <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Nie można automatycznie rzutować <see cref="T:System.Collections.DictionaryBase" /> typu źródła na typ docelowy. <paramref name="array" /></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.DictionaryBase.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.DictionaryBase.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w <see cref="T:System.Collections.DictionaryBase" /> wystąpieniu.</summary>
        <value>Liczba elementów zawartych w <see cref="T:System.Collections.DictionaryBase" /> wystąpieniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Dictionary { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.IDictionary" Usage="System.Collections.DictionaryBase.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę elementów zawartych w <see cref="T:System.Collections.DictionaryBase" /> wystąpieniu.</summary>
        <value><see cref="T:System.Collections.IDictionary" /> Reprezentuje<see cref="T:System.Collections.DictionaryBase" /> wystąpienie samego siebie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="dictionaryBase.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Collections.DictionaryBase" /> , która wykonuje iterację przez wystąpienie. <see cref="T:System.Collections.IDictionaryEnumerator" /></summary>
        <returns><see cref="T:System.Collections.IDictionaryEnumerator" /> Dla<see cref="T:System.Collections.DictionaryBase" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Instrukcja języka(`for each` w Visual Basic) ukrywa złożoność modułów wyliczających. C# `foreach`  W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>przywraca również moduł wyliczający z powrotem do tego położenia.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> nie jest zdefiniowane. W związku z tym przed <xref:System.Collections.IEnumerator.MoveNext%2A> przeczytaniem <xref:System.Collections.IEnumerator.Current%2A>wartości parametru należy wywołać metodę wyliczającą do pierwszego elementu kolekcji.  
  
 <xref:System.Collections.IEnumerator.Current%2A>zwraca ten sam obiekt do <xref:System.Collections.IEnumerator.MoveNext%2A> momentu <xref:System.Collections.IEnumerator.Reset%2A> wywołania metody lub. <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.IEnumerator.Current%2A> nie jest zdefiniowane. Aby ponownie <xref:System.Collections.IEnumerator.Current%2A> ustawić na pierwszy element kolekcji, możesz wywołać metodę <xref:System.Collections.IEnumerator.Reset%2A> i <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="InnerHashtable">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable InnerHashtable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Hashtable InnerHashtable" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.InnerHashtable" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property InnerHashtable As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Hashtable ^ InnerHashtable { System::Collections::Hashtable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerHashtable : System.Collections.Hashtable" Usage="System.Collections.DictionaryBase.InnerHashtable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę elementów zawartych w <see cref="T:System.Collections.DictionaryBase" /> wystąpieniu.</summary>
        <value><see cref="T:System.Collections.Hashtable" /> Reprezentuje<see cref="T:System.Collections.DictionaryBase" /> wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClear">
      <MemberSignature Language="C#" Value="protected virtual void OnClear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnClear" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClear ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClear();" />
      <MemberSignature Language="F#" Value="abstract member OnClear : unit -&gt; unit&#xA;override this.OnClear : unit -&gt; unit" Usage="dictionaryBase.OnClear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje dodatkowe procesy niestandardowe przed wyczyszczeniem zawartości <see cref="T:System.Collections.DictionaryBase" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody powinna zostać przesłonięta przez klasę pochodną, aby wykonać jakąś akcję przed wyczyszczeniem kolekcji.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które muszą zostać wykonane przed usunięciem wszystkich elementów z bazowego <see cref="T:System.Collections.Hashtable" />. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnClear" />jest wywoływany przed normalnym zachowaniem Clear <see cref="M:System.Collections.DictionaryBase.OnClearComplete" /> , natomiast jest wywoływana po standardowych zachowaniach Clear.  
  
Na przykład implementacje mogą wykluczać niektóre elementy z usuwania przez globalne czyszczenie.</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnClearComplete" />
        <altmember cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnClearComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnClearComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClearComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnClearComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClearComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClearComplete();" />
      <MemberSignature Language="F#" Value="abstract member OnClearComplete : unit -&gt; unit&#xA;override this.OnClearComplete : unit -&gt; unit" Usage="dictionaryBase.OnClearComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje dodatkowe procesy niestandardowe po wyczyszczeniu zawartości <see cref="T:System.Collections.DictionaryBase" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody została przesłonięta przez klasę pochodną, aby wykonać jakąś akcję po wyczyszczeniu kolekcji.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które należy wykonać po usunięciu wszystkich elementów z bazowego <see cref="T:System.Collections.Hashtable" />. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnClear" />jest wywoływany przed normalnym zachowaniem Clear <see cref="M:System.Collections.DictionaryBase.OnClearComplete" /> , natomiast jest wywoływana po standardowych zachowaniach Clear.</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnClear" />
        <altmember cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnGet">
      <MemberSignature Language="C#" Value="protected virtual object OnGet (object key, object currentValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object OnGet(object key, object currentValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnGet(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnGet (key As Object, currentValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ OnGet(System::Object ^ key, System::Object ^ currentValue);" />
      <MemberSignature Language="F#" Value="abstract member OnGet : obj * obj -&gt; obj&#xA;override this.OnGet : obj * obj -&gt; obj" Usage="dictionaryBase.OnGet (key, currentValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="currentValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do pobrania.</param>
        <param name="currentValue">Bieżąca wartość elementu skojarzonego z <paramref name="key" />.</param>
        <summary>Pobiera element z określonym kluczem i wartością w <see cref="T:System.Collections.DictionaryBase" /> wystąpieniu.</summary>
        <returns><see cref="T:System.Object" /> Zawierający element z określonym kluczem i wartością.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zwraca `currentValue`. Jest przeznaczony do przesłaniania przez klasę pochodną w celu wykonania dodatkowej akcji po pobraniu określonego elementu.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które należy wykonać podczas wykonywania standardowego działania <see cref="T:System.Collections.Hashtable" />pobierania. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnGet(System.Object,System.Object)" />można go użyć do określenia procesów do wykonania przed zwróceniem wartości pobranej z bazowego <see cref="T:System.Collections.Hashtable" />. Na przykład implementujące mogą rzutować wartość na inny typ przed jego zwróceniem.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnInsert">
      <MemberSignature Language="C#" Value="protected virtual void OnInsert (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsert(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInsert (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInsert(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnInsert : obj * obj -&gt; unit&#xA;override this.OnInsert : obj * obj -&gt; unit" Usage="dictionaryBase.OnInsert (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do wstawienia.</param>
        <param name="value">Wartość elementu do wstawienia.</param>
        <summary>Wykonuje dodatkowe procesy niestandardowe przed wstawieniem nowego elementu do <see cref="T:System.Collections.DictionaryBase" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody została przesłonięta przez klasę pochodną, aby wykonać jakąś akcję przed wstawieniem określonego elementu.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które należy wykonać przed wstawieniem elementu do źródłowej <see cref="T:System.Collections.Hashtable" />. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />jest wywoływany przed standardowym zachowaniem INSERT <see cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" /> , natomiast jest wywoływana po standardowej operacji wstawiania.  
  
Na przykład implementacje mogą ograniczać typy obiektów, które można wstawiać do <see cref="T:System.Collections.Hashtable" />.</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnInsertComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInsertComplete (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsertComplete(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInsertComplete (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInsertComplete(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnInsertComplete : obj * obj -&gt; unit&#xA;override this.OnInsertComplete : obj * obj -&gt; unit" Usage="dictionaryBase.OnInsertComplete (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do wstawienia.</param>
        <param name="value">Wartość elementu do wstawienia.</param>
        <summary>Wykonuje dodatkowe procesy niestandardowe po wstawieniu nowego elementu do <see cref="T:System.Collections.DictionaryBase" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody ma zostać zastąpiona przez klasę pochodną, aby wykonać jakąś akcję po wstawieniu określonego elementu.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które należy wykonać po wstawieniu elementu do źródłowej <see cref="T:System.Collections.Hashtable" />. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />jest wywoływany przed standardowym zachowaniem INSERT <see cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" /> , natomiast jest wywoływana po standardowej operacji wstawiania.</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnRemove">
      <MemberSignature Language="C#" Value="protected virtual void OnRemove (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemove(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemove (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemove(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRemove : obj * obj -&gt; unit&#xA;override this.OnRemove : obj * obj -&gt; unit" Usage="dictionaryBase.OnRemove (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <param name="value">Wartość elementu do usunięcia.</param>
        <summary>Wykonuje dodatkowe procesy niestandardowe przed usunięciem elementu z <see cref="T:System.Collections.DictionaryBase" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody została przesłonięta przez klasę pochodną, aby wykonać jakąś akcję przed usunięciem określonego elementu.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które muszą zostać wykonane przed usunięciem elementu z bazowego <see cref="T:System.Collections.Hashtable" />. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />jest wywoływany przed standardowym zachowaniem usuwania <see cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" /> , natomiast jest wywoływana po standardowych zachowaniach usuwania.  
  
Na przykład implementacje mogą uniemożliwiać usunięcie elementów, zawsze zwracając wyjątek w <see cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />.</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnClear" />
      </Docs>
    </Member>
    <Member MemberName="OnRemoveComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveComplete (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveComplete(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveComplete (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveComplete(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveComplete : obj * obj -&gt; unit&#xA;override this.OnRemoveComplete : obj * obj -&gt; unit" Usage="dictionaryBase.OnRemoveComplete (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <param name="value">Wartość elementu do usunięcia.</param>
        <summary>Wykonuje dodatkowe procesy niestandardowe po usunięciu elementu z <see cref="T:System.Collections.DictionaryBase" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody ma zostać zastąpiona przez klasę pochodną, aby wykonać jakąś akcję po usunięciu określonego elementu.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które należy wykonać po usunięciu elementu z bazowego <see cref="T:System.Collections.Hashtable" />. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />jest wywoływany przed standardowym zachowaniem usuwania <see cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" /> , natomiast jest wywoływana po standardowych zachowaniach usuwania.</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnClearComplete" />
      </Docs>
    </Member>
    <Member MemberName="OnSet">
      <MemberSignature Language="C#" Value="protected virtual void OnSet (object key, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSet(object key, object oldValue, object newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSet (key As Object, oldValue As Object, newValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSet(System::Object ^ key, System::Object ^ oldValue, System::Object ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnSet : obj * obj * obj -&gt; unit&#xA;override this.OnSet : obj * obj * obj -&gt; unit" Usage="dictionaryBase.OnSet (key, oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do zlokalizowania.</param>
        <param name="oldValue">Stara wartość elementu skojarzonego z <paramref name="key" />.</param>
        <param name="newValue">Nowa wartość elementu skojarzonego z <paramref name="key" />.</param>
        <summary>Wykonuje dodatkowe procesy niestandardowe przed ustawieniem wartości w <see cref="T:System.Collections.DictionaryBase" /> wystąpieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody została przesłonięta przez klasę pochodną, aby wykonać jakąś akcję przed ustawieniem określonego elementu.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które muszą zostać wykonane przed ustawieniem określonego elementu w podstawowym <see cref="T:System.Collections.Hashtable" />. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />jest wywoływana przed zachowaniem standardowego zestawu, natomiast <see cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" /> jest wywoływana po zastosowaniu standardowego ustawienia.  
  
Na przykład implementujące mogą ograniczyć wartości, które mogą zostać zastąpione przez wykonanie kontroli wewnątrz <see cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />.</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnSetComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSetComplete (object key, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetComplete(object key, object oldValue, object newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetComplete (key As Object, oldValue As Object, newValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetComplete(System::Object ^ key, System::Object ^ oldValue, System::Object ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnSetComplete : obj * obj * obj -&gt; unit&#xA;override this.OnSetComplete : obj * obj * obj -&gt; unit" Usage="dictionaryBase.OnSetComplete (key, oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do zlokalizowania.</param>
        <param name="oldValue">Stara wartość elementu skojarzonego z <paramref name="key" />.</param>
        <param name="newValue">Nowa wartość elementu skojarzonego z <paramref name="key" />.</param>
        <summary>Wykonuje dodatkowe procesy niestandardowe po ustawieniu wartości w <see cref="T:System.Collections.DictionaryBase" /> wystąpieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody ma zostać zastąpiona przez klasę pochodną, aby wykonać jakąś akcję po ustawieniu określonego elementu.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które należy wykonać po ustawieniu określonego elementu w podstawowym <see cref="T:System.Collections.Hashtable" />. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />jest wywoływana przed zachowaniem standardowego zestawu, natomiast <see cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" /> jest wywoływana po zastosowaniu standardowego ustawienia.</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnValidate">
      <MemberSignature Language="C#" Value="protected virtual void OnValidate (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidate(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidate (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidate(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnValidate : obj * obj -&gt; unit&#xA;override this.OnValidate : obj * obj -&gt; unit" Usage="dictionaryBase.OnValidate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do zweryfikowania.</param>
        <param name="value">Wartość elementu do zweryfikowania.</param>
        <summary>Wykonuje dodatkowe procesy niestandardowe podczas walidacji elementu z określonym kluczem i wartością.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody ma zostać zastąpiona przez klasę pochodną, aby wykonać jakąś akcję po sprawdzeniu poprawności określonego elementu.  
  
 Metody on * są wywoływane tylko w wystąpieniu zwracanym przez <xref:System.Collections.DictionaryBase.Dictionary%2A> właściwość, ale nie w wystąpieniu zwracanym <xref:System.Collections.DictionaryBase.InnerHashtable%2A> przez właściwość.  
  
 Domyślna implementacja tej metody jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda umożliwia realizatorom Definiowanie procesów, które muszą zostać wykonane podczas wykonywania standardowego zachowania bazowego <see cref="T:System.Collections.Hashtable" />. Definiując tę metodę, realizatorzy mogą dodawać funkcje do metod dziedziczonych bez konieczności przesłonięcia wszystkich innych metod.  
  
 <see cref="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />może służyć do nakładania ograniczeń dotyczących typu obiektów, które są akceptowane do kolekcji. Domyślna implementacja uniemożliwia <see langword="null" /> dodanie lub usunięcie z bazowego <see cref="T:System.Collections.Hashtable" />.</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do <see cref="T:System.Collections.DictionaryBase" /> obiektu jest synchronizowany (bezpieczny wątkowo).</summary>
        <value><see langword="true" />Jeśli dostęp do <see cref="T:System.Collections.DictionaryBase" /> obiektu jest synchronizowany (bezpieczny wątkowo); <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.DictionaryBase> Obiekt nie jest zsynchronizowany. Klasy pochodne mogą udostępniać zsynchronizowaną wersję <xref:System.Collections.DictionaryBase> klasy <xref:System.Collections.ICollection.SyncRoot%2A> przy użyciu właściwości.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zablokować kolekcję przy użyciu <xref:System.Collections.ICollection.SyncRoot%2A> właściwości podczas całego wyliczania.  
  
 [!code-cpp[System.Collections.DictionaryBase#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.DictionaryBase#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/source2.cs#3)]
 [!code-vb[System.Collections.DictionaryBase#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/source2.vb#3)]  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.DictionaryBase" /> obiektu.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.DictionaryBase" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne mogą udostępniać własne zsynchronizowane wersje <xref:System.Collections.DictionaryBase> klasy <xref:System.Collections.ICollection.SyncRoot%2A> przy użyciu właściwości. Kod synchronizacji musi wykonywać operacje na <xref:System.Collections.ICollection.SyncRoot%2A> właściwości <xref:System.Collections.DictionaryBase> obiektu <xref:System.Collections.DictionaryBase> , nie bezpośrednio w obiekcie. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W celu zapewnienia odpowiedniej synchronizacji z innymi wątkami, które mogą jednocześnie modyfikować <xref:System.Collections.DictionaryBase> obiekt.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zablokować kolekcję przy użyciu <xref:System.Collections.ICollection.SyncRoot%2A> właściwości podczas całego wyliczania.  
  
 [!code-cpp[System.Collections.DictionaryBase#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.DictionaryBase#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/source2.cs#3)]
 [!code-vb[System.Collections.DictionaryBase#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/source2.vb#3)]  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do dodania.</param>
        <param name="value">Wartość elementu do dodania.</param>
        <summary>Dodaje element z określonym kluczem i wartością do <see cref="T:System.Collections.DictionaryBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który nie ma korelacji między jego stanem a wartością kodu skrótu, nie powinien zazwyczaj być używany jako klucz. Na przykład <xref:System.String> obiekty są lepsze niż <xref:System.Text.StringBuilder> obiekty do użycia jako klucze.  
  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje <xref:System.Collections.DictionaryBase>w, na przykład `myCollection["myNonexistentKey"] = myValue`. Jeśli jednak określony klucz już istnieje w <xref:System.Collections.DictionaryBase>, <xref:System.Collections.IDictionary.Item%2A> ustawienie właściwości zastępuje starą wartość. Z kolei <xref:System.Collections.IDictionary.Add%2A> Metoda nie modyfikuje istniejących elementów.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element z tym samym kluczem już istnieje w <see cref="T:System.Collections.DictionaryBase" />.</exception>
        <exception cref="T:System.NotSupportedException">Jest <see cref="T:System.Collections.DictionaryBase" /> tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.DictionaryBase" /> Ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać zlokalizowany w <see cref="T:System.Collections.DictionaryBase" />.</param>
        <summary>Określa, <see cref="T:System.Collections.DictionaryBase" /> czy zawiera określony klucz.</summary>
        <returns><see langword="true" />Jeśli zawiera element z określonym kluczem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Collections.DictionaryBase" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest operacją O(1).  
  
 Począwszy od .NET Framework 2,0, ta metoda używa <xref:System.Object.Equals%2A> obiektów i <xref:System.IComparable.CompareTo%2A> metod `key` kolekcji, aby określić, czy `item` istnieje. We wcześniejszych wersjach .NET Framework to ustalenie zostało wykonane przy użyciu <xref:System.Object.Equals%2A> metod `key` i <xref:System.IComparable.CompareTo%2A> parametru dla obiektów w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Wykonywanie niezależnych od kultury operacji na ciągach</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Collections.DictionaryBase" /> obiekt ma stały rozmiar.</summary>
        <value><see langword="true" />Jeśli obiekt ma stały rozmiar; <see langword="false" />w przeciwnym razie. <see cref="T:System.Collections.DictionaryBase" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja o stałym rozmiarze nie zezwala na dodawanie lub usuwanie elementów po utworzeniu kolekcji, ale umożliwia modyfikację istniejących elementów.  
  
 Kolekcja o stałym rozmiarze jest po prostu kolekcją z otoką, która zapobiega dodawaniu i usuwaniu elementów; w związku z tym, jeśli wprowadzono zmiany do źródłowej kolekcji, w tym dodawanie lub usuwanie elementów, kolekcja o stałym rozmiarze odzwierciedla te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Collections.DictionaryBase" /> obiekt jest tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli obiekt jest tylko do odczytu; <see langword="false" />w przeciwnym razie. <see cref="T:System.Collections.DictionaryBase" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, którego wartość ma zostać pobrana lub ustawiona.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z określonym kluczem.</summary>
        <value>Wartość skojarzona z określonym kluczem. Jeśli określony klucz nie zostanie znaleziony, próba jego powracania <see langword="null" />i próba ustawienia powoduje utworzenie nowego elementu przy użyciu określonego klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia możliwość dostępu do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]`.  
  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje <xref:System.Collections.DictionaryBase>w, na przykład `myCollection["myNonexistentKey"] = myValue`. Jeśli jednak określony klucz już istnieje w <xref:System.Collections.DictionaryBase>, <xref:System.Collections.IDictionary.Item%2A> ustawienie właściwości zastępuje starą wartość. Z kolei <xref:System.Collections.IDictionary.Add%2A> Metoda nie modyfikuje istniejących elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O (1); ustawienie właściwości jest również operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Właściwość jest ustawiona i jest tylko <see cref="T:System.Collections.DictionaryBase" /> do odczytu.  
  
—lub— 
Właściwość jest ustawiona, <paramref name="key" /> nie istnieje w kolekcji <see cref="T:System.Collections.DictionaryBase" /> i ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt zawierający klucze <see cref="T:System.Collections.DictionaryBase" /> w obiekcie. <see cref="T:System.Collections.ICollection" /></summary>
        <value>Obiekt zawierający klucze <see cref="T:System.Collections.DictionaryBase" /> w obiekcie. <see cref="T:System.Collections.ICollection" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność kluczy w <xref:System.Collections.ICollection> obiekcie jest nieokreślona, ale jest taka sama jak w przypadku skojarzonych wartości <xref:System.Collections.ICollection> w obiekcie zwracanym przez <xref:System.Collections.IDictionary.Values%2A> właściwość.  
  
 Zwracana <xref:System.Collections.ICollection> wartość nie jest kopią statyczną; zamiast tego <xref:System.Collections.ICollection> odwołuje się do kluczy w oryginalnym <xref:System.Collections.DictionaryBase> obiekcie. W związku z tym zmiany <xref:System.Collections.DictionaryBase> w dalszym ciągu zostaną odzwierciedlone <xref:System.Collections.ICollection>w zwracanym elemencie.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają właściwość 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.IDictionary.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.DictionaryBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie zawiera elementu z określonym kluczem <xref:System.Collections.DictionaryBase> , pozostaje niezmieniona. <xref:System.Collections.DictionaryBase> Nie zgłoszono żadnego wyjątku.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Jest <see cref="T:System.Collections.DictionaryBase" /> tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.DictionaryBase" /> Ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Wykonywanie niezależnych od kultury operacji na ciągach</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt zawierający wartości <see cref="T:System.Collections.DictionaryBase" /> w obiekcie. <see cref="T:System.Collections.ICollection" /></summary>
        <value>Obiekt zawierający wartości <see cref="T:System.Collections.DictionaryBase" /> w obiekcie. <see cref="T:System.Collections.ICollection" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność wartości w <xref:System.Collections.ICollection> obiekcie jest nieokreślona, ale jest to taka sama kolejność, jak skojarzone klucze <xref:System.Collections.ICollection> w obiekcie zwracanym przez <xref:System.Collections.IDictionary.Keys%2A> właściwość.  
  
 Zwracana <xref:System.Collections.ICollection> wartość nie jest kopią statyczną; zamiast tego <xref:System.Collections.ICollection> odwołuje się do wartości w oryginalnym <xref:System.Collections.DictionaryBase> obiekcie. W związku z tym zmiany <xref:System.Collections.DictionaryBase> w dalszym ciągu zostaną odzwierciedlone <xref:System.Collections.ICollection>w zwracanym elemencie.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu implementuje <xref:System.Collections.DictionaryBase> klasę i używa tej implementacji do tworzenia <xref:System.String> słownika kluczy <xref:System.String.Length%2A> i wartości, które mają właściwość 5 znaków lub mniej.  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.IDictionary.Keys" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Collections.DictionaryBase" />, która wykonuje iterację przez. <see cref="T:System.Collections.IEnumerator" /></summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Dla .<see cref="T:System.Collections.DictionaryBase" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Instrukcja języka(`for each` w Visual Basic) ukrywa złożoność modułów wyliczających. C# `foreach` W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>przywraca również moduł wyliczający z powrotem do tego położenia. W tym miejscu wywołanie <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. W związku z tym przed <xref:System.Collections.IEnumerator.MoveNext%2A> przeczytaniem <xref:System.Collections.IEnumerator.Current%2A>wartości parametru należy wywołać metodę wyliczającą do pierwszego elementu kolekcji.  
  
 <xref:System.Collections.IEnumerator.Current%2A>zwraca ten sam obiekt do <xref:System.Collections.IEnumerator.MoveNext%2A> momentu <xref:System.Collections.IEnumerator.Reset%2A> wywołania metody lub. <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, wywołanie <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. Aby ponownie <xref:System.Collections.IEnumerator.Current%2A> ustawić na pierwszy element kolekcji, możesz wywołać metodę <xref:System.Collections.IEnumerator.Reset%2A> i <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> wygeneruje <xref:System.InvalidOperationException>. Jeśli kolekcja zostanie zmodyfikowana między <xref:System.Collections.IEnumerator.MoveNext%2A> i <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> zwraca element, który jest ustawiony na, nawet jeśli moduł wyliczający jest już unieważniony.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>

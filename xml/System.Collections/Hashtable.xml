<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Hashtable.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac54c6adcdcf0768c2d073d568527998677360d621e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c6adcdcf0768c2d073d568527998677360d621e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.Hashtable">
          <source>Represents a collection of key/value pairs that are organized based on the hash code of the key.</source>
          <target state="translated">Reprezentuje kolekcję pary klucz wartość, które są podzielone na podstawie kodu skrótu klucza.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Each element is a key/value pair stored in a <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> object.</source>
          <target state="translated">Każdy element jest parę klucza i wartości przechowywane w <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">Klucz nie może być <ph id="ph1">`null`</ph>, ale może być wartością.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The objects used as keys by a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are required to override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method (or the <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> interface) and the <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method (or the <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> interface).</source>
          <target state="translated">Obiekty używane jako klucze przy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> są wymagane w celu zastąpienia <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> — metoda (lub <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> interface) i <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> — metoda (lub <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> interfejs).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The implementation of both methods and interfaces must handle case sensitivity the same way; otherwise, the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> might behave incorrectly.</source>
          <target state="translated">Implementacja metody i interfejsy musi obsługiwać uwzględniana wielkość liter, ten sam sposób; w przeciwnym razie <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> może działać niepoprawnie.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>For example, when creating a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, you must use the <ph id="ph2">&lt;xref:System.Collections.CaseInsensitiveHashCodeProvider&gt;</ph> class (or any case-insensitive <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation) with the <ph id="ph4">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> class (or any case-insensitive <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> implementation).</source>
          <target state="translated">Na przykład podczas tworzenia <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, należy użyć <ph id="ph2">&lt;xref:System.Collections.CaseInsensitiveHashCodeProvider&gt;</ph> klasy (lub dowolna bez uwzględniania wielkości liter <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementacji) z <ph id="ph4">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> klasy (lub dowolna bez uwzględniania wielkości liter <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> implementacji).</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Furthermore, these methods must produce the same results when called with the same parameters while the key exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Ponadto te metody musi mieć takie same wyniki wywołanego z takimi samymi parametrami, podczas gdy ten klucz istnieje <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>An alternative is to use a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor with an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> parameter.</source>
          <target state="translated">Alternatywą jest użycie <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktora z <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> parametru.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>If key equality were simply reference equality, the inherited implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> would suffice.</source>
          <target state="translated">Jeśli klucza równości zostały po prostu równości odwołań, dziedziczone wykonania <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> będą wystarczające.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Key objects must be immutable as long as they are used as keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Obiekty klucza musi być niezmienialne tak długo, jak są używane jako klucze w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>When an element is added to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the element is placed into a bucket based on the hash code of the key.</source>
          <target state="translated">Gdy element zostanie dodany do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, element znajduje się w przedziale, oparte na wartość skrótu klucza.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Subsequent lookups of the key use the hash code of the key to search in only one particular bucket, thus substantially reducing the number of key comparisons required to find an element.</source>
          <target state="translated">Kolejne wyszukiwań klucza umożliwia wyszukiwanie tylko jednego określonego zasobnik, w związku z tym znacznie zmniejszyć liczbę kluczy porównania wymagane do znalezienia elementu skrótu klucza.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The load factor of a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> determines the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> określa maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Smaller load factors cause faster average lookup times at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze obciążenie czynniki spowodować godziny szybszy średni wyszukiwania kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The default load factor of 1.0 generally provides the best balance between speed and size.</source>
          <target state="translated">Domyślny współczynnik obciążenia 1.0 zazwyczaj zapewnia równowagę między szybkość i rozmiar.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>A different load factor can also be specified when the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is created.</source>
          <target state="translated">Współczynnik różne obciążenia można też określić, kiedy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> jest tworzony.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the actual load factor of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> increases.</source>
          <target state="translated">Po dodaniu elementów do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, współczynnik rzeczywiste obciążenie <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> zwiększa.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>When the actual load factor reaches the specified load factor, the number of buckets in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is automatically increased to the smallest prime number that is larger than twice the current number of <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> zwiększają się automatycznie na najmniejszą liczbę pierwszych, która jest większa niż dwa razy bieżącą liczbę <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> zasobników.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Each key object in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must provide its own hash function, which can be accessed by calling <ph id="ph2">&lt;xref:System.Collections.Hashtable.GetHash%2A&gt;</ph>.</source>
          <target state="translated">Każdy obiekt klucza w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> podać jego własnej funkcji skrótu, którego dostęp można uzyskać przez wywołanie metody <ph id="ph2">&lt;xref:System.Collections.Hashtable.GetHash%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>However, any object implementing <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> can be passed to a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, and that hash function is used for all objects in the table.</source>
          <target state="translated">Jednak żadnego obiekt implementujący <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> mogą zostać przekazane do <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktor i czy funkcja skrótu jest używany przez wszystkie obiekty w tabeli.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> can hold.</source>
          <target state="translated">Pojemność <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> jest liczba elementów <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> może przechowywać.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Po dodaniu elementów do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, automatycznie zostaje zwiększona wydajność co jest wymagane przez; Ponowna alokacja.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">Dla bardzo dużych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiekty, można zwiększyć maksymalną pojemność do 2 miliardów elementów w 64-bitowym systemie ustawiając <ph id="ph2">`enabled`</ph> atrybutu elementu konfiguracji, aby <ph id="ph3">`true`</ph> w środowisku czasu wykonywania.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`For Each`</ph> in Visual Basic) returns an object of the type of the elements in the collection.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> Instrukcji języka C# (<ph id="ph2">`For Each`</ph> w języku Visual Basic) zwraca obiekt typu elementów w kolekcji.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Since each element of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is a key/value pair, the element type is not the type of the key or the type of the value.</source>
          <target state="translated">Ponieważ każdy element <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> parę klucz/wartość jest typu elementu nie jest typu klucza lub typ wartości.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Instead, the element type is <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph>.</source>
          <target state="translated">Zamiast tego jest typ elementu <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>For example:</source>
          <target state="translated">Na przykład:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The <ph id="ph1">`foreach`</ph> statement is a wrapper around the enumerator, which only allows reading from, not writing to, the collection.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> Instrukcja jest otokę moduł wyliczający, który zezwala tylko odczyt z bez zapisywania do kolekcji.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">Ponieważ serializację i deserializację moduł wyliczający dla <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Because keys can be inherited and their behavior changed, their absolute uniqueness cannot be guaranteed by comparisons using the <ph id="ph1">&lt;xref:System.Type.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Ponieważ klucze mogą być dziedziczone i ich zachowanie zmieniona, ich bezwzględną unikatowości nie może zagwarantować porównania przy użyciu <ph id="ph1">&lt;xref:System.Type.Equals%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The following example shows how to create, initialize and perform various functions to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and how to print out its keys and values.</source>
          <target state="translated">Poniższy przykład przedstawia sposób tworzenia, inicjowanie i wykonywanie różnych funkcji do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> i jak wydrukować jej kluczy i wartości.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is thread safe for use by multiple reader threads and a single writing thread.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> Wątek jest bezpieczny dla używany przez wiele wątków czytnika i wątku pojedynczego zapisu.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>It is thread safe for multi-thread use when only one of the threads perform write (update) operations, which allows for lock-free reads provided that the writers are serialized to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Jest bezpieczne dla wątków dla wielu wątków używany, gdy tylko jeden z wątków wykonywać operacje zapisu (aktualizacji), co umożliwia obsługę odczyty zwolnić blokady, pod warunkiem, że zapisywania są serializowane do <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>To support multiple writers all operations on the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> must be done through the wrapper returned by the <ph id="ph2">&lt;see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /&gt;</ph> method, provided that there are no threads reading the <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Do obsługi wielu składników zapisywania wszystkich operacji na <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> muszą być wykonywane przez otoki zwrócony przez <ph id="ph2">&lt;see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /&gt;</ph> metody, pod warunkiem, że nie istnieją żadne wątków odczytywania <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="T:System.Collections.Hashtable">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the default initial capacity, load factor, hash code provider, and comparer.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przy użyciu domyślnego początkowa pojemność, załadowanie współczynnik dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Ten konstruktor jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> Obiektu można skopiować do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przez skopiowanie elementy z określonego słownika do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor, hash code provider, and comparer.</source>
          <target state="translated">Nowe <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa domyślną wartość współczynnika ładowania, dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Początkowa pojemność wynosi liczba elementów w słowniku źródła.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Nowe elementy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów w <ph id="ph3">`d`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją każdy klucz <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> i wdrożenia każdego klucza jest domyślna funkcja porównująca <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the default initial capacity and load factor, and the specified <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przy użyciu domyślnego początkowa pojemność i obciążenia współczynnik i określonego <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> jest używany w <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktora, obiekty używane jako klucze w <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu nie są wymagane w celu zastąpienia <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Ten konstruktor jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Przybliżoną liczbę elementów który <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> początkowo może zawierać obiektu.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, and the default load factor, hash code provider, and comparer.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przy użyciu określonej pojemności początkowa i domyślną wartość współczynnika ładowania, dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> Obiektu można skopiować do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją każdy klucz <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> i wdrożenia każdego klucza jest domyślna funkcja porównująca <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przez skopiowanie elementy z określonego słownika na nowy <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor and the specified <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">Nowy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i korzysta z domyślnego współczynnika ładowania i określonego <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Początkowa pojemność wynosi liczba elementów w słowniku źródła.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> jest używany w <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktora, obiekty używane jako klucze w <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu nie są wymagane w celu zastąpienia <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Nowe elementy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów w <ph id="ph3">`d`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> Obiektu można skopiować do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Wynik jest maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przez skopiowanie elementy z określonego słownika do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, and the default hash code provider and comparer.</source>
          <target state="translated">Nowe <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa współczynnik obciążenia i domyślny dostawca kod skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Początkowa pojemność wynosi liczba elementów w słowniku źródła.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Nowe elementy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów w <ph id="ph3">`d`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest mniejsza niż 0,1.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest większe niż 1,0.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Obiekt ma być używany do określenia, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the default initial capacity and load factor, and the specified hash code provider and comparer.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przy użyciu domyślnego początkowa pojemność i załadować współczynnik oraz skrót określonego dostawcy kodu i porównania.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Ten konstruktor jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Przybliżoną liczbę elementów który <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> początkowo może zawierać obiektu.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją każdy klucz <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> i wdrożenia każdego klucza jest domyślna funkcja porównująca <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity and <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, and the default load factor.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przy użyciu określonej pojemności początkowej i <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, a domyślna wartość współczynnika ładowania.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> jest używany w <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktora, obiekty używane jako klucze w <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> nie są wymagane w celu zastąpienia <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`capacity`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Przybliżoną liczbę elementów który <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> początkowo może zawierać obiektu.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Wynik jest maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity and load factor, and the default hash code provider and comparer.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przy użyciu określonej pojemności początkowej i obciążenia i domyślny dostawca kodu wyznaczania wartości skrótu oraz porównania.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`capacity`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest mniejsza niż 0,1.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest większe niż 1,0.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is causing an overflow.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> powoduje przepełnienie.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object containing the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> obiekt zawierający informacje wymagane do serializacji <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object containing the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> obiekt zawierający źródłowy i docelowy serializowanego strumienia skojarzonego z <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class that is serializable using the specified <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> objects.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> klasy, która jest możliwy do serializacji przy użyciu określonego <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> i <ph id="ph3">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> obiektów.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">Ponieważ serializację i deserializację moduł wyliczający dla <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> Obiektu można skopiować do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Obiekt ma być używany do określenia, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przez skopiowanie elementy z określonego słownika do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor, and the specified hash code provider and comparer.</source>
          <target state="translated">Nowe <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa domyślny współczynnik obciążenia oraz skrót określonego dostawcy kodu i porównania.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This API is obsolete.</source>
          <target state="translated">Ten interfejs API jest nieaktualny.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>For an alternative, see <ph id="ph1">&lt;see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" /&gt;</ph>.</source>
          <target state="translated">Aby zamiast, zobacz <ph id="ph1">&lt;see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Początkowa pojemność wynosi liczba elementów w słowniku źródła.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Nowe elementy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów w <ph id="ph3">`d`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> Obiektu można skopiować do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Wynik jest maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją każdy klucz <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> i wdrożenia każdego klucza jest domyślna funkcja porównująca <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przez skopiowanie elementy z określonego słownika do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor and <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">Nowy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa współczynnik obciążenia i <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Początkowa pojemność wynosi liczba elementów w słowniku źródła.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> jest używany w <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktora, obiekty używane jako klucze w <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu nie są wymagane w celu zastąpienia <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Nowe elementy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów w <ph id="ph3">`d`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest mniejsza niż 0,1.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest większe niż 1,0.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Przybliżoną liczbę elementów który <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> początkowo może zawierać obiektu.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Obiekt ma być używany do określenia, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, hash code provider, comparer, and the default load factor.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przy użyciu określonej pojemności początkowej, dostawcy kodu skrótu porównania i domyślny współczynnik obciążenia.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`capacity`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Przybliżoną liczbę elementów który <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> początkowo może zawierać obiektu.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Wynik jest maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją każdy klucz <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> i wdrożenia każdego klucza jest domyślna funkcja porównująca <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, load factor, and <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przy użyciu określonej pojemności początkowej, współczynnik ładowania i <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> jest używany w <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktora, obiekty używane jako klucze w <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> nie są wymagane w celu zastąpienia <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`capacity`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest mniejsza niż 0,1.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest większe niż 1,0.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> Obiektu można skopiować do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Wynik jest maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Obiekt ma być używany do określenia, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przez skopiowanie elementy z określonego słownika do nowego <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, hash code provider, and comparer.</source>
          <target state="translated">Nowe <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa współczynnik określonego obciążenia, dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Początkowa pojemność wynosi liczba elementów w słowniku źródła.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Nowe elementy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów w <ph id="ph3">`d`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest mniejsza niż 0,1.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest większe niż 1,0.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Przybliżoną liczbę elementów który <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> początkowo może zawierać obiektu.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Wynik jest maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Obiekt ma być używany do określenia, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, load factor, hash code provider, and comparer.</source>
          <target state="translated">Inicjuje nową, pustą wystąpienie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> przy użyciu określonej pojemności początkowej, załadowanie współczynnik dostawcy kodu wyznaczania wartości skrótu i porównania.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Współczynnik obciążenia to maksymalny stosunek elementów zasobników.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Dostawca kodu skrótu zrezygnuje skrótu kluczy w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślny dostawca kod skrótu jest implementacją klucza <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Moduł porównujący Określa, czy dwa klucze są takie same.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muszą być unikatowe.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Implementacja klucza jest domyślna funkcja porównująca <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Ten konstruktor jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`capacity`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest mniejsza niż 0,1.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> jest większe niż 1,0.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The key of the element to add.</source>
          <target state="translated">Klucz elementu do dodania.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The value of the element to add.</source>
          <target state="translated">Wartość elementu do dodania.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wartość może być <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>Adds an element with the specified key and value into the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Dodaje element z określonym kluczem i wartością w <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">Klucz nie może być <ph id="ph1">`null`</ph>, ale może być wartością.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>An object that has no correlation between its state and its hash code value should typically not be used as the key.</source>
          <target state="translated">Zazwyczaj obiekt, który ma korelacja stanu i jego wartość kodu skrótu nie zostać użyta jako klucz.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>For example, String objects are better than StringBuilder objects for use as keys.</source>
          <target state="translated">Na przykład ciąg obiekty są lepszym rozwiązaniem niż obiekty StringBuilder do użycia jako klucze.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property to add new elements by setting the value of a key that does not exist in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>; for example, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
          <target state="translated">Można również użyć <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> właściwości, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, na przykład <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property overwrites the old value.</source>
          <target state="translated">Jednak jeśli określony klucz już istnieje w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, ustawienie <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> stara wartość jest zastąpienie właściwości.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> method does not modify existing elements.</source>
          <target state="translated">Z kolei <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> — metoda nie modyfikuje istniejące elementy.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> is less than the capacity of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> jest mniejsza niż pojemność <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Jeśli pojemność wymaga zwiększenia w celu uwzględnienia nowego elementu, ta metoda staje się O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The following example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Poniższy przykład przedstawia sposób dodawania elementów do <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>An element with the same key already exists in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Element z tym samym kluczem już istnieje w <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> Jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> Ma stały rozmiar.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clear">
          <source>Removes all elements from the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Usuwa wszystkie elementy z <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> is set to zero, and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> jest ustawiany na zero, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source>The capacity remains unchanged.</source>
          <target state="translated">Pojemność pozostaje niezmieniona.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source>The following example shows how to clear the values of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Poniższy przykład pokazuje, jak można wyczyścić wartości <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> Jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Tworzy kopię pobieżną <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Kopia pobieżna <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Kopię pobieżną kolekcji kopiuje elementy kolekcji, czy znajdują się odwołania typy lub wartości, ale nie kopiuje obiektów, które dotyczą odwołania.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">Odwołania do nowej kolekcji wskazują te same obiekty, które wskazują odwołania w oryginalnej kolekcji.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Z kolei głęboką kopię kolekcji kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> clone has the same count, the same capacity, the same <ph id="ph2">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation, and the same <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation as the original <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Klonowania ma tego samego liczbę, samej pojemności takie same <ph id="ph2">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementacji i tym samym <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementacji jako oryginalny <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.comparer">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Pobiera lub ustawia <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> do użycia na potrzeby <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.comparer">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Do użycia na potrzeby <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.comparer">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.comparer">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>.</source>
          <target state="translated">Właściwość jest ustawiona na wartość, ale tablicy skrótów został utworzony przy użyciu <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Klucz do zlokalizowania w <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains a specific key.</source>
          <target state="translated">Określa, czy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zawiera określony klucz.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zawiera element z określonym kluczem, a w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> implements <ph id="ph2">&lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> implementuje <ph id="ph2">&lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>It behaves exactly as <ph id="ph1">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph>.</source>
          <target state="translated">Zachowuje się dokładnie jako <ph id="ph1">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Począwszy od programu .NET Framework 2.0, ta metoda używa obiektów kolekcji <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">`item`</ph> ustalenie, czy element istnieje.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">`item`</ph> parametrów dla obiektów w kolekcji.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>The following example shows how to determine whether the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> contains a specific element.</source>
          <target state="translated">Poniższy przykład przedstawia sposób określić, czy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> zawiera określony element.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Klucz do zlokalizowania w <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains a specific key.</source>
          <target state="translated">Określa, czy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zawiera określony klucz.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zawiera element z określonym kluczem, a w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>This method behaves exactly as <ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda działa dokładnie jako <ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Począwszy od programu .NET Framework 2.0, ta metoda używa obiektów kolekcji <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">`item`</ph> ustalenie, czy element istnieje.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">`item`</ph> parametrów dla obiektów w kolekcji.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>The following example shows how to determine whether the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> contains a specific element.</source>
          <target state="translated">Poniższy przykład przedstawia sposób określić, czy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> zawiera określony element.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The value to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Wartość do zlokalizowania w <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wartość może być <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains a specific value.</source>
          <target state="translated">Określa, czy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zawiera określoną wartość.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains an element with the specified <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zawiera element z określonym <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; w przeciwnym razie <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The values of the elements of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are compared to the specified value using the <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Wartości elementów <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> są porównywane przy użyciu określonej wartości <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Począwszy od programu .NET Framework 2.0, ta metoda używa obiektów kolekcji <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">`item`</ph> ustalenie, czy element istnieje.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">`item`</ph> parametrów dla obiektów w kolekcji.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The following example shows how to determine whether the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> contains a specific element.</source>
          <target state="translated">Poniższy przykład przedstawia sposób określić, czy <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> zawiera określony element.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the <ph id="ph2">&lt;see cref="T:System.Collections.DictionaryEntry" /&gt;</ph> objects copied from <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> czyli miejsce docelowe <ph id="ph2">&lt;see cref="T:System.Collections.DictionaryEntry" /&gt;</ph> obiektów kopiowanych ze <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Musi mieć indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Liczony od zera indeks w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept> od rozpoczyna się kopiowanie które.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>Copies the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> elements to a one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> instance at the specified index.</source>
          <target state="translated">Kopie <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> elementów na jednowymiarowe <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> wystąpienia pod określonym indeksem.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Elementy są kopiowane do <ph id="ph1">&lt;xref:System.Array&gt;</ph> w tej samej kolejności, w której moduł wyliczający iteruje <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>To copy only the keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use <ph id="ph2">`Hashtable.Keys.CopyTo`</ph>.</source>
          <target state="translated">Aby skopiować tylko klucze w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, użyj <ph id="ph2">`Hashtable.Keys.CopyTo`</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>To copy only the values in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use <ph id="ph2">`Hashtable.Values.CopyTo`</ph>.</source>
          <target state="translated">Aby skopiować tylko wartości w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, użyj <ph id="ph2">`Hashtable.Values.CopyTo`</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The following example shows how to copy the list of keys or the list of values in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykład przedstawia sposób kopiowania listy kluczy lub na liście wartości w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> do jednowymiarowego <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Liczba elementów w źródle <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> jest większa niż dostępne miejsce od <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> do końca tablicy docelowej <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Typ źródła <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> nie można automatycznie rzutować na typ docelowy <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Count">
          <source>Gets the number of key/value pairs contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Pobiera liczbę par klucz/wartość zawartych w <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Count">
          <source>The number of key/value pairs contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Liczba par klucz/wartość zawartych w <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Pobiera <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> do użycia na potrzeby <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> Do użycia na potrzeby <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> includes both the comparer and the hash code provider.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Zawiera modułu porównującego i dostawcy kodu wyznaczania wartości skrótu.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> jest używany w <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> konstruktora, obiekty używane jako klucze w <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> nie są wymagane w celu zastąpienia <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> and an <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Właściwość jest ustawiona na wartość, ale tablicy skrótów został utworzony przy użyciu <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> i <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> that iterates through the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Zwraca <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> który iteruje <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> Dla <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> Instrukcji języka C# (<ph id="ph2">`for each`</ph> w języku Visual Basic) ukrywa złożoność wyliczenia.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">W związku z tym przy użyciu <ph id="ph1">`foreach`</ph> jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> również wprowadzono moduł wyliczający wróć do tej pozycji.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">W tym miejscu <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">W związku z tym należy wywołać <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> zwraca ten sam obiekt do momentu <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> lub <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> jest wywoływana.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> Ustawia <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> do następnego elementu.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zwraca <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zwracają również <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Jeśli przez ostatnie wywołanie <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zwrócił <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Aby ustawić <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> aby pierwszym elementem kolekcji ponownie, należy wywołać <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> następuje <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne procedury wątku.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">Ponieważ serializację i deserializację moduł wyliczający dla <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>The following example compares the use of <ph id="ph1">&lt;xref:System.Collections.Hashtable.GetEnumerator%2A&gt;</ph> and <ph id="ph2">`foreach`</ph> to enumerate the contents of a <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Poniższy przykład porównuje stosowania <ph id="ph1">&lt;xref:System.Collections.Hashtable.GetEnumerator%2A&gt;</ph> i <ph id="ph2">`foreach`</ph> wyliczyć zawartości <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> for which a hash code is to be returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> Dla której ma zostać zwrócone skrótu.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>Returns the hash code for the specified key.</source>
          <target state="translated">Zwraca wartość skrótu dla określonego klucza.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>The hash code for <ph id="ph1">&lt;paramref name="key" /&gt;</ph>.</source>
          <target state="translated">Wartość skrótu dla <ph id="ph1">&lt;paramref name="key" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>If the hash table was created with a specific <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation, this method uses that hash code provider; otherwise, it uses the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> implementation of <ph id="ph3">`key`</ph>.</source>
          <target state="translated">Jeśli utworzono tabelę wyznaczania wartości skrótu z określonym <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementacji, ta metoda używa tego dostawcy Kod skrótu; w przeciwnym razie używa <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> implementacja <ph id="ph3">`key`</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object containing the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> obiektu zawierającego informacje o wymaganych do zserializowania <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object containing the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> obiekt zawierający źródłowy i docelowy serializowanego strumienia skojarzonego z <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and returns the data needed to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Implementuje <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interfejsu i zwraca dane potrzebne do serializacji <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The collection was modified.</source>
          <target state="translated">Kolekcja została zmodyfikowana.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.hcp">
          <source>Gets or sets the object that can dispense hash codes.</source>
          <target state="translated">Pobiera lub ustawia obiekt, który można rozdzielić skrótu.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.hcp">
          <source>The object that can dispense hash codes.</source>
          <target state="translated">Obiekt, który można rozdzielić skrótu.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.hcp">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.hcp">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>.</source>
          <target state="translated">Właściwość jest ustawiona na wartość, ale tablicy skrótów został utworzony przy użyciu <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Pobiera wartość wskazującą czy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ma stały rozmiar.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ma ustalony rozmiar; w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Wartość domyślna to <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
          <target state="translated">W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Kolekcja o stałym rozmiarze jest po prostu kolekcji z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym zmian w źródłowej kolekcji, włączając Dodawanie lub usuwanie elementów z kolekcji o stałym rozmiarze odzwierciedla te zmiany.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated">Pobiera wartość wskazującą czy <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> jest tylko do odczytu; w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Wartość domyślna to <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Pobiera wartość wskazującą czy uzyskują dostęp do <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> jest synchronizowane (wielowątkowość).</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli dostęp do <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> jest synchronizowane (wielowątkowość); w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Wartość domyślna to <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can support one writer and multiple readers concurrently.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> może obsługiwać jeden moduł zapisujący i wielu czytników jednocześnie.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>To support multiple writers, all operations must be done through the wrapper returned by the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Aby obsługiwać wiele składników zapisywania, wszystkie operacje muszą być wykonywane przez otoki zwrócony przez <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> podczas wyliczania całego:</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>The following example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, determine if a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> is synchronized, and use a synchronized <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Poniższy przykład przedstawia sposób synchronizacji <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, ustal, czy <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> jest synchronizowane i użyj zsynchronizowany <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The key whose value to get or set.</source>
          <target state="translated">Klucz wartości, których można pobrać lub ustawić.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>Gets or sets the value associated with the specified key.</source>
          <target state="translated">Pobiera lub ustawia wartość skojarzoną z określonym kluczem.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The value associated with the specified key.</source>
          <target state="translated">Wartość skojarzona z określonym kluczem.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>If the specified key is not found, attempting to get it returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>, and attempting to set it creates a new element using the specified key.</source>
          <target state="translated">Jeśli określony klucz nie zostanie znaleziony, próby pobrania jej zwraca <ph id="ph1">&lt;see langword="null" /&gt;</ph>, a próba skonfigurowania go tworzy nowy element przy użyciu określonego klucza.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[key]`</ph>.</source>
          <target state="translated">Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: <ph id="ph1">`myCollection[key]`</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property to add new elements by setting the value of a key that does not exist in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>; for example, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
          <target state="translated">Można również użyć <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> właściwości, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, na przykład <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property overwrites the old value.</source>
          <target state="translated">Jednak jeśli określony klucz już istnieje w <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, ustawienie <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> stara wartość jest zastąpienie właściwości.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> method does not modify existing elements.</source>
          <target state="translated">Z kolei <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> — metoda nie modyfikuje istniejące elementy.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">Klucz nie może być <ph id="ph1">`null`</ph>, ale może być wartością.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>To distinguish between <ph id="ph1">`null`</ph> that is returned because the specified key is not found and <ph id="ph2">`null`</ph> that is returned because the value of the specified key is <ph id="ph3">`null`</ph>, use the <ph id="ph4">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> method or the <ph id="ph5">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph> method to determine if the key exists in the list.</source>
          <target state="translated">Aby odróżnić <ph id="ph1">`null`</ph> który jest zwracany, ponieważ nie odnaleziono określonego klucza i <ph id="ph2">`null`</ph> który jest zwracany, ponieważ wartość określony klucz jest <ph id="ph3">`null`</ph>, użyj <ph id="ph4">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> — metoda lub <ph id="ph5">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph> metodę, aby określić, czy Ten klucz istnieje na liście.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1); Ustawienie właściwości jest również O(1) operacji.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.IList.Item%2A&gt;</ph> property.</source>
          <target state="translated">Używa języka C# do definiowania indeksatory zamiast implementacja słowa kluczowego <ph id="ph1">&lt;xref:System.Collections.IList.Item%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Implementuje Visual Basic <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> jako domyślna właściwość, która zapewnia te same funkcje indeksowania.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The property is set and the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated">Właściwość jest ustawiona i <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The property is set, <ph id="ph1">&lt;paramref name="key" /&gt;</ph> does not exist in the collection, and the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Ta właściwość jest ustawiona, <ph id="ph1">&lt;paramref name="key" /&gt;</ph> nie istnieje w kolekcji i <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ma stały rozmiar.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to compare with <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> Do porównania z <bpt id="p1">&lt;c&gt;</bpt>klucza<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>The key in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> to compare with <bpt id="p1">&lt;c&gt;</bpt>item<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Klucz w <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> do porównania z <bpt id="p1">&lt;c&gt;</bpt>elementu<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>Compares a specific <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> with a specific key in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Porównuje określony <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> z określonym kluczem w <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> and <ph id="ph3">&lt;paramref name="key" /&gt;</ph> are equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli <ph id="ph2">&lt;paramref name="item" /&gt;</ph> i <ph id="ph3">&lt;paramref name="key" /&gt;</ph> są równe; w przeciwnym razie <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>If the hash table was created with a specific <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation, this method uses that comparer; that is, <ph id="ph2">&lt;xref:System.Collections.IComparer.Compare%2A&gt;</ph> (<ph id="ph3">`item`</ph>, <ph id="ph4">`key`</ph>).</source>
          <target state="translated">Jeśli utworzono tabelę wyznaczania wartości skrótu z określonym <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementacji, ta metoda używa tego porównania; będący, <ph id="ph2">&lt;xref:System.Collections.IComparer.Compare%2A&gt;</ph> (<ph id="ph3">`item`</ph>, <ph id="ph4">`key`</ph>).</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>Otherwise, it uses <ph id="ph1">`item.Equals(key)`</ph>.</source>
          <target state="translated">W przeciwnym razie używa <ph id="ph1">`item.Equals(key)`</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="item" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="item" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Keys">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Pobiera <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> zawierającą klucze ze słownika <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> Zawierającą klucze ze słownika <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>The order of the keys in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is unspecified, but it is the same order as the associated values in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Collections.Hashtable.Values%2A&gt;</ph> method.</source>
          <target state="translated">Kolejność kluczy w <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> jest nieokreślony, ale takiej samej kolejności jak skojarzone wartości w <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> zwrócony przez <ph id="ph3">&lt;xref:System.Collections.Hashtable.Values%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is not a static copy; instead, the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> refers back to the keys in the original <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Zwrócona <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> nie jest statyczna kopia; zamiast tego <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> odwołuje się do kluczy w oryginalnym <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>Therefore, changes to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> continue to be reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">W związku z tym zmiany <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> kontynuować zostaną odzwierciedlone w <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>The source of the deserialization event.</source>
          <target state="translated">Źródło zdarzenia deserializacji.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and raises the deserialization event when the deserialization is complete.</source>
          <target state="translated">Implementuje <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interfejsu i zgłasza zdarzenie deserializacji po zakończeniu wykonywania deserializacji.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">Ponieważ serializację i deserializację moduł wyliczający dla <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object associated with the current <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> Obiekt skojarzony z bieżącym <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> jest nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The key of the element to remove.</source>
          <target state="translated">Klucz elementu do usunięcia.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>Removes the element with the specified key from the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Usuwa element z określonym kluczem z <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> does not contain an element with the specified key, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> remains unchanged.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> nie zawiera element z określonym kluczem <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> pozostaje niezmieniona.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>No exception is thrown.</source>
          <target state="translated">Nie wyjątek.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The following example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Poniższy przykład przedstawia sposób Usuń elementy z <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> Jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> Ma stały rozmiar.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> to synchronize.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> Do synchronizacji.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Returns a synchronized (thread-safe) wrapper for the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Zwraca zsynchronizowane otoki (wątkowo) dla <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>A synchronized (thread-safe) wrapper for the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">A zsynchronizowane (wątkowo) otoki dla <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method is thread safe for multiple readers and writers.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> Metoda jest wielowątkowość dla wielu czytników i modułów zapisujących.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Furthermore, the synchronized wrapper ensures that there is only one writer writing at a time.</source>
          <target state="translated">Ponadto zsynchronizowane otoki gwarantuje, że jest tylko jeden moduł zapisujący zapisywania naraz.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> podczas wyliczania całego:</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The following example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, determine if a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> is synchronized, and use a synchronized <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Poniższy przykład przedstawia sposób synchronizacji <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, ustal, czy <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> jest synchronizowane i użyj zsynchronizowany <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source><ph id="ph1">&lt;paramref name="table" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="table" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Pobiera obiekt, który może służyć do synchronizujący dostęp do <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Obiekt, który może służyć do synchronizujący dostęp do <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>To create a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Aby utworzyć zsynchronizowaną wersję <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, użyj <ph id="ph2">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>However, derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Jednak klasy pochodne zapewniają własne zsynchronizowanej wersji <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> przy użyciu <ph id="ph2">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> .</source>
          <target state="translated">Synchronizowanie kodu musi wykonywać operacje <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> z <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, nie są bezpośrednio w <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> podczas wyliczania całego:</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> that can be used to iterate through the collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> Który może służyć do iterowania po kolekcji.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> Instrukcji języka C# (<ph id="ph2">`for each`</ph> w języku Visual Basic) ukrywa złożoność wyliczenia.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">W związku z tym przy użyciu <ph id="ph1">`foreach`</ph> jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> również wprowadzono moduł wyliczający wróć do tej pozycji.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>At this position, calling <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">At to pozycja, wywoływania <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> zgłasza wyjątek.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">W związku z tym należy wywołać <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> zwraca ten sam obiekt do momentu <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> lub <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> jest wywoływana.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> Ustawia <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> do następnego elementu.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zwraca <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zwracają również <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, calling <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">Jeśli przez ostatnie wywołanie <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zwrócił <ph id="ph2">`false`</ph>, wywoływania <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> zgłasza wyjątek.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Aby ustawić <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> aby pierwszym elementem kolekcji ponownie, należy wywołać <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> następuje <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator can be invalidated and the next call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający może być unieważniona i następne wywołanie <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> zgłasza <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If the collection is modified between <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the element that it is set to, even if the enumerator is already invalidated.</source>
          <target state="translated">Jeśli kolekcja jest zmodyfikowany między <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> zwraca element, który ma ustawioną, nawet wtedy, gdy moduł wyliczający jest już unieważnione.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne procedury wątku.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Values">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the values in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Pobiera <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> zawierający wartości w <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the values in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> Zawierający wartości w <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>The order of the values in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is unspecified, but it is the same order as the associated keys in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Collections.Hashtable.Keys%2A&gt;</ph> method.</source>
          <target state="translated">Kolejność wartości na liście <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> jest nieokreślony, ale takiej samej kolejności jak skojarzonych kluczy w <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> zwrócony przez <ph id="ph3">&lt;xref:System.Collections.Hashtable.Keys%2A&gt;</ph> — metoda.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is not a static copy; instead, the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> refers back to the values in the original <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Zwrócona <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> nie jest statyczna kopia; zamiast tego <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> odwołuje się do wartości w oryginalnym <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>Therefore, changes to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> continue to be reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">W związku z tym zmiany <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> kontynuować zostaną odzwierciedlone w <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
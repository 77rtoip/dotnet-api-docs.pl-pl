<Type Name="Hashtable" FullName="System.Collections.Hashtable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ada8951fcce85aaeb9f49556c8747a91197ed9e3" />
    <Meta Name="ms.sourcegitcommit" Value="996ba67625b61917bcf75bfefe6dcb016019c2d8" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/02/2018" />
    <Meta Name="ms.locfileid" Value="50965542" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Hashtable extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Hashtable" />
  <TypeSignature Language="VB.NET" Value="Public Class Hashtable&#xA;Implements ICloneable, IDeserializationCallback, IDictionary, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Hashtable : ICloneable, System::Collections::IDictionary, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Hashtable = class&#xA;    interface IDictionary&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Przedstawia kolekcję par klucz wartość, które są zorganizowane na podstawie kodu skrótu klucza.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

Każdy element jest pary klucz/wartość przechowywanych w <xref:System.Collections.DictionaryEntry> obiektu. Klucz nie może być `null`, ale może być wartością.  

>  [!IMPORTANT]
>  Nie zaleca się używanie `Hashtable` klasy w przypadku nowych wdrożeń. Zamiast tego zaleca się użycie ogólnej <xref:System.Collections.Generic.HashSet%601> klasy. Aby uzyskać więcej informacji, zobacz [nie powinny być używane inne niż ogólne kolekcje](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) w witrynie GitHub.
  
 Obiekty używane jako klucze przez <xref:System.Collections.Hashtable> są wymagane, aby zastąpić <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> — metoda (lub <xref:System.Collections.IHashCodeProvider> interfejsu) i <xref:System.Object.Equals%2A?displayProperty=nameWithType> — metoda (lub <xref:System.Collections.IComparer> interfejsu). Implementacja interfejsy i metody musi obsługiwać rozróżnianie wielkości liter, ten sam sposób; w przeciwnym razie <xref:System.Collections.Hashtable> może zachowywać się nieprawidłowo. Na przykład podczas tworzenia <xref:System.Collections.Hashtable>, należy użyć <xref:System.Collections.CaseInsensitiveHashCodeProvider> klasy (lub wszystkie bez uwzględniania wielkości liter <xref:System.Collections.IHashCodeProvider> implementacji) za pomocą <xref:System.Collections.CaseInsensitiveComparer> klasy (lub wszystkie bez uwzględniania wielkości liter <xref:System.Collections.IComparer> implementacji).  
  
 Ponadto te metody musi mieć takie same wyniki, gdy wywołać z tymi samymi parametrami, gdy klucz istnieje w <xref:System.Collections.Hashtable>. Alternatywą jest użycie <xref:System.Collections.Hashtable> konstruktora z <xref:System.Collections.IEqualityComparer> parametru. Jeśli równości kluczy zostały po prostu równości odwołań, dziedziczona implementacja <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> będą wystarczające.  
  
 Obiekty kluczy muszą być niezmienne, tak długo, jak są używane jako klucze w <xref:System.Collections.Hashtable>.  
  
 Po dodaniu elementu do <xref:System.Collections.Hashtable>, element jest umieszczany w zasobnik, w oparciu o wartość skrótu klucza. Późniejszych wyszukiwań klucza Użyj skrótu klucza, aby wyszukać w tylko jednym przedziale określonego, w związku z tym znaczne zmniejszenie liczby kluczy porównań niezbędna do wykonania Wyszukiwanie elementu.  
  
 Współczynnik obciążenia <xref:System.Collections.Hashtable> określa maksymalny stosunek elementów do zasobników. Mniejsze obciążenie czynniki spowodować razy szybciej średni wyszukiwania kosztem użycia większej ilości pamięci. Domyślny współczynnik obciążenia 1.0 zazwyczaj zapewnia najlepszą równowagę między szybkości i rozmiaru. Współczynnik różne obciążenia mogą być również określony podczas <xref:System.Collections.Hashtable> zostanie utworzony.  
  
 Gdy elementy są dodawane do <xref:System.Collections.Hashtable>, współczynnik rzeczywistego obciążenia <xref:System.Collections.Hashtable> zwiększa się. Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów w <xref:System.Collections.Hashtable> jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącą liczbę <xref:System.Collections.Hashtable> zasobników.  
  
 Każdy obiekt klucza w <xref:System.Collections.Hashtable> należy podać jego własnej funkcji mieszania, która może być dostępna poprzez wywołanie <xref:System.Collections.Hashtable.GetHash%2A>. Jednak dowolny obiekt implementujący <xref:System.Collections.IHashCodeProvider> mogą być przekazywane do <xref:System.Collections.Hashtable> Konstruktor i że funkcja skrótu służy do wszystkich obiektów w tabeli.  
  
 Pojemność <xref:System.Collections.Hashtable> jest liczba elementów, które <xref:System.Collections.Hashtable> może przechowywać. Gdy elementy są dodawane do <xref:System.Collections.Hashtable>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami za pośrednictwem ponownej alokacji.  
  
 Dla bardzo dużych <xref:System.Collections.Hashtable> obiektów, zwiększenia maksymalnej pojemności do 2 miliardów elementów w systemie 64-bitowych, ustawiając `enabled` atrybutu tego elementu konfiguracji `true` w środowisku uruchomieniowym.  
  
 `foreach` Instrukcja języka C# (`For Each` w języku Visual Basic) zwraca obiekt typu elementów w kolekcji. Ponieważ każdy element obiektu <xref:System.Collections.Hashtable> to para klucz/wartość typu elementu nie jest typ klucza lub typu wartości. Typ elementu to <xref:System.Collections.DictionaryEntry>. Na przykład:  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/remarks.cpp#01)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/remarks.cs#01)]
 [!code-vb[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/remarks.vb#01)]  
  
 `foreach` Instrukcja jest otokę modułu wyliczającego, umożliwiający tylko odczyt z bez zapisywania do kolekcji.  
  
 Ponieważ serializację i deserializację moduł wyliczający <xref:System.Collections.Hashtable> może spowodować, że elementy, aby stać się zmienić kolejności, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metody.  
  
> [!NOTE]
>  Ponieważ klucze mogą być dziedziczone, a następnie zmienić ich zachowania, ich bezwzględnych unikatowości nie może zagwarantować porównania przy użyciu <xref:System.Type.Equals%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak tworzenie, inicjowanie i wykonywanie różnych funkcji do <xref:System.Collections.Hashtable> oraz wydrukować jej klucze i wartości.  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/hashtable_example.cpp#00)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/hashtable_example.cs#00)]
 [!code-vb[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/hashtable_example.vb#00)]
 [!code-powershell[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/powershell/VS_Snippets_CLR_System/system.collections.hashtable.class/ps/hashtable.ps1#00)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <see cref="T:System.Collections.Hashtable" /> Wątek jest bezpieczny do użycia przez wiele wątków czytnika i zapisu w jednym wątku. Jest bezpieczny dla wątków dla wielu wątków zastosowania tylko jeden z wątków wykonywać operacje zapisu (aktualizacja), umożliwiająca wolne od blokady odczytu, pod warunkiem, że moduły zapisujące są serializowane do <see cref="T:System.Collections.Hashtable" />. Do obsługi wszystkich operacji na wielu modułów zapisujących <see cref="T:System.Collections.Hashtable" /> musi odbywać się przy użyciu otoki zwrócony przez <see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /> metody, pod warunkiem, że nie istnieją żadne wątki odczytywanie <see cref="T:System.Collections.Hashtable" /> obiektu.  
  
Wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</threadsafe>
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.IHashCodeProvider" />
    <altmember cref="M:System.Object.GetHashCode" />
    <altmember cref="M:System.Object.Equals(System.Object)" />
    <altmember cref="T:System.Collections.DictionaryEntry" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.IEqualityComparer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> przy użyciu pojemność domyślna, obciążenia współczynnik, dostawcy kodu wyznaczania wartości skrótu i funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność tabeli mieszania jest używane do obliczania optymalnej liczby zasobników tabeli wyznaczania wartości skrótu, oparte na współczynnik obciążenia. Pojemność jest automatycznie zwiększana stosownie do potrzeb.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu do skopiowania do nowej <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowy <see cref="T:System.Collections.Hashtable" /> obiekt ma pojemność równa liczbie elementów kopiowanych i używa domyślny współczynnik obciążenia, dostawcy kodu wyznaczania wartości skrótu i funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność jest równa liczbę elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Elementy o nowym <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iterację <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable equalityComparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiekt, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego, za pomocą <see cref="T:System.Collections.Hashtable" /> obiektu.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i domyślny moduł porównujący jest implementacją każdy klucz <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> przy użyciu domyślnego pojemność i załadować współczynnik i określonego <see cref="T:System.Collections.IEqualityComparer" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność tabeli mieszania jest używane do obliczania optymalnej liczby zasobników tabeli wyznaczania wartości skrótu, oparte na współczynnik obciążenia. Pojemność jest automatycznie zwiększana stosownie do potrzeb.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 <xref:System.Collections.IEqualityComparer> Obiekt zawiera zarówno dostawcę kod skrótu, jak i modułu porównującego. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> Konstruktor, obiekty używane jako klucze w <xref:System.Collections.Hashtable> obiektu nie są wymagane do zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia realizację scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżona liczba elementów, <see cref="T:System.Collections.Hashtable" /> obiekt początkowo może zawierać.</param>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> przy użyciu określonego pojemność i domyślny współczynnik obciążenia, dostawcy kodu wyznaczania wartości skrótu i funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest `capacity`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza niż zero.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu do skopiowania do nowej <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiekt, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego, za pomocą <see cref="T:System.Collections.Hashtable" />.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i domyślny moduł porównujący jest implementacją każdy klucz <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> klasy przez skopiowanie elementy z określonego słownika nową <see cref="T:System.Collections.Hashtable" /> obiektu. Nowy <see cref="T:System.Collections.Hashtable" /> obiekt ma pojemność równa liczbie elementów kopiowanych i używa domyślny współczynnik obciążenia, a określony <see cref="T:System.Collections.IEqualityComparer" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność jest równa liczbę elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 <xref:System.Collections.IEqualityComparer> Obiekt zawiera zarówno dostawcę kod skrótu, jak i modułu porównującego. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> Konstruktor, obiekty używane jako klucze w <xref:System.Collections.Hashtable> obiektu nie są wymagane do zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia realizację scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Elementy o nowym <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iterację <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu do skopiowania do nowej <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1.0, który jest mnożony przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów do zasobników.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowy <see cref="T:System.Collections.Hashtable" /> obiekt ma pojemność równa liczbie elementów kopiowanych i używa współczynnika określonego obciążenia i domyślny dostawca kod skrótu i funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność jest równa liczbę elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci. Współczynnik obciążenia, 1.0 jest najlepszą równowagę między szybkości i rozmiaru.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Elementy o nowym <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iterację <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
—lub— 
 <paramref name="loadFactor" /> jest większe niż 1.0.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" /> obiektu.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu, który jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany w celu ustalenia, czy dwa klucze są takie same.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślny moduł porównujący czyli każdy klucz implementacji <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> przy użyciu domyślnego pojemność i załadować współczynnik i dostawcy kodu określonego hash i funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność tabeli mieszania jest używane do obliczania optymalnej liczby zasobników tabeli wyznaczania wartości skrótu, oparte na współczynnik obciążenia. Pojemność jest automatycznie zwiększana stosownie do potrzeb.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Skrót niestandardowego dostawcy kodu i niestandardowej funkcji porównującej umożliwiają scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżona liczba elementów, <see cref="T:System.Collections.Hashtable" /> obiekt początkowo może zawierać.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiekt, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego, za pomocą <see cref="T:System.Collections.Hashtable" />.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i domyślny moduł porównujący jest implementacją każdy klucz <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> przy użyciu określonego pojemność i <see cref="T:System.Collections.IEqualityComparer" />, a domyślny współczynnik obciążenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 <xref:System.Collections.IEqualityComparer> Obiekt zawiera zarówno dostawcę kod skrótu, jak i modułu porównującego. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> Konstruktor, obiekty używane jako klucze w <xref:System.Collections.Hashtable> nie są wymagane do zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia realizację scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza niż zero.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżona liczba elementów, <see cref="T:System.Collections.Hashtable" /> obiekt początkowo może zawierać.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1.0, który jest mnożony przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów do zasobników.</param>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> przy użyciu określonego pojemność i obciążenia współczynnik i domyślny dostawca kod skrótu i funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci. Współczynnik obciążenia, 1.0 jest najlepszą równowagę między szybkości i rozmiaru.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
—lub— 
 <paramref name="loadFactor" /> jest większe niż 1.0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="capacity" /> powoduje przepełnienie.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Hashtable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt zawierający informacje wymagane do wykonywania serializacji <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt zawierający źródłowe i docelowe serializowanym strumieniu skojarzone z <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> klasę, która jest możliwy do serializacji, przy użyciu określonego <see cref="T:System.Runtime.Serialization.SerializationInfo" /> i <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność tabeli mieszania jest używane do obliczania optymalnej liczby zasobników tabeli wyznaczania wartości skrótu, oparte na współczynnik obciążenia. Pojemność jest automatycznie zwiększana stosownie do potrzeb.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 Ponieważ serializację i deserializację moduł wyliczający <xref:System.Collections.Hashtable> może spowodować, że elementy, aby stać się zmienić kolejności, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu do skopiowania do nowej <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" />.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu, który jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany w celu ustalenia, czy dwa klucze są takie same.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślny moduł porównujący czyli każdy klucz implementacji <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowy <see cref="T:System.Collections.Hashtable" /> obiekt ma pojemność równa liczbie elementów kopiowanych i używa domyślny współczynnik obciążenia i dostawcy kodu określonego hash i funkcja porównująca. Ten interfejs API jest nieaktualny. Aby zamiast, zobacz <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność jest równa liczbę elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Skrót niestandardowego dostawcy kodu i niestandardowej funkcji porównującej umożliwiają scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Elementy o nowym <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iterację <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu do skopiowania do nowej <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1.0, który jest mnożony przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów do zasobników.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiekt, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego, za pomocą <see cref="T:System.Collections.Hashtable" />.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i domyślny moduł porównujący jest implementacją każdy klucz <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowy <see cref="T:System.Collections.Hashtable" /> obiekt ma pojemność równa liczbie elementów kopiowanych i używa współczynnik określonego obciążenia i <see cref="T:System.Collections.IEqualityComparer" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność jest równa liczbę elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci. Współczynnik obciążenia, 1.0 jest najlepszą równowagę między szybkości i rozmiaru.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 <xref:System.Collections.IEqualityComparer> Obiekt zawiera zarówno dostawcę kod skrótu, jak i modułu porównującego. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> Konstruktor, obiekty używane jako klucze w <xref:System.Collections.Hashtable> obiektu nie są wymagane do zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia realizację scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Elementy o nowym <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iterację <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
—lub— 
 <paramref name="loadFactor" /> jest większe niż 1.0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(int, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżona liczba elementów, <see cref="T:System.Collections.Hashtable" /> obiekt początkowo może zawierać.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" />.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu, który jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany w celu ustalenia, czy dwa klucze są takie same.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślny moduł porównujący czyli każdy klucz implementacji <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> przy użyciu określonego pojemność, dostawcy kodu wyznaczania wartości skrótu, modułu porównującego i domyślny współczynnik obciążenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Skrót niestandardowego dostawcy kodu i niestandardowej funkcji porównującej umożliwiają scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza niż zero.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżona liczba elementów, <see cref="T:System.Collections.Hashtable" /> obiekt początkowo może zawierać.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1.0, który jest mnożony przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów do zasobników.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiekt, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego, za pomocą <see cref="T:System.Collections.Hashtable" />.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i domyślny moduł porównujący jest implementacją każdy klucz <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> klasy przy użyciu określonego pojemność, współczynnik obciążenia i <see cref="T:System.Collections.IEqualityComparer" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci. Współczynnik obciążenia, 1.0 jest najlepszą równowagę między szybkości i rozmiaru.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 <xref:System.Collections.IEqualityComparer> Obiekt zawiera zarówno dostawcę kod skrótu, jak i modułu porównującego. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> Konstruktor, obiekty używane jako klucze w <xref:System.Collections.Hashtable> nie są wymagane do zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia realizację scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
—lub— 
 <paramref name="loadFactor" /> jest większe niż 1.0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu do skopiowania do nowej <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1.0, który jest mnożony przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów do zasobników.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" />.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu, który jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany w celu ustalenia, czy dwa klucze są takie same.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślny moduł porównujący czyli każdy klucz implementacji <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowy <see cref="T:System.Collections.Hashtable" /> obiekt ma pojemność równa liczbie elementów kopiowanych i używa współczynnik określonego obciążenia, dostawcy kodu wyznaczania wartości skrótu i funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność jest równa liczbę elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci. Współczynnik obciążenia, 1.0 jest najlepszą równowagę między szybkości i rozmiaru.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Skrót niestandardowego dostawcy kodu i niestandardowej funkcji porównującej umożliwiają scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Elementy o nowym <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iterację <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
—lub— 
 <paramref name="loadFactor" /> jest większe niż 1.0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use Hashtable(int, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżona liczba elementów, <see cref="T:System.Collections.Hashtable" /> obiekt początkowo może zawierać.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1.0, który jest mnożony przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów do zasobników.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" />.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślnego dostawcę kod skrótu, który jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany w celu ustalenia, czy dwa klucze są takie same.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślny moduł porównujący czyli każdy klucz implementacji <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe puste wystąpienie elementu <see cref="T:System.Collections.Hashtable" /> przy użyciu określonego pojemność, należy załadować współczynnik dostawcy kodu wyznaczania wartości skrótu i porównania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, oparte na współczynnik obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów do zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem użycia większej ilości pamięci. Współczynnik obciążenia, 1.0 jest najlepszą równowagę między szybkości i rozmiaru.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów jest automatycznie zwiększana do najmniejszej liczby prime, który jest większy niż dwa razy bieżącej liczby przedziałów.  
  
 Dostawca kod skrótu zrezygnuje kody skrótów kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Porównania określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Domyślny moduł porównujący jest implementacją klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Skrót niestandardowego dostawcy kodu i niestandardowej funkcji porównującej umożliwiają scenariuszy, takich jak wyszukiwanie za pomocą ciągów bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele zbędnych danych przy użyciu różnych <xref:System.Collections.Hashtable> konstruktorów i przedstawiono różnice w zachowaniu tabel skrótów, nawet wtedy, gdy każdy z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
—lub— 
 <paramref name="loadFactor" /> jest większe niż 1.0.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="hashtable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do dodania.</param>
        <param name="value">Wartość elementu do dodania. Wartość może być <see langword="null" />.</param>
        <summary>Dodaje element z określonym kluczem i określoną wartością do <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz nie może być `null`, ale może być wartością.  
  
 Zazwyczaj obiekt, który ma korelacja stanu i jego wartość Kod skrótu nie jest używany jako klucz. Na przykład obiektów w postaci ciągów są lepsze niż obiektów klasy StringBuilder do użycia jako klucze.  
  
 Można również użyć <xref:System.Collections.Hashtable.Item%2A> właściwości, aby dodać nowe elementy, ustawiając wartość klucza, który nie istnieje w <xref:System.Collections.Hashtable>, na przykład `myCollection["myNonexistentKey"] = myValue`. Jednakże jeśli określony klucz już istnieje w <xref:System.Collections.Hashtable>, ustawiając <xref:System.Collections.Hashtable.Item%2A> właściwość zastępuje starą wartość. Z kolei <xref:System.Collections.Hashtable.Add%2A> metoda nie modyfikować istniejące elementy.  
  
 Jeśli <xref:System.Collections.Hashtable.Count%2A> jest mniejsza niż pojemność <xref:System.Collections.Hashtable>, ta metoda jest operacją O(1). Jeśli pojemność musi zostać zwiększona, aby pomieścić nowy element, ta metoda staje się O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodać elementy do <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element o takim samym kluczem już istnieje w <see cref="T:System.Collections.Hashtable" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" /> Jest tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.Hashtable" /> Ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.Hashtable.Remove(System.Object)" />
        <altmember cref="P:System.Collections.Hashtable.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashtable.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Count%2A> jest równa zero i odwołania do innych obiektów z elementów kolekcji są również zwalniane. Pojemność pozostaje bez zmian.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak Wyczyść wartości <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" /> Jest tylko do odczytu.</exception>
        <altmember cref="M:System.Collections.IDictionary.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="hashtable.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię pobieżną <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Kopia pobieżna <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Płytka kopia elementu kolekcji kopiuje elementy kolekcji, czy typy odwołań i typy wartości, ale nie są kopiowane obiektów, które dotyczą odwołania. Odwołania do nowej kolekcji wskazują na te same obiekty, które wskazują odwołania w oryginalnej kolekcji.  
  
 Z kolei kopię głęboką kolekcji kopiuje elementy i wszystko bezpośrednio lub pośrednio odwołuje się elementów.  
  
 <xref:System.Collections.Hashtable> Klonowania ma tej samej liczby, tej samej pojemności niż <xref:System.Collections.IHashCodeProvider> implementacji i tym samym <xref:System.Collections.IComparer> implementacji co oryginalny <xref:System.Collections.Hashtable>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="comparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IComparer comparer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.comparer" />
      <MemberSignature Language="VB.NET" Value="Protected Property comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IComparer ^ comparer { System::Collections::IComparer ^ get(); void set(System::Collections::IComparer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.comparer : System.Collections.IComparer with get, set" Usage="System.Collections.Hashtable.comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use KeyComparer properties.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Collections.IComparer" /> na potrzeby <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.IComparer" /> Na potrzeby <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona na wartość, ale w tabeli wyznaczania wartości skrótu został utworzony przy użyciu <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="hashtable.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Hashtable" /> zawiera określony klucz.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> zawiera element z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Contains%2A> implementuje <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Działa dokładnie tak jak <xref:System.Collections.Hashtable.ContainsKey%2A>.  
  
 Ta metoda jest operacją O(1).  
  
 Począwszy od programu .NET Framework 2.0, Metoda ta wykorzystuje obiekty kolekcji <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metod `item` do określenia, czy element istnieje. We wcześniejszych wersjach programu .NET Framework oznaczanie to było wykonywane przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` parametru na obiektach w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy <xref:System.Collections.Hashtable> zawiera określony element.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="hashtable.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Hashtable" /> zawiera określony klucz.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> zawiera element z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta działa dokładnie tak jak <xref:System.Collections.Hashtable.Contains%2A>.  
  
 Ta metoda jest operacją O(1).  
  
 Począwszy od programu .NET Framework 2.0, Metoda ta wykorzystuje obiekty kolekcji <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metod `item` do określenia, czy element istnieje. We wcześniejszych wersjach programu .NET Framework oznaczanie to było wykonywane przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` parametru na obiektach w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy <xref:System.Collections.Hashtable> zawiera określony element.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.Contains(System.Object)" />
        <altmember cref="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="hashtable.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zlokalizowania w <see cref="T:System.Collections.Hashtable" />. Wartość może być <see langword="null" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Hashtable" /> zawiera określoną wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> zawiera element z określonym <paramref name="value" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości elementów <xref:System.Collections.Hashtable> są porównywane z określoną wartością za pomocą <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 Począwszy od programu .NET Framework 2.0, Metoda ta wykorzystuje obiekty kolekcji <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metod `item` do określenia, czy element istnieje. We wcześniejszych wersjach programu .NET Framework oznaczanie to było wykonywane przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` parametru na obiektach w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy <xref:System.Collections.Hashtable> zawiera określony element.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="hashtable.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> oznacza to miejsce docelowe <see cref="T:System.Collections.DictionaryEntry" /> obiektów kopiowanych ze <see cref="T:System.Collections.Hashtable" />. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje <see cref="T:System.Collections.Hashtable" /> elementów do jednowymiarowego obiektu <see cref="T:System.Array" /> wystąpienie pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający wykonuje iterację przez <xref:System.Collections.Hashtable>.  
  
 Aby skopiować tylko klucze ze słownika <xref:System.Collections.Hashtable>, użyj `Hashtable.Keys.CopyTo`.  
  
 Aby skopiować tylko wartości w <xref:System.Collections.Hashtable>, użyj `Hashtable.Values.CopyTo`.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak skopiować listę kluczy lub na liście wartości w <xref:System.Collections.Hashtable> do jednowymiarowego obiektu <xref:System.Array>.  
  
 [!code-cpp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ma charakter wielowymiarowy.  
  
—lub— 
Liczba elementów w źródle <see cref="T:System.Collections.Hashtable" /> jest większa niż dostępna ilość miejsca od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Typ źródła <see cref="T:System.Collections.Hashtable" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.Hashtable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Hashtable.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę par klucz/wartość zawartych w <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Liczba par klucz/wartość zawartych w <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property EqualityComparer As IEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IEqualityComparer ^ EqualityComparer { System::Collections::IEqualityComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EqualityComparer : System.Collections.IEqualityComparer" Usage="System.Collections.Hashtable.EqualityComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.IEqualityComparer" /> na potrzeby <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.IEqualityComparer" /> Na potrzeby <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.IEqualityComparer> Obejmuje zarówno modułu porównującego, jak i dostawcy kodu wyznaczania wartości skrótu. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> Konstruktor, obiekty używane jako klucze w <xref:System.Collections.Hashtable> nie są wymagane do zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona na wartość, ale w tabeli wyznaczania wartości skrótu został utworzony przy użyciu <see cref="T:System.Collections.IHashCodeProvider" /> i <see cref="T:System.Collections.IComparer" />.</exception>
        <altmember cref="T:System.Collections.Comparer" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="hashtable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IDictionaryEnumerator" /> iterację, która <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> Dla <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcja języka C# (`for each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających.  W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Przełącza moduł wyliczający do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> do wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> do pierwszego elementu w kolekcji ponownie wywołaj <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji w związku z tym wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Ta metoda jest operacją O(1).  
  
 Ponieważ serializację i deserializację moduł wyliczający <xref:System.Collections.Hashtable> może spowodować, że elementy, aby stać się zmienić kolejności, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie porównano użycie <xref:System.Collections.Hashtable.GetEnumerator%2A> i `foreach` wyliczyć zawartości <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Hashtable Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable Example/CS/source2.cs#2)]
 [!code-vb[Classic Hashtable Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetHash">
      <MemberSignature Language="C#" Value="protected virtual int GetHash (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 GetHash(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetHash(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetHash (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int GetHash(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member GetHash : obj -&gt; int&#xA;override this.GetHash : obj -&gt; int" Usage="hashtable.GetHash key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Object" /> Dla której ma zostać zwrócone wartość skrótu.</param>
        <summary>Zwraca wartość skrótu dla określonego klucza.</summary>
        <returns>Wartość skrótu dla <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli w tabeli wyznaczania wartości skrótu został utworzony z określonym <xref:System.Collections.IHashCodeProvider> implementacji, ta metoda korzysta z tego dostawcy Kod skrótu; w przeciwnym razie używa <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> implementacji `key`.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashtable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt zawierający informacje wymagane do wykonywania serializacji <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt zawierający źródłowe i docelowe serializowanym strumieniu skojarzone z <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Implementuje <see cref="T:System.Runtime.Serialization.ISerializable" /> interfejs i zwraca dane potrzebne do serializacji <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zmodyfikowana.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="hcp">
      <MemberSignature Language="C#" Value="protected System.Collections.IHashCodeProvider hcp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IHashCodeProvider hcp" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.hcp" />
      <MemberSignature Language="VB.NET" Value="Protected Property hcp As IHashCodeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IHashCodeProvider ^ hcp { System::Collections::IHashCodeProvider ^ get(); void set(System::Collections::IHashCodeProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.hcp : System.Collections.IHashCodeProvider with get, set" Usage="System.Collections.Hashtable.hcp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use EqualityComparer property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IHashCodeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który można rozdzielić kodów wartości skrótu.</summary>
        <value>Obiekt, który można rozdzielić kodów wartości skrótu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona na wartość, ale w tabeli wyznaczania wartości skrótu został utworzony przy użyciu <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.Hashtable.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Hashtable" /> ma stały rozmiar.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> ma stały rozmiar; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 Kolekcja o stałym rozmiarze jest po prostu zbiorem z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym jeśli zmiany zostały wprowadzone do podstawowej kolekcji, w tym dodawania lub usuwania elementów kolekcji o stałym rozmiarze uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.Hashtable.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Hashtable" /> jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.Hashtable.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy dostęp do <see cref="T:System.Collections.Hashtable" /> jest synchronizowane (wątkowo).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.Hashtable" /> jest synchronizowane (wątkowo); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element <xref:System.Collections.Hashtable> może obsługiwać jeden składnik zapisywania i wielu elementów odczytujących jednocześnie. Aby zapewnić obsługę wielu modułów zapisujących, wszystkie operacje muszą być wykonywane przez otoki zwrócony przez <xref:System.Collections.Hashtable.Synchronized%2A> metody.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Poniższy przykład kodu pokazuje, jak można zablokować kolekcję przy użyciu <xref:System.Collections.Hashtable.SyncRoot%2A> podczas całego procesu wyliczania:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak synchronizować <xref:System.Collections.Hashtable>, ustal, czy <xref:System.Collections.Hashtable> jest zsynchronizowana, a następnie użyj zsynchronizowany <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.Hashtable.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz o wartości do pobrania lub ustawienia.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z określonym kluczem.</summary>
        <value>Wartość skojarzona z określonym kluczem. Jeśli określony klucz nie zostanie znaleziony, próby pobrania jej zwraca <see langword="null" />, a próba skonfigurowania jej tworzy nowy element przy użyciu określonego klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]`.  
  
 Można również użyć <xref:System.Collections.Hashtable.Item%2A> właściwości, aby dodać nowe elementy, ustawiając wartość klucza, który nie istnieje w <xref:System.Collections.Hashtable>, na przykład `myCollection["myNonexistentKey"] = myValue`. Jednakże jeśli określony klucz już istnieje w <xref:System.Collections.Hashtable>, ustawiając <xref:System.Collections.Hashtable.Item%2A> właściwość zastępuje starą wartość. Z kolei <xref:System.Collections.Hashtable.Add%2A> metoda nie modyfikować istniejące elementy.  
  
 Klucz nie może być `null`, ale może być wartością. Rozróżnienie między `null` , jest zwracany, ponieważ nie odnaleziono określonego klucza i `null` , jest zwracany, ponieważ wartość określonego klucza jest `null`, użyj <xref:System.Collections.Hashtable.Contains%2A> metody lub <xref:System.Collections.Hashtable.ContainsKey%2A> metodę, aby określić, czy klucz znajduje się na liście.  
  
 Pobieranie wartości tej właściwości jest operacją O(1); Ustawianie właściwości również jest operacją O(1).  
  
 W języku C# używa słowa kluczowego w celu zdefiniowania indeksatorów, a nie Implementowanie <xref:System.Collections.IList.Item%2A> właściwości. Implementuje języka Visual Basic <xref:System.Collections.Hashtable.Item%2A> jako właściwość domyślną, która zapewnia taką samą funkcjonalność indeksowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Właściwość została ustawiona i <see cref="T:System.Collections.Hashtable" /> jest tylko do odczytu.  
  
—lub— 
Ta właściwość jest ustawiona, <paramref name="key" /> nie istnieje w kolekcji, a <see cref="T:System.Collections.Hashtable" /> ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="KeyEquals">
      <MemberSignature Language="C#" Value="protected virtual bool KeyEquals (object item, object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyEquals(object item, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyEquals (item As Object, key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyEquals(System::Object ^ item, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member KeyEquals : obj * obj -&gt; bool&#xA;override this.KeyEquals : obj * obj -&gt; bool" Usage="hashtable.KeyEquals (item, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> Do porównania z <c>klucz</c>.</param>
        <param name="key">Klucz w <see cref="T:System.Collections.Hashtable" /> do porównania z <c>elementu</c>.</param>
        <summary>Porównuje określonego <see cref="T:System.Object" /> z określonym kluczem w <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="item" /> i <paramref name="key" /> są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli w tabeli wyznaczania wartości skrótu został utworzony z określonym <xref:System.Collections.IComparer> implementacji, ta metoda korzysta z tego modułu porównującego; który jest, <xref:System.Collections.IComparer.Compare%2A> (`item`, `key`). W przeciwnym razie używa `item.Equals(key)`.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.Hashtable.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ICollection" /> zawierającą klucze ze słownika <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Zawierającą klucze ze słownika <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność kluczy w <xref:System.Collections.ICollection> jest nieokreślony, ale takiej samej kolejności jak skojarzone wartości w <xref:System.Collections.ICollection> zwrócone przez <xref:System.Collections.Hashtable.Values%2A> metody.  
  
 Zwrócony <xref:System.Collections.ICollection> nie jest statyczne kopia; zamiast tego <xref:System.Collections.ICollection> odwołuje się do kluczy w oryginalnym <xref:System.Collections.Hashtable>. W związku z tym, zmienia się na <xref:System.Collections.Hashtable> odzwierciedlenie w dalszym ciągu <xref:System.Collections.ICollection>.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashtable.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Źródło zdarzeń deserializacji.</param>
        <summary>Implementuje <see cref="T:System.Runtime.Serialization.ISerializable" /> interfejs i zgłasza zdarzenie deserializacji, po zakończeniu deserializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 Ponieważ serializację i deserializację moduł wyliczający <xref:System.Collections.Hashtable> może spowodować, że elementy, aby stać się zmienić kolejności, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Obiekt skojarzony z bieżącym <see cref="T:System.Collections.Hashtable" /> jest nieprawidłowy.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="hashtable.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Collections.Hashtable> nie zawiera element z określonym kluczem <xref:System.Collections.Hashtable> pozostaje bez zmian. Jest zgłaszany żaden wyjątek.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak usunąć elementy z <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" /> Jest tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.Hashtable" /> Ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Hashtable Synchronized(class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (table As Hashtable) As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Hashtable ^ Synchronized(System::Collections::Hashtable ^ table);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.Hashtable -&gt; System.Collections.Hashtable" Usage="System.Collections.Hashtable.Synchronized table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Collections.Hashtable" /> Do synchronizacji.</param>
        <summary>Zwraca zsynchronizowane otoki (bezpieczna wątkowo) dla <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Element synchronizacji (bezpieczna wątkowo) otoka dla <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Synchronized%2A> Metody jest bezpieczny wątkowo dla wielu czytników i składników zapisywania. Ponadto zsynchronizowane otoki gwarantuje, że jest tylko jeden moduł zapisujący pisania w danym momencie.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Poniższy przykład kodu pokazuje, jak można zablokować kolekcję przy użyciu <xref:System.Collections.Hashtable.SyncRoot%2A> podczas całego procesu wyliczania:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak synchronizować <xref:System.Collections.Hashtable>, ustal, czy <xref:System.Collections.Hashtable> jest zsynchronizowana, a następnie użyj zsynchronizowany <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.Hashtable.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć zsynchronizowaną wersję <xref:System.Collections.Hashtable>, użyj <xref:System.Collections.Hashtable.Synchronized%2A> metody. Klasy pochodne może jednak zapewniać własne zsynchronizowaną wersję <xref:System.Collections.Hashtable> przy użyciu <xref:System.Collections.Hashtable.SyncRoot%2A> właściwości. Synchronizowanie kodu należy wykonywać operacje na <xref:System.Collections.Hashtable.SyncRoot%2A> z <xref:System.Collections.Hashtable>, nie są bezpośrednio w <xref:System.Collections.Hashtable> . Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności utrzymuje właściwe synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie <xref:System.Collections.Hashtable> obiektu.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Poniższy przykład kodu pokazuje, jak można zablokować kolekcję przy użyciu <xref:System.Collections.Hashtable.SyncRoot%2A> podczas całego procesu wyliczania:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcja języka C# (`for each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających.  W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Przełącza moduł wyliczający do tej pozycji. Co to położenie, wywołanie <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> do wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, wywoływania <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> do pierwszego elementu w kolekcji ponownie wywołaj <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający unieważnić i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>. W przypadku modyfikowania kolekcji między <xref:System.Collections.IEnumerator.MoveNext%2A> i <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> zwraca element, który jest ustawiony, nawet wtedy, gdy moduł wyliczający jest już unieważnione.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji w związku z tym wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.Hashtable.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ICollection" /> zawierające wartości w <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Zawierające wartości w <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność wartości w <xref:System.Collections.ICollection> jest nieokreślony, ale takiej samej kolejności jak klucze skojarzone z <xref:System.Collections.ICollection> zwrócone przez <xref:System.Collections.Hashtable.Keys%2A> metody.  
  
 Zwrócony <xref:System.Collections.ICollection> nie jest statyczne kopia; zamiast tego <xref:System.Collections.ICollection> odwołuje się do wartości w oryginalnym <xref:System.Collections.Hashtable>. W związku z tym, zmienia się na <xref:System.Collections.Hashtable> odzwierciedlenie w dalszym ciągu <xref:System.Collections.ICollection>.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>
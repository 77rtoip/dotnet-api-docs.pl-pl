<Type Name="Hashtable" FullName="System.Collections.Hashtable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4c6adcdcf0768c2d073d568527998677360d621e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30440805" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Hashtable extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Hashtable" />
  <TypeSignature Language="VB.NET" Value="Public Class Hashtable&#xA;Implements ICloneable, IDeserializationCallback, IDictionary, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Hashtable : ICloneable, System::Collections::IDictionary, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kolekcję pary klucz wartość, które są podzielone na podstawie kodu skrótu klucza.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element jest parę klucza i wartości przechowywane w <xref:System.Collections.DictionaryEntry> obiektu. Klucz nie może być `null`, ale może być wartością.  
  
 Obiekty używane jako klucze przy <xref:System.Collections.Hashtable> są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> — metoda (lub <xref:System.Collections.IHashCodeProvider> interface) i <xref:System.Object.Equals%2A?displayProperty=nameWithType> — metoda (lub <xref:System.Collections.IComparer> interfejs). Implementacja metody i interfejsy musi obsługiwać uwzględniana wielkość liter, ten sam sposób; w przeciwnym razie <xref:System.Collections.Hashtable> może działać niepoprawnie. Na przykład podczas tworzenia <xref:System.Collections.Hashtable>, należy użyć <xref:System.Collections.CaseInsensitiveHashCodeProvider> klasy (lub dowolna bez uwzględniania wielkości liter <xref:System.Collections.IHashCodeProvider> implementacji) z <xref:System.Collections.CaseInsensitiveComparer> klasy (lub dowolna bez uwzględniania wielkości liter <xref:System.Collections.IComparer> implementacji).  
  
 Ponadto te metody musi mieć takie same wyniki wywołanego z takimi samymi parametrami, podczas gdy ten klucz istnieje <xref:System.Collections.Hashtable>. Alternatywą jest użycie <xref:System.Collections.Hashtable> konstruktora z <xref:System.Collections.IEqualityComparer> parametru. Jeśli klucza równości zostały po prostu równości odwołań, dziedziczone wykonania <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> będą wystarczające.  
  
 Obiekty klucza musi być niezmienialne tak długo, jak są używane jako klucze w <xref:System.Collections.Hashtable>.  
  
 Gdy element zostanie dodany do <xref:System.Collections.Hashtable>, element znajduje się w przedziale, oparte na wartość skrótu klucza. Kolejne wyszukiwań klucza umożliwia wyszukiwanie tylko jednego określonego zasobnik, w związku z tym znacznie zmniejszyć liczbę kluczy porównania wymagane do znalezienia elementu skrótu klucza.  
  
 Współczynnik obciążenia <xref:System.Collections.Hashtable> określa maksymalny stosunek elementów zasobników. Mniejsze obciążenie czynniki spowodować godziny szybszy średni wyszukiwania kosztem zużycie pamięci. Domyślny współczynnik obciążenia 1.0 zazwyczaj zapewnia równowagę między szybkość i rozmiar. Współczynnik różne obciążenia można też określić, kiedy <xref:System.Collections.Hashtable> jest tworzony.  
  
 Po dodaniu elementów do <xref:System.Collections.Hashtable>, współczynnik rzeczywiste obciążenie <xref:System.Collections.Hashtable> zwiększa. Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów w <xref:System.Collections.Hashtable> zwiększają się automatycznie na najmniejszą liczbę pierwszych, która jest większa niż dwa razy bieżącą liczbę <xref:System.Collections.Hashtable> zasobników.  
  
 Każdy obiekt klucza w <xref:System.Collections.Hashtable> podać jego własnej funkcji skrótu, którego dostęp można uzyskać przez wywołanie metody <xref:System.Collections.Hashtable.GetHash%2A>. Jednak żadnego obiekt implementujący <xref:System.Collections.IHashCodeProvider> mogą zostać przekazane do <xref:System.Collections.Hashtable> Konstruktor i czy funkcja skrótu jest używany przez wszystkie obiekty w tabeli.  
  
 Pojemność <xref:System.Collections.Hashtable> jest liczba elementów <xref:System.Collections.Hashtable> może przechowywać. Po dodaniu elementów do <xref:System.Collections.Hashtable>, automatycznie zostaje zwiększona wydajność co jest wymagane przez; Ponowna alokacja.  
  
 Dla bardzo dużych <xref:System.Collections.Hashtable> obiekty, można zwiększyć maksymalną pojemność do 2 miliardów elementów w 64-bitowym systemie ustawiając `enabled` atrybutu elementu konfiguracji, aby `true` w środowisku czasu wykonywania.  
  
 `foreach` Instrukcji języka C# (`For Each` w języku Visual Basic) zwraca obiekt typu elementów w kolekcji. Ponieważ każdy element <xref:System.Collections.Hashtable> parę klucz/wartość jest typu elementu nie jest typu klucza lub typ wartości. Zamiast tego jest typ elementu <xref:System.Collections.DictionaryEntry>. Na przykład:  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/remarks.cpp#01)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/remarks.cs#01)]
 [!code-vb[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/remarks.vb#01)]  
  
 `foreach` Instrukcja jest otokę moduł wyliczający, który zezwala tylko odczyt z bez zapisywania do kolekcji.  
  
 Ponieważ serializację i deserializację moduł wyliczający dla <xref:System.Collections.Hashtable> może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metody.  
  
> [!NOTE]
>  Ponieważ klucze mogą być dziedziczone i ich zachowanie zmieniona, ich bezwzględną unikatowości nie może zagwarantować porównania przy użyciu <xref:System.Type.Equals%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia, inicjowanie i wykonywanie różnych funkcji do <xref:System.Collections.Hashtable> i jak wydrukować jej kluczy i wartości.  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/hashtable_example.cpp#00)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/hashtable_example.cs#00)]
 [!code-vb[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/hashtable_example.vb#00)]
 [!code-powershell[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/powershell/VS_Snippets_CLR_System/system.collections.hashtable.class/ps/hashtable.ps1#00)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <see cref="T:System.Collections.Hashtable" /> Wątek jest bezpieczny dla używany przez wiele wątków czytnika i wątku pojedynczego zapisu. Jest bezpieczne dla wątków dla wielu wątków używany, gdy tylko jeden z wątków wykonywać operacje zapisu (aktualizacji), co umożliwia obsługę odczyty zwolnić blokady, pod warunkiem, że zapisywania są serializowane do <see cref="T:System.Collections.Hashtable" />. Do obsługi wielu składników zapisywania wszystkich operacji na <see cref="T:System.Collections.Hashtable" /> muszą być wykonywane przez otoki zwrócony przez <see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /> metody, pod warunkiem, że nie istnieją żadne wątków odczytywania <see cref="T:System.Collections.Hashtable" /> obiektu.  
  
 Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</threadsafe>
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.IHashCodeProvider" />
    <altmember cref="M:System.Object.GetHashCode" />
    <altmember cref="M:System.Object.Equals(System.Object)" />
    <altmember cref="T:System.Collections.DictionaryEntry" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.IEqualityComparer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> przy użyciu domyślnego początkowa pojemność, załadowanie współczynnik dostawcy kodu wyznaczania wartości skrótu i porównania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia. Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu można skopiować do nowego <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowe <see cref="T:System.Collections.Hashtable" /> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa domyślną wartość współczynnika ładowania, dostawcy kodu wyznaczania wartości skrótu i porównania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Nowe elementy <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <see cref="T:System.Collections.Hashtable" /> obiektu.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i wdrożenia każdego klucza jest domyślna funkcja porównująca <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> przy użyciu domyślnego początkowa pojemność i obciążenia współczynnik i określonego <see cref="T:System.Collections.IEqualityComparer" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia. Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 <xref:System.Collections.IEqualityComparer> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable> obiektu nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżoną liczbę elementów który <see cref="T:System.Collections.Hashtable" /> początkowo może zawierać obiektu.</param>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> przy użyciu określonej pojemności początkowa i domyślną wartość współczynnika ładowania, dostawcy kodu wyznaczania wartości skrótu i porównania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest `capacity`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu można skopiować do nowego <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <see cref="T:System.Collections.Hashtable" />.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i wdrożenia każdego klucza jest domyślna funkcja porównująca <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika na nowy <see cref="T:System.Collections.Hashtable" /> obiektu. Nowy <see cref="T:System.Collections.Hashtable" /> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i korzysta z domyślnego współczynnika ładowania i określonego <see cref="T:System.Collections.IEqualityComparer" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 <xref:System.Collections.IEqualityComparer> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable> obiektu nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Nowe elementy <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu można skopiować do nowego <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowe <see cref="T:System.Collections.Hashtable" /> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa współczynnik obciążenia i domyślny dostawca kod skrótu i porównania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Nowe elementy <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
 —lub—  
  
 <paramref name="loadFactor" /> jest większe niż 1,0.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" /> obiektu.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany do określenia, czy dwa klucze są takie same.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> przy użyciu domyślnego początkowa pojemność i załadować współczynnik oraz skrót określonego dostawcy kodu i porównania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia. Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżoną liczbę elementów który <see cref="T:System.Collections.Hashtable" /> początkowo może zawierać obiektu.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <see cref="T:System.Collections.Hashtable" />.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i wdrożenia każdego klucza jest domyślna funkcja porównująca <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> przy użyciu określonej pojemności początkowej i <see cref="T:System.Collections.IEqualityComparer" />, a domyślna wartość współczynnika ładowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 <xref:System.Collections.IEqualityComparer> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable> nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżoną liczbę elementów który <see cref="T:System.Collections.Hashtable" /> początkowo może zawierać obiektu.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników.</param>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> przy użyciu określonej pojemności początkowej i obciążenia i domyślny dostawca kodu wyznaczania wartości skrótu oraz porównania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
 —lub—  
  
 <paramref name="loadFactor" /> jest większe niż 1,0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="capacity" /> powoduje przepełnienie.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Hashtable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt zawierający informacje wymagane do serializacji <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt zawierający źródłowy i docelowy serializowanego strumienia skojarzonego z <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> klasy, która jest możliwy do serializacji przy użyciu określonego <see cref="T:System.Runtime.Serialization.SerializationInfo" /> i <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia. Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 Ponieważ serializację i deserializację moduł wyliczający dla <xref:System.Collections.Hashtable> może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu można skopiować do nowego <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" />.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany do określenia, czy dwa klucze są takie same.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowe <see cref="T:System.Collections.Hashtable" /> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa domyślny współczynnik obciążenia oraz skrót określonego dostawcy kodu i porównania. Ten interfejs API jest nieaktualny. Aby zamiast, zobacz <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Nowe elementy <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu można skopiować do nowego <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <see cref="T:System.Collections.Hashtable" />.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i wdrożenia każdego klucza jest domyślna funkcja porównująca <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowy <see cref="T:System.Collections.Hashtable" /> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa współczynnik obciążenia i <see cref="T:System.Collections.IEqualityComparer" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 <xref:System.Collections.IEqualityComparer> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable> obiektu nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Nowe elementy <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
 —lub—  
  
 <paramref name="loadFactor" /> jest większe niż 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(int, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżoną liczbę elementów który <see cref="T:System.Collections.Hashtable" /> początkowo może zawierać obiektu.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" />.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany do określenia, czy dwa klucze są takie same.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> przy użyciu określonej pojemności początkowej, dostawcy kodu skrótu porównania i domyślny współczynnik obciążenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżoną liczbę elementów który <see cref="T:System.Collections.Hashtable" /> początkowo może zawierać obiektu.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników.</param>
        <param name="equalityComparer">
          <see cref="T:System.Collections.IEqualityComparer" /> Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <see cref="T:System.Collections.Hashtable" />.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" /> i wdrożenia każdego klucza jest domyślna funkcja porównująca <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> przy użyciu określonej pojemności początkowej, współczynnik ładowania i <see cref="T:System.Collections.IEqualityComparer" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 <xref:System.Collections.IEqualityComparer> Obiektu zawiera dostawcy kodu wyznaczania wartości skrótu i porównania. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable> nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 <xref:System.Collections.IEqualityComparer> Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
 —lub—  
  
 <paramref name="loadFactor" /> jest większe niż 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> Obiektu można skopiować do nowego <see cref="T:System.Collections.Hashtable" /> obiektu.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" />.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany do określenia, czy dwa klucze są takie same.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Hashtable" /> przez skopiowanie elementy z określonego słownika do nowego <see cref="T:System.Collections.Hashtable" /> obiektu. Nowe <see cref="T:System.Collections.Hashtable" /> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa współczynnik określonego obciążenia, dostawcy kodu wyznaczania wartości skrótu i porównania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable> obiektu. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Nowe elementy <xref:System.Collections.Hashtable> są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary> obiektu.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
 —lub—  
  
 <paramref name="loadFactor" /> jest większe niż 1,0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Hashtable(int, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Przybliżoną liczbę elementów który <see cref="T:System.Collections.Hashtable" /> początkowo może zawierać obiektu.</param>
        <param name="loadFactor">Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników.</param>
        <param name="hcp">
          <see cref="T:System.Collections.IHashCodeProvider" /> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <see cref="T:System.Collections.Hashtable" />.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Obiekt ma być używany do określenia, czy dwa klucze są takie same.  
  
 —lub—  
  
 <see langword="null" /> Aby użyć modułu porównującego domyślna, czyli wdrożenia każdego klucza <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Inicjuje nową, pustą wystąpienie <see cref="T:System.Collections.Hashtable" /> przy użyciu określonej pojemności początkowej, załadowanie współczynnik dostawcy kodu wyznaczania wartości skrótu i porównania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable> obiektu. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.  
  
 Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.  
  
 Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.  
  
 Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>. Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable> muszą być unikatowe. Implementacja klucza jest domyślna funkcja porównująca <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tabele hash przy użyciu różnych <xref:System.Collections.Hashtable> konstruktory i przedstawiono różnice w zachowaniu tabel wyznaczania wartości skrótu, nawet wtedy, gdy każda z nich zawiera te same elementy.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="loadFactor" /> jest mniejsza niż 0,1.  
  
 —lub—  
  
 <paramref name="loadFactor" /> jest większe niż 1,0.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do dodania.</param>
        <param name="value">Wartość elementu do dodania. Wartość może być <see langword="null" />.</param>
        <summary>Dodaje element z określonym kluczem i wartością w <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz nie może być `null`, ale może być wartością.  
  
 Zazwyczaj obiekt, który ma korelacja stanu i jego wartość kodu skrótu nie zostać użyta jako klucz. Na przykład ciąg obiekty są lepszym rozwiązaniem niż obiekty StringBuilder do użycia jako klucze.  
  
 Można również użyć <xref:System.Collections.Hashtable.Item%2A> właściwości, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <xref:System.Collections.Hashtable>, na przykład `myCollection["myNonexistentKey"] = myValue`. Jednak jeśli określony klucz już istnieje w <xref:System.Collections.Hashtable>, ustawienie <xref:System.Collections.Hashtable.Item%2A> stara wartość jest zastąpienie właściwości. Z kolei <xref:System.Collections.Hashtable.Add%2A> — metoda nie modyfikuje istniejące elementy.  
  
 Jeśli <xref:System.Collections.Hashtable.Count%2A> jest mniejsza niż pojemność <xref:System.Collections.Hashtable>, ta metoda jest operacją O(1). Jeśli pojemność wymaga zwiększenia w celu uwzględnienia nowego elementu, ta metoda staje się O (`n`) operację, której `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dodawania elementów do <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element z tym samym kluczem już istnieje w <see cref="T:System.Collections.Hashtable" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" /> Jest tylko do odczytu.  
  
 —lub—  
  
 <see cref="T:System.Collections.Hashtable" /> Ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.Hashtable.Remove(System.Object)" />
        <altmember cref="P:System.Collections.Hashtable.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Count%2A> jest ustawiany na zero, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji. Pojemność pozostaje niezmieniona.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można wyczyścić wartości <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" /> Jest tylko do odczytu.</exception>
        <altmember cref="M:System.Collections.IDictionary.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię pobieżną <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Kopia pobieżna <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopię pobieżną kolekcji kopiuje elementy kolekcji, czy znajdują się odwołania typy lub wartości, ale nie kopiuje obiektów, które dotyczą odwołania. Odwołania do nowej kolekcji wskazują te same obiekty, które wskazują odwołania w oryginalnej kolekcji.  
  
 Z kolei głęboką kopię kolekcji kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.  
  
 <xref:System.Collections.Hashtable> Klonowania ma tego samego liczbę, samej pojemności takie same <xref:System.Collections.IHashCodeProvider> implementacji i tym samym <xref:System.Collections.IComparer> implementacji jako oryginalny <xref:System.Collections.Hashtable>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="comparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IComparer comparer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.comparer" />
      <MemberSignature Language="VB.NET" Value="Protected Property comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IComparer ^ comparer { System::Collections::IComparer ^ get(); void set(System::Collections::IComparer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use KeyComparer properties.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Collections.IComparer" /> do użycia na potrzeby <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.IComparer" /> Do użycia na potrzeby <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona na wartość, ale tablicy skrótów został utworzony przy użyciu <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Hashtable" /> zawiera określony klucz.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> zawiera element z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Contains%2A> implementuje <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Zachowuje się dokładnie jako <xref:System.Collections.Hashtable.ContainsKey%2A>.  
  
 Ta metoda jest operacją O(1).  
  
 Począwszy od programu .NET Framework 2.0, ta metoda używa obiektów kolekcji <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` ustalenie, czy element istnieje. We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` parametrów dla obiektów w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób określić, czy <xref:System.Collections.Hashtable> zawiera określony element.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Hashtable" /> zawiera określony klucz.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> zawiera element z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa dokładnie jako <xref:System.Collections.Hashtable.Contains%2A>.  
  
 Ta metoda jest operacją O(1).  
  
 Począwszy od programu .NET Framework 2.0, ta metoda używa obiektów kolekcji <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` ustalenie, czy element istnieje. We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` parametrów dla obiektów w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób określić, czy <xref:System.Collections.Hashtable> zawiera określony element.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.Contains(System.Object)" />
        <altmember cref="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zlokalizowania w <see cref="T:System.Collections.Hashtable" />. Wartość może być <see langword="null" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Hashtable" /> zawiera określoną wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> zawiera element z określonym <paramref name="value" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości elementów <xref:System.Collections.Hashtable> są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 Począwszy od programu .NET Framework 2.0, ta metoda używa obiektów kolekcji <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` ustalenie, czy element istnieje. We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` parametrów dla obiektów w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób określić, czy <xref:System.Collections.Hashtable> zawiera określony element.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> czyli miejsce docelowe <see cref="T:System.Collections.DictionaryEntry" /> obiektów kopiowanych ze <see cref="T:System.Collections.Hashtable" />. <see cref="T:System.Array" /> Musi mieć indeksowania liczony od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopie <see cref="T:System.Collections.Hashtable" /> elementów na jednowymiarowe <see cref="T:System.Array" /> wystąpienia pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Hashtable>.  
  
 Aby skopiować tylko klucze w <xref:System.Collections.Hashtable>, użyj `Hashtable.Keys.CopyTo`.  
  
 Aby skopiować tylko wartości w <xref:System.Collections.Hashtable>, użyj `Hashtable.Values.CopyTo`.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób kopiowania listy kluczy lub na liście wartości w <xref:System.Collections.Hashtable> do jednowymiarowego <xref:System.Array>.  
  
 [!code-cpp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> jest wielowymiarowy.  
  
 —lub—  
  
 Liczba elementów w źródle <see cref="T:System.Collections.Hashtable" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Typ źródła <see cref="T:System.Collections.Hashtable" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.Hashtable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę par klucz/wartość zawartych w <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Liczba par klucz/wartość zawartych w <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property EqualityComparer As IEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IEqualityComparer ^ EqualityComparer { System::Collections::IEqualityComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.IEqualityComparer" /> do użycia na potrzeby <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.IEqualityComparer" /> Do użycia na potrzeby <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.IEqualityComparer> Zawiera modułu porównującego i dostawcy kodu wyznaczania wartości skrótu. Jeśli <xref:System.Collections.IEqualityComparer> jest używany w <xref:System.Collections.Hashtable> konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable> nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona na wartość, ale tablicy skrótów został utworzony przy użyciu <see cref="T:System.Collections.IHashCodeProvider" /> i <see cref="T:System.Collections.IComparer" />.</exception>
        <altmember cref="T:System.Collections.Comparer" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IDictionaryEnumerator" /> który iteruje <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> Dla <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> również wprowadzono moduł wyliczający wróć do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> aby pierwszym elementem kolekcji ponownie, należy wywołać <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne procedury wątku.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Ta metoda jest operacją O(1).  
  
 Ponieważ serializację i deserializację moduł wyliczający dla <xref:System.Collections.Hashtable> może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład porównuje stosowania <xref:System.Collections.Hashtable.GetEnumerator%2A> i `foreach` wyliczyć zawartości <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Hashtable Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable Example/CS/source2.cs#2)]
 [!code-vb[Classic Hashtable Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetHash">
      <MemberSignature Language="C#" Value="protected virtual int GetHash (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 GetHash(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetHash(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetHash (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int GetHash(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Object" /> Dla której ma zostać zwrócone skrótu.</param>
        <summary>Zwraca wartość skrótu dla określonego klucza.</summary>
        <returns>Wartość skrótu dla <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli utworzono tabelę wyznaczania wartości skrótu z określonym <xref:System.Collections.IHashCodeProvider> implementacji, ta metoda używa tego dostawcy Kod skrótu; w przeciwnym razie używa <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> implementacja `key`.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu zawierającego informacje o wymaganych do zserializowania <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt zawierający źródłowy i docelowy serializowanego strumienia skojarzonego z <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Implementuje <see cref="T:System.Runtime.Serialization.ISerializable" /> interfejsu i zwraca dane potrzebne do serializacji <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zmodyfikowana.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="hcp">
      <MemberSignature Language="C#" Value="protected System.Collections.IHashCodeProvider hcp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IHashCodeProvider hcp" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.hcp" />
      <MemberSignature Language="VB.NET" Value="Protected Property hcp As IHashCodeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IHashCodeProvider ^ hcp { System::Collections::IHashCodeProvider ^ get(); void set(System::Collections::IHashCodeProvider ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use EqualityComparer property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IHashCodeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który można rozdzielić skrótu.</summary>
        <value>Obiekt, który można rozdzielić skrótu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona na wartość, ale tablicy skrótów został utworzony przy użyciu <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Hashtable" /> ma stały rozmiar.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> ma ustalony rozmiar; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 Kolekcja o stałym rozmiarze jest po prostu kolekcji z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym zmian w źródłowej kolekcji, włączając Dodawanie lub usuwanie elementów z kolekcji o stałym rozmiarze odzwierciedla te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Hashtable" /> jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Hashtable" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy uzyskują dostęp do <see cref="T:System.Collections.Hashtable" /> jest synchronizowane (wielowątkowość).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.Hashtable" /> jest synchronizowane (wielowątkowość); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Collections.Hashtable> może obsługiwać jeden moduł zapisujący i wielu czytników jednocześnie. Aby obsługiwać wiele składników zapisywania, wszystkie operacje muszą być wykonywane przez otoki zwrócony przez <xref:System.Collections.Hashtable.Synchronized%2A> metody.  
  
 Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <xref:System.Collections.Hashtable.SyncRoot%2A> podczas wyliczania całego:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób synchronizacji <xref:System.Collections.Hashtable>, ustal, czy <xref:System.Collections.Hashtable> jest synchronizowane i użyj zsynchronizowany <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wartości, których można pobrać lub ustawić.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z określonym kluczem.</summary>
        <value>Wartość skojarzona z określonym kluczem. Jeśli określony klucz nie zostanie znaleziony, próby pobrania jej zwraca <see langword="null" />, a próba skonfigurowania go tworzy nowy element przy użyciu określonego klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]`.  
  
 Można również użyć <xref:System.Collections.Hashtable.Item%2A> właściwości, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <xref:System.Collections.Hashtable>, na przykład `myCollection["myNonexistentKey"] = myValue`. Jednak jeśli określony klucz już istnieje w <xref:System.Collections.Hashtable>, ustawienie <xref:System.Collections.Hashtable.Item%2A> stara wartość jest zastąpienie właściwości. Z kolei <xref:System.Collections.Hashtable.Add%2A> — metoda nie modyfikuje istniejące elementy.  
  
 Klucz nie może być `null`, ale może być wartością. Aby odróżnić `null` który jest zwracany, ponieważ nie odnaleziono określonego klucza i `null` który jest zwracany, ponieważ wartość określony klucz jest `null`, użyj <xref:System.Collections.Hashtable.Contains%2A> — metoda lub <xref:System.Collections.Hashtable.ContainsKey%2A> metodę, aby określić, czy Ten klucz istnieje na liście.  
  
 Pobieranie wartości tej właściwości jest operacją O(1); Ustawienie właściwości jest również O(1) operacji.  
  
 Używa języka C# do definiowania indeksatory zamiast implementacja słowa kluczowego <xref:System.Collections.IList.Item%2A> właściwości. Implementuje Visual Basic <xref:System.Collections.Hashtable.Item%2A> jako domyślna właściwość, która zapewnia te same funkcje indeksowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Właściwość jest ustawiona i <see cref="T:System.Collections.Hashtable" /> jest tylko do odczytu.  
  
 —lub—  
  
 Ta właściwość jest ustawiona, <paramref name="key" /> nie istnieje w kolekcji i <see cref="T:System.Collections.Hashtable" /> ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="KeyEquals">
      <MemberSignature Language="C#" Value="protected virtual bool KeyEquals (object item, object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyEquals(object item, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyEquals (item As Object, key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyEquals(System::Object ^ item, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> Do porównania z <c>klucza</c>.</param>
        <param name="key">Klucz w <see cref="T:System.Collections.Hashtable" /> do porównania z <c>elementu</c>.</param>
        <summary>Porównuje określony <see cref="T:System.Object" /> z określonym kluczem w <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="item" /> i <paramref name="key" /> są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli utworzono tabelę wyznaczania wartości skrótu z określonym <xref:System.Collections.IComparer> implementacji, ta metoda używa tego porównania; będący, <xref:System.Collections.IComparer.Compare%2A> (`item`, `key`). W przeciwnym razie używa `item.Equals(key)`.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ICollection" /> zawierającą klucze ze słownika <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Zawierającą klucze ze słownika <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność kluczy w <xref:System.Collections.ICollection> jest nieokreślony, ale takiej samej kolejności jak skojarzone wartości w <xref:System.Collections.ICollection> zwrócony przez <xref:System.Collections.Hashtable.Values%2A> metody.  
  
 Zwrócona <xref:System.Collections.ICollection> nie jest statyczna kopia; zamiast tego <xref:System.Collections.ICollection> odwołuje się do kluczy w oryginalnym <xref:System.Collections.Hashtable>. W związku z tym zmiany <xref:System.Collections.Hashtable> kontynuować zostaną odzwierciedlone w <xref:System.Collections.ICollection>.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Źródło zdarzenia deserializacji.</param>
        <summary>Implementuje <see cref="T:System.Runtime.Serialization.ISerializable" /> interfejsu i zgłasza zdarzenie deserializacji po zakończeniu wykonywania deserializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Hashtable.Count%2A>.  
  
 Ponieważ serializację i deserializację moduł wyliczający dla <xref:System.Collections.Hashtable> może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Obiekt skojarzony z bieżącym <see cref="T:System.Collections.Hashtable" /> jest nieprawidłowy.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Collections.Hashtable> nie zawiera element z określonym kluczem <xref:System.Collections.Hashtable> pozostaje niezmieniona. Nie wyjątek.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób Usuń elementy z <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Hashtable" /> Jest tylko do odczytu.  
  
 —lub—  
  
 <see cref="T:System.Collections.Hashtable" /> Ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Hashtable Synchronized(class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (table As Hashtable) As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Hashtable ^ Synchronized(System::Collections::Hashtable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Collections.Hashtable" /> Do synchronizacji.</param>
        <summary>Zwraca zsynchronizowane otoki (wątkowo) dla <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>A zsynchronizowane (wątkowo) otoki dla <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Synchronized%2A> Metoda jest wielowątkowość dla wielu czytników i modułów zapisujących. Ponadto zsynchronizowane otoki gwarantuje, że jest tylko jeden moduł zapisujący zapisywania naraz.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <xref:System.Collections.Hashtable.SyncRoot%2A> podczas wyliczania całego:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób synchronizacji <xref:System.Collections.Hashtable>, ustal, czy <xref:System.Collections.Hashtable> jest synchronizowane i użyj zsynchronizowany <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć zsynchronizowaną wersję <xref:System.Collections.Hashtable>, użyj <xref:System.Collections.Hashtable.Synchronized%2A> metody. Jednak klasy pochodne zapewniają własne zsynchronizowanej wersji <xref:System.Collections.Hashtable> przy użyciu <xref:System.Collections.Hashtable.SyncRoot%2A> właściwości. Synchronizowanie kodu musi wykonywać operacje <xref:System.Collections.Hashtable.SyncRoot%2A> z <xref:System.Collections.Hashtable>, nie są bezpośrednio w <xref:System.Collections.Hashtable> . Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie <xref:System.Collections.Hashtable> obiektu.  
  
 Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <xref:System.Collections.Hashtable.SyncRoot%2A> podczas wyliczania całego:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> również wprowadzono moduł wyliczający wróć do tej pozycji. At to pozycja, wywoływania <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, wywoływania <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> aby pierwszym elementem kolekcji ponownie, należy wywołać <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający może być unieważniona i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>. Jeśli kolekcja jest zmodyfikowany między <xref:System.Collections.IEnumerator.MoveNext%2A> i <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> zwraca element, który ma ustawioną, nawet wtedy, gdy moduł wyliczający jest już unieważnione.  
  
 Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ICollection" /> zawierający wartości w <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Zawierający wartości w <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność wartości na liście <xref:System.Collections.ICollection> jest nieokreślony, ale takiej samej kolejności jak skojarzonych kluczy w <xref:System.Collections.ICollection> zwrócony przez <xref:System.Collections.Hashtable.Keys%2A> — metoda.  
  
 Zwrócona <xref:System.Collections.ICollection> nie jest statyczna kopia; zamiast tego <xref:System.Collections.ICollection> odwołuje się do wartości w oryginalnym <xref:System.Collections.Hashtable>. W związku z tym zmiany <xref:System.Collections.Hashtable> kontynuować zostaną odzwierciedlone w <xref:System.Collections.ICollection>.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ProjectCollection" FullName="Microsoft.Build.Evaluation.ProjectCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1e607db4ee16a44b6f5c635bce20c321c6e42f25" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69258956" /></Metadata><TypeSignature Language="C#" Value="public class ProjectCollection : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ProjectCollection extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Evaluation.ProjectCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class ProjectCollection&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProjectCollection : IDisposable" />
  <TypeSignature Language="F#" Value="type ProjectCollection = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Hermetyzuje zestaw powiązanych projektów, ich zestawów narzędzi, domyślny zestaw właściwości globalnych i rejestratorów, które powinny być używane do ich kompilowania. Wersja globalna tej klasy działa jako domyślna kolekcja projektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W domenie aplikacji może istnieć wiele kolekcji projektów. Jednak te nie mogą być kompilowane współbieżnie.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kolekcję projektów bez właściwości globalnych lub rejestratorów. Zestaw narzędzi kolekcji projektów jest inicjowany z pliku konfiguracji i rejestru.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProjectCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProjectCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Tworzy kolekcję projektów bez właściwości globalnych lub rejestratorów. Zestaw narzędzi kolekcji projektów jest inicjowany z pliku konfiguracji i rejestru.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProjectCollection (Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor(Microsoft.Build.Evaluation.ToolsetDefinitionLocations)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (toolsetLocations As ToolsetDefinitionLocations)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProjectCollection(Microsoft::Build::Evaluation::ToolsetDefinitionLocations toolsetLocations);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.ProjectCollection : Microsoft.Build.Evaluation.ToolsetDefinitionLocations -&gt; Microsoft.Build.Evaluation.ProjectCollection" Usage="new Microsoft.Build.Evaluation.ProjectCollection toolsetLocations" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="toolsetLocations" Type="Microsoft.Build.Evaluation.ToolsetDefinitionLocations" />
      </Parameters>
      <Docs>
        <param name="toolsetLocations">Lokalizacje, z których mają zostać załadowane zestawy narzędzi.</param>
        <summary>Tworzy kolekcję projektów bez właściwości globalnych lub rejestratorów. Zestaw narzędzi kolekcji projektów jest inicjowany z zestawów narzędzi w podanych lokalizacjach.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProjectCollection (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (globalProperties As IDictionary(Of String, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProjectCollection(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.ProjectCollection : System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; Microsoft.Build.Evaluation.ProjectCollection" Usage="new Microsoft.Build.Evaluation.ProjectCollection globalProperties" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="globalProperties">Domyślne właściwości globalne do użycia. Może mieć wartość zerową.</param>
        <summary>Tworzy wystąpienie kolekcji projektów z określonymi właściwościami globalnymi, brak rejestratorów i odczytuje informacje zestawu narzędzi z pliku konfiguracji i rejestru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może zgłosić InvalidToolsetDefinitionException.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProjectCollection (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, valuetype Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},Microsoft.Build.Evaluation.ToolsetDefinitionLocations)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProjectCollection(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, Microsoft::Build::Evaluation::ToolsetDefinitionLocations toolsetDefinitionLocations);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.ProjectCollection : System.Collections.Generic.IDictionary&lt;string, string&gt; * seq&lt;Microsoft.Build.Framework.ILogger&gt; * Microsoft.Build.Evaluation.ToolsetDefinitionLocations -&gt; Microsoft.Build.Evaluation.ProjectCollection" Usage="new Microsoft.Build.Evaluation.ProjectCollection (globalProperties, loggers, toolsetDefinitionLocations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="toolsetDefinitionLocations" Type="Microsoft.Build.Evaluation.ToolsetDefinitionLocations" />
      </Parameters>
      <Docs>
        <param name="globalProperties">Domyślne właściwości globalne do użycia. Może mieć wartość zerową.</param>
        <param name="loggers">Rejestratory do zarejestrowania. Może mieć wartość zerową.</param>
        <param name="toolsetDefinitionLocations">Lokalizacje, z których mają zostać załadowane zestawy narzędzi.</param>
        <summary>Tworzy wystąpienie kolekcji projektów z określonymi właściwościami globalnymi i rejestratorami oraz przy użyciu określonych lokalizacji zestawu narzędzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może zgłosić InvalidToolsetDefinitionException.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProjectCollection (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers, valuetype Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int32 maxNodeCount, bool onlyLogCriticalEvents) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.ToolsetDefinitionLocations,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProjectCollection(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers, Microsoft::Build::Evaluation::ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.ProjectCollection : System.Collections.Generic.IDictionary&lt;string, string&gt; * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; * Microsoft.Build.Evaluation.ToolsetDefinitionLocations * int * bool -&gt; Microsoft.Build.Evaluation.ProjectCollection" Usage="new Microsoft.Build.Evaluation.ProjectCollection (globalProperties, loggers, remoteLoggers, toolsetDefinitionLocations, maxNodeCount, onlyLogCriticalEvents)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
        <Parameter Name="toolsetDefinitionLocations" Type="Microsoft.Build.Evaluation.ToolsetDefinitionLocations" />
        <Parameter Name="maxNodeCount" Type="System.Int32" />
        <Parameter Name="onlyLogCriticalEvents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="globalProperties">Domyślne właściwości globalne do użycia. Może mieć wartość zerową.</param>
        <param name="loggers">Rejestratory do zarejestrowania. Może mieć wartość null i być określony dla dowolnej kompilacji.</param>
        <param name="remoteLoggers">Wszystkie rejestratory zdalne do zarejestrowania. Może mieć wartość null i być określony dla dowolnej kompilacji.</param>
        <param name="toolsetDefinitionLocations">Lokalizacje, z których mają zostać załadowane zestawy narzędzi.</param>
        <param name="maxNodeCount">Maksymalna liczba węzłów do użycia podczas kompilowania.</param>
        <param name="onlyLogCriticalEvents">W przypadku ustawienia wartości true zostaną zarejestrowane tylko zdarzenia krytyczne.</param>
        <summary>Tworzy kolekcję projektów z określonymi właściwościami globalnymi, rejestratorami, liczbą węzłów i wartością onlyLogCriticalEvents. Zestaw narzędzi kolekcji projektów jest inicjowany z zestawów narzędzi w podanych lokalizacjach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca InvalidProjectFileException, jeśli jakiekolwiek właściwości globalne są zastrzeżone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToolset">
      <MemberSignature Language="C#" Value="public void AddToolset (Microsoft.Build.Evaluation.Toolset toolset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToolset(class Microsoft.Build.Evaluation.Toolset toolset) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.AddToolset(Microsoft.Build.Evaluation.Toolset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToolset(Microsoft::Build::Evaluation::Toolset ^ toolset);" />
      <MemberSignature Language="F#" Value="member this.AddToolset : Microsoft.Build.Evaluation.Toolset -&gt; unit" Usage="projectCollection.AddToolset toolset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolset" Type="Microsoft.Build.Evaluation.Toolset" />
      </Parameters>
      <Docs>
        <param name="toolset">Zestaw narzędzi, który ma zostać dodany.</param>
        <summary>Dodaje nowy zestaw narzędzi do kolekcji projektu. Zastępuje wszystkie istniejące zestawy narzędzi z tą samą wersją narzędzia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsToolset">
      <MemberSignature Language="C#" Value="public bool ContainsToolset (string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsToolset(string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.ContainsToolset(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsToolset (toolsVersion As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsToolset(System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="member this.ContainsToolset : string -&gt; bool" Usage="projectCollection.ContainsToolset toolsVersion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="toolsVersion">Wersja narzędzi do wyszukania.</param>
        <summary>Określa, czy zestaw narzędzi jest zdefiniowany dla danej wersji narzędzia.</summary>
        <returns><see langword="true" />Jeśli istnieje zestaw narzędzi zdefiniowany dla danej wersji narzędzi; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="Microsoft.Build.Evaluation.ProjectCollection.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę projektów załadowanych obecnie do tej kolekcji.</summary>
        <value>Liczba projektów, które są obecnie załadowane do tej kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultToolsVersion">
      <MemberSignature Language="C#" Value="public string DefaultToolsVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultToolsVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultToolsVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultToolsVersion { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultToolsVersion : string with get, set" Usage="Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślną wersję narzędzi tej kolekcji projektów.</summary>
        <value>Domyślna wersja narzędzi tej kolekcji projektów, która jest zawsze zdefiniowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość domyślna jest uzyskiwana z pliku. exe. config, z rejestru systemowego lub, jeśli nie są obecne, z zakodowanych w wersji narzędzi "2,0".  
  
 Metoda Set zgłasza InvalidOperationException, jeśli zestaw narzędzi o podanej wersji narzędzia nie został zdefiniowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableMarkDirty">
      <MemberSignature Language="C#" Value="public bool DisableMarkDirty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisableMarkDirty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty" />
      <MemberSignature Language="VB.NET" Value="Public Property DisableMarkDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisableMarkDirty { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisableMarkDirty : bool with get, set" Usage="Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia flagę określającą, <see cref="M:Microsoft.Build.Evaluation.Project.MarkDirty" /> czy jest tymczasowo wyłączona w projektach w tej kolekcji. Pozwala to na przykład ustawić właściwości globalne bez projektów, które są oznaczone jako zanieczyszczone do ponownej oceny.</summary>
        <value>Zwraca flagę, która określa <see langword="MarkDirty" /> , czy jest tymczasowo wyłączona.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zarówno zasoby zarządzane jak i niezarządzane.  Wywoływana, gdy host nie potrzebuje już kolekcji projektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="projectCollection.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zarówno zasoby zarządzane jak i niezarządzane.  Wywoływana, gdy host nie potrzebuje już kolekcji projektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wersjach programu MSBuild, które zostały dostarczone z .NET Framework 4,5 i Visual Studio 12,0, należy wywołać UnloadProject (), zanim element ProjectCollection wyjdzie poza zakres ".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="projectCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">W przypadku wartości true zwalnia zarówno zasoby zarządzane, jak i niezarządzane; w przeciwnym razie zwalnia tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zarówno zasoby zarządzane jak i niezarządzane.  Wywoływana, gdy host nie potrzebuje już kolekcji projektu. Zamyka wszystkie usługi rejestrowania, które są własnością kolekcji projektu i zwalnia wątek rejestratora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Postępuj zgodnie z wytycznymi usuwania elementów bezużytecznych platformy .NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string unescapedString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string unescapedString) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (unescapedString As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ unescapedString);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="Microsoft.Build.Evaluation.ProjectCollection.Escape unescapedString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unescapedString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unescapedString">Ciąg do przekonwertowania.</param>
        <summary>Konwertuje znaki specjalne w ciągu na format ucieczki MSBuild.</summary>
        <returns>Przekonwertowany ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład "% 3B" dla ";". Konwertowane są tylko znaki, które są szczególnie istotne dla analizy MSBuild. Obiekty wywołujące mogą używać tej metody, aby bezpiecznie przeanalizować ciąg za pomocą innych metod, które w przeciwnym razie zwiększą jego rozmiar. Obiekty wywołujące mogą również użyć tej metody, aby bezpiecznie zapisać ciąg w pliku projektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectPropertyInstance GetGlobalProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectPropertyInstance GetGlobalProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.GetGlobalProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGlobalProperty (name As String) As ProjectPropertyInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectPropertyInstance ^ GetGlobalProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetGlobalProperty : string -&gt; Microsoft.Build.Execution.ProjectPropertyInstance" Usage="projectCollection.GetGlobalProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectPropertyInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości, która ma zostać pobrana.</param>
        <summary>Pobiera każdą właściwość globalną kolekcji projektów o określonej nazwie.</summary>
        <returns>Wszystkie właściwości globalne w kolekcji projektów o określonej nazwie; w przeciwnym razie zwraca wartość null.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedProjects">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.Project&gt; GetLoadedProjects (string fullPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.Project&gt; GetLoadedProjects(string fullPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.GetLoadedProjects(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedProjects (fullPath As String) As ICollection(Of Project)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::Project ^&gt; ^ GetLoadedProjects(System::String ^ fullPath);" />
      <MemberSignature Language="F#" Value="member this.GetLoadedProjects : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.Project&gt;" Usage="projectCollection.GetLoadedProjects fullPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.Project&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fullPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fullPath">Ścieżka do pliku projektu, który ma zostać dopasowany.</param>
        <summary>Pobiera wszystkie projekty, których ścieżka projektu pasuje do podanej ścieżki.</summary>
        <returns>Wszystkie projekty, których ścieżka projektu pasuje do danej ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może istnieć więcej niż jeden projekt o danej ścieżce, ponieważ projekty są również rozróżniane przez właściwości globalne i/lub narzędzia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetToolset">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.Toolset GetToolset (string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Build.Evaluation.Toolset GetToolset(string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.GetToolset(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToolset (toolsVersion As String) As Toolset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Microsoft::Build::Evaluation::Toolset ^ GetToolset(System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="abstract member GetToolset : string -&gt; Microsoft.Build.Evaluation.Toolset&#xA;override this.GetToolset : string -&gt; Microsoft.Build.Evaluation.Toolset" Usage="projectCollection.GetToolset toolsVersion" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Microsoft.Build.Evaluation.IToolsetProvider.GetToolset(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Toolset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="toolsVersion">Wersja narzędzi do dopasowania.</param>
        <summary>Pobiera zestaw narzędzi z określoną wersją narzędzia.</summary>
        <returns>Zestaw narzędzi z określoną wersją narzędzia lub <see langword="null" /> Jeśli nie istnieje zestaw narzędzi zgodny z tą wersją narzędzi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalProjectCollection">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.ProjectCollection GlobalProjectCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Build.Evaluation.ProjectCollection GlobalProjectCollection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property GlobalProjectCollection As ProjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Build::Evaluation::ProjectCollection ^ GlobalProjectCollection { Microsoft::Build::Evaluation::ProjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalProjectCollection : Microsoft.Build.Evaluation.ProjectCollection" Usage="Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt globalnej kolekcji projektów.</summary>
        <value>Globalny obiekt kolekcji projektów. To jest kolekcja pojedynczych projektów bez właściwości globalnych lub rejestratorów. Informacje o zestawie narzędzi są uzyskiwane z pliku konfiguracji i rejestru.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezpieczne pod względem współbieżności.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GlobalProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GlobalProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.GlobalProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalProperties As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GlobalProperties { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalProperties : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="Microsoft.Build.Evaluation.ProjectCollection.GlobalProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślne właściwości globalne tylko do odczytu dla wszystkich projektów w tej kolekcji.</summary>
        <value>Domyślne właściwości globalne tylko do odczytu dla wszystkich projektów w tej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty%2A> i<xref:Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty%2A> , aby dodawać, ustawiać i usuwać właściwości globalne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HostServices">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.HostServices HostServices { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Execution.HostServices HostServices" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.HostServices" />
      <MemberSignature Language="VB.NET" Value="Public Property HostServices As HostServices" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Execution::HostServices ^ HostServices { Microsoft::Build::Execution::HostServices ^ get(); void set(Microsoft::Build::Execution::HostServices ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HostServices : Microsoft.Build.Execution.HostServices with get, set" Usage="Microsoft.Build.Evaluation.ProjectCollection.HostServices" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.HostServices</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który dostarcza usługi hosta do zadań podczas kompilacji projektów zawartych w kolekcji projektu.</summary>
        <value>Obiekt usług hosta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie funkcja zwraca <xref:Microsoft.Build.Evaluation.ProjectCollection.HostServices%2A>wartość, która może mieć wartość null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBuildEnabled">
      <MemberSignature Language="C#" Value="public bool IsBuildEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBuildEnabled" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBuildEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBuildEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBuildEnabled : bool with get, set" Usage="Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy elementy docelowe i zadania projektów w kolekcji projektu można skompilować.</summary>
        <value><see langword="true" />Jeśli obiekty docelowe i zadania projektów w tej kolekcji projektu można skompilować; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może służyć do celów bezpieczeństwa. Domyślnie nowy projekt ma takie samo ustawienie IsBuildEnabled jak nadrzędna Kolekcja projektów, która go zawiera. Gdy IsBuildEnabled ma wartość false, Metoda kompilacji w tym projekcie kończy się niepowodzeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedProjects">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.Project&gt; LoadedProjects { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.Project&gt; LoadedProjects" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.LoadedProjects" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LoadedProjects As ICollection(Of Project)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::Project ^&gt; ^ LoadedProjects { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::Project ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadedProjects : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.Project&gt;" Usage="Microsoft.Build.Evaluation.ProjectCollection.LoadedProjects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.Project&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie projekty aktualnie załadowane do tej kolekcji.</summary>
        <value>Wszystkie projekty aktualnie załadowane do tej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy projekt ma unikatową kombinację ścieżki, właściwości globalnych i wersji narzędzi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadProject">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Szacuje projekt na podstawie kodu źródłowego w danym pliku projektu. Kod źródłowy jest oceniany z wersją globalnych właściwości i narzędzi tej kolekcji projektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wersjach programu MSBuild, które zostały dostarczone z .NET Framework 4,5 i Visual Studio 12,0, należy wywołać UnloadProject przed przekroczeniem zakresu ProjectCollection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadProject">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.Project LoadProject (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.Project LoadProject(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadProject (fileName As String) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::Project ^ LoadProject(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.LoadProject : string -&gt; Microsoft.Build.Evaluation.Project" Usage="projectCollection.LoadProject fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik projektu do obliczenia.</param>
        <summary>Szacuje projekt na podstawie kodu źródłowego w danym pliku projektu. Kod źródłowy jest oceniany z wersją globalnych właściwości i narzędzi tej kolekcji projektu.</summary>
        <returns>Jeśli istniejący projekt w kolekcji został już oceniony z danego pliku projektu, zwracany jest istniejący projekt. W przeciwnym razie tworzony jest nowy projekt, oceniany, dodawany do kolekcji projektów i zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wersjach programu MSBuild, które zostały dostarczone z .NET Framework 4,5 i Visual Studio 12,0, należy wywołać UnloadProject przed przekroczeniem zakresu ProjectCollection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadProject">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.Project LoadProject (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.Project LoadProject(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::Project ^ LoadProject(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="member this.LoadProject : System.Xml.XmlReader -&gt; Microsoft.Build.Evaluation.Project" Usage="projectCollection.LoadProject xmlReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Czytnik Xml, z którego ma być odczytywany kod źródłowy projektu.</param>
        <summary>Szacuje projekt z kodu źródłowego odczytanego z danego czytnika XML. Kod źródłowy jest oceniany z wersją globalnych właściwości i narzędzi tej kolekcji projektu.</summary>
        <returns>Nowy projekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Projekt jest dodawany do kolekcji projektów, gdy ten projekt lub dany katalog główny projektu otrzymuje pełną ścieżkę do pliku projektu.  
  
 W wersjach programu MSBuild, które zostały dostarczone z .NET Framework 4,5 i Visual Studio 12,0, należy wywołać UnloadProject przed przekroczeniem zakresu ProjectCollection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadProject">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.Project LoadProject (string fileName, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.Project LoadProject(string fileName, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadProject (fileName As String, toolsVersion As String) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::Project ^ LoadProject(System::String ^ fileName, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="member this.LoadProject : string * string -&gt; Microsoft.Build.Evaluation.Project" Usage="projectCollection.LoadProject (fileName, toolsVersion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik projektu do obliczenia.</param>
        <param name="toolsVersion">Wersja narzędzi do użycia. Może mieć wartość zerową.</param>
        <summary>Szacuje projekt z kodu źródłowego odczytanego z danego pliku projektu. Kod źródłowy jest oceniany przy użyciu globalnych właściwości tej kolekcji projektów i danej wersji narzędzi.</summary>
        <returns>Jeśli istniejący projekt w kolekcji został już oceniony z danego pliku projektu i z daną wersją narzędzi, zwracany jest istniejący projekt. W przeciwnym razie tworzony jest nowy projekt, oceniany, dodawany do kolekcji projektów i zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wersjach programu MSBuild, które zostały dostarczone z .NET Framework 4,5 i Visual Studio 12,0, należy wywołać UnloadProject przed przekroczeniem zakresu ProjectCollection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadProject">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.Project LoadProject (System.Xml.XmlReader xmlReader, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.Project LoadProject(class System.Xml.XmlReader xmlReader, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::Project ^ LoadProject(System::Xml::XmlReader ^ xmlReader, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="member this.LoadProject : System.Xml.XmlReader * string -&gt; Microsoft.Build.Evaluation.Project" Usage="projectCollection.LoadProject (xmlReader, toolsVersion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Czytnik Xml, z którego ma być odczytywany kod źródłowy projektu.</param>
        <param name="toolsVersion">Wersja narzędzi do użycia. Może mieć wartość zerową.</param>
        <summary>Szacuje projekt z kodu źródłowego odczytanego z danego czytnika XML. Kod źródłowy jest oceniany przy użyciu globalnych właściwości tej kolekcji projektów i danej wersji narzędzi.</summary>
        <returns>Nowy projekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Projekt jest dodawany do kolekcji projektów, gdy ten projekt lub dany katalog główny projektu otrzymuje pełną ścieżkę do pliku projektu.  
  
 W wersjach programu MSBuild, które zostały dostarczone z .NET Framework 4,5 i Visual Studio 12,0, należy wywołać UnloadProject przed przekroczeniem zakresu ProjectCollection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadProject">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.Project LoadProject (string fileName, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.Project LoadProject(string fileName, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadProject (fileName As String, globalProperties As IDictionary(Of String, String), toolsVersion As String) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::Project ^ LoadProject(System::String ^ fileName, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="member this.LoadProject : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="projectCollection.LoadProject (fileName, globalProperties, toolsVersion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik projektu do oceny.</param>
        <param name="globalProperties">Właściwości globalne do użycia. Może mieć wartość null, w takim przypadku zostaną użyte właściwości globalne zawarte w kolekcji projektu.</param>
        <param name="toolsVersion">Wersja narzędzia. Może mieć wartość zerową.</param>
        <summary>Szacuje projekt z kodu źródłowego odczytanego z danego pliku projektu. Kod źródłowy jest oceniany przy użyciu podanych właściwości globalnych i narzędzi.</summary>
        <returns>Jeśli istniejący projekt w kolekcji został już oceniony z danego pliku projektu i z podaną właściwością globalną i wersją narzędzi, zwracany jest istniejący projekt. W przeciwnym razie tworzony jest nowy projekt, oceniany, dodawany do kolekcji projektów i zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wersjach programu MSBuild, które zostały dostarczone z .NET Framework 4,5 i Visual Studio 12,0, należy wywołać UnloadProject przed przekroczeniem zakresu ProjectCollection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadProject">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.Project LoadProject (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.Project LoadProject(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::Project ^ LoadProject(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="member this.LoadProject : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="projectCollection.LoadProject (xmlReader, globalProperties, toolsVersion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Czytnik XML, z którego ma zostać odczytany projekt</param>
        <param name="globalProperties">Właściwości globalne do użycia. Może mieć wartość null; w takim przypadku użyte zostaną globalne właściwości zawarte w kolekcji projektu.</param>
        <param name="toolsVersion">Wersja narzędzia. Może mieć wartość zerową.</param>
        <summary>Szacuje projekt z kodu źródłowego odczytanego z danego czytnika XML. Kod źródłowy jest oceniany przy użyciu podanych właściwości globalnych i narzędzi.</summary>
        <returns>Nowy projekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Projekt jest dodawany do kolekcji projektów, gdy ten projekt lub dany katalog główny projektu otrzymuje pełną ścieżkę do pliku projektu.  
  
 W wersjach programu MSBuild, które zostały dostarczone z .NET Framework 4,5 i Visual Studio 12,0, należy wywołać UnloadProject przed przekroczeniem zakresu ProjectCollection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loggers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Framework.ILogger&gt; Loggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Framework.ILogger&gt; Loggers" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.Loggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Loggers As ICollection(Of ILogger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ Loggers { System::Collections::Generic::ICollection&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Loggers : System.Collections.Generic.ICollection&lt;Microsoft.Build.Framework.ILogger&gt;" Usage="Microsoft.Build.Evaluation.ProjectCollection.Loggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Framework.ILogger&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie rejestratory, które mogą być używane przez projekty w tej kolekcji.</summary>
        <value>Wszystkie rejestratory, które projekty w tej kolekcji mogą wykorzystać do ich kompilacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rejestratory są dodawane za pomocą <xref:Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnlyLogCriticalEvents">
      <MemberSignature Language="C#" Value="public bool OnlyLogCriticalEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OnlyLogCriticalEvents" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property OnlyLogCriticalEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OnlyLogCriticalEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OnlyLogCriticalEvents : bool with get, set" Usage="Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rejestrowane są tylko krytyczne zdarzenia, takie jak ostrzeżenia i błędy.</summary>
        <value><see langword="true" />Jeśli rejestrowane są tylko krytyczne zdarzenia, takie jak ostrzeżenia i błędy; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectAdded">
      <MemberSignature Language="C#" Value="public event Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler ProjectAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Build.Evaluation.ProjectCollection/ProjectAddedEventHandler ProjectAdded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectAdded" />
      <MemberSignature Language="VB.NET" Value="Public Event ProjectAdded As ProjectCollection.ProjectAddedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Microsoft::Build::Evaluation::ProjectCollection::ProjectAddedEventHandler ^ ProjectAdded;" />
      <MemberSignature Language="F#" Value="member this.ProjectAdded : Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler " Usage="member this.ProjectAdded : Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectCollection+ProjectAddedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zdarzenie, które jest wywoływane, gdy projekt zostanie dodany do ProjectRootElementCache tej kolekcji projektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;Microsoft.Build.Evaluation.ProjectChangedEventArgs&gt; ProjectChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class Microsoft.Build.Evaluation.ProjectChangedEventArgs&gt; ProjectChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event ProjectChanged As EventHandler(Of ProjectChangedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;Microsoft::Build::Evaluation::ProjectChangedEventArgs ^&gt; ^ ProjectChanged;" />
      <MemberSignature Language="F#" Value="member this.ProjectChanged : EventHandler&lt;Microsoft.Build.Evaluation.ProjectChangedEventArgs&gt; " Usage="member this.ProjectChanged : System.EventHandler&lt;Microsoft.Build.Evaluation.ProjectChangedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;Microsoft.Build.Evaluation.ProjectChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uruchamiany, gdy <see cref="T:Microsoft.Build.Evaluation.Project" /> element zawarty w tym wystąpieniu został bezpośrednio zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest wywoływane dla bezpośrednich zmian XML projektu za pośrednictwem modelu konstrukcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectCollectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs&gt; ProjectCollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs&gt; ProjectCollectionChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event ProjectCollectionChanged As EventHandler(Of ProjectCollectionChangedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;Microsoft::Build::Evaluation::ProjectCollectionChangedEventArgs ^&gt; ^ ProjectCollectionChanged;" />
      <MemberSignature Language="F#" Value="member this.ProjectCollectionChanged : EventHandler&lt;Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs&gt; " Usage="member this.ProjectCollectionChanged : System.EventHandler&lt;Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uruchamiany, gdy stan zostanie zmieniony w tym wystąpieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest zgłaszane w przypadku zmian w poszczególnych projektach.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectXmlChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs&gt; ProjectXmlChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs&gt; ProjectXmlChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event ProjectXmlChanged As EventHandler(Of ProjectXmlChangedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;Microsoft::Build::Evaluation::ProjectXmlChangedEventArgs ^&gt; ^ ProjectXmlChanged;" />
      <MemberSignature Language="F#" Value="member this.ProjectXmlChanged : EventHandler&lt;Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs&gt; " Usage="member this.ProjectXmlChanged : System.EventHandler&lt;Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uruchamiany, gdy <see cref="T:Microsoft.Build.Construction.ProjectRootElement" /> zostanie zmieniony element zawarty w tym wystąpieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest wywoływane w przypadku zmian właściwości globalnych lub wszelkich innych zmian, które nie są w rzeczywistości zanieczyszczony XML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterForwardingLoggers">
      <MemberSignature Language="C#" Value="public void RegisterForwardingLoggers (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForwardingLoggers(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.RegisterForwardingLoggers(System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForwardingLoggers (remoteLoggers As IEnumerable(Of ForwardingLoggerRecord))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForwardingLoggers(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.RegisterForwardingLoggers : seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; unit" Usage="projectCollection.RegisterForwardingLoggers remoteLoggers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="remoteLoggers">Zdalne rejestratory do dodania. Może mieć wartość zerową.</param>
        <summary>Dodaje te rejestratory zdalne do kolekcji zdalnych rejestratorów używanych do kompilowania projektów w tej kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterLogger">
      <MemberSignature Language="C#" Value="public void RegisterLogger (Microsoft.Build.Framework.ILogger logger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterLogger(class Microsoft.Build.Framework.ILogger logger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger(Microsoft.Build.Framework.ILogger)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterLogger (logger As ILogger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterLogger(Microsoft::Build::Framework::ILogger ^ logger);" />
      <MemberSignature Language="F#" Value="member this.RegisterLogger : Microsoft.Build.Framework.ILogger -&gt; unit" Usage="projectCollection.RegisterLogger logger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logger" Type="Microsoft.Build.Framework.ILogger" />
      </Parameters>
      <Docs>
        <param name="logger">Rejestrator do dodania.</param>
        <summary>Dodaje dany Rejestrator do kolekcji rejestratorów używanych do kompilowania projektów w tej kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli obiekt rejestratora znajduje się już w kolekcji, nic nie robi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterLoggers">
      <MemberSignature Language="C#" Value="public void RegisterLoggers (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterLoggers(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.RegisterLoggers(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterLoggers (loggers As IEnumerable(Of ILogger))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterLoggers(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.RegisterLoggers : seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; unit" Usage="projectCollection.RegisterLoggers loggers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="loggers">Rejestratory do dodania. Może mieć wartość zerową.</param>
        <summary>Dodaje danego rejestratora do kolekcji rejestratorów używanych do kompilowania projektów w tej kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pomija wszystkie obiekty rejestratora, które znajdują się już w kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllToolsets">
      <MemberSignature Language="C#" Value="public void RemoveAllToolsets ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAllToolsets() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.RemoveAllToolsets" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAllToolsets ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAllToolsets();" />
      <MemberSignature Language="F#" Value="member this.RemoveAllToolsets : unit -&gt; unit" Usage="projectCollection.RemoveAllToolsets " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie zestawy narzędzi z kolekcji projektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGlobalProperty">
      <MemberSignature Language="C#" Value="public bool RemoveGlobalProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveGlobalProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveGlobalProperty (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveGlobalProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RemoveGlobalProperty : string -&gt; bool" Usage="projectCollection.RemoveGlobalProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa domyślnej właściwości globalnej do usunięcia.</param>
        <summary>Usuwa Właściwość globalną z zestawu domyślnych właściwości globalnych.</summary>
        <returns><see langword="true" />Jeśli właściwość globalna jest obecna przed usunięciem; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveToolset">
      <MemberSignature Language="C#" Value="public bool RemoveToolset (string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveToolset(string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.RemoveToolset(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveToolset (toolsVersion As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveToolset(System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="member this.RemoveToolset : string -&gt; bool" Usage="projectCollection.RemoveToolset toolsVersion" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="toolsVersion">Zestaw narzędzi, który ma zostać usunięty.</param>
        <summary>Usuwa zestaw narzędzi z kolekcji projektu.</summary>
        <returns><see langword="true" />Jeśli zestaw narzędzi jest obecny przed usunięciem; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetGlobalProperty">
      <MemberSignature Language="C#" Value="public void SetGlobalProperty (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetGlobalProperty(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetGlobalProperty (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetGlobalProperty(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetGlobalProperty : string * string -&gt; unit" Usage="projectCollection.SetGlobalProperty (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa domyślnej właściwości globalnej, która ma zostać dodana lub ustawiona.</param>
        <param name="value">Nowa wartość domyślnej właściwości globalnej.</param>
        <summary>Ustawia wartość właściwości w domyślnym zestawie właściwości globalnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie zostanie znaleziona zgodna właściwość, właściwość zostanie utworzona i zainicjowana przy użyciu danej wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipEvaluation">
      <MemberSignature Language="C#" Value="public bool SkipEvaluation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipEvaluation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipEvaluation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipEvaluation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipEvaluation : bool with get, set" Usage="Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ReevaluateIfNecessary jest tymczasowo wyłączona w projektach w tej kolekcji. Jest to przydatne w przypadku, gdy host oczekuje na wykonanie wielu operacji odczytu i zapisu w projektach, i chce czasowo wyświęcić prawidłowość wydajności.</summary>
        <value>Flaga określająca, czy ReevaluateIfNecessary jest tymczasowo wyłączona.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolsetLocations">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ToolsetDefinitionLocations ToolsetLocations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Build.Evaluation.ToolsetDefinitionLocations ToolsetLocations" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.ToolsetLocations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ToolsetLocations As ToolsetDefinitionLocations" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Evaluation::ToolsetDefinitionLocations ToolsetLocations { Microsoft::Build::Evaluation::ToolsetDefinitionLocations get(); };" />
      <MemberSignature Language="F#" Value="member this.ToolsetLocations : Microsoft.Build.Evaluation.ToolsetDefinitionLocations" Usage="Microsoft.Build.Evaluation.ProjectCollection.ToolsetLocations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ToolsetDefinitionLocations</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalizacje używane do znajdowania zestawów narzędzi.</summary>
        <value>Lokalizacje używane do znajdowania zestawów narzędzi.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Toolsets">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.Toolset&gt; Toolsets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.Toolset&gt; Toolsets" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.Toolsets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Toolsets As ICollection(Of Toolset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::Toolset ^&gt; ^ Toolsets { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::Toolset ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Toolsets : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.Toolset&gt;" Usage="Microsoft.Build.Evaluation.ProjectCollection.Toolsets" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.Build.Evaluation.IToolsetProvider.Toolsets</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.Toolset&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestawy narzędzi dostępne dla tej kolekcji projektów.</summary>
        <value>Zestawy narzędzi dostępne dla tej kolekcji projektów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnloadProject">
      <MemberSignature Language="C#" Value="public bool TryUnloadProject (Microsoft.Build.Construction.ProjectRootElement projectRootElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUnloadProject(class Microsoft.Build.Construction.ProjectRootElement projectRootElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUnloadProject(Microsoft::Build::Construction::ProjectRootElement ^ projectRootElement);" />
      <MemberSignature Language="F#" Value="member this.TryUnloadProject : Microsoft.Build.Construction.ProjectRootElement -&gt; bool" Usage="projectCollection.TryUnloadProject projectRootElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="projectRootElement" Type="Microsoft.Build.Construction.ProjectRootElement" />
      </Parameters>
      <Docs>
        <param name="projectRootElement">Element główny projektu do zwolnienia.</param>
        <summary>Próbuje usunąć projekt z kolekcji.</summary>
        <returns><see langword="true" />Jeśli projekt został zwolniony; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string escapedString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string escapedString) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (escapedString As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ escapedString);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="Microsoft.Build.Evaluation.ProjectCollection.Unescape escapedString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="escapedString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="escapedString">Ciąg do przekonwertowania.</param>
        <summary>Konwertuje znaki ucieczki w ciągu na znaki programu MSBuild o specjalnym znaczeniu.</summary>
        <returns>Przekonwertowany ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład "% 3B" jest konwertowany na ";".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadAllProjects">
      <MemberSignature Language="C#" Value="public void UnloadAllProjects ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnloadAllProjects() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.UnloadAllProjects" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnloadAllProjects ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnloadAllProjects();" />
      <MemberSignature Language="F#" Value="member this.UnloadAllProjects : unit -&gt; unit" Usage="projectCollection.UnloadAllProjects " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie projekty w tej kolekcji projektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Host powinien wywołać tę metodę, gdy nie potrzebuje już projektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnloadProject">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa element główny projektu z głównej pamięci podręcznej projektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnloadProject">
      <MemberSignature Language="C#" Value="public void UnloadProject (Microsoft.Build.Construction.ProjectRootElement projectRootElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnloadProject(class Microsoft.Build.Construction.ProjectRootElement projectRootElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Construction.ProjectRootElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnloadProject(Microsoft::Build::Construction::ProjectRootElement ^ projectRootElement);" />
      <MemberSignature Language="F#" Value="member this.UnloadProject : Microsoft.Build.Construction.ProjectRootElement -&gt; unit" Usage="projectCollection.UnloadProject projectRootElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="projectRootElement" Type="Microsoft.Build.Construction.ProjectRootElement" />
      </Parameters>
      <Docs>
        <param name="projectRootElement">Element główny projektu do zwolnienia.</param>
        <summary>Usuwa element główny projektu z głównej pamięci podręcznej projektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przydatna w przypadku, gdy host wie, że wszystkie projekty używające tego elementu głównego zostały usunięte i że wszystkie niezapisane zmiany powinny zostać odrzucone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zgłaszany, jeśli element główny projektu do zwolnienia jest nadal używany przez załadowany projekt lub jego import.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnloadProject">
      <MemberSignature Language="C#" Value="public void UnloadProject (Microsoft.Build.Evaluation.Project project);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnloadProject(class Microsoft.Build.Evaluation.Project project) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Evaluation.Project)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnloadProject(Microsoft::Build::Evaluation::Project ^ project);" />
      <MemberSignature Language="F#" Value="member this.UnloadProject : Microsoft.Build.Evaluation.Project -&gt; unit" Usage="projectCollection.UnloadProject project" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="project" Type="Microsoft.Build.Evaluation.Project" />
      </Parameters>
      <Docs>
        <param name="project">Projekt do usunięcia.</param>
        <summary>Usuwa dany projekt z kolekcji projektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Host powinien wywołać tę metodę, gdy nie potrzebuje już projektu.  
  
 Zwraca InvalidOperationException, jeśli dany projekt nie znajduje się w kolekcji projektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterAllLoggers">
      <MemberSignature Language="C#" Value="public void UnregisterAllLoggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterAllLoggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectCollection.UnregisterAllLoggers" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterAllLoggers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterAllLoggers();" />
      <MemberSignature Language="F#" Value="member this.UnregisterAllLoggers : unit -&gt; unit" Usage="projectCollection.UnregisterAllLoggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie rejestratory z kolekcji rejestratorów używanych przez kompilacje projektu w tej kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectCollection.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="Microsoft.Build.Evaluation.ProjectCollection.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję pliku zestawu zawierającego aparat MSBuild.</summary>
        <value>Wersja pliku zestawu zawierającego aparat MSBuild.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja pliku systemu Windows (w odróżnieniu od wartości zasobu ProductVersion), która nie musi być wersją zestawu. Aby uzyskać wersję zestawu, użyj stałej. AssemblyVersion.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

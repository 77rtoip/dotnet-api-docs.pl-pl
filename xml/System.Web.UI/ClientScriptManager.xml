<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="362838f0721b50d4f9941389c889e4c552a1bbc0" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53395984" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje metody do zarządzania skryptów klienta w aplikacjach sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager> Klasa jest używana do zarządzania skryptów klienta i dodać je do aplikacji sieci Web. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> klasy z <xref:System.Web.UI.Page.ClientScript%2A> właściwość <xref:System.Web.UI.Page> obiektu.  
  
 Możesz dodać skrypt klienta do strony sieci Web deklaratywnie przez skrypt w kod znaczników HTML strony. W razie dynamiczne dodawanie skrypt po stronie klienta jest istnieją jednak sytuacje. Aby dynamicznie dodać skrypt, należy użyć <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody lub <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metody, w zależności od tego, kiedy i w jaki sposób chcesz dodać skrypt. Aby uzyskać więcej informacji, zobacz [jak: Dynamiczne dodawanie skrypt po stronie klienta do stron ASP.NET Web Pages](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 <xref:System.Web.UI.ClientScriptManager> Klasy unikatowo identyfikuje skryptów przy użyciu klucza <xref:System.String> i <xref:System.Type>. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Przy użyciu typu skrypt pomaga uniknąć pomylenia podobne skryptów z formantów innego użytkownika, które mogą być używane na stronie.  
  
 <xref:System.Web.UI.ClientScriptManager> Klasy może służyć do wywołania zwrotne klienta w sytuacjach, gdy istnieje potrzeba uruchomienia kodu serwera z klienta bez przeprowadzania ogłaszania zwrotnego. Jest to określane jako wykonywania wywołanie zwrotne out-of-band do serwera. W wywołaniu zwrotnym klienta funkcji skryptu klienta wysyła żądania asynchronicznego do strony sieci Web platformy ASP.NET. Strony sieci Web uruchamia zmodyfikowanej wersji cyklu życia procesu wywołania zwrotnego. Użyj <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodę, aby uzyskać odwołanie do funkcji klienta, gdy wywoływany, inicjuje wywołanie zwrotne klienta w celu zdarzeń serwera. Aby uzyskać więcej informacji, zobacz [Implementowanie klienta wywołania zwrotne bez ogłaszania zwrotnego](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Wywołania zwrotne skryptu nie będzie działać w starszych przeglądarkach, które nie obsługują Document Object Model (DOM), i wymagają one, że ECMAScript jest włączona na komputerze klienckim. Aby sprawdzić, czy przeglądarka obsługuje wywołań zwrotnych, należy użyć <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> właściwość, która jest dostępna za pośrednictwem <xref:System.Web.HttpRequest.Browser%2A> właściwości wewnętrzne ASP.NET <xref:System.Web.HttpContext.Request%2A> obiektu.  
  
 Użyj <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metody i <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> metodę, aby zdefiniować zdarzenie do zwrotu klienta. Te metody umożliwiają funkcji skryptu klienta, gdy wywoływany, aby spowodować, że serwer, który można opublikować wróć do strony. To zdarzenie ogłaszania wstecznego klienta różni się od klienta wywołania zwrotnego, strona sieci Web kończy normalne cyklu życia procesu zdarzenie ogłaszania wstecznego klienta.  
  
> [!NOTE]
>  Jeśli używasz <xref:System.Web.UI.WebControls.Button> kontroli i <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość jest ustawiona na `false`, wówczas można użyć <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodę, aby zwrócić klienta ogłaszanie zwrotne zdarzenie <xref:System.Web.UI.WebControls.Button> kontroli.  
  
 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> Właściwość <xref:System.Web.UI.WebControls.Button> kontroli <xref:System.Web.UI.WebControls.ImageButton> kontroli i <xref:System.Web.UI.WebControls.LinkButton> sterowania można uruchomić skrypt po stronie klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Dwa skrypty klienta zostały zdefiniowane na stronie: `PopupScript`, powoduje wyświetlenie komunikat ostrzegawczy, gdy strona jest ładowany, i `ButtonClickScript`, definiujący Obsługa klienta dla przycisku HTML `onClick` zdarzeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">Skrypt po stronie klienta w programie ASP.NET Web Pages</related>
    <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta, bez ogłaszania zwrotnego na stronach ASP.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera odwołanie do funkcji klienta, gdy wywoływany, inicjuje przez klienta wywołania zwrotnego do zdarzeń serwera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> obsługująca wywołania zwrotnego klienta. Kontrolka musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejs i dostarczyć <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="argument">Argument przekazywany ze skryptu klienta do serwera 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> Metoda.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik zdarzenia pomyślnego serwera.</param>
        <param name="context">Skrypt klienta, który jest oceniany na komputerze klienckim przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przekazywany do obsługi zdarzeń klienta.</param>
        <summary>Pobiera odwołanie do funkcji klienta, gdy wywoływany, inicjuje przez klienta wywołania zwrotnego do zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody obejmuje określoną kontrolkę, argument, skrypt po stronie klienta i kontekstu.</summary>
        <returns>Nazwa funkcji klienta, który wywołuje wywołania zwrotnego klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Metoda wykonuje wywołanie zwrotne out-of-band do serwera, który jest zmodyfikowana wersja normalne cyklu życia strony. Aby uzyskać więcej informacji, zobacz [Implementowanie klienta wywołania zwrotne bez ogłaszania zwrotnego](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Gdy przeglądarka jest Microsoft Internet Explorer (wersja 5.0 lub nowszy), mechanizm wywołania zwrotnego skryptu jest implementowane za pośrednictwem obiektu Microsoft.XmlHttp COM i wymaga przeglądarki, należy ustawić, aby uruchomić formanty ActiveX. W przypadku innych przeglądarek XMLHttpRequest za pomocą przeglądarki w lokalnym modelu DOM (Document Object) jest używany. Aby sprawdzić, czy przeglądarka obsługuje wywołania zwrotne klienta, użyj <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> właściwości. Aby sprawdzić, czy przeglądarka obsługuje XML przy użyciu protokołu HTTP, użyj <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> właściwości. Obie te właściwości są dostępne za pośrednictwem <xref:System.Web.HttpRequest.Browser%2A> właściwości wewnętrzne ASP.NET <xref:System.Web.HttpContext.Request%2A> obiektu.  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Przeciążenia <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metoda wykonuje wywołanie zwrotne synchronicznie za pomocą języka XML przy użyciu protokołu HTTP. Podczas wysyłania danych synchronicznie w scenariuszu wywołania zwrotnego, synchroniczne wywołania zwrotne zwrócenia natychmiast i nie blokują przeglądarki. Wywołanie zwrotne nie dwa synchroniczne wywołania zwrotne można wykonać w tym samym czasie w przeglądarce. Jeśli drugi synchroniczne wywołanie zwrotne jest wywoływane, gdy jeden znajduje się obecnie w stanie oczekiwania, drugi synchroniczne wywołanie zwrotne anuluje pierwszy i zwróci tylko drugie wywołanie zwrotne.  
  
 Aby wysyłać dane asynchronicznie, użyj jednego z przeciążeń, które przyjmuje `useAsync` parametr, który jest wartością logiczną wartość kontroli tego zachowania. W tym scenariuszu asynchronicznej może mieć wielu wywołań zwrotnych oczekujące; kolejność ich zwrotu nie jest gwarantowana odpowiadającej kolejności, w którym zostały zainicjowane.  
  
 Ponadto to przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody określa Brak funkcji klienta, aby obsłużyć przypadek jest w stanie błędu generowane przez <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metody. Aby określić procedurę obsługi wywołania zwrotnego klienta błędów, użyj jednego z przeciążeń, które przyjmuje `clientErrorCallback` parametru.  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Metoda przyjmuje opcjonalny ciąg `argument` parametr i zwraca ciąg. Aby przekazać do odbierania wielu wartości, połączyć wartości w danych wejściowych lub zwraca ciąg, odpowiednio.  
  
> [!NOTE]
>  Należy unikać używania stan widoku w celu wykonania strona lub kontrolka właściwości, które muszą zostać zaktualizowane podczas operacji wywołania zwrotnego skryptu. W przypadku właściwości przetrwać żądań strony, można użyć stanu sesji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania dwa przeciążenia metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody w przypadku wywołania zwrotnego klienta, który zwiększa liczb całkowitych.  
  
 Dwa mechanizmy wywołania zwrotnego są wyświetlane; Różnica między nimi polega na użyciu `context` parametru. A `ReceiveServerData1` funkcji wywołania zwrotnego klienta jest realizowane przy użyciu `context` parametru. Z kolei `ReceiveServerData2` funkcji wywołania zwrotnego klienta jest zdefiniowany w `<script>` na stronie. A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metodą jest program obsługi serwera, który zwiększa wartość, która jest przekazywana do niego i <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> metoda zwraca zwiększona wartość jako ciąg. Jeśli <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metoda zwraca błąd, a następnie `ProcessCallBackError` klienta funkcja jest wywoływana.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.Control" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Web.UI.Control" /> Określonego nie implementuje <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta, bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> obsługująca wywołania zwrotnego klienta. Kontrolka musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejs i dostarczyć <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="argument">Argument przekazywany ze skryptu klienta do serwera 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> Metoda.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik zdarzenia pomyślnego serwera.</param>
        <param name="context">Skrypt klienta, który jest oceniany na komputerze klienckim przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przekazywany do obsługi zdarzeń klienta.</param>
        <param name="useAsync"><see langword="true" /> Aby wykonać wywołanie zwrotne asynchronicznie; <see langword="false" /> do wykonania wywołania zwrotnego synchronicznie.</param>
        <summary>Pobiera odwołanie do funkcji klienta, gdy wywoływany, inicjuje przez klienta wywołania zwrotnego do zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody obejmuje określoną kontrolkę, argument, skrypt po stronie klienta, kontekstu i wartość logiczną.</summary>
        <returns>Nazwa funkcji klienta, który wywołuje wywołania zwrotnego klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metoda wymaga `useAsync` parametr, który umożliwia wykonywanie wywołania zwrotnego klienta asynchronicznie, ustawiając wartość `true`. Wersje przeciążenia tej metody, które nie wymagają `useAsync` ustawiona wartość `false` domyślnie.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz uwagi dla przeciążenia <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.Control" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Web.UI.Control" /> Określonego nie implementuje <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta, bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Nazwa serwera <see cref="T:System.Web.UI.Control" /> obsługująca wywołania zwrotnego klienta. Kontrolka musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejs i dostarczyć <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="argument">Argument przekazywany ze skryptu klienta do serwera 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> Metoda.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik zdarzenia pomyślnego serwera.</param>
        <param name="context">Skrypt klienta, który jest oceniany na komputerze klienckim przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przekazywany do obsługi zdarzeń klienta.</param>
        <param name="clientErrorCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik w przypadku wystąpienia błędu programu obsługi zdarzeń serwera.</param>
        <param name="useAsync"><see langword="true" /> Aby wykonać wywołanie zwrotne asynchronicznie; <see langword="false" /> do wykonania wywołania zwrotnego synchronicznie.</param>
        <summary>Pobiera odwołanie do funkcji klienta, gdy wywoływany, inicjuje przez klienta wywołania zwrotnego do zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody zawiera określonego obiektu docelowego, argument, skrypt po stronie klienta, kontekstu, procedura obsługi błędów i wartość logiczną.</summary>
        <returns>Nazwa funkcji klienta, który wywołuje wywołania zwrotnego klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metoda przyjmuje `target` ciągu parametr zamiast <xref:System.Web.UI.Control> parametru. Użyj tego przeciążenia, wywołanie zwrotne, aby przejść z powrotem na coś innego niż ciąg zawierający <xref:System.Web.UI.Control.UniqueID%2A> formantu.  
  
 Ponadto to przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metoda wymaga `useAsync` i `clientErrorCallback` parametru. `useAsync` Parametr umożliwia wykonywanie wywołania zwrotnego klienta asynchronicznie, ustawiając wartość `true`. Wersje przeciążenia tej metody, które nie wymagają `useAsync` ustawiona wartość `false` domyślnie. `clientErrorCallback` Parametru pozwala na zdefiniowanie nazwy funkcji klienta, która jest wywoływana, gdy obsługi serwera <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metody zwraca błąd. Wersje przeciążenia tej metody, które nie wymagają `clientErrorCallback` ustawiona wartość null.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz uwagi dla przeciążenia <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania dwa przeciążenia metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody w przypadku wywołania zwrotnego klienta, który zwiększa liczb całkowitych.  
  
 Dwa mechanizmy wywołania zwrotnego są wyświetlane; Różnica między nimi polega na użyciu `context` parametru. A `ReceiveServerData1` funkcji wywołania zwrotnego klienta jest realizowane przy użyciu `context` parametru. Z kolei `ReceiveServerData2` funkcji wywołania zwrotnego klienta jest zdefiniowany w `<script>` na stronie. A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metodą jest program obsługi serwera, który zwiększa wartość, która jest przekazywana do niego i <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> metoda zwraca zwiększona wartość jako ciąg. Jeśli <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metoda zwraca błąd, a następnie funkcja klienta `ProcessCallBackError` jest wywoływana.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta, bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> obsługująca wywołania zwrotnego klienta. Kontrolka musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejs i dostarczyć <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="argument">Argument przekazywany ze skryptu klienta do serwera <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik zdarzenia pomyślnego serwera.</param>
        <param name="context">Skrypt klienta, który jest oceniany na komputerze klienckim przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przekazywany do obsługi zdarzeń klienta.</param>
        <param name="clientErrorCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik w przypadku wystąpienia błędu programu obsługi zdarzeń serwera.</param>
        <param name="useAsync"><see langword="true" /> Aby wykonać wywołanie zwrotne asynchronicznie; <see langword="false" /> do wykonania wywołania zwrotnego synchronicznie.</param>
        <summary>Pobiera odwołanie do funkcji klienta, gdy wywoływany, inicjuje przez klienta wywołania zwrotnego do zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody obejmuje określoną kontrolkę, argument, skrypt po stronie klienta, kontekstu, procedura obsługi błędów i wartość logiczną.</summary>
        <returns>Nazwa funkcji klienta, który wywołuje wywołania zwrotnego klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metoda wymaga `useAsync` i `clientErrorCallback` parametru. `useAsync` Parametr umożliwia wykonywanie wywołania zwrotnego klienta asynchronicznie, ustawiając wartość `true`. Wersje przeciążenia tej metody, które nie wymagają `useAsync` ustawiona wartość `false` domyślnie. `clientErrorCallback` Parametru pozwala na zdefiniowanie nazwy funkcji klienta, która jest wywoływana, gdy obsługi serwera ( <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metoda) zwraca błąd. Wersje przeciążenia tej metody, które nie wymagają `clientErrorCallback` ustawiona wartość null.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz uwagi dla przeciążenia <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.Control" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Web.UI.Control" /> Określonego nie implementuje <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta, bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera odwołanie, za pomocą <see langword="javascript:" /> dołączany na początku, który może służyć w zdarzeniu klienta można opublikować na serwerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant serwera przetwarzania zwrotu.</param>
        <param name="argument">Parametr przekazany do kontrolki serwera.</param>
        <summary>Pobiera odwołanie, za pomocą <see langword="javascript:" /> dołączany na początku, który może służyć w zdarzeniu klienta można opublikować na serwerze, na określoną kontrolkę i argumentów określonego zdarzenia.</summary>
        <returns>Ciąg reprezentujący wywołanie JavaScript do zwrotu funkcji, która zawiera argumenty formantu docelowego Identyfikatora i zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda wymaga formantu, który obsługuje zwrot do zaimplementowania <xref:System.Web.UI.IPostBackEventHandler> interfejsu. Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, można użyć dyrektywy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> metody. Kontrolka niestandardowa, `MyControl`, implementuje <xref:System.Web.UI.IPostBackEventHandler> interfejsu. Po kliknięciu elementu zakotwiczenia kodu HTML na stronie <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> wywoływana jest metoda formantu niestandardowego.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Poniższy przykładowy kod ma taką samą funkcjonalność, jak poprzedni, chyba że zamiast formant niestandardowy <xref:System.Web.UI.Page> klasy implementuje <xref:System.Web.UI.IPostBackEventHandler> interfejsu.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Formant serwera przetwarzania zwrotu.</param>
        <param name="argument">Parametr przekazany do kontrolki serwera.</param>
        <param name="registerForEventValidation"><see langword="true" /> Aby zarejestrować zdarzenie ogłaszania wstecznego do weryfikacji; <see langword="false" /> nie zarejestrować zdarzenie wstecz post do sprawdzania poprawności.</param>
        <summary>Pobiera odwołanie, za pomocą <see langword="javascript:" /> dołączany na początku, który może służyć w zdarzeniu klienta można opublikować na serwerze dla określonego kontrolką argumenty określonego zdarzenia i wskazanie logiczna czy rejestrować wpis ją ponownie, aby zdarzenia Sprawdzanie poprawności.</summary>
        <returns>Ciąg reprezentujący wywołanie JavaScript do zwrotu funkcji, która zawiera argumenty formantu docelowego Identyfikatora i zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda wymaga formantu, który obsługuje zwrot do zaimplementowania <xref:System.Web.UI.IPostBackEventHandler> interfejsu. Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, można użyć dyrektywy.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg, który może służyć w zdarzeniu klienta, aby spowodować ogłaszania zwrotnego na serwerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> definiujący zwrotu.</param>
        <summary>Zwraca ciąg, który może służyć w zdarzeniu klienta, aby spowodować ogłaszania zwrotnego na serwerze. Ciąg odwołania jest definiowany przez określony <see cref="T:System.Web.UI.PostBackOptions" /> wystąpienia.</summary>
        <returns>Ciąg, który, gdy traktowane jako skrypt na kliencie, ogłaszanie zwrotne klienta inicjuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, można użyć dyrektywy.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metody mogą być używane z <xref:System.Web.UI.WebControls.Button> decyduje o <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość `false`. W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda zwraca klienta ogłaszanie zwrotne zdarzenie <xref:System.Web.UI.WebControls.Button> kontroli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" /> Parametr <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta, bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> która przetwarza ogłaszania zwrotnego na serwerze.</param>
        <param name="argument">Ciąg opcjonalne argumenty do przekazania do formantu, który przetwarza zwrotu.</param>
        <summary>Zwraca ciąg, który może służyć w zdarzeniu klienta, aby spowodować ogłaszania zwrotnego na serwerze. Ciąg odwołania jest definiowany przez określony formant, który obsługuje odświeżenie strony i argument ciągu informacji dodatkowych zdarzeń.</summary>
        <returns>Ciąg, który, gdy traktowane jako skrypt na kliencie, inicjuje zwrotu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, można użyć dyrektywy.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metody mogą być używane z <xref:System.Web.UI.WebControls.Button> decyduje o <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość `false`. W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda zwraca klienta ogłaszanie zwrotne zdarzenie <xref:System.Web.UI.WebControls.Button> kontroli.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metody. Kontrolka niestandardowa, `MyControl`, implementuje <xref:System.Web.UI.IPostBackEventHandler> interfejsu. Po kliknięciu przycisku na stronie <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> wywoływana jest metoda formantu niestandardowego.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Poniższy przykładowy kod ma taką samą funkcjonalność, jak poprzedni, chyba że zamiast formant niestandardowy <xref:System.Web.UI.Page> klasy implementuje <xref:System.Web.UI.IPostBackEventHandler> interfejsu.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określony <see cref="T:System.Web.UI.Control" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta, bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> definiujący zwrotu.</param>
        <param name="registerForEventValidation"><see langword="true" /> Aby zarejestrować odwołanie zdarzenia do weryfikacji; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca ciąg, który może służyć w zdarzeniu klienta, aby spowodować ogłaszania zwrotnego na serwerze. Ciąg odwołania jest definiowany przez określony <see cref="T:System.Web.UI.PostBackOptions" /> obiektu. Opcjonalnie rejestruje odwołanie zdarzenia do sprawdzania poprawności.</summary>
        <returns>Ciąg, który, gdy traktowane jako skrypt na kliencie, ogłaszanie zwrotne klienta inicjuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page> obiektu, należy użyć dyrektywy.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metody mogą być używane z <xref:System.Web.UI.WebControls.Button> decyduje o <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość `false`. W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda zwraca klienta ogłaszanie zwrotne zdarzenie <xref:System.Web.UI.WebControls.Button> kontroli.  
  
 Jeśli `registerForEventValidation` jest `true`, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> wywołania metody <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> metody do rejestrowania zdarzeń odwołanie do sprawdzania poprawności przy użyciu Identyfikatora unikatowy kontroli, który reprezentuje kontrolkę klienta, które generuje zdarzenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" /> Jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta, bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> która przetwarza ogłaszania zwrotnego na serwerze.</param>
        <param name="argument">Parametry opcjonalne argumenty do przekazania do <paramref name="control" />.</param>
        <param name="registerForEventValidation"><see langword="true" /> Aby zarejestrować odwołanie zdarzenia do weryfikacji; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca ciąg do użycia w przypadku klienta spowodować ogłaszania zwrotnego na serwerze. Ciąg odwołania jest definiowany przez określony formant, który obsługuje odświeżenie strony i argument ciągu informacji dodatkowych zdarzeń. Opcjonalnie rejestruje odwołanie zdarzenia do sprawdzania poprawności.</summary>
        <returns>Ciąg, który, gdy traktowane jako skrypt na kliencie, inicjuje zwrotu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, można użyć dyrektywy.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metody mogą być używane z <xref:System.Web.UI.WebControls.Button> decyduje o <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość `false`. W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda zwraca klienta ogłaszanie zwrotne zdarzenie <xref:System.Web.UI.WebControls.Button> kontroli.  
  
 Jeśli `registerForEventValidation` ma wartość true, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> wywołania metody <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> metody do rejestrowania zdarzeń odwołanie do sprawdzania poprawności przy użyciu Identyfikatora unikatowy kontroli, który reprezentuje kontrolkę klienta, które generuje zdarzenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określony <see cref="T:System.Web.UI.Control" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta, bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ zasobu.</param>
        <param name="resourceName">W pełni kwalifikowana nazwa zasobu w zestawie.</param>
        <summary>Pobiera odwołanie adresu URL do zasobu w zestawie.</summary>
        <returns>Odwołanie adresu URL do zasobu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Metoda zwraca odwołanie adresu URL do zasobu osadzonego w zestawie. Zwracane odwołanie nie jest zakodowany w adresie URL. Zasoby mogą być pliki skryptów, obrazów ani żadnych plików statycznych. Należy określić typ bazując na obiekt, który będzie uzyskiwać dostęp do zasobu.  
  
 Zarejestrowane przy użyciu strony zasobów sieci Web jest unikatowo identyfikowana przez jej typ i nazwa. Można zarejestrować tylko jeden zasób z danego typu i nazwy pary ze stroną. Próby rejestracji zasobów, która jest już zarejestrowana nie tworzy zduplikowane zarejestrowanego zasobu.  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Metoda jest używana w połączeniu z <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> metody uzyskania dostępu do zasobów osadzonych w zestawach. Aby uzyskać więcej informacji na temat korzystania z zasobów w aplikacjach, zobacz [omówienie zasoby strony sieci Web programu ASP.NET](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> metody. *Typu* parametr w tym przykładzie jest ustawiony na typ klasy w zestawie, zawierające zasób. `resourceName` Parametr jest określony za pomocą w pełni kwalifikowana ścieżka do zasobu, który zawiera domyślny obszar nazw.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Poniższy przykład kodu pokazuje, jak programowe stosowanie <xref:System.Web.UI.WebResourceAttribute> atrybutu metadanych do oznaczenia zestawu dla zasobów, które będą obsługiwane. Skompilować następujące klasy w bibliotece klas z domyślnej przestrzeni nazw, ustaw `Samples.AspNet.CS.Controls` lub `Samples.AspNet.VB.Controls`, w zależności od jakiego języka używasz.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 W tym przykładzie wymaga plik JavaScript o nazwie `Script_include.js`. Plik .js jest osadzony zasób w zestawie, który zawiera `ClientScriptResourceLabel` obiektu. Jeśli używasz programu Visual Studio, w oknie dialogowym właściwości projektu biblioteki klas, ustaw **Build Action** do **zasób osadzony** po wybraniu pliku skryptu. Jeśli kompilacja biblioteki w wierszu polecenia, należy użyć przełącznika do zasobu osadzonego.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ zasobu sieci web jest <see langword="null" />.

—lub—

Nazwa zasobu sieci web jest <see langword="null" />.  
  
—lub— 
Nazwa zasobu sieci web ma długość zerową.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">Omówienie zasoby strony sieci Web programu ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/ Resource (osadzanie pliku zasobów do danych wyjściowych) (opcje kompilatora C#)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy jest zarejestrowany w bloku skryptu klienta <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz bloku skryptu klienta do wyszukiwania.</param>
        <summary>Określa, czy jest zarejestrowany w bloku skryptu klienta <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza.</summary>
        <returns><see langword="true" /> Jeśli blok skryptu klienta jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody, przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu tworzenia.  
  
 Skrypt klienta jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty.  
  
 To przeciążenie <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metoda wywołuje przeciążenia przyjmującego zarówno `key` i `type` z typem ustawiona jako <xref:System.Web.UI.Page> obiektu  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ bloku skryptu klienta do wyszukiwania.</param>
        <param name="key">Klucz bloku skryptu klienta do wyszukiwania.</param>
        <summary>Określa, czy jest zarejestrowany w bloku skryptu klienta <see cref="T:System.Web.UI.Page" /> obiektu przy użyciu klucza i typu.</summary>
        <returns><see langword="true" /> Jeśli blok skryptu klienta jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody, przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu tworzenia.  
  
 Skrypt klienta jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Należy określić typ bazując na obiekt, który będzie uzyskiwać dostęp do zasobu. Na przykład korzystając z `Page` wystąpienia dostępu do zasobu, należy określić `Page` typu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metody. Należy pamiętać, że jeśli logika do wyszukania istniejącego bloku skryptu klienta zostały usunięte, nie będzie mieć dwa skrypty zduplikowane klienta w kodzie źródłowym HTML renderowanej strony ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metoda sprawdza, czy duplikaty. Zaletą sprawdzanie jest ograniczyć niepotrzebne obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ skryptu klienta jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy skrypt po stronie klienta obejmują jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz skryptu klienta obejmują do wyszukania.</param>
        <summary>Określa, czy skrypt po stronie klienta obejmują jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza.</summary>
        <returns><see langword="true" /> Jeśli uwzględniony skrypt po stronie klienta jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody, przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu tworzenia.  
  
 Skrypt klienta obejmują jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty.  
  
 To przeciążenie <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metoda wywołuje przeciążenia przyjmującego zarówno `key` i `type` z typem ustawiona jako <xref:System.Web.UI.Page> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta obejmują do wyszukania.</param>
        <param name="key">Klucz skryptu klienta obejmują do wyszukania.</param>
        <summary>Określa, czy skrypt po stronie klienta obejmują jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu przy użyciu klucza i typu.</summary>
        <returns><see langword="true" /> Jeśli uwzględniony skrypt po stronie klienta jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody, przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> zawiera metody w celu uniknięcia, rejestrowanie skryptu, zduplikowane klienta. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu tworzenia.  
  
 Skrypt klienta obejmują jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Należy określić typ bazując na obiekt, który będzie uzyskiwać dostęp do zasobu. Na przykład podczas dostępu do zasobu, przy użyciu wystąpienia strony, należy określić `Page` typu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> metody. Należy pamiętać, że jeśli logika poszukaj obejmują istniejącego skryptu klienta zostały usunięte, nie będzie mieć dwa skrypty zduplikowane klienta w kodzie źródłowym HTML renderowanej strony ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metoda sprawdza, czy duplikaty. Zaletą sprawdzanie jest ograniczyć niepotrzebne obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 W tym przykładzie wymaga plik JavaScript o nazwie `Script_include.js`, z następującą zawartością:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Skrypt po stronie klienta jest dołączana jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy oświadczenie OnSubmit jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz instrukcji OnSubmit do wyszukania.</param>
        <summary>Określa, czy oświadczenie OnSubmit jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza.</summary>
        <returns><see langword="true" /> Jeśli instrukcja OnSubmit jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody, przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metodę, aby uniknąć zduplikowanych OnSubmit instrukcje rejestrowania. Jest to szczególnie ważne, jeśli instrukcja wymaga dużej ilości zasobów serwera w celu tworzenia.  
  
 Instrukcja jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Instrukcje z tego samego klucza i typ są traktowane jako duplikaty.  
  
 To przeciążenie <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metoda wywołuje przeciążenia przyjmującego zarówno `key` i `type` z typem ustawiona jako <xref:System.Web.UI.Page> obiektu  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ instrukcji OnSubmit do wyszukania.</param>
        <param name="key">Klucz instrukcji OnSubmit do wyszukania.</param>
        <summary>Określa, czy oświadczenie OnSubmit jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu przy użyciu określonego klucza i typu.</summary>
        <returns><see langword="true" /> Jeśli instrukcja OnSubmit jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody, przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metodę, aby uniknąć zduplikowanych instrukcje rejestrowania. Jest to szczególnie ważne, jeśli instrukcja wymaga dużej ilości zasobów serwera w celu tworzenia.  
  
 Instrukcja jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Instrukcje z tego samego klucza i typ są traktowane jako duplikaty. Należy określić typ bazując na obiekt, który będzie uzyskiwać dostęp do zasobu. Na przykład korzystając z `Page` wystąpienia dostępu do zasobu, należy określić `Page` typu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metody. Skrypt o nazwie `OnSubmitScript` jest zarejestrowane w usłudze <xref:System.Web.UI.Page> tak, aby po stronie przesłaniu formularza skrypt zostanie wywołany.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ instrukcji OnSubmit jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy skrypt uruchamiania jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz skryptu uruchamiania do wyszukania.</param>
        <summary>Określa, czy skrypt uruchamiania jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza.</summary>
        <returns><see langword="true" /> Jeśli skrypt uruchamiania jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody, przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu tworzenia.  
  
 Skrypt uruchamiania jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty.  
  
 To przeciążenie <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metoda wywołuje przeciążenia przyjmującego oba parametry `key` i `type` z typem ustawiona jako <xref:System.Web.UI.Page> obiektu  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu uruchamiania do wyszukania.</param>
        <param name="key">Klucz skryptu uruchamiania do wyszukania.</param>
        <summary>Określa, czy skrypt uruchamiania jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu przy użyciu określonego klucza i typu.</summary>
        <returns><see langword="true" /> Jeśli skrypt uruchamiania jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody, przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu tworzenia.  
  
 Skrypt uruchamiania klienta jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metody. Należy pamiętać, że jeśli logika do wyszukania istniejącego bloku skryptu uruchamiania zostały usunięte, nie będzie mieć dwa skrypty uruchamiania duplikatów w kodzie źródłowym HTML renderowanej strony ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metoda sprawdza, czy duplikaty. Zaletą sprawdzanie jest ograniczyć niepotrzebne obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ skryptu uruchamiania jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Nazwa tablicy do zarejestrowania.</param>
        <param name="arrayValue">Tablica wartości lub wartości, które można zarejestrować.</param>
        <summary>Rejestruje deklarację tablicy języka JavaScript przy użyciu <see cref="T:System.Web.UI.Page" /> obiektu przy użyciu tablicy nazwy i wartości tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> Sprawdza, czy tablica zarejestrowanych istnieje o takiej samej nazwie jak nazwa określona w `arrayName` parametru i jeśli tak, dodaje wartości określone w `arrayValue` parametru. Ponieważ podstawowego mechanizmu przechowywania jest oparta na <xref:System.Collections.ArrayList>, duplikaty są dozwolone. Jeśli zarejestrowane macierzy o takiej samej nazwie jak `arrayName` parametr nie istnieje, jest on tworzony i wartościami w `arrayValue` dodano do niego parametr.  
  
 Literał ciągu w tablica wynikowa JavaScript, zawierają znaki pojedynczego cudzysłowu (') lub poprzedzone znakiem zmiany znaczenia podwójnego cudzysłowu (\\") w `arrayValue` parametru. Wartość `arrayValue` parametr powinien mieć pojedynczy element. Jeśli więcej niż jedną wartość musi zostać dodane do tablicy, należy wprowadzić wiele wywołań przy użyciu <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> i <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metody. W przykładzie rejestruje tablicy i wartości ukryte i definiuje `OnClick` zdarzenia `<input>` przycisk, aby obliczyć sumę dwóch wartości tablicy i wartości ukryte.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje skryptu klienta za pomocą <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta do rejestracji.</param>
        <param name="key">Klucz skryptu klienta do rejestracji.</param>
        <param name="script">Literał do zarejestrowania skrypt klienta.</param>
        <summary>Rejestruje skryptu klienta za pomocą <see cref="T:System.Web.UI.Page" /> obiektu, używając typu, klucza i skrypt literału.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt klienta jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie można zarejestrować tylko jeden skrypt za pomocą danego typu i pary kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy zduplikowane skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metodę, aby określić, czy skrypt klienta przy użyciu podanej pary klucza i typu jest już zarejestrowany i uniknąć niepotrzebnego podjęto próbę dodania skryptu.  
  
 W tym przeciążenia <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody, należy się upewnić, że skrypt w `script` parametru jest opakowana w `<script>` bloku elementu.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Metoda dodaje blok skryptu do góry renderowanej strony. Bloki skryptu nie musi być danych wyjściowych w kolejności, w której są one zarejestrowane. Jeśli kolejność Bloki skryptu jest ważne, użyj <xref:System.Text.StringBuilder> do grupowania skrypty w ciągu jednego obiektu, a następnie zarejestrować je w bloku skryptu jednego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta do rejestracji.</param>
        <param name="key">Klucz skryptu klienta do rejestracji.</param>
        <param name="script">Literał do zarejestrowania skrypt klienta.</param>
        <param name="addScriptTags">Wartość logiczna wskazująca, czy należy dodać tagów skryptu.</param>
        <summary>Rejestruje skryptu klienta za pomocą <see cref="T:System.Web.UI.Page" /> przy użyciu typu, kluczy skryptu literału i logicznych wartość wskazującą, czy można dodać tagów skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt klienta jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie można zarejestrować tylko jeden skrypt za pomocą danego typu i pary kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy zduplikowane skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metodę pozwala ustalić, czy skrypt klienta przy użyciu podanej pary klucza i typu jest już zarejestrowany. Dzięki temu można uniknąć niepotrzebnego podjęto próbę dodania skryptu.  
  
 W tym przeciążenia <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody, można wskazać, czy skrypt jest dostarczany w `script` parametru jest ujęte w nawiasy `<script>` bloku elementu za pomocą `addScriptTags` parametru. Ustawienie `addScriptTags` do `true` wskazuje, że tagi skryptu zostanie dodana automatycznie.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Metoda dodaje blok skryptu do góry renderowanej strony. Bloki skryptu nie musi być danych wyjściowych w kolejności, w której są one zarejestrowane. Jeśli kolejność Bloki skryptu jest ważne, użyj <xref:System.Text.StringBuilder> do grupowania skrypty w ciągu jednego obiektu, a następnie zarejestrować je w bloku skryptu jednego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody. Należy pamiętać, że `addScriptTags` parametr ma wartość `true` tak początkowe i skrypt taga zamykającego nie są dołączone `script` parametru.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ bloku skryptu klienta jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Skrypt po stronie klienta obejmują z rejestrów <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Obejmują klucz skryptu klienta do rejestracji.</param>
        <param name="url">Adres URL skryptu klienta obejmują do zarejestrowania.</param>
        <summary>Rejestruje skryptu klienta za pomocą <see cref="T:System.Web.UI.Page" /> przy użyciu klucza i adres URL, co umożliwia skryptu, który ma być wywoływana z klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt klienta obejmują jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie można zarejestrować tylko jeden skrypt za pomocą danego typu i pary kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy zduplikowane skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> metodę, aby określić, czy skrypt klienta obejmują z danym kluczem i pary typ jest już zarejestrowany i uniknąć niepotrzebnego podjęto próbę dodania skryptu.  
  
> [!NOTE]
>  Aby rozwiązać adres URL klienta, użyj <xref:System.Web.UI.Control.ResolveClientUrl%2A> metody. Ta metoda używa kontekstu adresu URL, na którym jest wywoływana, aby rozpoznać ścieżki.  
  
 To przeciążenie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metoda wywołuje przeciążenia przyjmującego `key`, `URL`, a `type` parametru.  
  
 Metoda dodaje blok skryptu, u góry renderowanej strony.  
  
   
  
## Examples  
 Aby uzyskać powiązane informacje o składni, użycia i przykłady, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta obejmują do zarejestrowania.</param>
        <param name="key">Obejmują klucz skryptu klienta do rejestracji.</param>
        <param name="url">Adres URL skryptu klienta obejmują do zarejestrowania.</param>
        <summary>Skrypt po stronie klienta obejmują z rejestrów <see cref="T:System.Web.UI.Page" /> przy użyciu typu, klucza i adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metoda przyjmuje *klucz* i *adresu url* parametry, aby zidentyfikować skryptu, a także `type` obejmują parametru, aby określić identyfikator skryptu klienta. Należy określić typ bazując na obiekt, który będzie uzyskiwać dostęp do zasobu. Na przykład korzystając z `Page` wystąpienia dostępu do zasobu, należy określić `Page` typu.  
  
> [!NOTE]
>  Aby rozwiązać adres URL klienta, użyj <xref:System.Web.UI.Control.ResolveClientUrl%2A> metody. Ta metoda używa kontekstu adresu URL, na którym jest wywoływana, aby rozpoznać ścieżki.  
  
 Metoda ta umożliwia dodanie bloku skryptu w górnej części renderowanej strony.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody. Należy pamiętać, że jeśli logika poszukaj obejmują istniejącego skryptu klienta zostały usunięte, nadal nie będzie mieć skrypty klienta zduplikowane na renderowanej stronie ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metoda sprawdza, czy duplikaty. Zaletą sprawdzanie jest ograniczyć niepotrzebne obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Ten przykład wymaga plik JavaScript o nazwie Script_include.js z następującą zawartością:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Skrypt po stronie klienta jest dołączana jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Adres URL jest <see langword="null" />.  
  
—lub— 
Adres URL jest pusty.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ zasobu skryptu klienta do rejestracji.</param>
        <param name="resourceName">Nazwa zasobu skryptu klienta do rejestracji.</param>
        <summary>Rejestruje zasób skryptu klienta za pomocą <see cref="T:System.Web.UI.Page" /> przy użyciu typ i nazwę zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Metoda jest używana podczas uzyskiwania dostępu do zasobów skompilowanego z zestawów przy użyciu programu obsługi WebResource.axd HTTP. <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Metoda rejestruje skrypt za pomocą <xref:System.Web.UI.Page> obiektu i uniemożliwia zduplikowane skryptów. Ta metoda opakowuje zawartość adresu URL zasobu `<script>` bloku elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Poniższy przykład kodu pokazuje, jak programowe stosowanie <xref:System.Web.UI.WebResourceAttribute> atrybutu metadanych do oznaczenia zestawu dla zasobów, które będą obsługiwane.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 W tym przykładzie wymaga plik JavaScript o nazwie `Script_include.js`, z następującą zawartością:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Skompilować `Script_include.js` plików jako zasób w `Samples.AspNet.CS.Controls` zestawu, który zawiera `ClientScriptResourceLabel` klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ zasobu klienta jest <see langword="null" />.

—lub—

Nazwa zasobu klienta jest <see langword="null" />.  
  
—lub— 
Nazwa zasobu klienta ma długość zerową.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) z określoną kontrolkę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId"><see cref="T:System.Web.UI.Control" /> Na stronie, która zawiera atrybut niestandardowy.</param>
        <param name="attributeName">Nazwa niestandardowego atrybutu w celu zarejestrowania.</param>
        <param name="attributeValue">Wartość atrybutu niestandardowego.</param>
        <summary>Rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) z określoną kontrolkę podany identyfikator kontrolki, nazwę i wartość atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Metoda rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) na określonym <xref:System.Web.UI.Control>. Ten atrybut expando ustawiono dynamicznie poziomu języka JavaScript w celu zachowania zgodności XHTML dla kodu znaczników kontrolki renderowany. Cudzysłowów i ukośników odwrotnych w wartości atrybutów niestandardowych (expando) będą miały zmienione znaczenie. Jeśli użytkownik nie chce jako znak ucieczki dla cudzysłowów i ukośników odwrotnych, wywołaj <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> przeciążyć metodę i ustawić `encode` parametr `false`.  
  
 Jeśli nie odnaleziono atrybutu expando lub kontrolki, Dodaj atrybut expando, aby nie zostanie znaleziony, skrypt po stronie klienta jest nadal emitowane, ale nie wpłynie to na formant.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId"><see cref="T:System.Web.UI.Control" /> Na stronie, która zawiera atrybut niestandardowy.</param>
        <param name="attributeName">Nazwa niestandardowego atrybutu w celu zarejestrowania.</param>
        <param name="attributeValue">Wartość atrybutu niestandardowego.</param>
        <param name="encode">Wartość logiczną wskazującą, czy kodowanie niestandardowego atrybutu w celu zarejestrowania.</param>
        <summary>Rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) z określoną kontrolkę podany identyfikator kontrolki, nazwę atrybutu, wartość atrybutu i wartość logiczną wskazującą, czy należy zakodować wartości atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Metoda rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) na określonym <xref:System.Web.UI.Control>. Ten atrybut expando ustawiono dynamicznie poziomu języka JavaScript w celu zachowania zgodności XHTML dla kodu znaczników kontrolki renderowany. Ustaw `encode` parametr `true` Jeśli potrzebujesz jako znak ucieczki dla cudzysłowów i ukośników odwrotnych w wartości atrybutu z expando.  
  
 Jeśli nie odnaleziono atrybutu expando lub kontrolki, Dodaj atrybut expando, aby nie zostanie znaleziony, skrypt po stronie klienta jest nadal emitowane, ale nie wpłynie to na formant.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Skrypt klienta w zestawach renderowanej strony `title` atrybutu `<span>` elementu.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje odwołanie zdarzenia do sprawdzania poprawności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontroli klienta generowania zdarzenia.</param>
        <summary>Rejestruje identyfikator unikatowy formantu reprezentujący kontroli klienta generowania zdarzenia odwołanie zdarzenia do sprawdzania poprawności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji i przykładów, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody i <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> metody, aby zarejestrować wywołanie zwrotne do sprawdzania poprawności i jak weryfikować, że wywołanie zwrotne pochodzi ze strony.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> obiekt określający, jak klienta JavaScript jest generowany w celu zainicjowania zwrotu zdarzeń.</param>
        <summary>Rejestruje odwołanie zdarzenia do weryfikacji za pomocą <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji i przykładów, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontroli klienta generowania zdarzenia.</param>
        <param name="argument">Argumenty zdarzenia wykryto zdarzenie klienta.</param>
        <summary>Rejestruje odwołanie zdarzenia do weryfikacji za pomocą kontrolki Unikatowy identyfikator zdarzenia argumentów i reprezentujący kontroli klienta generowania zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody i <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> metody, aby zarejestrować wywołanie zwrotne weryfikacji i aby zweryfikować, że wywołanie zwrotne pochodzi ze strony. W celu weryfikacji, jak pokazano w przykładzie, można zmodyfikować weryfikacji `argument` parametru, aby zawierać informacje specyficzne dla użytkownika, takich jak tożsamość lub roli  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metodę, aby zarejestrować wywołanie zwrotne w celu weryfikacji.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda jest wywoływana przed <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" /> metody.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">Wywołania zwrotnego klienta w przykładzie realizacji sprawdzania poprawności</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Nazwa pola ukrytego do zarejestrowania.</param>
        <param name="hiddenFieldInitialValue">Początkowa wartość pola do zarejestrowania.</param>
        <summary>Rejestruje ukryte wartością <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Metoda tworzy ukryty `<input>` element na renderowanej stronie HTML.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> i <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metody. W przykładzie rejestruje tablicy i wartości ukryte i definiuje `OnClick` zdarzenia `<input>` przycisk, aby obliczyć sumę dwóch wartości tablicy i wartości ukryte.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hiddenFieldName" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ instrukcji OnSubmit do zarejestrowania.</param>
        <param name="key">Klucz instrukcji OnSubmit do zarejestrowania.</param>
        <param name="script">Literał skryptu instrukcji OnSubmit do zarejestrowania.</param>
        <summary>Rejestruje OnSubmit instrukcją <see cref="T:System.Web.UI.Page" /> przy użyciu typu, klucza i skrypt literału. Podczas wykonywania instrukcji <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> zostanie przesłany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Instrukcja OnSubmit jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Instrukcje z tego samego klucza i typ są traktowane jako duplikaty. Na stronie można zarejestrować tylko jednej instrukcji z danego typu i pary kluczy. Podjęto próbę zarejestrowania instrukcję, która jest już zarejestrowana nie można utworzyć duplikat instrukcji.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metodę, aby określić, czy instrukcji OnSubmit jest już zarejestrowany z daną parą klucza i typu i uniknąć niepotrzebnego podjęto próbę dodania skryptu.  
  
 `script` Parametru <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metoda może zawierać kilka poleceń skryptu, tak długo, jak są one prawidłowo rozdzielanych średnikami (;).  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Dodaje skryptu, który jest wykonywany przed strona zostanie przesłany i daje możliwość anulowania przesyłania.  
  
 Aby uzyskać więcej informacji na temat formularzy HTML i `OnSubmit` atrybutów, zobacz [witryny sieci Web konsorcjum World Wide Web Consortium (W3C)](https://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje skryptu uruchamiania przy użyciu <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu uruchamiania do zarejestrowania.</param>
        <param name="key">Klucz skryptu uruchamiania do zarejestrowania.</param>
        <param name="script">Literał do zarejestrowania skrypt uruchamiania.</param>
        <summary>Rejestruje skryptu uruchamiania przy użyciu <see cref="T:System.Web.UI.Page" /> przy użyciu typu, klucza i skrypt literału.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt klienta jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie można zarejestrować tylko jeden skrypt za pomocą danego typu i pary kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy zduplikowane skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metodę, aby określić, czy skryptu uruchamiania przy użyciu podanej pary klucza i typu jest już zarejestrowane i uniknąć niepotrzebnego podjęto próbę dodania skryptu.  
  
 W tym przeciążenia <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody, należy się upewnić, że skrypt w `script` parametru jest ujęte w nawiasy `<script>` bloku elementu.  
  
 Blok skryptu dodawany przez <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metoda jest wykonywana po zakończenie ładowania strony ale przed stroną <xref:System.Web.UI.Control.OnLoad%2A> zdarzenie jest wywoływane. Bloki skryptu nie musi być danych wyjściowych w kolejności, w której są one zarejestrowane. Jeśli kolejność Bloki skryptu jest ważne, użyj <xref:System.Text.StringBuilder> do grupowania skrypty w ciągu jednego obiektu, a następnie zarejestrować je w bloku skryptu jednego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody. Należy zauważyć, że początkowe i skrypt taga zamykającego znajdują się w obrębie `script` parametru. Aby skrypt, tagi dodane na podstawie ustawienia dodatkowych parametrów, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu uruchamiania do zarejestrowania.</param>
        <param name="key">Klucz skryptu uruchamiania do zarejestrowania.</param>
        <param name="script">Literał do zarejestrowania skrypt uruchamiania.</param>
        <param name="addScriptTags">Wartość logiczna wskazująca, czy należy dodać tagów skryptu.</param>
        <summary>Rejestruje skryptu uruchamiania przy użyciu <see cref="T:System.Web.UI.Page" /> przy użyciu typu, klucz, skrypt literału i wartość logiczną wskazującą, czy należy dodać tagów skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt uruchamiania jest unikatowo identyfikowane za pomocą jego klucza i jego typu. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie można zarejestrować tylko jeden skrypt za pomocą danego typu i pary kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy zduplikowane skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metodę, aby określić, czy skryptu uruchamiania przy użyciu podanej pary klucza i typu jest już zarejestrowane i uniknąć niepotrzebnego podjęto próbę dodania skryptu.  
  
 W tym przeciążenia <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody, można wskazać, czy skrypt jest dostarczany w `script` parametru jest ujęte w nawiasy `<script>` bloku elementu za pomocą `addScriptTags` parametru. Ustawienie `addScriptTags` do `true` wskazuje, że tagi skryptu zostanie dodana automatycznie.  
  
 Blok skryptu dodawany przez <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metoda jest wykonywana po zakończenie ładowania strony ale przed stroną <xref:System.Web.UI.Control.OnLoad%2A> zdarzenie jest wywoływane. Bloki skryptu nie musi być danych wyjściowych w kolejności, w której są one zarejestrowane. Jeśli kolejność Bloki skryptu jest ważne, użyj <xref:System.Text.StringBuilder> do grupowania skrypty w ciągu jednego obiektu, a następnie zarejestrować je w bloku skryptu jednego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody. Należy pamiętać, że `addScriptTags` parametr ma wartość `false` tak początku i zamykanie tagów skryptu są dołączone `script` parametru.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza poprawność zdarzenie klienta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontroli klienta generowania zdarzenia.</param>
        <summary>Sprawdza poprawność zdarzenie klienta, który został zarejestrowany używania weryfikacji zdarzeń <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" /> metody.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontroli klienta generowania zdarzenia.</param>
        <param name="argument">Argumenty zdarzenia wykryto zdarzenie klienta.</param>
        <summary>Sprawdza poprawność zdarzenie klienta, który został zarejestrowany używania weryfikacji zdarzeń <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody i <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> metody, aby zarejestrować wywołanie zwrotne weryfikacji i aby zweryfikować, że wywołanie zwrotne pochodzi ze strony. W celu weryfikacji, pokazano poniżej, można zmodyfikować weryfikacji `argument` parametru, aby zawierać informacje specyficzne dla użytkownika, takich jak tożsamość lub roli  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uniqueId" /> jest <see langword="null" /> ani być pustym ciągiem ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
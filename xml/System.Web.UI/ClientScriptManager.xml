<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6168b3c68c5da16b52610f467bf142b8c7177fe9" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69398993" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje metody zarządzania skryptami klienta w aplikacjach sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager> Klasa służy do zarządzania skryptami klienta i dodawania ich do aplikacji sieci Web. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> klasy <xref:System.Web.UI.Page.ClientScript%2A> z właściwości <xref:System.Web.UI.Page> obiektu.  
  
 Skrypt klienta można dodać do strony sieci Web deklaratywnie poprzez dołączenie skryptu do znacznika HTML strony. Są jednak sytuacje, w których konieczna jest dynamiczna Dodawanie skryptu klienta. Aby dynamicznie dodać skrypt, <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Użyj metody <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> , metody, metody lub <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metody, w zależności od tego, kiedy i jak chcesz dodać skrypt. Aby uzyskać więcej informacji, zobacz [jak: Dynamicznie Dodaj skrypt klienta do ASP.NET stron](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666)sieci Web.  
  
 Klasa jednoznacznie identyfikuje skrypty za pomocą klucza <xref:System.String> i <xref:System.Type>. <xref:System.Web.UI.ClientScriptManager> Skrypty z tym samym kluczem i typem są uważane za duplikaty. Użycie typu skryptu pozwala uniknąć pomyłki podobnych skryptów z różnych kontrolek użytkownika, które mogą być używane na stronie.  
  
 <xref:System.Web.UI.ClientScriptManager> Klasa może służyć do wywoływania wywołań zwrotnych klienta w sytuacjach, gdy jest to pożądane do uruchomienia kodu serwera z klienta bez konieczności ogłaszania zwrotnego. Jest to określane jako przeprowadzenie wywołania zwrotnego poza pasmem do serwera. W wywołaniu zwrotnym klienta funkcja skryptu klienta wysyła żądanie asynchroniczne do strony sieci Web ASP.NET. Na stronie sieci Web jest uruchomiona zmodyfikowana wersja normalnego cyklu życia w celu przetworzenia wywołania zwrotnego. <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Użyj metody, aby uzyskać odwołanie do funkcji klienta, która po wywołaniu inicjuje wywołanie zwrotne klienta do zdarzenia serwera. Aby uzyskać więcej informacji, zobacz [implementowanie wywołań zwrotnych klienta bez ogłaszania zwrotnego](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Wywołania zwrotne skryptu nie będą działały w starszych przeglądarkach, które nie obsługują Document Object Model (DOM) i wymagają włączenia języka ECMAScript na kliencie. Aby sprawdzić, czy przeglądarka obsługuje wywołania zwrotne, użyj <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> właściwości, która jest dostępna <xref:System.Web.HttpRequest.Browser%2A> za pomocą właściwości obiektu wewnętrznego <xref:System.Web.HttpContext.Request%2A> ASP.NET.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Użyj metody<xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> i metody, aby zdefiniować zdarzenie ogłaszania zwrotnego klienta. Te metody umożliwiają włączenie funkcji skryptu klienta, gdy są wywoływane, aby serwer mógł ogłaszać z powrotem na stronie. Zdarzenie ogłaszania zwrotnego klienta różni się od wywołania zwrotnego klienta w przypadku, gdy strona sieci Web zakończy normalny cykl życia, aby przetworzyć zdarzenie ogłaszania zwrotnego klienta.  
  
> [!NOTE]
>  Jeśli <xref:System.Web.UI.WebControls.Button> używasz kontrolki, `false` <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> a właściwość jest ustawiona na, możesz użyć <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metody do zwrócenia zdarzenia ogłaszania zwrotnego klienta dla <xref:System.Web.UI.WebControls.Button> kontrolki.  
  
 Właściwość kontrolki ,<xref:System.Web.UI.WebControls.ImageButton> kontrolki i <xref:System.Web.UI.WebControls.LinkButton> kontrolka może służyć do uruchamiania skryptu klienta. <xref:System.Web.UI.WebControls.Button> <xref:System.Web.UI.WebControls.Button.OnClientClick%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Na stronie są zdefiniowane dwa skrypty klienta: `PopupScript`, która wyświetla komunikat o alercie podczas ładowania strony, i `ButtonClickScript`definiuje procedurę obsługi klienta `onClick` dla zdarzenia przycisku html.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">Skrypt klienta na stronach sieci Web ASP.NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta bez ogłaszania zwrotnego na stronach ASP.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje odwołanie do funkcji klienta, która po wywołaniu inicjuje wywołanie klienta z powrotem do zdarzenia serwera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> , który obsługuje wywołanie zwrotne klienta. Formant musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejs i <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> dostarczyć metodę.</param>
        <param name="argument">Argument przesłany ze skryptu klienta do serwera 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />Method.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta, która otrzymuje wynik pomyślnego zdarzenia serwera.</param>
        <param name="context">Skrypt klienta, który jest oceniany na kliencie przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przenoszona z powrotem do programu obsługi zdarzeń klienta.</param>
        <summary>Uzyskuje odwołanie do funkcji klienta, która po wywołaniu inicjuje wywołanie klienta z powrotem do zdarzenia serwera. Funkcja klienta dla tej przeciążonej metody obejmuje określony formant, argument, skrypt klienta i kontekst.</summary>
        <returns>Nazwa funkcji klienta, która wywołuje wywołanie zwrotne klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Metoda wykonuje wywołanie zwrotne poza pasmem do serwera, który jest zmodyfikowaną wersją normalnego cyklu życia strony. Aby uzyskać więcej informacji, zobacz [implementowanie wywołań zwrotnych klienta bez ogłaszania zwrotnego](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Gdy przeglądarka to program Microsoft Internet Explorer (wersja 5,0 lub nowsza), mechanizm wywołania zwrotnego skryptu jest implementowany za pośrednictwem obiektu COM Microsoft. XMLHTTP i wymaga ustawienia przeglądarki do uruchamiania formantów ActiveX. W przypadku innych przeglądarek używany jest element XMLHttpRequest używający lokalnego Document Object Model przeglądarki (DOM). Aby sprawdzić, czy przeglądarka obsługuje wywołania zwrotne klienta, należy <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> użyć właściwości. Aby sprawdzić, czy przeglądarka obsługuje XML za pośrednictwem protokołu HTTP <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> , użyj właściwości. Obie właściwości są dostępne przez <xref:System.Web.HttpRequest.Browser%2A> Właściwość wewnętrznego obiektu ASP.NET. <xref:System.Web.HttpContext.Request%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Przeciążenie<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody wykonuje wywołanie zwrotne synchronicznie za pomocą XML przez http. Podczas synchronicznego wysyłania danych w scenariuszu wywołania zwrotnego synchroniczne wywołania zwrotne zwracają natychmiast i nie blokują przeglądarki. W przeglądarce nie można jednocześnie wykonać operacji wywołania zwrotnego synchronicznego wywołania zwrotnego. W przypadku uruchomienia drugiego synchronicznego wywołania zwrotnego, gdy jeden aktualnie oczekuje, drugie synchroniczne wywołanie zwrotne anuluje pierwsze i tylko drugie wywołanie zwrotne zwróci wartość.  
  
 Aby wysłać dane asynchronicznie, użyj jednego z przeciążeń przyjmujących `useAsync` parametr, który jest wartością logiczną kontrolującą to zachowanie. W scenariuszu asynchronicznym można mieć wiele oczekujących wywołań zwrotnych; Jednak kolejność, w jakiej są zwracane, nie jest gwarantowana w kolejności, w jakiej zostały zainicjowane.  
  
 Ponadto to Przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody nie określa żadnej funkcji klienta do obsługi przypadku warunku błędu wygenerowanego <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> przez metodę. Aby określić obsługę wywołania zwrotnego błędu klienta, należy użyć jednego z przeciążeń `clientErrorCallback` , które pobiera parametr.  
  
 Metoda przyjmuje opcjonalny parametr ciągu `argument` i zwraca ciąg. <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Aby przekazać lub odebrać wiele wartości, Połącz odpowiednio wartości w polu wejściowym lub zwracanym ciągu.  
  
> [!NOTE]
>  Należy unikać używania stanu widoku we wdrożeniu właściwości strony lub kontrolki, które muszą zostać zaktualizowane podczas operacji wywołania zwrotnego skryptu. Jeśli właściwości są zażyje żądania stron, można użyć stanu sesji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać dwóch przeciążeń <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody w scenariuszu wywołania zwrotnego klienta, który zwiększa liczbę liczb całkowitych.  
  
 Przedstawiono dwa mechanizmy wywołania zwrotnego; różnica między nimi polega na użyciu `context` parametru. Funkcja wywołania zwrotnego `context` `ReceiveServerData1` klienta jest podawana przy użyciu parametru. Z kolei `ReceiveServerData2` funkcja wywołania zwrotnego klienta jest definiowana `<script>` w bloku na stronie. Metoda to program obsługi serwera, który zwiększa wartość, która jest przenoszona do niego <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> , a metoda zwraca wartość zwiększającą się jako ciąg. <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Jeśli metoda zwróci błąd, `ProcessCallBackError` funkcja klienta jest wywoływana. <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona wartość to <see langword="null" />. <see cref="T:System.Web.UI.Control" /></exception>
        <exception cref="T:System.InvalidOperationException">Określony program nie <see cref="T:System.Web.UI.ICallbackEventHandler" /> implementuje interfejsu. <see cref="T:System.Web.UI.Control" /></exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> , który obsługuje wywołanie zwrotne klienta. Formant musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejs i <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> dostarczyć metodę.</param>
        <param name="argument">Argument przesłany ze skryptu klienta do serwera 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />Method.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta, która otrzymuje wynik pomyślnego zdarzenia serwera.</param>
        <param name="context">Skrypt klienta, który jest oceniany na kliencie przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przenoszona z powrotem do programu obsługi zdarzeń klienta.</param>
        <param name="useAsync"><see langword="true" />Aby wykonać wywołanie zwrotne asynchronicznie; <see langword="false" /> aby synchronicznie wykonać wywołanie zwrotne.</param>
        <summary>Uzyskuje odwołanie do funkcji klienta, która po wywołaniu inicjuje wywołanie klienta z powrotem do zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody obejmuje określony formant, argument, skrypt klienta, kontekst i wartość logiczną.</summary>
        <returns>Nazwa funkcji klienta, która wywołuje wywołanie zwrotne klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody `useAsync` wymaga parametru, który umożliwia asynchroniczne wykonywanie wywołania zwrotnego klienta przez ustawienie wartości na `true`. Wersje przeciążenia tej metody, które nie wymagają, `useAsync` aby `false` parametr domyślnie ustawił wartość.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz uwagi dotyczące metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona wartość to <see langword="null" />. <see cref="T:System.Web.UI.Control" /></exception>
        <exception cref="T:System.InvalidOperationException">Określony program nie <see cref="T:System.Web.UI.ICallbackEventHandler" /> implementuje interfejsu. <see cref="T:System.Web.UI.Control" /></exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Nazwa serwera <see cref="T:System.Web.UI.Control" /> , który obsługuje wywołanie zwrotne klienta. Formant musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejs i <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> dostarczyć metodę.</param>
        <param name="argument">Argument przesłany ze skryptu klienta do serwera 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />Method.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta, która otrzymuje wynik pomyślnego zdarzenia serwera.</param>
        <param name="context">Skrypt klienta, który jest oceniany na kliencie przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przenoszona z powrotem do programu obsługi zdarzeń klienta.</param>
        <param name="clientErrorCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik w przypadku wystąpienia błędu w programie obsługi zdarzeń serwera.</param>
        <param name="useAsync"><see langword="true" />Aby wykonać wywołanie zwrotne asynchronicznie; <see langword="false" /> aby synchronicznie wykonać wywołanie zwrotne.</param>
        <summary>Uzyskuje odwołanie do funkcji klienta, która po wywołaniu inicjuje wywołanie klienta z powrotem do zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody obejmuje określony element docelowy, argument, skrypt klienta, kontekst, procedurę obsługi błędów i wartość logiczną.</summary>
        <returns>Nazwa funkcji klienta, która wywołuje wywołanie zwrotne klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody `target` przyjmuje parametr <xref:System.Web.UI.Control> String zamiast parametru. Użyj tego przeciążenia, gdy chcesz, aby wywołanie zwrotne powracać do czegoś innego niż ciąg <xref:System.Web.UI.Control.UniqueID%2A> zawierający kontrolkę.  
  
 Ponadto to Przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody `useAsync` wymaga `clientErrorCallback` parametru i. Parametr umożliwia asynchroniczne wykonywanie wywołania zwrotnego klienta przez ustawienie wartości na `true`. `useAsync` Wersje przeciążenia tej metody, które nie wymagają, `useAsync` aby `false` parametr domyślnie ustawił wartość. Parametr umożliwia zdefiniowanie nazwy funkcji klienta, która jest wywoływana <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> , jeśli program obsługi serwera, metoda zwraca błąd. `clientErrorCallback` Wersje przeciążenia tej metody, które nie wymagają `clientErrorCallback` parametru ustaw wartość null.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz uwagi dotyczące metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> przeciążenia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać dwóch przeciążeń <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody w scenariuszu wywołania zwrotnego klienta, który zwiększa liczbę liczb całkowitych.  
  
 Przedstawiono dwa mechanizmy wywołania zwrotnego; różnica między nimi polega na użyciu `context` parametru. Funkcja wywołania zwrotnego `context` `ReceiveServerData1` klienta jest podawana przy użyciu parametru. Z kolei `ReceiveServerData2` funkcja wywołania zwrotnego klienta jest definiowana `<script>` w bloku na stronie. Metoda to program obsługi serwera, który zwiększa wartość, która jest przenoszona do niego <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> , a metoda zwraca wartość zwiększającą się jako ciąg. <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Jeśli metoda zwróci błąd, funkcja `ProcessCallBackError` klienta jest wywoływana. <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> , który obsługuje wywołanie zwrotne klienta. Formant musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejs i <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> dostarczyć metodę.</param>
        <param name="argument">Do metody serwera <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> przeszedł argument ze skryptu klienta.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta, która otrzymuje wynik pomyślnego zdarzenia serwera.</param>
        <param name="context">Skrypt klienta, który jest oceniany na kliencie przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przenoszona z powrotem do programu obsługi zdarzeń klienta.</param>
        <param name="clientErrorCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik w przypadku wystąpienia błędu w programie obsługi zdarzeń serwera.</param>
        <param name="useAsync"><see langword="true" />Aby wykonać wywołanie zwrotne asynchronicznie; <see langword="false" /> aby synchronicznie wykonać wywołanie zwrotne.</param>
        <summary>Uzyskuje odwołanie do funkcji klienta, która po wywołaniu inicjuje wywołanie klienta z powrotem do zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody obejmuje określony formant, argument, skrypt klienta, kontekst, procedurę obsługi błędów i wartość logiczną.</summary>
        <returns>Nazwa funkcji klienta, która wywołuje wywołanie zwrotne klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody `useAsync` wymaga `clientErrorCallback` parametru i. Parametr umożliwia asynchroniczne wykonywanie wywołania zwrotnego klienta przez ustawienie wartości na `true`. `useAsync` Wersje przeciążenia tej metody, które nie wymagają, `useAsync` aby `false` parametr domyślnie ustawił wartość. Parametr umożliwia zdefiniowanie nazwy funkcji klienta, która jest wywoływana, jeśli procedura obsługi serwera <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> (Metoda) zwraca błąd. `clientErrorCallback` Wersje przeciążenia tej metody, które nie wymagają `clientErrorCallback` parametru ustaw wartość null.  
  
 Aby uzyskać więcej informacji na temat tej metody, zobacz uwagi dotyczące metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona wartość to <see langword="null" />. <see cref="T:System.Web.UI.Control" /></exception>
        <exception cref="T:System.InvalidOperationException">Określony program nie <see cref="T:System.Web.UI.ICallbackEventHandler" /> implementuje interfejsu. <see cref="T:System.Web.UI.Control" /></exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera odwołanie z <see langword="javascript:" /> dołączonym do początku, które może być użyte w zdarzeniu klienta do ogłaszania zwrotnego na serwerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka serwerowa do przetworzenia ogłaszania zwrotnego.</param>
        <param name="argument">Parametr przeszedł do kontrolki serwerowej.</param>
        <summary>Pobiera odwołanie z <see langword="javascript:" /> dołączonym do początku, które może być używane w zdarzeniu klienta do ogłaszania zwrotnego na serwerze dla określonej kontrolki i z określonymi argumentami zdarzeń.</summary>
        <returns>Ciąg reprezentujący wywołanie języka JavaScript do funkcji ogłaszania zwrotnego, która zawiera identyfikator formantu docelowego i argumenty zdarzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie metody wymaga kontrolki, która obsługuje ogłaszanie zwrotne w <xref:System.Web.UI.IPostBackEventHandler> celu zaimplementowania interfejsu. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs dla programu <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> metody. Kontrolka `MyControl`niestandardowa, <xref:System.Web.UI.IPostBackEventHandler> implementuje interfejs. Po kliknięciu <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> elementu zakotwiczenia HTML na stronie wywoływana jest metoda kontrolki niestandardowej.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Poniższy przykład kodu ma takie same funkcje jak poprzedni, z tą różnicą, że zamiast kontrolki <xref:System.Web.UI.Page> niestandardowej Klasa <xref:System.Web.UI.IPostBackEventHandler> implementuje interfejs.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka serwerowa do przetworzenia ogłaszania zwrotnego.</param>
        <param name="argument">Parametr przeszedł do kontrolki serwerowej.</param>
        <param name="registerForEventValidation"><see langword="true" />Aby zarejestrować zdarzenie ogłaszania zwrotnego w celu weryfikacji; <see langword="false" /> nie można zarejestrować zdarzenia post na potrzeby walidacji.</param>
        <summary>Pobiera odwołanie, z <see langword="javascript:" /> dołączonym do początku, które może być używane w zdarzeniu klienta do ogłaszania zwrotnego na serwerze dla określonej kontrolki z określonymi argumentami zdarzeń i wskazywanie wartości logicznej, czy należy zarejestrować ogłoszenie z powrotem dla zdarzenia zatwierdzenia.</summary>
        <returns>Ciąg reprezentujący wywołanie języka JavaScript do funkcji ogłaszania zwrotnego, która zawiera identyfikator formantu docelowego i argumenty zdarzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie metody wymaga kontrolki, która obsługuje ogłaszanie zwrotne w <xref:System.Web.UI.IPostBackEventHandler> celu zaimplementowania interfejsu. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs dla programu <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg, który może zostać użyty w zdarzeniu klienta w celu wypróbowania ogłaszania zwrotnego na serwerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> który definiuje ogłaszanie zwrotne.</param>
        <summary>Zwraca ciąg, który może zostać użyty w zdarzeniu klienta w celu wypróbowania ogłaszania zwrotnego na serwerze. Ciąg odwołania jest definiowany przez określone <see cref="T:System.Web.UI.PostBackOptions" /> wystąpienie.</summary>
        <returns>Ciąg, który jest traktowany jak skrypt na kliencie, inicjuje ogłaszanie zwrotne klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs dla programu <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
 Metoda może być używana z kontrolką <xref:System.Web.UI.WebControls.Button> , gdy <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość jest `false`. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metoda zwraca zdarzenie ogłaszania zwrotnego klienta <xref:System.Web.UI.WebControls.Button> dla kontrolki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" /> Parametr jest<see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> , który przetwarza ogłaszanie zwrotne na serwerze.</param>
        <param name="argument">Ciąg opcjonalnych argumentów do przekazania do kontrolki, która przetwarza ogłaszanie zwrotne.</param>
        <summary>Zwraca ciąg, który może zostać użyty w zdarzeniu klienta w celu wypróbowania ogłaszania zwrotnego na serwerze. Ciąg odwołania jest definiowany przez określony formant, który obsługuje ogłaszanie zwrotne i argument ciągu dodatkowych informacji o zdarzeniu.</summary>
        <returns>Ciąg, który jest traktowany jak skrypt na kliencie, inicjuje ogłaszanie zwrotne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs dla programu <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
 Metoda może być używana z kontrolką <xref:System.Web.UI.WebControls.Button> , gdy <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość jest `false`. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metoda zwraca zdarzenie ogłaszania zwrotnego klienta <xref:System.Web.UI.WebControls.Button> dla kontrolki.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metody. Kontrolka `MyControl`niestandardowa, <xref:System.Web.UI.IPostBackEventHandler> implementuje interfejs. Po kliknięciu <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> przycisku na stronie wywoływana jest metoda kontrolki niestandardowej.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Poniższy przykład kodu ma takie same funkcje jak poprzedni, z tą różnicą, że zamiast kontrolki <xref:System.Web.UI.Page> niestandardowej Klasa <xref:System.Web.UI.IPostBackEventHandler> implementuje interfejs.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <see cref="T:System.Web.UI.Control" /> wartość to <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> który definiuje ogłaszanie zwrotne.</param>
        <param name="registerForEventValidation"><see langword="true" />Aby zarejestrować odwołanie do zdarzenia w celu weryfikacji; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zwraca ciąg, który może zostać użyty w zdarzeniu klienta w celu wypróbowania ogłaszania zwrotnego na serwerze. Ciąg odwołania jest definiowany przez określony <see cref="T:System.Web.UI.PostBackOptions" /> obiekt. Opcjonalnie rejestruje odwołanie do zdarzenia na potrzeby walidacji.</summary>
        <returns>Ciąg, który jest traktowany jak skrypt na kliencie, inicjuje ogłaszanie zwrotne klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> Interfejs <xref:System.Web.UI.Page> dla obiektu, należy użyć dyrektywy.  
  
 Metoda może być używana z kontrolką <xref:System.Web.UI.WebControls.Button> , gdy <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość jest `false`. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metoda zwraca zdarzenie ogłaszania zwrotnego klienta <xref:System.Web.UI.WebControls.Button> dla kontrolki.  
  
 Jeśli `registerForEventValidation` jest `true` ,<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29>Metoda wywołuje metodęwceluzarejestrowaniaodwołaniazdarzenianapotrzebywalidacjizunikatowymidentyfikatoremformantu,któryreprezentujekontrolkęklientagenerującązdarzenie.<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" /> Ma<see langword="null" />wartość.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> , który przetwarza ogłaszanie zwrotne na serwerze.</param>
        <param name="argument">Ciąg opcjonalnych argumentów do przekazania <paramref name="control" />.</param>
        <param name="registerForEventValidation"><see langword="true" />Aby zarejestrować odwołanie do zdarzenia w celu weryfikacji; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zwraca ciąg, który ma być używany w zdarzeniu klienta, aby spowodować ogłaszanie zwrotne na serwerze. Ciąg odwołania jest definiowany przez określony formant, który obsługuje ogłaszanie zwrotne i argument ciągu dodatkowych informacji o zdarzeniu. Opcjonalnie rejestruje odwołanie do zdarzenia na potrzeby walidacji.</summary>
        <returns>Ciąg, który jest traktowany jak skrypt na kliencie, inicjuje ogłaszanie zwrotne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs dla programu <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
 Metoda może być używana z kontrolką <xref:System.Web.UI.WebControls.Button> , gdy <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość jest `false`. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metoda zwraca zdarzenie ogłaszania zwrotnego klienta <xref:System.Web.UI.WebControls.Button> dla kontrolki.  
  
 Jeśli `registerForEventValidation` ma wartość true <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> , metoda wywołuje <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> metodę w celu zarejestrowania odwołania zdarzenia na potrzeby walidacji z unikatowym identyfikatorem formantu, który reprezentuje kontrolkę klienta generującą zdarzenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <see cref="T:System.Web.UI.Control" /> wartość to <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Wywołania zwrotne klienta bez ogłaszania zwrotnego na stronach ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ zasobu.</param>
        <param name="resourceName">W pełni kwalifikowana nazwa zasobu w zestawie.</param>
        <summary>Pobiera odwołanie do adresu URL do zasobu w zestawie.</summary>
        <returns>Odwołanie do zasobu w adresie URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Metoda zwraca odwołanie do adresu URL do zasobu osadzonego w zestawie. Zwrócone odwołanie nie jest zakodowane w adresie URL. Zasoby mogą być plikami skryptów, obrazami lub dowolnym plikiem statycznym. Należy określić typ na podstawie obiektu, który będzie uzyskiwać dostęp do zasobu.  
  
 Zasób internetowy zarejestrowany na stronie jest jednoznacznie identyfikowany przez jego typ i nazwę. Na stronie można zarejestrować tylko jeden zasób z danym typem i parą nazw. Próba zarejestrowania zasobu, który jest już zarejestrowany, nie powoduje utworzenia duplikatu zarejestrowanego zasobu.  
  
 Metoda jest używana w połączeniu <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> z metodą uzyskiwania dostępu do zasobów osadzonych w zestawach. <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Aby uzyskać więcej informacji na temat używania zasobów w aplikacjach, zobacz [Omówienie zasobów strony sieci Web ASP.NET](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> metody. Parametr *typu* w tym przykładzie jest ustawiony na typ klasy w zestawie zawierającym zasób. `resourceName` Parametr jest określony z w pełni kwalifikowaną ścieżką do zasobu, który obejmuje domyślną przestrzeń nazw.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Poniższy przykład kodu demonstruje, <xref:System.Web.UI.WebResourceAttribute> jak programowo zastosować atrybut metadanych, aby oznaczyć zestaw dla zasobów, które będą obsługiwane. Skompiluj następujące klasy w bibliotece klas z domyślną przestrzenią nazw ustawioną na `Samples.AspNet.CS.Controls` lub `Samples.AspNet.VB.Controls`, w zależności od używanego języka.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Ten przykład wymaga pliku JavaScript o nazwie `Script_include.js`. Plik. js jest osadzonym zasobem w zestawie, który zawiera `ClientScriptResourceLabel` obiekt. Jeśli używasz programu Visual Studio, w okno Właściwości projektu biblioteki klas ustaw opcję **Akcja kompilacji** na **zasób osadzony** po wybraniu pliku skryptu. Jeśli kompilujesz bibliotekę w wierszu polecenia, użyj przełącznika [/Resource](~/docs/csharp/language-reference/compiler-options/resource-compiler-option.md) , aby osadzić zasób.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ zasobu sieci Web to <see langword="null" />.

—lub—

Nazwa zasobu sieci Web to <see langword="null" />.  
  
—lub— 
Nazwa zasobu sieci Web ma długość równą zero.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">ASP.NET zasobów strony sieci Web — Omówienie</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/Resource (Osadź plik zasobów do wyjścia) (C# opcje kompilatora)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy blok skryptu klienta jest zarejestrowany w <see cref="T:System.Web.UI.Page" /> obiekcie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz bloku skryptu klienta do wyszukania.</param>
        <summary>Określa, czy blok skryptu klienta jest zarejestrowany w <see cref="T:System.Web.UI.Page" /> obiekcie przy użyciu określonego klucza.</summary>
        <returns><see langword="true" />Jeśli blok skryptu klienta jest zarejestrowany; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody, aby uniknąć rejestrowania duplikatów skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera do utworzenia.  
  
 Skrypt klienta jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty.  
  
 To Przeciążenie <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metody wywołuje Przeciążenie, które przyjmuje `key` zarówno `type` parametr, jak i parametru z typem ustawionym jako <xref:System.Web.UI.Page> obiekt  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ bloku skryptu klienta, który ma zostać wyszukany.</param>
        <param name="key">Klucz bloku skryptu klienta do wyszukania.</param>
        <summary>Określa, czy blok skryptu klienta jest zarejestrowany w <see cref="T:System.Web.UI.Page" /> obiekcie przy użyciu klucza i typu.</summary>
        <returns><see langword="true" />Jeśli blok skryptu klienta jest zarejestrowany; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody, aby uniknąć rejestrowania duplikatów skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera do utworzenia.  
  
 Skrypt klienta jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty. Należy określić typ na podstawie obiektu, który będzie uzyskiwać dostęp do zasobu. Na przykład w przypadku używania `Page` wystąpienia w celu uzyskania dostępu do zasobu należy `Page` określić typ.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metody. Należy pamiętać, że jeśli logika do sprawdzenia istniejącego bloku skryptu klienta została usunięta, nie będą dwa zduplikowane skrypty klienta w kodzie źródłowym HTML renderowanej strony, ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Metoda sprawdza duplikaty. Zaletą sprawdzania jest zmniejszenie niepotrzebnych obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ skryptu klienta to <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy skrypt klienta ma być zarejestrowany w <see cref="T:System.Web.UI.Page" /> obiekcie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz skryptu klienta obejmuje wyszukiwanie.</param>
        <summary>Określa, czy skrypt klienta ma być zarejestrowany w <see cref="T:System.Web.UI.Page" /> obiekcie przy użyciu określonego klucza.</summary>
        <returns><see langword="true" />Jeśli zarejestrowano skrypt klienta; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody, aby uniknąć rejestrowania duplikatów skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera do utworzenia.  
  
 Skrypt klienta zawiera unikatową identyfikację za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty.  
  
 To Przeciążenie <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metody wywołuje Przeciążenie, które przyjmuje `key` zarówno `type` parametr, jak i parametru z typem ustawionym jako <xref:System.Web.UI.Page> obiekt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta, który ma zostać wyszukany.</param>
        <param name="key">Klucz skryptu klienta obejmuje wyszukiwanie.</param>
        <summary>Określa, czy skrypt klienta ma być zarejestrowany w <see cref="T:System.Web.UI.Page" /> obiekcie przy użyciu klucza i typu.</summary>
        <returns><see langword="true" />Jeśli zarejestrowano skrypt klienta; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody, aby uniknąć rejestrowania duplikatu skryptu klienta. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera do utworzenia.  
  
 Skrypt klienta zawiera unikatową identyfikację za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty. Należy określić typ na podstawie obiektu, który będzie uzyskiwać dostęp do zasobu. Na przykład podczas korzystania z wystąpienia strony w celu uzyskania dostępu do zasobu należy określić `Page` typ.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> metody. Należy pamiętać, że jeśli logika do sprawdzenia istniejącego skryptu klienta nie zostanie usunięta, w kodzie źródłowym HTML renderowanej strony nie będzie dwa zduplikowane skrypty klienta, ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> Metoda sprawdza duplikaty. Zaletą sprawdzania jest zmniejszenie niepotrzebnych obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Ten przykład wymaga pliku JavaScript o nazwie `Script_include.js`, z następującą zawartością:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ dołączania skryptu klienta <see langword="null" />to.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy instrukcja onsubmit jest zarejestrowana w <see cref="T:System.Web.UI.Page" /> obiekcie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz instrukcji onsubmit do wyszukania.</param>
        <summary>Określa, czy instrukcja onsubmit jest zarejestrowana w <see cref="T:System.Web.UI.Page" /> obiekcie przy użyciu określonego klucza.</summary>
        <returns><see langword="true" />Jeśli zarejestrowano instrukcję onsubmit; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metody, aby uniknąć rejestrowania zduplikowanych instrukcji onsubmit. Jest to szczególnie ważne, jeśli instrukcja wymaga dużej ilości zasobów serwera do utworzenia.  
  
 Instrukcja jest jednoznacznie identyfikowana przy użyciu jej klucza i jego typu. Instrukcje z tym samym kluczem i typem są uważane za duplikaty.  
  
 To Przeciążenie <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metody wywołuje Przeciążenie, które przyjmuje `key` zarówno `type` parametr, jak i parametru z typem ustawionym jako <xref:System.Web.UI.Page> obiekt  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ instrukcji onsubmit do wyszukania.</param>
        <param name="key">Klucz instrukcji onsubmit do wyszukania.</param>
        <summary>Określa, czy instrukcja onsubmit jest zarejestrowana w <see cref="T:System.Web.UI.Page" /> obiekcie przy użyciu określonego klucza i typu.</summary>
        <returns><see langword="true" />Jeśli zarejestrowano instrukcję onsubmit; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metody, aby uniknąć rejestrowania zduplikowanych instrukcji. Jest to szczególnie ważne, jeśli instrukcja wymaga dużej ilości zasobów serwera do utworzenia.  
  
 Instrukcja jest jednoznacznie identyfikowana przy użyciu jej klucza i jego typu. Instrukcje z tym samym kluczem i typem są uważane za duplikaty. Należy określić typ na podstawie obiektu, który będzie uzyskiwać dostęp do zasobu. Na przykład w przypadku używania `Page` wystąpienia w celu uzyskania dostępu do zasobu należy `Page` określić typ.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metody. Skrypt o nazwie `OnSubmitScript` jest zarejestrowany <xref:System.Web.UI.Page> w tak, aby podczas przesyłania formularza strony był wywoływany skrypt.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ instrukcji onsubmit to <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy skrypt uruchamiania jest zarejestrowany w <see cref="T:System.Web.UI.Page" /> obiekcie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz skryptu uruchamiania, który ma zostać wyszukany.</param>
        <summary>Określa, czy skrypt uruchamiania jest zarejestrowany z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu określonego klucza.</summary>
        <returns><see langword="true" />Jeśli skrypt uruchamiania jest zarejestrowany; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody, aby uniknąć rejestrowania duplikatów skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera do utworzenia.  
  
 Skrypt uruchamiania jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty.  
  
 To Przeciążenie <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metody wywołuje Przeciążenie, które pobiera zarówno ciąg `key` , jak i `type` parametr z typem ustawionym jako <xref:System.Web.UI.Page> obiekt  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu uruchomieniowego, który ma zostać wyszukany.</param>
        <param name="key">Klucz skryptu uruchamiania, który ma zostać wyszukany.</param>
        <summary>Określa, czy skrypt uruchamiania jest zarejestrowany z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu określonego klucza i typu.</summary>
        <returns><see langword="true" />Jeśli skrypt uruchamiania jest zarejestrowany; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody, aby uniknąć rejestrowania duplikatów skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera do utworzenia.  
  
 Skrypt uruchamiania klienta jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metody. Należy pamiętać, że jeśli logika do sprawdzenia istniejących bloków skryptu uruchomienia została usunięta, w kodzie źródłowym HTML renderowanej strony nie ma dwóch zduplikowanych skryptów uruchamiania, ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Metoda sprawdza duplikaty. Zaletą sprawdzania jest zmniejszenie niepotrzebnych obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ skryptu uruchamiania to <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Nazwa tablicy do zarejestrowania.</param>
        <param name="arrayValue">Wartość lub wartości tablicy do zarejestrowania.</param>
        <summary>Rejestruje deklarację tablicy JavaScript z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu nazwy tablicy i wartości tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprawdza <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> , czy zarejestrowana tablica istnieje o takiej samej nazwie jak nazwa określona `arrayName` w parametrze i, jeśli tak, dodaje wartości określone w `arrayValue` parametrze. Ponieważ podstawowy mechanizm magazynowania jest oparty na <xref:System.Collections.ArrayList>, duplikaty są dozwolone. Jeśli zarejestrowana tablica o tej samej nazwie, co `arrayName` parametr nie istnieje, zostanie utworzona i zostaną dodane do niej wartości. `arrayValue`  
  
 Jeśli chcesz, aby literały ciągu w wyników tablicy JavaScript zawierały znaki pojedynczego cudzysłowu (') lub znaki podwójnego cudzysłowu\\(") `arrayValue` w tym parametrze. Wartość `arrayValue` parametru powinna być pojedynczym elementem. Jeśli do tablicy należy dodać więcej niż jedną wartość, wykonaj wiele wywołań przy użyciu <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metod i. <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Przykład rejestruje tablicę i ukrytą wartość i definiuje `OnClick` zdarzenie `<input>` przycisku, aby obliczyć sumę dwóch wartości tablicy i wartość ukrytą.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" />jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje skrypt klienta przy użyciu <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta do zarejestrowania.</param>
        <param name="key">Klucz skryptu klienta do zarejestrowania.</param>
        <param name="script">Literał skryptu klienta do zarejestrowania.</param>
        <summary>Rejestruje skrypt klienta z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu typu, klucza i literału skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt klienta jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty. Na stronie można zarejestrować tylko jeden skrypt z danym typem i parą kluczy. Próba zarejestrowania skryptu, który jest już zarejestrowany, nie powoduje utworzenia duplikatu skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metodę, aby określić, czy skrypt klienta z danym kluczem i parą typów jest już zarejestrowany i Unikaj niepotrzebnych prób dodania skryptu.  
  
 W tym przeciążeniu <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody należy upewnić się, że skrypt podany `script` w `<script>` parametrze jest opakowany w blok elementu.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Metoda dodaje blok skryptu na początku renderowanej strony. Bloki skryptu nie są gwarantowane w kolejności, w jakiej zostały zarejestrowane. Jeśli kolejność bloków skryptu jest ważna, użyj <xref:System.Text.StringBuilder> obiektu, aby zebrać skrypty razem w jednym ciągu, a następnie zarejestrować je wszystkie w jednym bloku skryptu klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta do zarejestrowania.</param>
        <param name="key">Klucz skryptu klienta do zarejestrowania.</param>
        <param name="script">Literał skryptu klienta do zarejestrowania.</param>
        <param name="addScriptTags">Wartość logiczna wskazująca, czy dodać tagi skryptu.</param>
        <summary>Rejestruje skrypt klienta z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu typu, klucza, literału skryptu i wartości logicznej wskazującej, czy dodać tagi skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt klienta jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty. Na stronie można zarejestrować tylko jeden skrypt z danym typem i parą kluczy. Próba zarejestrowania skryptu, który jest już zarejestrowany, nie powoduje utworzenia duplikatu skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metodę, aby określić, czy skrypt klienta z danym kluczem i parą typów jest już zarejestrowany. Pozwala to uniknąć niepotrzebnych prób dodania skryptu.  
  
 W tym przeciążeniu <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody można wskazać, czy skrypt podany `script` w `<script>` parametrze jest opakowany blokiem elementu przy użyciu `addScriptTags` parametru. Ustawienie `addScriptTags`wskazuje,że Tagiskryptówzostanądodaneautomatycznie.`true`  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Metoda dodaje blok skryptu na początku renderowanej strony. Bloki skryptu nie są gwarantowane w kolejności, w jakiej zostały zarejestrowane. Jeśli kolejność bloków skryptu jest ważna, użyj <xref:System.Text.StringBuilder> obiektu, aby zebrać skrypty razem w jednym ciągu, a następnie zarejestrować je wszystkie w jednym bloku skryptu klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody. Należy pamiętać, `addScriptTags` że parametr jest ustawiony `true` na tak, że początkowe i zamykające Tagi skryptu nie `script` są dołączone do parametru.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ bloku skryptu klienta to <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje skrypt klienta Dołącz <see cref="T:System.Web.UI.Page" /> do obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz skryptu klienta ma być zarejestrowany.</param>
        <param name="url">Adres URL skryptu klienta ma być zarejestrowany.</param>
        <summary>Rejestruje skrypt klienta z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu klucza i adresu URL, co umożliwia wywoływanie skryptu z klienta programu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt klienta zawiera unikatową identyfikację za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty. Na stronie można zarejestrować tylko jeden skrypt z danym typem i parą kluczy. Próba zarejestrowania skryptu, który jest już zarejestrowany, nie powoduje utworzenia duplikatu skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> metodę, aby określić, czy skrypt klienta zawiera dany klucz, a para typów jest już zarejestrowana i Unikaj niepotrzebnych prób dodania skryptu.  
  
> [!NOTE]
>  Aby rozwiązać adres URL klienta, użyj <xref:System.Web.UI.Control.ResolveClientUrl%2A> metody. Ta metoda używa kontekstu adresu URL, na którym jest wywoływana, aby rozwiązać ścieżkę.  
  
 To Przeciążenie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody wywołuje Przeciążenie, które `key`przyjmuje `type` parametr, `URL`a i.  
  
 Metoda dodaje blok skryptu w górnej części renderowanej strony.  
  
   
  
## Examples  
 Aby uzyskać informacje pokrewne, w tym składnię, użycie i przykład, <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>Zobacz.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta zawiera do zarejestrowania.</param>
        <param name="key">Klucz skryptu klienta ma być zarejestrowany.</param>
        <param name="url">Adres URL skryptu klienta ma być zarejestrowany.</param>
        <summary>Rejestruje skrypt klienta Dołącz <see cref="T:System.Web.UI.Page" /> do obiektu przy użyciu typu, klucza i adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody przyjmuje parametry *Key* i *URL* w celu zidentyfikowania `type` skryptu, a także parametr określający identyfikację skryptu klienta. Należy określić typ na podstawie obiektu, który będzie uzyskiwać dostęp do zasobu. Na przykład w przypadku używania `Page` wystąpienia w celu uzyskania dostępu do zasobu należy `Page` określić typ.  
  
> [!NOTE]
>  Aby rozwiązać adres URL klienta, użyj <xref:System.Web.UI.Control.ResolveClientUrl%2A> metody. Ta metoda używa kontekstu adresu URL, na którym jest wywoływana, aby rozwiązać ścieżkę.  
  
 Ta metoda dodaje blok skryptu w górnej części renderowanej strony.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody. Należy pamiętać, że jeśli logika do sprawdzenia istniejącego skryptu klienta nie została usunięta, na renderowanej stronie nie będzie można duplikować skryptów klienta, ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> Metoda sprawdza duplikaty. Zaletą sprawdzania jest zmniejszenie niepotrzebnych obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Ten przykład wymaga pliku JavaScript o nazwie Script_include. js z następującą zawartością:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ dołączania skryptu klienta <see langword="null" />to.</exception>
        <exception cref="T:System.ArgumentException">Adres URL to <see langword="null" />.  
  
—lub— 
Adres URL jest pusty.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ zasobu skryptu klienta do zarejestrowania.</param>
        <param name="resourceName">Nazwa zasobu skryptu klienta do zarejestrowania.</param>
        <summary>Rejestruje zasób skryptu klienta z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu typu i nazwy zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Metoda jest używana podczas uzyskiwania dostępu do skompilowanych zasobów z zestawów za pośrednictwem programu obsługi protokołu HTTP WebResource. axd. Metoda rejestruje skrypt <xref:System.Web.UI.Page> przy użyciu obiektu i zapobiega duplikowaniu skryptów. <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Ta metoda otacza zawartość adresu URL zasobu z `<script>` blokiem elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Poniższy przykład kodu demonstruje, <xref:System.Web.UI.WebResourceAttribute> jak programowo zastosować atrybut metadanych, aby oznaczyć zestaw dla zasobów, które będą obsługiwane.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Ten przykład wymaga pliku JavaScript o nazwie `Script_include.js`, z następującą zawartością:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Skompiluj plik jako zasób `Samples.AspNet.CS.Controls` w zestawie, który zawiera `ClientScriptResourceLabel` klasę. `Script_include.js`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ zasobu klienta to <see langword="null" />.

—lub—

Nazwa zasobu klienta to <see langword="null" />.  
  
—lub— 
Nazwa zasobu klienta ma długość równą zero.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje parę nazwa/wartość jako atrybut niestandardowy (Expand) określonej kontrolki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId"><see cref="T:System.Web.UI.Control" /> Na stronie zawierającej atrybut niestandardowy.</param>
        <param name="attributeName">Nazwa atrybutu niestandardowego do zarejestrowania.</param>
        <param name="attributeValue">Wartość atrybutu niestandardowego.</param>
        <summary>Rejestruje parę nazwa/wartość jako atrybut niestandardowy (Expand) dla określonej kontrolki, który ma identyfikator formantu, nazwę atrybutu i wartość atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda rejestruje parę nazwa/wartość jako atrybut niestandardowy (Expand) w określonym <xref:System.Web.UI.Control>. <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Atrybut expand jest ustawiany dynamicznie z JavaScript, aby zachować zgodność XHTML dla renderowanego znacznika kontrolki. Cudzysłowy i ukośniki odwrotne w wartościach atrybutu niestandardowego (Expand) są wyprowadzane. Jeśli nie chcesz wycofać cudzysłowów ani ukośników odwrotnych, wywołaj <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> metodę przeciążenia i `encode` ustaw parametr na `false`.  
  
 Jeśli nie można odnaleźć atrybutu expanda lub nie można odnaleźć formantu, który ma dodać atrybut expand do, skrypt klienta jest nadal emitowany, ale nie ma wpływu na kontrolkę.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId"><see cref="T:System.Web.UI.Control" /> Na stronie zawierającej atrybut niestandardowy.</param>
        <param name="attributeName">Nazwa atrybutu niestandardowego do zarejestrowania.</param>
        <param name="attributeValue">Wartość atrybutu niestandardowego.</param>
        <param name="encode">Wartość logiczna wskazująca, czy zakodować atrybut niestandardowy do zarejestrowania.</param>
        <summary>Rejestruje parę nazwa/wartość jako atrybut niestandardowy (Expand) dla określonej kontrolki, podając identyfikator kontrolki, nazwę atrybutu, wartość atrybutu i wartość logiczną wskazującą, czy należy zakodować wartość atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda rejestruje parę nazwa/wartość jako atrybut niestandardowy (Expand) w określonym <xref:System.Web.UI.Control>. <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Atrybut expand jest ustawiany dynamicznie z JavaScript, aby zachować zgodność XHTML dla renderowanego znacznika kontrolki. Ustaw parametr na `true` , jeśli chcesz wypróbować cudzysłowy i ukośniki odwrotne w wartości atrybutu expando. `encode`  
  
 Jeśli nie można odnaleźć atrybutu expanda lub nie można odnaleźć formantu, który ma dodać atrybut expand do, skrypt klienta jest nadal emitowany, ale nie ma wpływu na kontrolkę.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> jak używać metody <xref:System.Web.UI.ClientScriptManager> klasy. Skrypt klienta na renderowanej stronie ustawia `title` atrybut `<span>` elementu.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje odwołanie do zdarzenia na potrzeby walidacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontrolę klienta generującą zdarzenie.</param>
        <summary>Rejestruje odwołanie do zdarzenia na potrzeby walidacji z unikatowym IDENTYFIKATORem formantu reprezentującym kontrolę klienta generującą zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji i przykładów, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metodę.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> i metody w celu rejestrowania wywołania zwrotnego na potrzeby walidacji oraz sprawdzania, czy wywołanie zwrotne pochodzi ze strony.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options"><see cref="T:System.Web.UI.PostBackOptions" /> Obiekt, który określa sposób generowania skryptu JavaScript przez klienta w celu zainicjowania zdarzenia ogłaszania zwrotnego.</param>
        <summary>Rejestruje odwołanie do zdarzenia na potrzeby walidacji za pomocą <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji i przykładów, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metodę.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontrolę klienta generującą zdarzenie.</param>
        <param name="argument">Argumenty zdarzenia przekazane ze zdarzeniem klienta.</param>
        <summary>Rejestruje odwołanie do zdarzenia na potrzeby walidacji z unikatowym IDENTYFIKATORem kontrolki i argumentami zdarzeń reprezentującymi kontrolkę klienta generującą zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> i metody w celu zarejestrowania wywołania zwrotnego w celu sprawdzenia poprawności i sprawdzenia, czy wywołanie zwrotne pochodzi ze strony. Aby ulepszyć weryfikację pokazaną w tym przykładzie, można zmodyfikować parametr `argument` weryfikacji w taki sposób, aby zawierał informacje specyficzne dla użytkownika, takie jak tożsamość lub rola  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody do zarejestrowania wywołania zwrotnego na potrzeby walidacji.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda jest wywoływana przed <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" /> metodą.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">Wywołanie zwrotne klienta z przykładem implementacji walidacji</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Nazwa ukrytego pola do zarejestrowania.</param>
        <param name="hiddenFieldInitialValue">Początkowa wartość pola do zarejestrowania.</param>
        <summary>Rejestruje ukrytą wartość przy użyciu <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda tworzy element ukryty `<input>` na renderowanej stronie HTML. <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metod i. <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Przykład rejestruje tablicę i ukrytą wartość i definiuje `OnClick` zdarzenie `<input>` przycisku, aby obliczyć sumę dwóch wartości tablicy i wartość ukrytą.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hiddenFieldName" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ instrukcji onsubmit do zarejestrowania.</param>
        <param name="key">Klucz instrukcji onsubmit do zarejestrowania.</param>
        <param name="script">Literał skryptu instrukcji onsubmit do zarejestrowania.</param>
        <summary>Rejestruje instrukcję onsubmit z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu typu, klucza i literału skryptu. Instrukcja <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> jest wykonywana, gdy zostanie przesłane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Instrukcja onsubmit jest jednoznacznie identyfikowana za pomocą jej klucza i jego typu. Instrukcje z tym samym kluczem i typem są uważane za duplikaty. Na stronie można zarejestrować tylko jedną instrukcję z danym typem i parą kluczy. Próba zarejestrowania instrukcji, która jest już zarejestrowana, nie spowoduje utworzenia duplikatu instrukcji.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metodę, aby określić, czy instrukcja onsubmit jest już zarejestrowana dla danego klucza i pary typów i Unikaj niepotrzebnych prób dodania skryptu.  
  
 `script` Parametr<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metody może zawierać wiele poleceń skryptu, o ile są prawidłowo rozdzielane średnikami (;).  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Dodaje skrypt, który jest wykonywany przed przesłaniem strony i umożliwia anulowanie przesyłania.  
  
 Aby uzyskać więcej informacji na temat formularzy HTML `OnSubmit` i atrybutów, zobacz [witrynę sieci Web organizacja World Wide Web Consortium (W3C)](https://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje skrypt uruchamiania przy użyciu <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu uruchomieniowego do zarejestrowania.</param>
        <param name="key">Klucz skryptu uruchomieniowego do zarejestrowania.</param>
        <param name="script">Literał skryptu uruchamiania do zarejestrowania.</param>
        <summary>Rejestruje skrypt uruchamiania z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu typu, klucza i literału skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt klienta jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty. Na stronie można zarejestrować tylko jeden skrypt z danym typem i parą kluczy. Próba zarejestrowania skryptu, który jest już zarejestrowany, nie powoduje utworzenia duplikatu skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metodę, aby określić, czy skrypt uruchamiania z danym kluczem i parą typów jest już zarejestrowany i Unikaj niepotrzebnych prób dodania skryptu.  
  
 W tym przeciążeniu <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody należy upewnić się, że skrypt podany `script` w `<script>` parametrze jest opakowany blokiem elementu.  
  
 Blok skryptu dodany przez <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodę jest wykonywany po zakończeniu ładowania strony, ale przed podniesieniem <xref:System.Web.UI.Control.OnLoad%2A> zdarzenia strony. Bloki skryptu nie są gwarantowane w kolejności, w jakiej zostały zarejestrowane. Jeśli kolejność bloków skryptu jest ważna, użyj <xref:System.Text.StringBuilder> obiektu, aby zebrać skrypty razem w jednym ciągu, a następnie zarejestrować je wszystkie w jednym bloku skryptu klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody. Należy zauważyć, że początkowe i zamykające Tagi skryptu są dołączone `script` do parametru. Aby dodać tagi skryptu na podstawie dodatkowego ustawienia parametru, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodę.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu uruchomieniowego do zarejestrowania.</param>
        <param name="key">Klucz skryptu uruchomieniowego do zarejestrowania.</param>
        <param name="script">Literał skryptu uruchamiania do zarejestrowania.</param>
        <param name="addScriptTags">Wartość logiczna wskazująca, czy dodać tagi skryptu.</param>
        <summary>Rejestruje skrypt uruchamiania z <see cref="T:System.Web.UI.Page" /> obiektem przy użyciu typu, klucza, literału skryptu i wartości logicznej wskazującej, czy dodać tagi skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt uruchamiania jest jednoznacznie identyfikowany za pomocą jego klucza i jego typu. Skrypty z tym samym kluczem i typem są uważane za duplikaty. Na stronie można zarejestrować tylko jeden skrypt z danym typem i parą kluczy. Próba zarejestrowania skryptu, który jest już zarejestrowany, nie powoduje utworzenia duplikatu skryptu.  
  
 Wywołaj <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metodę, aby określić, czy skrypt uruchamiania z danym kluczem i parą typów jest już zarejestrowany i Unikaj niepotrzebnych prób dodania skryptu.  
  
 W tym przeciążeniu <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody można wskazać, czy skrypt podany `script` w `<script>` parametrze jest opakowany blokiem elementu przy użyciu `addScriptTags` parametru. Ustawienie `addScriptTags`wskazuje,że Tagiskryptówzostanądodaneautomatycznie.`true`  
  
 Blok skryptu dodany przez <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodę jest wykonywany po zakończeniu ładowania strony, ale przed podniesieniem <xref:System.Web.UI.Control.OnLoad%2A> zdarzenia strony. Bloki skryptu nie są gwarantowane w kolejności, w jakiej zostały zarejestrowane. Jeśli kolejność bloków skryptu jest ważna, użyj <xref:System.Text.StringBuilder> obiektu, aby zebrać skrypty razem w jednym ciągu, a następnie zarejestrować je wszystkie w jednym bloku skryptu klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody. Należy pamiętać, `addScriptTags` że parametr jest ustawiony `false` na tak, że początkowe i zamykające `script` Tagi skryptu są dołączone do parametru.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza poprawność zdarzenia klienta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontrolę klienta generującą zdarzenie.</param>
        <summary>Sprawdza poprawność zdarzenia klienta zarejestrowanego pod kątem walidacji <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" /> zdarzenia przy użyciu metody.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontrolę klienta generującą zdarzenie.</param>
        <param name="argument">Argumenty zdarzenia przekazane ze zdarzeniem klienta.</param>
        <summary>Sprawdza poprawność zdarzenia klienta zarejestrowanego pod kątem walidacji <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" /> zdarzenia przy użyciu metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> i metody w celu zarejestrowania wywołania zwrotnego w celu sprawdzenia poprawności i sprawdzenia, czy wywołanie zwrotne pochodzi ze strony. Aby ulepszyć weryfikację w tym miejscu, można zmodyfikować parametr weryfikacji `argument` w taki sposób, aby zawierał informacje specyficzne dla użytkownika, takie jak tożsamość lub rola  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uniqueId" />jest <see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>

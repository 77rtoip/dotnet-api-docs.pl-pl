<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e19ff5181caa07c458ad6ff38334f4d37a7d0917" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31910625" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje metody do zarządzania skrypty klienta w aplikacji sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager> Klasa jest używana do zarządzania skrypty klienta i dodaj je do aplikacji sieci Web. Można pobrać odwołania do <xref:System.Web.UI.ClientScriptManager> klasę z <xref:System.Web.UI.Page.ClientScript%2A> właściwość <xref:System.Web.UI.Page> obiektu.  
  
 Przez dołączenie skrypt do kod znaczników HTML strony, można dodać skrypt klienta deklaratywnie do strony sieci Web. Istnieją sytuacje, kiedy dynamiczne dodawanie skrypt po stronie klienta są potrzebne. Aby dodać skrypt dynamicznie, użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody, <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody, <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody, lub <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metody, w zależności od tego, kiedy i w jaki sposób chcesz dodać skrypt. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie klienta skryptu dynamicznie do składnika ASP.NET Web Pages](http://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 <xref:System.Web.UI.ClientScriptManager> Klasy unikatowo identyfikuje skrypty przy użyciu klucza <xref:System.String> i <xref:System.Type>. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Przy użyciu typu skrypt pomaga uniknąć mylące podobne Skrypty formantów innego użytkownika, które mogą być używane na stronie.  
  
 <xref:System.Web.UI.ClientScriptManager> Klasa może być używana do wywołania wywołania zwrotne klienta w sytuacjach, gdy jest pożądane, aby uruchomić kod serwera z klienta bez wykonywania odświeżania strony. Jest to określane jako wykonywania wywołania zwrotnego poza pasmem do serwera. W wywołaniu zwrotnym klienta funkcji skryptu klienta wysyła żądanie asynchroniczne do strony sieci Web ASP.NET. Strony sieci Web uruchamia zmodyfikowanej wersji cyklu życia procesu wywołania zwrotnego. Użyj <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodę, aby otrzymać odwołanie do funkcji klienta, gdy została wywołana, inicjuje wywołania zwrotnego klienta do zdarzeń serwera. Aby uzyskać więcej informacji, zobacz [implementacja klienta wywołania zwrotne bez ogłaszania zwrotnego](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Wywołania zwrotne skryptu nie będzie działać w starszych przeglądarek, które nie obsługują modelu DOM (Document Object) i wymagają włączenia ECMAScript na kliencie. Aby sprawdzić, czy przeglądarka obsługuje wywołań zwrotnych, użyj <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> właściwość, która jest dostępna za pośrednictwem <xref:System.Web.HttpRequest.Browser%2A> właściwość wewnętrzna ASP.NET <xref:System.Web.HttpContext.Request%2A> obiektu.  
  
 Użyj <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> — metoda i <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> metodę, aby zdefiniować zdarzenie ogłaszania zwrotnego strony klienta. Te metody włączyć funkcje skryptu klienta, gdy została wywołana, aby spowodować, że serwer publikowania wróć do strony. Zdarzenie ogłaszania zwrotnego strony klienta różni się od wywołania zwrotnego klienta, w tym strony sieci Web zakończeniu cyklu życia procesu zdarzenia odświeżania strony klienta.  
  
> [!NOTE]
>  Jeśli używasz <xref:System.Web.UI.WebControls.Button> kontroli i <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> właściwość jest ustawiona na `false`, możesz użyć <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodę, aby zwrócić klienta ogłaszanie zdarzeń dla <xref:System.Web.UI.WebControls.Button> formantu.  
  
 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> Właściwość <xref:System.Web.UI.WebControls.Button> kontroli, <xref:System.Web.UI.WebControls.ImageButton> kontroli, i <xref:System.Web.UI.WebControls.LinkButton> formant może służyć do uruchamiania skryptu klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Dwa skrypty klienta są zdefiniowane na stronie: `PopupScript`, podczas ładowania strony, który zawiera komunikat ostrzegawczy i `ButtonClickScript`, który definiuje obsługi klienta dla przycisku HTML `onClick` zdarzeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera odwołanie do funkcji klienta, gdy została wywołana, inicjuje, kiedy klient wywołania zwrotnego zdarzeń serwera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> obsługująca wywołania zwrotnego klienta. Formant musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu i podaj <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="argument">Argument przekazywany ze skryptu klienta do serwera  
  
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> Metoda.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta odbierająca wynik zdarzenia pomyślnego serwera.</param>
        <param name="context">Skrypt klienta, które jest obliczane na komputerze klienckim przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przekazywane z powrotem do klienta programu obsługi zdarzeń.</param>
        <summary>Pobiera odwołanie do funkcji klienta, gdy została wywołana, inicjuje, kiedy klient wywołania zwrotnego zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody zawiera określony formant, argument, skrypt po stronie klienta i kontekstu.</summary>
        <returns>Nazwa funkcji klienta, która wywołuje metodę wywołania zwrotnego klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Metoda wykonuje wywołanie zwrotne poza pasmem do serwera, który to zmodyfikowana wersja normalnego cyklu życia strony. Aby uzyskać więcej informacji, zobacz [implementacja klienta wywołania zwrotne bez ogłaszania zwrotnego](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Jeśli przeglądarka Microsoft Internet Explorer (w wersji 5.0 lub nowszej), mechanizm wywołania zwrotnego skryptu jest implementowane za pośrednictwem obiektu Microsoft.XmlHttp COM i wymaga przeglądarki, aby ustawić uruchamianie formantów ActiveX. W przypadku innych przeglądarek XMLHttpRequest przy użyciu przeglądarki lokalnego modelu DOM (Document Object) jest używany. Aby sprawdzić, czy przeglądarka obsługuje wywołań zwrotnych klienta, użyj <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> właściwości. Aby sprawdzić, czy przeglądarka obsługuje XML za pośrednictwem protokołu HTTP, użyj <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> właściwości. Obie właściwości są dostępne za pośrednictwem <xref:System.Web.HttpRequest.Browser%2A> właściwość wewnętrzna ASP.NET <xref:System.Web.HttpContext.Request%2A> obiektu.  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Przeciążenia z <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metoda wykonuje wywołanie zwrotne synchronicznie przy użyciu XML za pośrednictwem protokołu HTTP. Podczas wysyłania danych synchronicznie w scenariuszu wywołania zwrotnego, synchroniczne wywołania zwrotne wróć natychmiast i nie blokują przeglądarki. Bez wywołania zwrotnego dwóch synchroniczne wywołania zwrotne można wykonać w tym samym czasie w przeglądarce. Jeśli drugi synchroniczne wywołania zwrotnego jest wywoływane, gdy jedna jest aktualnie oczekujący, pierwszy anuluje drugie synchroniczne wywołania zwrotnego i zwróci tylko drugi wywołania zwrotnego.  
  
 Aby wysyłać dane asynchronicznie, użyj jednego z przeciążeń, które przyjmuje `useAsync` parametr, który jest wartością logiczną wartość kontroli tego zachowania. W scenariuszu asynchroniczne może mieć wielu wywołań zwrotnych oczekujące; kolejności, w którym zwracają nie jest gwarantowana odpowiadające kolejności, w którym zostały zainicjowane.  
  
 Ponadto to przeciążenie metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody określa żadnej funkcji klienta do obsługi w przypadku błędu generowane przez <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metody. Aby określić obsługi wywołania zwrotnego błąd klienta, użyj jednego z przeciążeń, które przyjmuje `clientErrorCallback` parametru.  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Metoda przyjmuje opcjonalny ciąg `argument` parametrów i zwraca wartość typu ciąg. Umożliwia przekazywanie do odbierania wielu wartości złączenia wartości w danych wejściowych lub zwraca ciąg, odpowiednio.  
  
> [!NOTE]
>  Unikaj używania stan widoku w celu wykonania strona lub kontrolka właściwości, które muszą zostać zaktualizowane podczas operacji wywołania zwrotnego skryptu. Jeśli po żądań strony właściwości, można użyć stanu sesji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia dwa przeciążenia <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody w scenariuszu wywołania zwrotnego klienta, który zwiększa liczb całkowitych.  
  
 Wyświetlane są dwa mechanizmy wywołania zwrotnego; Różnica między nimi jest używanie `context` parametru. A `ReceiveServerData1` funkcja wywołania zwrotnego klienta jest realizowane przy użyciu `context` parametru. Z kolei `ReceiveServerData2` funkcja wywołania zwrotnego klienta jest zdefiniowany w `<script>` na stronie. A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metoda jest obsługi serwera, która zwiększa wartość, która została przekazana do niej i <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> metoda zwraca wartość zwiększany jako ciąg. Jeśli <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metoda zwraca błąd, a następnie `ProcessCallBackError` została wywołana funkcja klienta.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.Control" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.Control" /> Określonego nie implementuje <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> obsługująca wywołania zwrotnego klienta. Formant musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu i podaj <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="argument">Argument przekazywany ze skryptu klienta do serwera  
  
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> Metoda.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta odbierająca wynik zdarzenia pomyślnego serwera.</param>
        <param name="context">Skrypt klienta, które jest obliczane na komputerze klienckim przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przekazywane z powrotem do klienta programu obsługi zdarzeń.</param>
        <param name="useAsync">
          <see langword="true" /> Aby wykonać wywołania zwrotnego asynchronicznie; <see langword="false" /> można synchronicznie wykonać wywołania zwrotnego.</param>
        <summary>Pobiera odwołanie do funkcji klienta, gdy została wywołana, inicjuje a klienta wywołania zwrotnego zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody zawiera określony formant, argument, skrypt po stronie klienta, kontekst oraz wartość logiczna.</summary>
        <returns>Nazwa funkcji klienta, która wywołuje metodę wywołania zwrotnego klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metoda wymaga `useAsync` parametr, który umożliwia wykonywanie wywołania zwrotnego klienta asynchronicznie przez ustawienie wartości `true`. Wersje przeciążenie tej metody, które nie wymagają `useAsync` ustawiona wartość `false` domyślnie.  
  
 Aby uzyskać więcej informacji na tej metody, zobacz uwagi do przeciążenia <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.Control" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.Control" /> Określonego nie implementuje <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Nazwa serwera <see cref="T:System.Web.UI.Control" /> obsługująca wywołania zwrotnego klienta. Formant musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu i podaj <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="argument">Argument przekazywany ze skryptu klienta do serwera  
  
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> Metoda.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta odbierająca wynik zdarzenia pomyślnego serwera.</param>
        <param name="context">Skrypt klienta, które jest obliczane na komputerze klienckim przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przekazywane z powrotem do klienta programu obsługi zdarzeń.</param>
        <param name="clientErrorCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik po wystąpieniu błędu w obsłudze zdarzeń serwera.</param>
        <param name="useAsync">
          <see langword="true" /> Aby wykonać wywołania zwrotnego asynchronicznie; <see langword="false" /> można synchronicznie wykonać wywołania zwrotnego.</param>
        <summary>Pobiera odwołanie do funkcji klienta, gdy została wywołana, inicjuje a klienta wywołania zwrotnego zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody zawiera określony element docelowy, argument, skrypt po stronie klienta, kontekstu, program obsługi błędów oraz wartość logiczna.</summary>
        <returns>Nazwa funkcji klienta, która wywołuje metodę wywołania zwrotnego klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> ma metody `target` ciągu parametru zamiast <xref:System.Web.UI.Control> parametru. To przeciążenie należy użyć wywołania zwrotnego, aby powrócić do czegoś innego niż ciąg zawierający <xref:System.Web.UI.Control.UniqueID%2A> formantu.  
  
 Ponadto to przeciążenie metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metoda wymaga `useAsync` i `clientErrorCallback` parametru. `useAsync` Parametr umożliwia wykonywanie wywołania zwrotnego klienta asynchronicznie przez ustawienie wartości `true`. Wersje przeciążenie tej metody, które nie wymagają `useAsync` ustawiona wartość `false` domyślnie. `clientErrorCallback` Parametrów można zdefiniować nazwę funkcji klienta, która jest wywoływana, gdy program obsługi serwera <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> , zwraca błąd. Wersje przeciążenie tej metody, które nie wymagają `clientErrorCallback` ustawiona wartość null.  
  
 Aby uzyskać więcej informacji na tej metody, zobacz uwagi do przeciążenia <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia dwa przeciążenia <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody w scenariuszu wywołania zwrotnego klienta, który zwiększa liczb całkowitych.  
  
 Wyświetlane są dwa mechanizmy wywołania zwrotnego; Różnica między nimi jest używanie `context` parametru. A `ReceiveServerData1` funkcja wywołania zwrotnego klienta jest realizowane przy użyciu `context` parametru. Z kolei `ReceiveServerData2` funkcja wywołania zwrotnego klienta jest zdefiniowany w `<script>` na stronie. A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metoda jest obsługi serwera, która zwiększa wartość, która została przekazana do niej i <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> metoda zwraca wartość zwiększany jako ciąg. Jeśli <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metoda zwraca błąd, a następnie funkcja klienta `ProcessCallBackError` jest wywoływana.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> obsługująca wywołania zwrotnego klienta. Formant musi implementować <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu i podaj <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="argument">Argument przekazywany ze skryptu klienta do serwera <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> metody.</param>
        <param name="clientCallback">Nazwa programu obsługi zdarzeń klienta odbierająca wynik zdarzenia pomyślnego serwera.</param>
        <param name="context">Skrypt klienta, które jest obliczane na komputerze klienckim przed zainicjowaniem wywołania zwrotnego. Wynik skryptu jest przekazywane z powrotem do klienta programu obsługi zdarzeń.</param>
        <param name="clientErrorCallback">Nazwa programu obsługi zdarzeń klienta, który odbiera wynik po wystąpieniu błędu w obsłudze zdarzeń serwera.</param>
        <param name="useAsync">
          <see langword="true" /> Aby wykonać wywołania zwrotnego asynchronicznie; <see langword="false" /> można synchronicznie wykonać wywołania zwrotnego.</param>
        <summary>Pobiera odwołanie do funkcji klienta, gdy została wywołana, inicjuje a klienta wywołania zwrotnego zdarzeń serwera. Funkcja klienta dla tej przeciążonej metody obejmuje określonego formantu, argument, skrypt po stronie klienta, kontekstu, program obsługi błędów i wartość logiczną.</summary>
        <returns>Nazwa funkcji klienta, która wywołuje metodę wywołania zwrotnego klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metoda wymaga `useAsync` i `clientErrorCallback` parametru. `useAsync` Parametr umożliwia wykonywanie wywołania zwrotnego klienta asynchronicznie przez ustawienie wartości `true`. Wersje przeciążenie tej metody, które nie wymagają `useAsync` ustawiona wartość `false` domyślnie. `clientErrorCallback` Parametrów można zdefiniować nazwę funkcji klienta, która jest wywoływana, gdy program obsługi serwera ( <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metody) zwraca błąd. Wersje przeciążenie tej metody, które nie wymagają `clientErrorCallback` ustawiona wartość null.  
  
 Aby uzyskać więcej informacji na tej metody, zobacz uwagi do przeciążenia <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.Control" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.Control" /> Określonego nie implementuje <see cref="T:System.Web.UI.ICallbackEventHandler" /> interfejsu.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera odwołanie, z <see langword="javascript:" /> dołączany na początku, używanym w przypadku klienta można opublikować na serwerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolki serwera do przetworzenia ogłaszania zwrotnego.</param>
        <param name="argument">Parametr przekazany do kontrolki serwera.</param>
        <summary>Pobiera odwołanie, z <see langword="javascript:" /> dołączany na początku, używany w przypadku klienta w publikowania na serwerze dla określonego formantu i z argumentami określone zdarzenie.</summary>
        <returns>Ciąg reprezentujący wywołanie JavaScript do funkcji odświeżania strony, która zawiera argumenty Formant docelowy identyfikator i zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy użyciu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda wymaga formantu, który obsługuje ogłaszania zwrotnego do zaimplementowania <xref:System.Web.UI.IPostBackEventHandler> interfejsu. Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> metody. Formant niestandardowy `MyControl`, implementuje <xref:System.Web.UI.IPostBackEventHandler> interfejsu. Po kliknięciu elementu zakotwiczenia kodu HTML na stronie <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> wywoływana jest metoda kontrolki niestandardowej.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Poniższy przykładowy kod ma te same funkcje co mieszanego, z wyjątkiem zamiast kontrolkę niestandardową <xref:System.Web.UI.Page> klasa implementuje <xref:System.Web.UI.IPostBackEventHandler> interfejsu.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolki serwera do przetworzenia ogłaszania zwrotnego.</param>
        <param name="argument">Parametr przekazany do kontrolki serwera.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> Aby zarejestrować zdarzenie ogłaszania zwrotnego strony do weryfikacji; <see langword="false" /> nie zarejestrować zdarzenie ogłaszania zwrotnego do walidacji.</param>
        <summary>Pobiera odwołanie, z <see langword="javascript:" /> dołączany na początku, używanym w przypadku klienta można opublikować na serwerze dla określonego sterować za pomocą określonego zdarzenia argumentów i logiczna wskazuje czy rejestrować post wstecz dla zdarzenia Sprawdzanie poprawności.</summary>
        <returns>Ciąg reprezentujący wywołanie JavaScript do funkcji odświeżania strony, która zawiera argumenty Formant docelowy identyfikator i zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy użyciu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda wymaga formantu, który obsługuje ogłaszania zwrotnego do zaimplementowania <xref:System.Web.UI.IPostBackEventHandler> interfejsu. Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg, który może być używany w przypadku klienta, powoduje odświeżenie strony do serwera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> definiuje ogłaszania zwrotnego.</param>
        <summary>Zwraca ciąg, który może być używany w przypadku klienta, powoduje odświeżenie strony do serwera. Ciąg odwołania jest zdefiniowany przez określony <see cref="T:System.Web.UI.PostBackOptions" /> wystąpienia.</summary>
        <returns>Ciąg znaków, gdy traktowane jako skryptu na komputerze klienckim, ogłaszanie klienta inicjuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metoda może być używana z <xref:System.Web.UI.WebControls.Button> decyduje o <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> jest właściwość `false`. W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> zwraca zdarzenia dla ogłaszanie klienta <xref:System.Web.UI.WebControls.Button> formantu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" /> Parametr jest <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> która przetwarza ogłaszania zwrotnego na serwerze.</param>
        <param name="argument">Ciąg opcjonalne argumenty do przekazania do formantu, który przetwarza ogłaszania zwrotnego.</param>
        <summary>Zwraca ciąg, który może być używany w przypadku klienta, powoduje odświeżenie strony do serwera. Ciąg odwołania jest określony przez określony formant, który obsługuje ogłaszania zwrotnego i argument ciągu informacji dodatkowych zdarzeń.</summary>
        <returns>Ciąg znaków, gdy traktowane jako skryptu po stronie klienta, inicjuje ogłaszania zwrotnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metoda może być używana z <xref:System.Web.UI.WebControls.Button> decyduje o <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> jest właściwość `false`. W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> zwraca zdarzenia dla ogłaszanie klienta <xref:System.Web.UI.WebControls.Button> formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metody. Formant niestandardowy `MyControl`, implementuje <xref:System.Web.UI.IPostBackEventHandler> interfejsu. Po kliknięciu przycisku na stronie <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> wywoływana jest metoda kontrolki niestandardowej.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Poniższy przykładowy kod ma te same funkcje co mieszanego, z wyjątkiem zamiast kontrolkę niestandardową <xref:System.Web.UI.Page> klasa implementuje <xref:System.Web.UI.IPostBackEventHandler> interfejsu.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określony <see cref="T:System.Web.UI.Control" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> definiuje ogłaszania zwrotnego.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> Aby zarejestrować zdarzenie odwołanie do weryfikacji; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca ciąg, który może być używany w przypadku klienta, powoduje odświeżenie strony do serwera. Ciąg odwołania jest zdefiniowany przez określony <see cref="T:System.Web.UI.PostBackOptions" /> obiektu. Opcjonalnie rejestruje zdarzenia odwołanie do sprawdzania poprawności.</summary>
        <returns>Ciąg znaków, gdy traktowane jako skryptu na komputerze klienckim, ogłaszanie klienta inicjuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page> obiektów, należy użyć dyrektywy.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metoda może być używana z <xref:System.Web.UI.WebControls.Button> decyduje o <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> jest właściwość `false`. W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> zwraca zdarzenia dla ogłaszanie klienta <xref:System.Web.UI.WebControls.Button> formantu.  
  
 Jeśli `registerForEventValidation` jest `true`, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> wywołania metody <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> metoda rejestrowania zdarzeń odwołanie do sprawdzania poprawności z identyfikator unikatowy formantu reprezentujący kontrolkę klienta, który generuje zdarzenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" /> Jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Serwer <see cref="T:System.Web.UI.Control" /> która przetwarza ogłaszania zwrotnego na serwerze.</param>
        <param name="argument">Parametry opcjonalne argumenty do przekazania do <c>kontroli</c>.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> Aby zarejestrować zdarzenie odwołanie do weryfikacji; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca ciąg do użycia w przypadku klienta powoduje odświeżenie strony do serwera. Ciąg odwołania jest określony przez określony formant, który obsługuje ogłaszania zwrotnego i argument ciągu informacji dodatkowych zdarzeń. Opcjonalnie rejestruje zdarzenia odwołanie do sprawdzania poprawności.</summary>
        <returns>Ciąg znaków, gdy traktowane jako skryptu po stronie klienta, inicjuje ogłaszania zwrotnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować <xref:System.Web.UI.IPostBackEventHandler> interfejs na potrzeby <xref:System.Web.UI.Page>, należy użyć dyrektywy.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Metoda może być używana z <xref:System.Web.UI.WebControls.Button> decyduje o <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> jest właściwość `false`. W tym scenariuszu <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> zwraca zdarzenia dla ogłaszanie klienta <xref:System.Web.UI.WebControls.Button> formantu.  
  
 Jeśli `registerForEventValidation` ma wartość true, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> wywołania metody <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> metoda rejestrowania zdarzeń odwołanie do sprawdzania poprawności z identyfikator unikatowy formantu reprezentujący kontrolkę klienta, który generuje zdarzenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określony <see cref="T:System.Web.UI.Control" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ zasobu.</param>
        <param name="resourceName">Pełna nazwa zasobu w zestawie.</param>
        <summary>Pobiera adres URL odwołania do zasobu w zestawie.</summary>
        <returns>Adres URL odwołania do zasobu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Metoda zwraca URL odwołania do zasobu osadzonego w zestawie. Zwracane odwołanie nie jest zakodowane w adresie URL. Zasoby mogą być plików skryptów, obrazy lub żadnych plików statycznych. Należy określić typ oparte na obiekcie, który będą uzyskiwać dostęp do zasobu.  
  
 Zasób sieci Web zarejestrowane na stronie jest unikatowo identyfikowana przez jego typem i nazwą. Może być zarejestrowany tylko jeden zasób z danego typu i pary nazwa ze stroną. Podjęto próbę zarejestrowania z zasobem, który jest już zarejestrowany nie tworzy duplikat zarejestrowanych zasobów.  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Metoda jest używana w połączeniu z <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> metodę dostępu do zasobów osadzonych w zestawach. Aby uzyskać więcej informacji o użyciu zasobów w aplikacjach, zobacz [Omówienie zasobów strony sieci Web programu ASP.NET](http://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> metody. *Typu* parametr w tym przykładzie jest ustawiony na typ klasy w zestawie zawiera zasób. `resourceName` z w pełni kwalifikowana ścieżka do zasobu, który zawiera domyślnej przestrzeni nazw jest określony parametr.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 W poniższym przykładzie pokazano, jak programowane stosowanie <xref:System.Web.UI.WebResourceAttribute> atrybutu metadanych do zestawu zasobów, które zostanie obsłużona oznaczyć. Skompiluj następujące klasy w bibliotece klas z ustawioną domyślną przestrzeń nazw `Samples.AspNet.CS.Controls` lub `Samples.AspNet.VB.Controls`, w zależności od języka, jakiego używasz.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 W tym przykładzie wymaga plik JavaScript o nazwie `Script_include.js`. Plik js jest osadzony zasób w zestawie, który zawiera `ClientScriptResourceLabel` obiektu. Jeśli używasz programu Visual Studio], w oknie właściwości projektu biblioteki klas, ustaw **Akcja kompilacji** do **osadzonego zasobu** po wybraniu pliku skryptu. Jeśli kompilacja biblioteki w wierszu polecenia, użyj przełącznika ma zostać osadzony zasób.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa zasobu sieci web jest <see langword="null" />.  
  
 \- lub -  
  
 Nazwa zasobu sieci web ma długość równą zero.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy blok skryptu klienta jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do wyszukania bloku skryptu klienta.</param>
        <summary>Określa, czy blok skryptu klienta jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza.</summary>
        <returns>
          <see langword="true" /> Jeśli blok skryptu klienta jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu utworzenia.  
  
 Skrypt po stronie klienta jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty.  
  
 To przeciążenie metody <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metoda wywołuje przeciążenia, które przyjmuje zarówno `key` i `type` z typem ustawiona jako <xref:System.Web.UI.Page> obiektu  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ bloku skryptu klienta do wyszukiwania.</param>
        <param name="key">Klucz do wyszukania bloku skryptu klienta.</param>
        <summary>Określa, czy blok skryptu klienta jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> przy użyciu klucza i typu.</summary>
        <returns>
          <see langword="true" /> Jeśli blok skryptu klienta jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu utworzenia.  
  
 Skrypt po stronie klienta jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Należy określić typ oparte na obiekcie, który będą uzyskiwać dostęp do zasobu. Na przykład korzystając z `Page` wystąpienia dostępu do zasobu, należy określić `Page` typu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metody. Należy pamiętać, że jeśli logikę do wyszukania istniejącego bloku skryptu klienta zostały usunięte, nie nie byłoby dwa skrypty zduplikowane klienta w kodzie źródłowym HTML renderowanej strony ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metoda sprawdza, czy duplikaty. Zaletą sprawdzanie jest ograniczyć niepotrzebne obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ skryptu klienta jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy skrypt po stronie klienta obejmują został zarejestrowany za pomocą <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz skrypt po stronie klienta obejmują do wyszukania.</param>
        <summary>Określa, czy skrypt po stronie klienta obejmują został zarejestrowany za pomocą <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza.</summary>
        <returns>
          <see langword="true" /> Jeśli dołączysz skrypt po stronie klienta jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu utworzenia.  
  
 Skrypt po stronie klienta obejmują jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty.  
  
 To przeciążenie metody <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metoda wywołuje przeciążenia, które przyjmuje zarówno `key` i `type` z typem ustawiona jako <xref:System.Web.UI.Page> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta obejmują do wyszukania.</param>
        <param name="key">Klucz skrypt po stronie klienta obejmują do wyszukania.</param>
        <summary>Określa, czy skrypt po stronie klienta obejmują został zarejestrowany za pomocą <see cref="T:System.Web.UI.Page" /> przy użyciu klucza i typu.</summary>
        <returns>
          <see langword="true" /> Jeśli dołączysz skrypt po stronie klienta jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> zawiera metody w celu uniknięcia rejestrowanie skrypt po stronie klienta zduplikowane. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu utworzenia.  
  
 Skrypt po stronie klienta obejmują jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Należy określić typ oparte na obiekcie, który będą uzyskiwać dostęp do zasobu. Na przykład podczas dostępu do zasobu, przy użyciu wystąpienia strony, należy określić `Page` typu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> metody. Należy pamiętać, że jeśli logika Sprawdź, czy istniejący skrypt klienta obejmują zostały usunięte, nie nie byłoby dwa skrypty klienta duplikatów w kodzie źródłowym HTML renderowanej strony ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metoda sprawdza, czy duplikaty. Zaletą sprawdzanie jest ograniczyć niepotrzebne obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 W tym przykładzie wymaga plik JavaScript o nazwie `Script_include.js`, z następującą zawartość:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Skrypt po stronie klienta obejmują typ jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy oświadczenie OnSubmit jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz instrukcji OnSubmit do wyszukania.</param>
        <summary>Określa, czy oświadczenie OnSubmit jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza.</summary>
        <returns>
          <see langword="true" /> Jeśli nie zarejestrowano instrukcji OnSubmit; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metodę, aby uniknąć zduplikowanych OnSubmit instrukcje rejestrowania. Jest to szczególnie ważne, jeśli jest wymagany dużą ilość zasobów serwera w celu utworzenia.  
  
 Instrukcja jest unikatowo identyfikowana przez jego klucza i jej typie. Instrukcje z tego samego klucza i typ są traktowane jako duplikaty.  
  
 To przeciążenie metody <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metoda wywołuje przeciążenia, które przyjmuje zarówno `key` i `type` z typem ustawiona jako <xref:System.Web.UI.Page> obiektu  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ instrukcji OnSubmit do wyszukania.</param>
        <param name="key">Klucz instrukcji OnSubmit do wyszukania.</param>
        <summary>Określa, czy oświadczenie OnSubmit jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza i typu.</summary>
        <returns>
          <see langword="true" /> Jeśli nie zarejestrowano instrukcji OnSubmit; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metodę, aby uniknąć zduplikowanych instrukcje rejestrowania. Jest to szczególnie ważne, jeśli jest wymagany dużą ilość zasobów serwera w celu utworzenia.  
  
 Instrukcja jest unikatowo identyfikowana przez jego klucza i jej typie. Instrukcje z tego samego klucza i typ są traktowane jako duplikaty. Należy określić typ oparte na obiekcie, który będą uzyskiwać dostęp do zasobu. Na przykład korzystając z `Page` wystąpienia dostępu do zasobu, należy określić `Page` typu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metody. Skrypt o nazwie `OnSubmitScript` został zarejestrowany za pomocą <xref:System.Web.UI.Page> tak, aby po stronie przesłaniu formularza skrypt zostanie wywołany.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ instrukcji OnSubmit jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy skrypt uruchamiania jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz uruchomienia skryptu do wyszukania.</param>
        <summary>Określa, czy skrypt uruchamiania jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza.</summary>
        <returns>
          <see langword="true" /> Jeśli skrypt uruchamiania jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu utworzenia.  
  
 Skrypt uruchamiania jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty.  
  
 To przeciążenie metody <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metoda wywołuje przeciążenia, które przyjmuje zarówno ciąg `key` i `type` z typem ustawiona jako <xref:System.Web.UI.Page> obiektu  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ uruchomienia skryptu do wyszukania.</param>
        <param name="key">Klucz uruchomienia skryptu do wyszukania.</param>
        <summary>Określa, czy skrypt uruchamiania jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> przy użyciu określonego klucza i typu.</summary>
        <returns>
          <see langword="true" /> Jeśli skrypt uruchamiania jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody w celu uniknięcia zarejestrowanie zduplikowane skryptów. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu utworzenia.  
  
 Skrypt uruchamiania klienta jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metody. Należy pamiętać, że jeśli logiki, aby wyszukać istniejący blok skryptu uruchamiania zostały usunięte, nie nie byłoby dwa skrypty uruchamiania duplikatów w kodzie źródłowym HTML renderowanej strony ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metoda sprawdza, czy duplikaty. Zaletą sprawdzanie jest ograniczyć niepotrzebne obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ uruchamiania skryptu jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Nazwa tablicy do zarejestrowania.</param>
        <param name="arrayValue">Tablica wartości lub wartości do zarejestrowania.</param>
        <summary>Rejestruje deklaracji tablicy JavaScript z <see cref="T:System.Web.UI.Page" /> przy użyciu tablicy nazwy i wartości tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> Sprawdza, czy tablica zarejestrowanych istnieje o takiej samej nazwie jak nazwa określona w `arrayName` parametru i jeśli tak, dodaje wartości określone w `arrayValue` parametru. Ponieważ podstawowy mechanizm magazynu jest oparta na <xref:System.Collections.ArrayList>, duplikaty są dozwolone. Jeśli zarejestrowane tablicy o takiej samej nazwie jak `arrayName` parametr nie istnieje, jest tworzona i wartościami w `arrayValue` parametru do niego dodana.  
  
 Literał ciągu w tablicy wynikowej JavaScript, obejmują pojedynczy znaki cudzysłowu (') lub wpisywany podwójny cudzysłów (\\") w `arrayValue` parametru. Wartość `arrayValue` parametr powinien być pojedynczym elementem. Jeśli więcej niż jedną wartość musi być dodawane do tablicy, wywołań wielu przy użyciu <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> i <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metody. W przykładzie rejestruje tablicy i wartość ukryte i definiuje `OnClick` zdarzenie `<input>` przycisk, aby obliczyć sumę dwóch wartości w tablicy wartości hidden.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje klienta skryptu <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta do rejestracji.</param>
        <param name="key">Klucz skryptu klienta do rejestracji.</param>
        <param name="script">Literał zarejestrować skryptu klienta.</param>
        <summary>Rejestruje klienta skryptu <see cref="T:System.Web.UI.Page" /> przy użyciu typu, klucz i skryptu literału.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt po stronie klienta jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie może być zarejestrowany tylko jeden skrypt z danego typu i parę kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy duplikat skryptu.  
  
 Wywołanie <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metody w celu określenia, czy skrypt po stronie klienta z danego typu parę klucz jest już zarejestrowany i uniknąć niepotrzebnego próby dodania skryptu.  
  
 W tym przeciążenia <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody, należy się upewnić, że skrypt jest dostarczany w `script` parametru jest ujęte w `<script>` bloku elementu.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Metoda dodaje blok skryptu na początku renderowanej strony. W blokach skryptu nie ma gwarancji jako dane wyjściowe w kolejności, które są zarejestrowane. Jeśli kolejność blokach skryptu odgrywa ważną rolę, użyj <xref:System.Text.StringBuilder> do grupowania skrypty w ciągu jednego obiektu, a następnie zarejestruj je w bloku skryptu jednego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta do rejestracji.</param>
        <param name="key">Klucz skryptu klienta do rejestracji.</param>
        <param name="script">Literał zarejestrować skryptu klienta.</param>
        <param name="addScriptTags">Wartość logiczna wskazująca, czy dodać tagi skryptu.</param>
        <summary>Rejestruje klienta skryptu <see cref="T:System.Web.UI.Page" /> przy użyciu typu, kluczy skryptu literału i logicznych wartość wskazującą, czy można dodać tagów skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt po stronie klienta jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie może być zarejestrowany tylko jeden skrypt z danego typu i parę kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy duplikat skryptu.  
  
 Wywołanie <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metodę, aby określić, czy skrypt po stronie klienta z danego typu parę klucz jest już zarejestrowany. Dzięki temu można uniknąć niepotrzebnego próby dodania skryptu.  
  
 W tym przeciążenia <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody, można określić, czy skrypt jest dostarczany w `script` parametru jest ujęte w `<script>` bloku elementu przy użyciu `addScriptTags` parametru. Ustawienie `addScriptTags` do `true` wskazuje automatycznie dodawane tagów skryptu.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Metoda dodaje blok skryptu na początku renderowanej strony. W blokach skryptu nie ma gwarancji jako dane wyjściowe w kolejności, które są zarejestrowane. Jeśli kolejność blokach skryptu odgrywa ważną rolę, użyj <xref:System.Text.StringBuilder> do grupowania skrypty w ciągu jednego obiektu, a następnie zarejestruj je w bloku skryptu jednego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody. Należy pamiętać, że `addScriptTags` ustawiono parametr `true` tak początku i zamykanie tagów skryptu nie są dołączone `script` parametru.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Typ bloku skryptu klienta jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Skrypt po stronie klienta obejmują z rejestrów <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz skrypt po stronie klienta obejmują do zarejestrowania.</param>
        <param name="url">Adres URL skryptu klienta obejmują do zarejestrowania.</param>
        <summary>Rejestruje klienta skryptu <see cref="T:System.Web.UI.Page" /> przy użyciu klucza i adresu URL, który umożliwia uruchomienie skryptu można wywoływać z klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt po stronie klienta obejmują jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie może być zarejestrowany tylko jeden skrypt z danego typu i parę kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy duplikat skryptu.  
  
 Wywołanie <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> metodę, aby ustalić, czy skrypt po stronie klienta obejmują z danym kluczem oraz pary typu jest już zarejestrowany i uniknąć niepotrzebnego próby dodania skryptu.  
  
> [!NOTE]
>  Aby usunąć adres URL klienta, użyj <xref:System.Web.UI.Control.ResolveClientUrl%2A> metody. Ta metoda używa kontekstu adres URL, na którym jest ona wywoływana, aby rozpoznać ścieżki.  
  
 To przeciążenie metody <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metoda wywołuje przeciążenia, które przyjmuje `key`, `URL`, a `type` parametru.  
  
 Metoda dodaje blok skryptu w górnej części renderowanej strony.  
  
   
  
## Examples  
 Powiązane informacje, wraz ze składnią, użycia i przykładem, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ skryptu klienta obejmują do zarejestrowania.</param>
        <param name="key">Klucz skrypt po stronie klienta obejmują do zarejestrowania.</param>
        <param name="url">Adres URL skryptu klienta obejmują do zarejestrowania.</param>
        <summary>Skrypt po stronie klienta obejmują z rejestrów <see cref="T:System.Web.UI.Page" /> przy użyciu typu klucza i adres URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> przyjmuje — metoda *klucza* i *adres url* parametrów, aby określić skrypt, a także `type` obejmują parametr, aby określić identyfikator skryptu klienta. Należy określić typ oparte na obiekcie, który będą uzyskiwać dostęp do zasobu. Na przykład korzystając z `Page` wystąpienia dostępu do zasobu, należy określić `Page` typu.  
  
> [!NOTE]
>  Aby usunąć adres URL klienta, użyj <xref:System.Web.UI.Control.ResolveClientUrl%2A> metody. Ta metoda używa kontekstu adres URL, na którym jest ona wywoływana, aby rozpoznać ścieżki.  
  
 Ta metoda dodaje blok skryptu w górnej części renderowanej strony.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metody. Jeśli logika Sprawdź, czy istniejący skrypt klienta obejmują zostały usunięte, będzie nadal nie będzie skrypty zduplikowane klienta na renderowanej stronie ponieważ <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metoda sprawdza, czy duplikaty. Zaletą sprawdzanie jest ograniczyć niepotrzebne obliczeń.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 W tym przykładzie wymaga plik JavaScript o nazwie Script_include.js z następującą zawartość:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Skrypt po stronie klienta obejmują typ jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Adres URL jest <see langword="null" />.  
  
 \- lub -  
  
 Adres URL jest pusty.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ zasobu skryptu klienta do rejestracji.</param>
        <param name="resourceName">Nazwa zasobu skryptu klienta do rejestracji.</param>
        <summary>Rejestruje klienta zasobu skryptu z <see cref="T:System.Web.UI.Page" /> przy użyciu typu i nazwy zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Metoda jest używana podczas uzyskiwania dostępu do zasobów skompilowanego z zestawów przy użyciu programu obsługi WebResource.axd HTTP. <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Metoda rejestruje skryptu <xref:System.Web.UI.Page> obiektu i uniemożliwia zduplikowane skryptów. Ta metoda opakowuje zawartość adresu URL zasobu z `<script>` bloku elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 W poniższym przykładzie pokazano, jak programowane stosowanie <xref:System.Web.UI.WebResourceAttribute> atrybutu metadanych do zestawu zasobów, które zostanie obsłużona oznaczyć.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 W tym przykładzie wymaga plik JavaScript o nazwie `Script_include.js`, z następującą zawartość:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Kompiluj `Script_include.js` pliku jako zasób w `Samples.AspNet.CS.Controls` zestaw zawierający `ClientScriptResourceLabel` klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa zasobu klienta jest <see langword="null" />.  
  
 \- lub -  
  
 Nazwa zasobu klienta ma długość równą zero.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) określonego formantu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">
          <see cref="T:System.Web.UI.Control" /> Na stronie zawierającej atrybutu niestandardowego.</param>
        <param name="attributeName">Nazwa atrybutu niestandardowego do zarejestrowania.</param>
        <param name="attributeValue">Wartość atrybutu niestandardowego.</param>
        <summary>Rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) określonego formantu podany identyfikator formantu, atrybut nazwy i wartości atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Metoda rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) na określony <xref:System.Web.UI.Control>. Atrybut expando ustawiono dynamicznie z poziomu języka JavaScript w celu zachowania zgodności XHTML dla znacznika renderowanych formantu. Cudzysłowy i ukośników odwrotnych w wartości atrybutu niestandardowego (expando) będą miały zmienione znaczenie. Jeśli nie chcesz escape cudzysłowy i ukośników odwrotnych, wywołanie <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> przeciążyć metodę i ustawić `encode` parametr `false`.  
  
 Jeśli nie odnaleziono atrybutu expando lub Dodaj atrybut expando do formantu nie zostanie odnaleziony, nadal jest emitowany skryptu klienta, ale nie wpłynie formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">
          <see cref="T:System.Web.UI.Control" /> Na stronie zawierającej atrybutu niestandardowego.</param>
        <param name="attributeName">Nazwa atrybutu niestandardowego do zarejestrowania.</param>
        <param name="attributeValue">Wartość atrybutu niestandardowego.</param>
        <param name="encode">Wartość logiczna wskazująca, czy kodowanie atrybutu niestandardowego do zarejestrowania.</param>
        <summary>Rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) określonego formantu podany identyfikator formantu, nazwę atrybutu, wartość atrybutu i wartość logiczną wskazującą, czy do kodowania wartości atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Metoda rejestruje pary nazwa/wartość jako atrybut niestandardowy (expando) na określony <xref:System.Web.UI.Control>. Atrybut expando ustawiono dynamicznie z poziomu języka JavaScript w celu zachowania zgodności XHTML dla znacznika renderowanych formantu. Ustaw `encode` parametr `true` Chcąc escape cudzysłowy i ukośników odwrotnych w wartości atrybutu z expando.  
  
 Jeśli nie odnaleziono atrybutu expando lub Dodaj atrybut expando do formantu nie zostanie odnaleziony, nadal jest emitowany skryptu klienta, ale nie wpłynie formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Skrypt po stronie klienta w zestawach renderowanej strony `title` atrybutu `<span>` elementu.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje odwołanie do zdarzenia do weryfikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontroli klienta generowania zdarzenia.</param>
        <summary>Rejestruje identyfikator unikatowy formantu reprezentujący kontroli klienta generowania zdarzenia odwołanie do zdarzenia do weryfikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dodatkowe informacje i przykłady, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> — metoda i <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> metody, aby można było zarejestrować wywołanie zwrotne weryfikacji i sprawdzania poprawności, że wywołanie zwrotne pochodzi ze strony.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> obiekt, który określa, jak jest generowany klienta JavaScript do zainicjowania zdarzenia odświeżania strony.</param>
        <summary>Rejestruje odwołanie do zdarzenia do sprawdzania poprawności z <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dodatkowe informacje i przykłady, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontroli klienta generowania zdarzenia.</param>
        <param name="argument">Przekazano argumentów zdarzenia ze zdarzeniem klienta.</param>
        <summary>Rejestruje odwołanie do zdarzenia do walidacji formantu Unikatowy identyfikator zdarzenia argumenty i reprezentujący kontroli klienta generowania zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> — metoda i <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> metody do rejestrowania wywołań zwrotnych dla sprawdzania poprawności i do sprawdzania, czy wywołanie zwrotne pochodzi ze strony. Zwiększające weryfikacji pokazano w przykładzie można zmodyfikować walidacji `argument` parametr zawiera informacje specyficzne dla użytkownika, takich jak tożsamość lub roli  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody do rejestrowania wywołania zwrotnego do walidacji.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda jest wywoływana przed <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" /> metody.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Nazwa pola ukrytego do zarejestrowania.</param>
        <param name="hiddenFieldInitialValue">Wartość początkowa pola, aby zarejestrować.</param>
        <summary>Rejestruje ukryte wartości z <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Metoda tworzy ukryty `<input>` elementu na stronie HTML renderowanych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> i <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metody. W przykładzie rejestruje tablicy i wartość ukryte i definiuje `OnClick` zdarzenie `<input>` przycisk, aby obliczyć sumę dwóch wartości w tablicy wartości hidden.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hiddenFieldName" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ instrukcji OnSubmit do zarejestrowania.</param>
        <param name="key">Klucz instrukcji OnSubmit do zarejestrowania.</param>
        <param name="script">Literał skryptu instrukcji OnSubmit do zarejestrowania.</param>
        <summary>Rejestruje instrukcję OnSubmit z <see cref="T:System.Web.UI.Page" /> przy użyciu typu klucza i skrypt literału. Podczas wykonywania instrukcji <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> zostało przesłane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Instrukcja OnSubmit jest unikatowo identyfikowana przez jego klucza i jej typie. Instrukcje z tego samego klucza i typ są traktowane jako duplikaty. Na stronie można zarejestrować tylko jednej instrukcji z danego typu i parę kluczy. Podjęto próbę zarejestrowania instrukcję, która jest już zarejestrowany nie utworzy duplikat instrukcji.  
  
 Wywołanie <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metody w celu określenia, czy instrukcji OnSubmit jest już zarejestrowany z daną parą klucza i typ i uniknąć niepotrzebnego próby dodania skryptu.  
  
 `script` Parametr <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> — metoda może zawierać wielu poleceń skryptu, jak długo są poprawnie rozdzielone średnikami (;).  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Dodaje skrypt, który jest wykonywany przed przesłaniem strony daje możliwość anulowanie przesyłania.  
  
 Aby uzyskać więcej informacji na temat formularzy HTML i `OnSubmit` atrybutów, zobacz [witryny sieci Web w sieci World Wide Web konsorcjum W3C](http://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje uruchomienia skryptu <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ uruchomienia skryptu do zarejestrowania.</param>
        <param name="key">Klucz uruchomienia skryptu do zarejestrowania.</param>
        <param name="script">Skrypt uruchamiania literału do zarejestrowania.</param>
        <summary>Rejestruje uruchomienia skryptu <see cref="T:System.Web.UI.Page" /> przy użyciu typu klucza i skrypt literału.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt po stronie klienta jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie może być zarejestrowany tylko jeden skrypt z danego typu i parę kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy duplikat skryptu.  
  
 Wywołanie <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metody w celu określenia, czy skryptu z daną parą klucza i typ uruchamiania jest już zarejestrowany i uniknąć niepotrzebnego próby dodania skryptu.  
  
 W tym przeciążenia <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody, należy się upewnić, że skrypt jest dostarczany w `script` parametru jest ujęte w `<script>` bloku elementu.  
  
 Blok skryptu dodawany przez <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metoda jest wykonywana po stronie zakończeniu ładowania, ale przed stroną <xref:System.Web.UI.Control.OnLoad%2A> zdarzenia. W blokach skryptu nie ma gwarancji jako dane wyjściowe w kolejności, które są zarejestrowane. Jeśli kolejność blokach skryptu odgrywa ważną rolę, użyj <xref:System.Text.StringBuilder> do grupowania skrypty w ciągu jednego obiektu, a następnie zarejestruj je w bloku skryptu jednego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody. Należy pamiętać, że początku i zamykanie tagów skryptu znajdują się w obrębie `script` parametru. Aby skrypt tagi dodane na podstawie ustawienia dodatkowych parametrów, zobacz <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ uruchomienia skryptu do zarejestrowania.</param>
        <param name="key">Klucz uruchomienia skryptu do zarejestrowania.</param>
        <param name="script">Skrypt uruchamiania literału do zarejestrowania.</param>
        <param name="addScriptTags">Wartość logiczna wskazująca, czy dodać tagi skryptu.</param>
        <summary>Rejestruje uruchomienia skryptu <see cref="T:System.Web.UI.Page" /> przy użyciu typu, klucz skrypt literału i wartość logiczną wskazującą, czy dodać tagi skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt uruchamiania jest unikatowo identyfikowana przez jego klucza i jej typie. Skrypty za pomocą tego samego klucza i typ są traktowane jako duplikaty. Na stronie może być zarejestrowany tylko jeden skrypt z danego typu i parę kluczy. Podjęto próbę zarejestrowania skrypt, który jest już zarejestrowany nie tworzy duplikat skryptu.  
  
 Wywołanie <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metody w celu określenia, czy skryptu z daną parą klucza i typ uruchamiania jest już zarejestrowany i uniknąć niepotrzebnego próby dodania skryptu.  
  
 W tym przeciążenia <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody, można określić, czy skrypt jest dostarczany w `script` parametru jest ujęte w `<script>` bloku elementu przy użyciu `addScriptTags` parametru. Ustawienie `addScriptTags` do `true` wskazuje automatycznie dodawane tagów skryptu.  
  
 Blok skryptu dodawany przez <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metoda jest wykonywana po stronie zakończeniu ładowania, ale przed stroną <xref:System.Web.UI.Control.OnLoad%2A> zdarzenia. W blokach skryptu nie ma gwarancji jako dane wyjściowe w kolejności, które są zarejestrowane. Jeśli kolejność blokach skryptu odgrywa ważną rolę, użyj <xref:System.Text.StringBuilder> do grupowania skrypty w ciągu jednego obiektu, a następnie zarejestruj je w bloku skryptu jednego klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody. Należy pamiętać, że `addScriptTags` ustawiono parametr `false` tak początku i zamykania tagów skryptu są dołączone do `script` parametru.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weryfikuje zdarzeń klienta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontroli klienta generowania zdarzenia.</param>
        <summary>Weryfikuje zdarzenie klienta, który został zarejestrowany dla zdarzeń weryfikacji przy użyciu <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" /> metody.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Unikatowy identyfikator reprezentujący kontroli klienta generowania zdarzenia.</param>
        <param name="argument">Argumenty przekazywane ze zdarzeniem klienta.</param>
        <summary>Weryfikuje zdarzenie klienta, który został zarejestrowany dla zdarzeń weryfikacji przy użyciu <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> — metoda i <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> metody do rejestrowania wywołań zwrotnych dla sprawdzania poprawności i do sprawdzania, czy wywołanie zwrotne pochodzi ze strony. Zwiększające weryfikacji pokazanych tu można zmodyfikować walidacji `argument` parametr zawiera informacje specyficzne dla użytkownika, takich jak tożsamość lub roli  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uniqueId" /> jest <see langword="null" /> lub ciąg pusty ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
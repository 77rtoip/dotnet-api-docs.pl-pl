<Type Name="Page" FullName="System.Web.UI.Page">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b65c377cb9b1c281d1a229b674c0e23ee51b2a3a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36576935" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits TemplateControl&#xA;Implements IHttpHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Web::UI::TemplateControl, System::Web::IHttpHandler" />
  <TypeSignature Language="F#" Value="type Page = class&#xA;    inherit TemplateControl&#xA;    interface IHttpHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje plik .aspx, znanej także jako strony formularzy sieci Web, pobrany z serwera, który jest hostem aplikacji sieci Web ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page> Klasy jest skojarzone z plików, które mają rozszerzenie aspx. Te pliki są kompilowane w czasie wykonywania jako <xref:System.Web.UI.Page> obiekty i są przechowywane w pamięci serwera.  
  
 Jeśli chcesz utworzyć strony formularzy sieci Web, przy użyciu techniki CodeBehind dziedziczyć po tej klasie. Projektanci Programowanie (RAD) szybkie aplikacji, takich jak program Microsoft Visual Studio automatycznie używać tego modelu do utworzenia strony formularzy sieci Web.  
  
 <xref:System.Web.UI.Page> Obiektu służy jako kontener nazewnictwa dla wszystkich kontrolek serwera na stronie, z wyjątkiem tych, które implementują <xref:System.Web.UI.INamingContainer> interfejsu lub są formantów podrzędnych formantów, które implementują ten interfejs.  
  
 <xref:System.Web.UI.Page> Klasa jest formant, który działa jako interfejs użytkownika dla aplikacji sieci Web i jako taki powinien poddawanych aby upewnić się, że najlepsze rozwiązania dla zapisywania bezpiecznego kodu oraz zabezpieczanie aplikacji zostaną wykonane. Aby uzyskać ogólne informacje dotyczące tych tematów, zobacz [omówienie z sieci Web aplikacji zagrożenia bezpieczeństwa](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: najlepszych rozwiązań dotyczących zasad zabezpieczeń](http://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), i [podstawowe pojęcia dotyczące zabezpieczeń](~/docs/standard/security/key-security-concepts.md). Aby uzyskać bardziej szczegółowe informacje, zobacz [zabezpieczanie standardowych formantów](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [jak: bezpieczne komunikaty o błędach programu wyświetlania](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [jak: chronić przed skryptu wykorzystuje luki w aplikacji sieci Web przez stosowanie HTML Kodowanie na ciągi](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), i [wprowadzenie do formantów weryfikacji](http://msdn.microsoft.com/library/3c0e7514-cff2-4bed-936d-ee3f7b740190).  
  
   
  
## Examples  
 Projekt programu Visual Studio Web lokacji z kodem źródłowym jest dostępna powiązany z tym tematem: [Pobierz](http://go.microsoft.com/fwlink/?LinkId=192425).  
  
 Poniższy przykład kodu pokazuje sposób <xref:System.Web.UI.Page> klasa jest używana w modelu strony związane z kodem. Należy pamiętać, że plik źródłowy CodeBehind deklaruje częściowej klasy, która dziedziczy z klasy strony podstawowej. Klasa strony podstawowej może być <xref:System.Web.UI.Page>, lub można ją z inną klasę, która jest pochodną <xref:System.Web.UI.Page>. Ponadto należy zauważyć, że klasy częściowej pozwala pliku CodeBehind używania formantów na stronie bez konieczności zdefiniowano do definiowania ich jako elementy członkowskie pola.  
  
 [!code-csharp[System.Web.UI.Page_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 Poniższy przykładowy kod przedstawia plik .aspx, umożliwiająca poprzedniego pliku źródłowego związane z kodem.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 Należy użyć dyrektywy i użyj `Inherits` i `CodeFile` atrybuty Połącz plik CodeBehind plik .aspx. W tym przykładzie `Inherits` atrybut wskazuje `MyCodeBehind` klasy i `CodeFile` atrybut wskazuje ścieżkę do pliku specyficzny dla języka, który zawiera klasę.  
  
 Poniższy przykład kodu pokazuje modelu pojedynczego pliku strony i uzyskiwania dostępu do <xref:System.Web.UI.Page.IsPostBack%2A> właściwości i <xref:System.Web.UI.Page.Response%2A> właściwość <xref:System.Web.UI.Page>.  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.Page" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor domyślny inicjuje wszystkie pola z wartościami domyślnymi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected internal void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddContentTemplate (templateName As String, template As ITemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddContentTemplate(System::String ^ templateName, System::Web::UI::ITemplate ^ template);" />
      <MemberSignature Language="F#" Value="member this.AddContentTemplate : string * System.Web.UI.ITemplate -&gt; unit" Usage="page.AddContentTemplate (templateName, template)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" />
      </Parameters>
      <Docs>
        <param name="templateName">Nazwa szablonu zawartości do dodania.</param>
        <param name="template">Szablon zawartości</param>
        <summary>Wywoływana podczas inicjowania strony, aby utworzyć kolekcję zawartości (z formantami zawartości), który jest przekazywany do strony głównej, jeśli bieżąca strona lub strony wzorcowej odwołuje się do strony głównej.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Szablon zawartości o takiej samej nazwie już istnieje.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOnPreRenderCompleteAsync">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje otwierające i zamykające delegatów obsługi zdarzeń dla asynchronicznego strony.</summary>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler);" />
      <MemberSignature Language="F#" Value="member this.AddOnPreRenderCompleteAsync : System.Web.BeginEventHandler * System.Web.EndEventHandler -&gt; unit" Usage="page.AddOnPreRenderCompleteAsync (beginHandler, endHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Delegat dla <see cref="T:System.Web.BeginEventHandler" /> metody.</param>
        <param name="endHandler">Delegat dla <see cref="T:System.Web.EndEventHandler" /> metody.</param>
        <summary>Rejestruje początkowe i końcowe delegatów obsługi zdarzeń, które nie wymagają informacji o stanie dla asynchronicznego strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> metody w celu dodania obsługi do asynchronicznego strony sieci Web.  
  
 Możesz zarejestrować wielu obsług asynchroniczne; jednak tylko jeden obsługi jest uruchamiany w czasie. Jeśli chcesz jednocześnie przetwarzać wiele metod asynchronicznych, należy użyć pojedynczej <xref:System.Web.BeginEventHandler> — metoda i uruchamianie wielu operacji asynchronicznych z programu obsługi.  
  
 Asynchroniczne wywołania między <xref:System.Web.UI.Control.PreRender> i <xref:System.Web.UI.Page.PreRenderComplete> zdarzenia.  
  
 Najpierw wszystkie <xref:System.Web.UI.Page> zdarzenia (za pośrednictwem <xref:System.Web.UI.Control.PreRender> zdarzeń) uruchom, a następnie każdy zarejestrowanych <xref:System.Web.BeginEventHandler> metoda jest wywoływana. Podczas obsługi zakończeniu odpowiadającego <xref:System.Web.EndEventHandler> metoda jest wywoływana. W przypadku wielu obsług asynchroniczne jest nazywany dalej programu obsługi.  
  
 Po wywołaniu obsługi zarejestrowanych zdarzeń asynchroniczne pozostałe zdarzenia strony są nazywane, począwszy od <xref:System.Web.UI.Page.PreRenderComplete> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje asynchroniczne żądanie, aby wyświetlić kod źródłowy HTML strony domyślne lokalnego serwera sieci Web w <xref:System.Web.UI.WebControls.TextBox> formantu.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="&lt;async&gt;" /> Dyrektywy strony nie jest ustawiony na <see langword="true" />.  \- lub - <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> metoda jest wywoływana po wykonaniu <see cref="E:System.Web.UI.Control.PreRender" /> zdarzeń.</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> Lub <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler, state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddOnPreRenderCompleteAsync : System.Web.BeginEventHandler * System.Web.EndEventHandler * obj -&gt; unit" Usage="page.AddOnPreRenderCompleteAsync (beginHandler, endHandler, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Delegat dla <see cref="T:System.Web.BeginEventHandler" /> metody.</param>
        <param name="endHandler">Delegat dla <see cref="T:System.Web.EndEventHandler" /> metody.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla programów obsługi zdarzeń.</param>
        <summary>Rejestruje otwierające i zamykające delegatów obsługi zdarzeń dla asynchronicznego strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> metody w celu dodania obsługi, które wymagają informacji o stanie do asynchronicznego strony sieci Web. Przekazany obiekt `state` parametr może być dowolny obiekt wymaganych przez aplikację do przekazywania informacji między delegatów obsługi zdarzeń określony w `beginHandler` i `endHandler` parametrów.  
  
 Możesz zarejestrować wielu obsług asynchroniczne; jednak tylko jeden obsługi jest uruchamiany w czasie. Jeśli chcesz jednocześnie przetwarzać wiele metod asynchronicznych, należy użyć pojedynczej <xref:System.Web.BeginEventHandler> — metoda i uruchamianie wielu operacji asynchronicznych z programu obsługi.  
  
 Asynchroniczne wywołania między <xref:System.Web.UI.Control.PreRender> i <xref:System.Web.UI.Page.PreRenderComplete> zdarzenia.  
  
 Najpierw wszystkie <xref:System.Web.UI.Page> zdarzenia (za pośrednictwem <xref:System.Web.UI.Control.PreRender> zdarzeń) uruchom, a następnie każdy zarejestrowanych <xref:System.Web.BeginEventHandler> metoda jest wywoływana. Podczas obsługi zakończeniu odpowiadającego <xref:System.Web.EndEventHandler> metoda jest wywoływana. W przypadku wielu obsług asynchroniczne jest nazywany dalej programu obsługi.  
  
 Po wywołaniu obsługi zarejestrowanych zdarzeń asynchroniczne pozostałe zdarzenia strony są nazywane, począwszy od <xref:System.Web.UI.Page.PreRenderComplete> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje asynchroniczne żądanie, aby wyświetlić kod źródłowy HTML strony domyślne lokalnego serwera sieci Web w <xref:System.Web.UI.WebControls.TextBox> formantu.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="&lt;async&gt;" /> Dyrektywy strony nie jest ustawiony na <see langword="true" />.  \- lub - <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> metoda jest wywoływana po wykonaniu <see cref="E:System.Web.UI.Control.PreRender" /> zdarzeń.</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> Lub <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected internal void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddWrappedFileDependencies (virtualFileDependencies As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddWrappedFileDependencies(System::Object ^ virtualFileDependencies);" />
      <MemberSignature Language="F#" Value="member this.AddWrappedFileDependencies : obj -&gt; unit" Usage="page.AddWrappedFileDependencies virtualFileDependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">
          <see cref="T:System.Object" /> Zawierający listę nazw plików.</param>
        <summary>Dodaje listę plików zależnych, które składają się na bieżącej stronie. Ta metoda jest używana wewnętrznie przez architekturę stron ASP.NET i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A> Metoda dodaje listę plików, takich jak pliki kontrolek użytkownika, które składają się na bieżącej stronie. W przypadku tych stronach modyfikacji całego strona ma być kompilowana następnym razem, gdy jest żądany. Ta metoda obsługuje infrastrukturę programu .NET Framework i nie jest przeznaczona do użycia bezpośrednio w kodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.UI.Page.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.HttpApplicationState" /> dla bieżącego żądania sieci Web.</summary>
        <value>Bieżące dane w <see cref="T:System.Web.HttpApplicationState" /> klasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page.Application_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AspCompatBeginProcessRequest (context As HttpContext, cb As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AspCompatBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ cb, System::Object ^ extraData);" />
      <MemberSignature Language="F#" Value="member this.AspCompatBeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult" Usage="page.AspCompatBeginProcessRequest (context, cb, extraData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Informacje o bieżącym żądaniu.</param>
        <param name="cb">Metoda wywołania zwrotnego.</param>
        <param name="extraData">Dodatkowe dane potrzebne do przetwarzania żądania w taki sam sposób jak żądania ASP.</param>
        <summary>Inicjuje żądanie zasobów strony ASP (Active Server). Ta metoda jest zapewnia zgodność z starszych aplikacji ASP.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AspCompatEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AspCompatEndProcessRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.AspCompatEndProcessRequest : IAsyncResult -&gt; unit" Usage="page.AspCompatEndProcessRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Strona ASP generowane przez żądanie.</param>
        <summary>Kończy żądanie dla zasobów strony ASP (Active Server). Ta metoda jest zapewnia zgodność z starszych aplikacji ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AspCompatMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AspCompatMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AspCompatMode : bool with get, set" Usage="System.Web.UI.Page.AspCompatMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia wartość wskazującą, czy strony można wykonywać w wątku jednowątkowego apartamentu (STA).</summary>
        <value>
          <see langword="true" /> Jeśli strona obsługuje kod Active Server Pages (ASP); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `true`, ta właściwość umożliwia strony ma być wykonywana w wątku jednowątkowego apartamentu (STA). Dzięki temu stronę, aby wywołać STA składniki, takie jak składniki utworzonych w języku Visual Basic 6.0. Ustawienie tej właściwości na `true` umożliwia również stronę, aby wywoływać składniki modelu COM +, które wymagają dostępu do niezarządzanego wbudowanych obiektów ASP. Są one dostępne za pośrednictwem ASP `ObjectContext` obiektu lub `OnStartPage` metody.  
  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw `aspcompat` atrybutu `true` użycie dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AsyncMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AsyncMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncMode : bool with get, set" Usage="System.Web.UI.Page.AsyncMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia wartość wskazującą, czy strony są przetwarzane synchronicznie lub asynchronicznie.</summary>
        <value>
          <see langword="true" /> Jeśli strona jest przetwarzane asynchronicznie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AsyncMode%2A> Właściwość jest ustawiana przez <xref:System.Web.UI.Page> analizator podczas generowania kodu dla strony. Użyj `Async` atrybutu w dyrektywie, ustaw tę wartość.  
  
 Asynchroniczne strony nie działają podczas `AspCompat` atrybut ma ustawioną `true` lub `Transaction` atrybut ma ustawioną wartość innych niż `Disabled` w dyrektywie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AsyncPageBeginProcessRequest (context As HttpContext, callback As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AsyncPageBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ callback, System::Object ^ extraData);" />
      <MemberSignature Language="F#" Value="member this.AsyncPageBeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult" Usage="page.AsyncPageBeginProcessRequest (context, callback, extraData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla żądania.</param>
        <param name="callback">Metoda wywołania zwrotnego, które mają zostać powiadomione po zakończeniu procesu.</param>
        <param name="extraData">Dane stanu dla metody asynchronicznej.</param>
        <summary>Rozpoczyna przetwarzanie żądania asynchroniczne strony.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się żądania asynchronicznego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AsyncPageEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AsyncPageEndProcessRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.AsyncPageEndProcessRequest : IAsyncResult -&gt; unit" Usage="page.AsyncPageEndProcessRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Odwołuje się do oczekującego żądania asynchronicznego.</param>
        <summary>Kończy się przetwarzanie żądania asynchroniczne strony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AsyncTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncTimeout : TimeSpan with get, set" Usage="System.Web.UI.Page.AsyncTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą interwał limitu czasu, używane podczas przetwarzania zadania asynchronicznego.</summary>
        <value>A <see cref="T:System.TimeSpan" /> zawierający przedział czasu dozwolony na ukończenie zadania asynchronicznego. Domyślny interwał wynosi 45 sekund.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Limit czasu asynchronicznego strony reprezentuje ilość czasu oczekiwania strony do wykonywania zadań asynchronicznych. W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw na stronie asynchronicznego limitu czasu interwału za pomocą pliku konfiguracji sieci Web lub w dyrektywie. Wartości w sekcji konfiguracji strony zostaną zastąpione w dyrektywie strony.  
  
 Zdefiniuj przy użyciu zadania asynchronicznego <xref:System.Web.UI.PageAsyncTask> klasy i zarejestruj początkowego, kończenie i obsługi limitu czasu. Jeśli zadanie asynchroniczne nie zostanie zakończone w określonym przedziale czasu, zostanie wywołany program obsługi limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.Page.AsyncTimeout%2A> właściwości o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> i <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metody. Zwróć uwagę na użycie początku, kończenie i limit czasu obsługi. W tym przykładzie sztuczne opóźnienie wprowadzane do pokazują sytuacji zadanie asynchroniczne przekroczenia limitu czasu przydzielonego do zadania, jak określono w <xref:System.Web.UI.Page.AsyncTimeout%2A> właściwości. W rzeczywistych scenariuszy zadanie asynchroniczne może posłużyć do wykonania wywołania bazy danych lub generowania obrazu, na przykład i obsługi limitu czasu udostępnia bezpieczne degradacji, jeśli zadanie nie jest wykonywane w określonym czasie. Należy pamiętać, że <xref:System.Web.UI.Page.AsyncTimeout%2A> właściwość jest ustawiona w dyrektywie page.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Właściwość została ustawiona na wartość ujemną.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPostBackControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ AutoPostBackControl { System::Web::UI::Control ^ get(); void set(System::Web::UI::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AutoPostBackControl : System.Web.UI.Control with get, set" Usage="System.Web.UI.Page.AutoPostBackControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontrolki na stronie, która jest używana do wykonywania ogłaszania zwrotnego.</summary>
        <value>Formant, który służy do wykonywania ogłaszania zwrotnego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.UI.Page.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia wartość wskazującą, czy dane wyjściowe strony są buforowane.</summary>
        <value>
          <see langword="true" /> Jeśli dane wyjściowe strony są buforowane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw <xref:System.Web.UI.Page.Buffer%2A> atrybutu `true` użycie dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.Buffer%2A> Właściwość ustawia i pobiera <xref:System.Web.HttpResponse.BufferOutput%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.UI.Page.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.Caching.Cache" /> obiekt skojarzony z aplikacją, w której znajduje się strony.</summary>
        <value>
          <see cref="T:System.Web.Caching.Cache" /> Skojarzoną z aplikacją strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja <xref:System.Web.Caching.Cache> obiekt umożliwia przechowywanie i pobieranie dowolne dane dla kolejnych żądań. Pamięć podręczna nie jest specjalnie skojarzony z sesją strony lub użytkownika. Jest on używany głównie w celu zwiększenia wydajności aplikacji. Aby uzyskać więcej informacji, zobacz [buforowanie danych aplikacji](http://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d). Aby uzyskać więcej informacji o różnicę między aplikacji w pamięci podręcznej i buforowania danych wyjściowych strony, zobacz [ASP.NET buforowanie omówienie](http://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d).  
  
   
  
## Examples  
 Poniższy przykład kodu wstawia sumę dwóch liczb całkowitych do <xref:System.Web.Caching.Cache?displayProperty=nameWithType> przy użyciu <xref:System.Web.UI.Page.Cache%2A?displayProperty=nameWithType> właściwości. Następnie pobiera wartość, przy użyciu <xref:System.Web.Caching.Cache.Get%2A?displayProperty=nameWithType> — metoda i zapisuje go do <xref:System.Web.UI.WebControls.Label> formant serwera sieci Web.  
  
 [!code-csharp[System.Web.Page.Cache_Replacement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache_Replacement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Wystąpienie <see cref="T:System.Web.Caching.Cache" /> nie zostanie utworzony.</exception>
        <altmember cref="T:System.Web.Caching.Cache" />
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientQueryString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientQueryString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientQueryString : string" Usage="System.Web.UI.Page.ClientQueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera część ciągu zapytania żądanego adresu URL.</summary>
        <value>Część ciągu zapytania żądanego adresu URL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ClientQueryString%2A> Właściwość zawiera część ciągu zapytania żądanego przez przeglądarkę adresu URL. Na przykład, jeśli jest żądany adres URL "http://www.contoso.com/default.aspx?id=100", <xref:System.Web.UI.Page.ClientQueryString%2A> będzie zawierać właściwości "id = 100". <xref:System.Web.UI.Page.ClientQueryString%2A> Właściwości jest zakodowany; użyj <xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=nameWithType> metody zdekodować ciągu zapytania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientScript As ClientScriptManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ClientScriptManager ^ ClientScript { System::Web::UI::ClientScriptManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientScript : System.Web.UI.ClientScriptManager" Usage="System.Web.UI.Page.ClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.UI.ClientScriptManager" /> obiekt używany do zarządzania, rejestrowania i dodać skrypt do strony.</summary>
        <value>A <see cref="T:System.Web.UI.ClientScriptManager" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.Page.ClientScript%2A> właściwości do pobrania <xref:System.Web.UI.ClientScriptManager> obiektu, który może służyć do zarządzania, rejestrowania i dodać skrypt do strony sieci Web. Aby uzyskać więcej informacji, zobacz <xref:System.Web.UI.ClientScriptManager> klasy.  
  
 <xref:System.Web.UI.ClientScriptManager> Klasa jest nowa w [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] i zastępuje <xref:System.Web.UI.Page> klasy metod zarządzania skrypty, które obecnie są przestarzałe.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Web.UI.ClientScriptManager> temat klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientTarget As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientTarget { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientTarget : string with get, set" Usage="System.Web.UI.Page.ClientTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która umożliwia zastępowanie automatycznego wykrywania możliwości przeglądarki i określ sposób renderowania strony dla klientów przeglądarki.</summary>
        <value>A <see cref="T:System.String" /> , który określa możliwości przeglądarki, które chcesz zastąpić.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ustawisz <xref:System.Web.UI.Page.ClientTarget%2A> właściwość <xref:System.Web.HttpBrowserCapabilities> obiekt skojarzony z <xref:System.Web.UI.Page.Request%2A?displayProperty=nameWithType> właściwość odzwierciedla możliwości przeglądarki klienta. Jeśli ta właściwość jest ustawiona, wykrywanie przeglądarki klienta jest wyłączone i strony użyje funkcji przeglądarki skojarzone z wartością (alias) podane.  
  
 Głównego pliku konfiguracji Web.config na komputerze serwera sieci Web definiuje następujące domyślne aliasy służące jako skrót dla typowych ciągów agent użytkownika:  
  
-   `uplevel`, który określa możliwości przeglądarki odpowiednikiem programu Internet Explorer 6.0.  
  
-   `downlevel`, który określa możliwości przeglądarki odpowiednikiem starszych przeglądarek, które nie obsługują skrypt po stronie klienta. Aby określić, jak strony sieci Web będzie działać w przeglądarce, która ma wyłączone skrypt po stronie klienta można użyć tego aliasu.  
  
 Alias programowo przy użyciu tej właściwości można ustawić lub możesz ustawić deklaratywnie przy użyciu `ClientTarget` atrybutu dyrektywy.  
  
 Można zdefiniować dodatkowe aliasy w `clientTarget` sekcji w pliku Web.config poziomie aplikacji. Aby uzyskać więcej informacji, zobacz [clientTarget — Element (schemat ustawień programu ASP.NET)](http://msdn.microsoft.com/library/17a0fa6e-a065-49cc-b900-ef73eda6a922).  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje `ie302` alias i zawiera sekcje potrzebne do skonfigurowania aplikacji w pliku Web.config. Za pomocą tego aliasu, można ustawić <xref:System.Web.UI.Page.ClientTarget%2A> właściwości `ie302` i dostosowywanie stron specjalnie dla przeglądarki Internet Explorer 3.02.  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CodePage { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int with get, set" Usage="System.Web.UI.Page.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa identyfikator strony kodu dla bieżącej <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Liczba całkowita, która reprezentuje identyfikator strony kodu dla bieżącej <see cref="T:System.Web.UI.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw `CodePage` atrybutu wartości przy użyciu dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.UI.Page.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia typ HTTP MIME <see cref="T:System.Web.HttpResponse" /> obiekt skojarzony ze stroną.</summary>
        <value>Typ HTTP MIME skojarzony z bieżącą stroną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw `ContentType` atrybutu przy użyciu dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Page.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.HttpContext" /> obiekt skojarzony ze stroną.</summary>
        <value>
          <see cref="T:System.Web.HttpContext" /> Obiekt, który zawiera informacje związane z bieżącej strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia dostęp programistyczny do kontekstu, w którym strona działa, wraz z informacjami dotyczącymi żądania, odpowiedzi i sesji oraz aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.UI.Page.Context%2A> właściwości, aby uzyskać dostęp do <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> i <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> metod i <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> właściwości. W przykładzie jest tworzony trzy niestandardowymi wyjątkami za pomocą <xref:System.Web.HttpContext.AddError%2A> — metoda i używa <xref:System.Web.HttpContext.AllErrors%2A> właściwości można załadować tych wyjątków do tablicy. Następnie zapisuje tablicy do strony zawierającej i używa <xref:System.Web.HttpContext.ClearError%2A> metodę, aby wyczyścić wszystkie błędy z <xref:System.Web.UI.Page.Context%2A> właściwości.  
  
 [!code-csharp[System.Web.UI.Page.Context#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateHtmlTextWriter (tw As TextWriter) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriter(System::IO::TextWriter ^ tw);" />
      <MemberSignature Language="F#" Value="abstract member CreateHtmlTextWriter : System.IO.TextWriter -&gt; System.Web.UI.HtmlTextWriter&#xA;override this.CreateHtmlTextWriter : System.IO.TextWriter -&gt; System.Web.UI.HtmlTextWriter" Usage="page.CreateHtmlTextWriter tw" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw">
          <see cref="T:System.IO.TextWriter" /> Użyty do utworzenia <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <summary>Tworzy <see cref="T:System.Web.UI.HtmlTextWriter" /> obiektu do renderowania zawartości strony.</summary>
        <returns>
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Lub <see cref="T:System.Web.UI.Html32TextWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> Metoda tworzy <xref:System.IO.TextWriter> za pośrednictwem <xref:System.Web.HttpRequest.Browser%2A> właściwość <xref:System.Web.HttpContext.Request%2A> obiekt skojarzony z żądaniem strony. Można dodać odwołania do <xref:System.Web.UI.HtmlTextWriter> w `browserCaps` sekcji konfiguracji. Zastąpienie <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> metodę w celu wyszukiwania niestandardowego.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> metodę w celu utworzenia wystąpienia niestandardowego <xref:System.Web.UI.HtmlTextWriter> obiektu o nazwie `MyHtmlTextWriter`. <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> Metoda zostanie przesłonięta w `MyPage` klasy, która jest pochodną <xref:System.Web.UI.Page>, dzięki czemu `MyHtmlTextWriter` renderowanie kontrolek serwera ASP.NET, gdy strona zostanie wywołana. Należy pamiętać, że w tym przykładzie uniemożliwi karty <xref:System.IO.TextWriter> zachowanie.  
  
 [!code-csharp[Page_CreateHtmlTextWriter#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page_CreateHtmlTextWriter#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Html32TextWriter" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateHtmlTextWriterFromType (tw As TextWriter, writerType As Type) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriterFromType(System::IO::TextWriter ^ tw, Type ^ writerType);" />
      <MemberSignature Language="F#" Value="static member CreateHtmlTextWriterFromType : System.IO.TextWriter * Type -&gt; System.Web.UI.HtmlTextWriter" Usage="System.Web.UI.Page.CreateHtmlTextWriterFromType (tw, writerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
        <Parameter Name="writerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tw">
          <see cref="T:System.IO.TextWriter" /> Użyty do utworzenia <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <param name="writerType">Typ składnika zapisywania tekstu do utworzenia.</param>
        <summary>Tworzy określony <see cref="T:System.Web.UI.HtmlTextWriter" /> obiektu do renderowania zawartości strony.</summary>
        <returns>
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Która renderuje zawartość strony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana wewnętrznie w strony karty.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="writerType" /> Parametr ma wartość nieprawidłowego typu.</exception>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Culture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : string with get, set" Usage="System.Web.UI.Page.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia identyfikator kultury <see cref="T:System.Threading.Thread" /> obiekt skojarzony ze stroną.</summary>
        <value>Identyfikator prawidłową kulturą.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw `Culture` atrybutu dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia wartość tej właściwości. Ponadto można również jawnie ustawić wartość <xref:System.Web.UI.Page.Culture%2A> właściwości programowo lub w elemencie w pliku Web.config pliku.  
  
 <xref:System.Web.UI.Page.Culture%2A> Właściwość jest używana w celu zlokalizowania zawartości strony. Można ją ustawić na dowolnym identyfikator prawidłową kulturą. Na przykład `en-us` identyfikator kultury ustawia strony amerykańskim angielskim, podczas `fr` identyfikator kultury ustawia strony na język francuski. Można również ustawić wartość `auto` które wykona automatyczne wykrywanie przeglądarki preferowany język i ustaw go. Automatyczne wykrywanie języka może być kwalifikowany za pomocą wartości domyślnej takich jak `auto:en-us`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo> Przegląd klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub DesignerInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DesignerInitialize();" />
      <MemberSignature Language="F#" Value="member this.DesignerInitialize : unit -&gt; unit" Usage="page.DesignerInitialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje inicjowanie wystąpienia <see cref="T:System.Web.UI.Page" /> klasy, która jest wymagana przez projektantów RAD. Ta metoda jest używana tylko w czasie projektowania.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.UserControl.DesignerInitialize" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackMode () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackMode();" />
      <MemberSignature Language="F#" Value="abstract member DeterminePostBackMode : unit -&gt; System.Collections.Specialized.NameValueCollection&#xA;override this.DeterminePostBackMode : unit -&gt; System.Collections.Specialized.NameValueCollection" Usage="page.DeterminePostBackMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.Specialized.NameValueCollection" /> danych publikowanych strony za pomocą polecenia GET lub POST.</summary>
        <returns>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> obiekt, który zawiera dane formularza. Jeśli ogłaszania zwrotnego używane polecenie wpisu, informacje z formularza jest zwracana z <see cref="P:System.Web.UI.Page.Context" /> obiektu. Jeśli ogłaszania zwrotnego używane polecenia GET, jest zwracana informacji o ciągu zapytania. Jeśli po raz pierwszy żąda strony <see langword="null" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.DeterminePostBackMode%2A> Metoda zwraca <xref:System.Collections.Specialized.NameValueCollection> obiekt, który zawiera dane przesłane wróć do strony. Obecność strony ukryte pola VIEWSTATE i EVENTTARGET jest używana w celu określenia, czy wystąpił zdarzenia odświeżania strony. <xref:System.Web.UI.Page.IsPostBack%2A> Właściwości jest ustawiana podczas <xref:System.Web.UI.Page.DeterminePostBackMode%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackModeUnvalidated () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackModeUnvalidated();" />
      <MemberSignature Language="F#" Value="abstract member DeterminePostBackModeUnvalidated : unit -&gt; System.Collections.Specialized.NameValueCollection&#xA;override this.DeterminePostBackModeUnvalidated : unit -&gt; System.Collections.Specialized.NameValueCollection" Usage="page.DeterminePostBackModeUnvalidated " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję nazwy i wartości danych, które zostało przesłane do strony przy użyciu POST lub GET polecenia, bez wykonywania sprawdzania poprawności żądania ASP.NET na żądanie.</summary>
        <returns>Obiekt zawierający niezweryfikowane dane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Web.UnvalidatedRequestValues> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableEventValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableEventValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableEventValidation : bool with get, set" Usage="System.Web.UI.Page.EnableEventValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy strona weryfikuje zdarzenia odświeżania strony i wywołania zwrotnego.</summary>
        <value>
          <see langword="true" /> Jeśli strona weryfikuje zdarzenia odświeżania strony i wywołania zwrotnego; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Web.UI.Page.EnableEventValidation%2A> właściwość jest ustawiona na `true`, ASP.NET sprawdza, czy zdarzenia formantu pochodzi z interfejsu użytkownika, który był renderowany przez tego formantu. Formant rejestruje jego zdarzeń podczas renderowania i następnie weryfikuje podczas odświeżania lub wywołania zwrotnego obsługi zdarzeń. Na przykład jeśli formant listy zawiera opcje numerowane 1, 2 lub 3 podczas renderowania strony i odebranie odświeżania strony żądania określenie opcji numer 4, ASP.NET spowodują zgłoszenie wyjątku. Domyślnie wszystkie formanty sterowane zdarzeniami w programie ASP.NET używają tej funkcji.  
  
 Podczas pisania skryptu klienta, który zmienia formantu w kliencie w czasie wykonywania, może być konieczne użycie <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metody, aby uniknąć błędów sprawdzania poprawności zdarzeń wartość false.  
  
> [!IMPORTANT]
>  Ta funkcja ogranicza ryzyko nieautoryzowani lub złośliwi odświeżania strony żądań i wywołania zwrotne. Zdecydowanie zaleca się, że nie można wyłączyć sprawdzanie poprawności zdarzenia.  
  
 Możesz ustawić <xref:System.Web.UI.Page.EnableEventValidation%2A> właściwości przez ustawienie `enableEventValidation` atrybutu dyrektywy lub `enableEventValidation` atrybut elementu w pliku Web.config. Jeśli ta właściwość jest ustawiona w kodzie, należy ustawić go przed zainicjowaniem strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.EnableEventValidation" /> Właściwość została ustawiona po stronie został zainicjowany.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
        <altmember cref="T:System.Web.UI.SupportsEventValidationAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Page.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy strona zachowuje swój stan widoku, oraz stan widoku dowolnego serwera kontrolek, kiedy zawiera bieżącego żądania strony.</summary>
        <value>
          <see langword="true" /> Jeśli strona zachowuje swój stan widoku; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dowiedzieć się, jak Dlaczego warto wyłączyć stan widoku, zobacz <xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=nameWithType>.  
  
 Nawet jeśli <xref:System.Web.UI.Page.EnableViewState%2A> jest `false`, strona może zawierać pola stanu widoku ukryte, które jest używana przez platformę ASP.NET do wykrywania odświeżania strony.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Web.UI.Page.EnableViewState%2A> właściwości `false` po załadowaniu strony. Powoduje wyłączenie stanu widoku <xref:System.Web.UI.Page> obiektu, co oznacza są zapisywane informacje o stanie widoku strony ani wszystkie formanty zawarte przez stronę.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewStateMac" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableViewStateMac As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableViewStateMac { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewStateMac : bool with get, set" Usage="System.Web.UI.Page.EnableViewStateMac" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ASP.NET, należy sprawdzić kod uwierzytelniania wiadomości (MAC) w stanie widoku strony, gdy strona jest przesyłana z powrotem od klienta.</summary>
        <value>
          <see langword="true" /> Jeśli stan widoku powinny być MAC zaznaczone i kodowany; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 MAC stan widoku jest zaszyfrowana wersja ukrytej zmiennej jest utrwalonego stan widoku danej strony w przypadku, gdy strona jest wysyłany do przeglądarki. Jeśli ta właściwość jest równa `true`, zaszyfrowany stan widoku jest zaznaczone, aby sprawdzić, czy nie został zmodyfikowany z na kliencie.  
  
 Nie należy ustawiać tej właściwości w kodzie. Ustaw `EnableViewStateMac` atrybutu przy użyciu dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
> [!IMPORTANT]
>  Ten atrybut nie powinno być używane `false` w środowisku produkcyjnym witryny sieci Web, nawet wtedy, gdy aplikacja lub strona nie używa stanu widoku. Stan widoku, który pomaga MAC zabezpieczenia innych funkcji programu ASP.NET, oprócz stanu widoku.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewState" />
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorPage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorPage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorPage : string with get, set" Usage="System.Web.UI.Page.ErrorPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia stronę błędu, do którego kierowane jest żądanie przeglądarki w przypadku strony nieobsługiwany wyjątek.</summary>
        <value>Strona błędu, do którego zostanie przekierowany przeglądarki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page_ErrorPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page_ErrorPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecuteRegisteredAsyncTasks ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecuteRegisteredAsyncTasks();" />
      <MemberSignature Language="F#" Value="member this.ExecuteRegisteredAsyncTasks : unit -&gt; unit" Usage="page.ExecuteRegisteredAsyncTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna wykonywanie zadanie asynchroniczne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdefiniuj zadanie asynchroniczne przy użyciu <xref:System.Web.UI.PageAsyncTask> klasy. Po zadania jest zdefiniowany i jest zarejestrowana w usłudze przy użyciu strony <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metody <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> można wywołać metody rozpoczęcia zadania asynchronicznego.  
  
 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Automatycznie wywoływana jest metoda w tym punkcie przetwarzania strony, gdy wszelkie zarejestrowane zadania asynchroniczne, jeśli istnieją, są wywoływane ze stroną asynchronicznego. To wywołanie automatyczne <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> występuje tuż przed <xref:System.Web.UI.Page.PreRenderComplete> zdarzeń. Wywołanie <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metody dla zadań, które ma zostać wywołana w czasie niż automatyczne wywołanie tej metody. Uwaga: zadania asynchroniczne będą wykonywane tylko raz, nawet jeśli <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> można wywołać więcej niż raz.  
  
 <xref:System.Web.UI.Page.AsyncTimeout%2A> Właściwości jest resetowany przy każdym wywołaniu do <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metody. Ostatnia wartość <xref:System.Web.UI.Page.AsyncTimeout%2A> przed wywołaniem <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metody pierwszeństwo. Jeśli zadanie asynchroniczne przyjmuje więcej niż <xref:System.Web.UI.Page.AsyncTimeout%2A>, kolejne zadania wywoływane podczas tego <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> są upłynął limit czasu połączenia natychmiast.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.Page.AsyncTimeout%2A> właściwości o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> i <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metody. Zwróć uwagę na użycie początku, kończenie i limit czasu obsługi. W tym przykładzie sztuczne opóźnienie wprowadzane do pokazują sytuacji zadanie asynchroniczne przekroczenia limitu czasu przydzielonego do zadania, jak określono w <xref:System.Web.UI.Page.AsyncTimeout%2A> właściwości. W rzeczywistych scenariuszy zadanie asynchroniczne może posłużyć do wykonania wywołania bazy danych lub generowania obrazu, na przykład i obsługi limitu czasu udostępnia bezpieczne degradacji, jeśli zadanie nie jest wykonywane w określonym czasie.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Brak wyjątków w zadaniu asynchronicznym.</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberSignature Language="VB.NET" Value="Protected Property FileDependencies As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::ArrayList ^ FileDependencies {  void set(System::Collections::ArrayList ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FileDependencies : System.Collections.ArrayList" Usage="System.Web.UI.Page.FileDependencies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia tablicę plików, który bieżącego <see cref="T:System.Web.HttpResponse" /> jest zależny od obiektu.</summary>
        <value>Tablica plików bieżącego <see cref="T:System.Web.HttpResponse" /> jest zależny od obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przestarzała. Użyj <xref:System.Web.HttpResponse.AddFileDependencies%2A> metody lub <xref:System.Web.HttpResponse.AddFileDependency%2A> metody <xref:System.Web.HttpResponse> zamiast klasy.  
  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw `FileDependencies` atrybutu `true` użycie dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="override this.FindControl : string -&gt; System.Web.UI.Control" Usage="page.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Identyfikator formantu, który ma zostać odnaleziona.</param>
        <summary>Przeszukuje strony kontenera nazewnictwa dla kontrolki serwera, o podanym identyfikatorze.</summary>
        <returns>Określony formant lub <see langword="null" /> Jeśli określony formant nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FindControl%2A> Metody można użyć do kontroli dostępu do których <xref:System.Web.UI.Control.ID%2A> nie jest dostępny w czasie projektowania. Metoda szuka tylko strony natychmiastowa lub najwyższego poziomu, kontener. go nie nie rekursywnie wyszukiwania dla formantów w kontenerach nazewnictwa znajdujących się na stronie. Aby uzyskać dostęp do formantów w kontenerze nazewnictwa podrzędnego, należy wywołać `FindControl` metoda tego kontenera.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Web.UI.Page.FindControl%2A> metodą lokalizowania formantów wewnątrz szablonów. W tym przykładzie dwa <xref:System.Web.UI.WebControls.Repeater> zdefiniowanych formantów; każdy zawiera inny sposób, aby wykryć <xref:System.Web.UI.WebControls.LinkButton.Click> zdarzenie <xref:System.Web.UI.WebControls.LinkButton> wewnątrz szablon elementu powtarzanego.  
  
 [!code-aspx-csharp[System.Web.UI.Page_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As HtmlForm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlForm ^ Form { System::Web::UI::HtmlControls::HtmlForm ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Web.UI.HtmlControls.HtmlForm" Usage="System.Web.UI.Page.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera formularza HTML strony.</summary>
        <value>
          <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> Obiekt skojarzony ze stroną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.Page.Form%2A> dostęp do metody i właściwości dla właściwości <xref:System.Web.UI.HtmlControls.HtmlForm> obiektu, który jest podstawą hierarchii kontrolki na stronie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FrameworkInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FrameworkInitialize();" />
      <MemberSignature Language="F#" Value="override this.FrameworkInitialize : unit -&gt; unit" Usage="page.FrameworkInitialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje drzewa formantów podczas generowania strony oparte na deklaratywne charakter strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FrameworkInitialize%2A> Inicjuje metody <xref:System.Web.UI.Page> obiektu i tworzy drzewa formantów oparte na deklaratywne charakter strony. <xref:System.Web.UI.Page.FrameworkInitialize%2A> Metoda zostanie przesłonięta przez generowania analizowania i kodu strony dla <xref:System.Web.UI.Page> klasy deklaratywne strony. Zazwyczaj powinien nie za pośrednictwem należy przesłonić tę metodę. Jeśli zastąpienie, należy wywołać klasy podstawowej <xref:System.Web.UI.Page.FrameworkInitialize%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDataItem () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetDataItem();" />
      <MemberSignature Language="F#" Value="member this.GetDataItem : unit -&gt; obj" Usage="page.GetDataItem " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera element danych w górnej części Stos kontekstu wiązania z danymi.</summary>
        <returns>Obiekt w górnej części Stos kontekstu powiązania danych.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Nie jest kontekst wiązania z danymi strony.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientEvent(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientEvent : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackClientEvent (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formantu serwera, który odbiera zdarzenie ogłaszania zwrotnego klienta.</param>
        <param name="argument">A <see cref="T:System.String" /> przekazywany do <see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" />.</param>
        <summary>Pobiera odwołanie, którego można użyć w przypadku klienta można opublikować na serwerze dla określonego formantu i z argumentami określone zdarzenie.</summary>
        <returns>Ciąg, który reprezentuje zdarzenie klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Web.UI.ClientScriptManager> klasy dla alternatywy dla tego elementu przestarzałe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.Button.OnClientClick" />
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolki serwera do przetworzenia ogłaszania zwrotnego.</param>
        <param name="argument">Parametr przekazany do kontrolki serwera.</param>
        <summary>Pobiera odwołanie, z <see langword="javascript:" /> dołączany na początku, używany w przypadku klienta w publikowania na serwerze dla określonego formantu i z argumentami określone zdarzenie.</summary>
        <returns>Ciąg reprezentujący wywołanie JavaScript do funkcji odświeżania strony, która zawiera argumenty Formant docelowy identyfikator i zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> metody zamiast tego przestarzałe elementu członkowskiego.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg, który może być używany w przypadku klienta, powoduje odświeżenie strony do serwera. Ta metoda jest przestarzała. Użyj <see cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" /> metoda <see cref="T:System.Web.UI.ClientScriptManager" /> zamiast klasy.</summary>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control -&gt; string" Usage="page.GetPostBackEventReference control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolki serwera do przetworzenia ogłaszania zwrotnego na serwerze.</param>
        <summary>Zwraca ciąg, który może być używany w przypadku klienta, powoduje odświeżenie strony do serwera. Ciąg odwołania jest zdefiniowany przez określony <see cref="T:System.Web.UI.Control" /> obiektu.</summary>
        <returns>Ciąg znaków, gdy traktowane jako skryptu po stronie klienta, inicjuje ogłaszania zwrotnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przestarzała. Użyj <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda <xref:System.Web.UI.ClientScriptManager> zamiast klasy.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page_GetPostBackEventReference#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolki serwera do przetworzenia ogłaszania zwrotnego.</param>
        <param name="argument">Parametr przekazany do kontrolki serwera.</param>
        <summary>Zwraca ciąg, który może być używany w przypadku klienta, powoduje odświeżenie strony do serwera. Ciąg odwołania jest określony przez określony formant, który obsługuje ogłaszania zwrotnego i argument ciągu informacji dodatkowych zdarzeń.</summary>
        <returns>Ciąg znaków, gdy traktowane jako skryptu po stronie klienta, inicjuje ogłaszania zwrotnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przestarzała. Użyj <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metoda <xref:System.Web.UI.ClientScriptManager> zamiast klasy.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page_GetPostBackEventReference#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetTypeHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeHashCode : unit -&gt; int&#xA;override this.GetTypeHashCode : unit -&gt; int" Usage="page.GetTypeHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu, który jest generowany przez <see cref="T:System.Web.UI.Page" /> obiektów, które są generowane w czasie wykonywania. Ta wartość skrótu jest unikatowa dla <see cref="T:System.Web.UI.Page" /> obiektu kontroli hierarchii.</summary>
        <returns>Wartość skrótu wygenerowane w czasie wykonywania. Wartość domyślna to 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie zastępuje tę metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValidators (validationGroup As String) As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::ValidatorCollection ^ GetValidators(System::String ^ validationGroup);" />
      <MemberSignature Language="F#" Value="member this.GetValidators : string -&gt; System.Web.UI.ValidatorCollection" Usage="page.GetValidators validationGroup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Grupy sprawdzania poprawności do zwrócenia, lub <see langword="null" /> do zwrócenia sprawdzania poprawności domyślnej grupy.</param>
        <summary>Zwraca kolekcję kontroli moduły sprawdzania poprawności określonej grupy.</summary>
        <returns>A <see cref="T:System.Web.UI.ValidatorCollection" /> zawierający formant moduły weryfikacji dla grupy określonej sprawdzania poprawności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetValidators%2A> Metoda zwraca wszystkie obiekty weryfikacji skojarzony z grupą weryfikacji określonych. Może zwrócić sprawdzania poprawności domyślnej grupy (wszystkie formanty walidacji skojarzone z formantami bez `ValidationGroup` zestaw właściwości), ustawiając `validationGroup` parametr `null`.  
  
 Aby sprawdzić poprawność członkami grupy sprawdzania poprawności, można wyliczyć nad zbieraniem i wywołanie <xref:System.Web.UI.IValidator.Validate%2A> zwróciła metodę każdego modułu sprawdzania poprawności.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.UI.Page.GetValidators%2A> metodę, aby zwrócić sprawdzania poprawności domyślnej grupy.  
  
 [!code-csharp[PageGetValidators#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.Validate(System.String)" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetWrappedFileDependencies (virtualFileDependencies As String()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetWrappedFileDependencies(cli::array &lt;System::String ^&gt; ^ virtualFileDependencies);" />
      <MemberSignature Language="F#" Value="member this.GetWrappedFileDependencies : string[] -&gt; obj" Usage="page.GetWrappedFileDependencies virtualFileDependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Tablica ciągów lokalizacji pliku wirtualnego.</param>
        <summary>Zwraca listę nazw plików fizycznych, które odpowiadają do listy lokalizacji pliku wirtualnego.</summary>
        <returns>Obiekt zawierający listę lokalizacji pliku fizycznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A> Metoda pobiera listę plików, takich jak pliki kontrolek użytkownika, które składają się na bieżącej stronie. W przypadku tych stronach modyfikacji całego strona ma być kompilowana następnym razem, gdy jest żądany. Nie zastępuje tę metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Header As HtmlHead" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlHead ^ Header { System::Web::UI::HtmlControls::HtmlHead ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Header : System.Web.UI.HtmlControls.HtmlHead" Usage="System.Web.UI.Page.Header" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dokument nagłówka strony, jeśli <see langword="head" /> jest zdefiniowany element o <see langword="runat=server" /> w deklaracji strony.</summary>
        <value>
          <see cref="T:System.Web.UI.HtmlControls.HtmlHead" /> Zawierający nagłówka strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Header%2A> Właściwości pobiera odwołanie do <xref:System.Web.UI.HtmlControls.HtmlHead> obiektów, której można ustawić dokumentu informacji w nagłówku strony. <xref:System.Web.UI.HtmlControls.HtmlHead> Można dodawać informacje, takie jak arkusze stylów, reguły stylu, tytuł i metadane `head` elementu.  
  
> [!NOTE]
>  Dodawanie style programowo przy użyciu metody <xref:System.Web.UI.IStyleSheet> interfejs podczas asynchronicznego ogłaszania zwrotnego nie jest obsługiwany. Po dodaniu możliwości technologii AJAX do strony sieci Web asynchroniczne ogłaszanie zwrotne aktualizacji regiony strony bez aktualizowania całej strony. Aby uzyskać więcej informacji, zobacz [Microsoft Ajax omówienie](http://msdn.microsoft.com/library/be84d9b3-b7cd-47d7-8494-be4abfaad9cb).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób uzyskiwania dostępu do <xref:System.Web.UI.HtmlControls.HtmlHead> kontrolować programowo przy użyciu <xref:System.Web.UI.Page.Header%2A> właściwości. A `title` elementu i `style` elementu są dodawane do `head` elementu strony.  
  
 [!code-aspx-csharp[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlHead" />
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlLink" />
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Page.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia identyfikator dla konkretnego wystąpienia <see cref="T:System.Web.UI.Page" /> klasy.</summary>
        <value>Identyfikator wystąpienia <see cref="T:System.Web.UI.Page" /> klasy. Wartość domyślna to "_Page".</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Page.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera znak używany do rozdzielania identyfikatory sterowania podczas kompilowania Unikatowy identyfikator formantu na stronie.</summary>
        <value>Znak używany do rozdzielania identyfikatory formantu. Domyślnie jest ustawiony <see cref="T:System.Web.UI.Adapters.PageAdapter" /> wystąpienia, który renderuje stronę. <see cref="P:System.Web.UI.Page.IdSeparator" /> Jest polem po stronie serwera i nie powinien być modyfikowany.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.ID" />
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InitComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ InitComplete;" />
      <MemberSignature Language="F#" Value="member this.InitComplete : EventHandler " Usage="member this.InitComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu inicjowania strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitComplete> Zdarzenie jest wywoływane po zakończeniu etapu inicjowania strony. Na tym etapie cyklu życia strony zadeklarowany wszystkie formanty na stronie są inicjowane, ale nie jest jeszcze wypełniona stanu strony. Formanty serwera można uzyskać dostęp, ale ich nie będą jeszcze zawierać informacje zwracane przez użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [NIB: Korzystanie z zdarzenia](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeCulture ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeCulture();" />
      <MemberSignature Language="F#" Value="abstract member InitializeCulture : unit -&gt; unit&#xA;override this.InitializeCulture : unit -&gt; unit" Usage="page.InitializeCulture " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia <see cref="P:System.Web.UI.Page.Culture" /> i <see cref="P:System.Web.UI.Page.UICulture" /> dla bieżącego wątku strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitializeCulture%2A> Metoda zawiera nie kodowania logiki. Kontrolowanie deweloperzy rozszerzania funkcji programu <xref:System.Web.UI.Page> klasy można zastąpić <xref:System.Web.UI.Page.InitializeCulture%2A> metodę, aby zainicjować <xref:System.Web.UI.Page.Culture%2A> i <xref:System.Web.UI.Page.UICulture%2A> informacji dla strony.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.Web.UI.Page.FrameworkInitialize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje wyjściowej pamięci podręcznej dla bieżącego żądania strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest przeznaczona do użycia bezpośrednio w kodzie. Aby włączyć i manipulowania buforowanie danych wyjściowych strony, użyj jednej z tych metod:  
  
-   Ustaw opcje deklaratywnie użycie dyrektywy w pliku .aspx.  
  
-   Użyj metody i właściwości <xref:System.Web.HttpCachePolicy> klasy, która jest udostępniana przez `Response.Cache` obiektu w kodzie strony.  
  
 Aby uzyskać więcej informacji, zobacz [stron ASP.NET buforowanie](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected internal virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub InitOutputCache (cacheSettings As OutputCacheParameters)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void InitOutputCache(System::Web::UI::OutputCacheParameters ^ cacheSettings);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : System.Web.UI.OutputCacheParameters -&gt; unit&#xA;override this.InitOutputCache : System.Web.UI.OutputCacheParameters -&gt; unit" Usage="page.InitOutputCache cacheSettings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" />
      </Parameters>
      <Docs>
        <param name="cacheSettings">
          <see cref="T:System.Web.UI.OutputCacheParameters" /> Zawierający ustawienia pamięci podręcznej.</param>
        <summary>Inicjuje wyjściowej pamięci podręcznej dla bieżącego żądania strony na podstawie <see cref="T:System.Web.UI.OutputCacheParameters" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy wywołać tę metodę. Aby włączyć i manipulowania buforowanie danych wyjściowych strony, należy użyć dyrektywy w pliku aspx lub metody i właściwości <xref:System.Web.HttpCachePolicy> klasy. Te ostatnie są dostępne za pośrednictwem `Response.Cache` składni w strony deklaracji bloku lub kodu powiązanego pliku kodu. Aby uzyskać więcej informacji, zobacz [stron ASP.NET buforowanie](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie znaleziono profilu pamięci podręcznej.  \- lub - Brak dyrektywy ani ustawienia konfiguracji atrybutu profilu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Lokalizacja ustawienia pamięci podręcznej danych wyjściowych jest nieprawidłowa.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : int * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit&#xA;override this.InitOutputCache : int * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit" Usage="page.InitOutputCache (duration, varyByHeader, varyByCustom, location, varyByParam)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">Ilość czasu, które obiekty przechowywane w wyjściowej pamięci podręcznej są prawidłowe.</param>
        <param name="varyByHeader">Rozdzielana średnikami lista nagłówków, których zawartość z pamięci podręcznej danych wyjściowych będzie zależeć od.</param>
        <param name="varyByCustom">
          <see langword="Vary" /> Nagłówka HTTP.</param>
        <param name="location">Jeden z <see cref="T:System.Web.UI.OutputCacheLocation" /> wartości.</param>
        <param name="varyByParam">Rozdzielana średnikami lista odebranych przez metodę GET lub POST zawartość z pamięci podręcznej danych wyjściowych będzie zależeć od parametrów.</param>
        <summary>Inicjuje wyjściowej pamięci podręcznej dla bieżącego żądania strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy wywołać tę metodę. Aby włączyć i manipulowania buforowanie danych wyjściowych strony, należy użyć dyrektywy w pliku aspx lub metody i właściwości <xref:System.Web.HttpCachePolicy> klasy. Te ostatnie są dostępne za pośrednictwem `Response.Cache` składni w kodzie strony. Aby uzyskać więcej informacji, zobacz [stron ASP.NET buforowanie](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono nieprawidłową wartość dla <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByContentEncoding As String, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByContentEncoding, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : int * string * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit&#xA;override this.InitOutputCache : int * string * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit" Usage="page.InitOutputCache (duration, varyByContentEncoding, varyByHeader, varyByCustom, location, varyByParam)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByContentEncoding" Type="System.String" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">Ilość czasu, które obiekty przechowywane w wyjściowej pamięci podręcznej są prawidłowe.</param>
        <param name="varyByContentEncoding">Rozdzielana średnikami lista zestawów znaków (kodowań zawartości) zawartości z pamięci podręcznej danych wyjściowych będzie różnią się zależnie od.</param>
        <param name="varyByHeader">Rozdzielana średnikami lista nagłówków, których zawartość z pamięci podręcznej danych wyjściowych będzie zależeć od.</param>
        <param name="varyByCustom">
          <see langword="Vary" /> Nagłówka HTTP.</param>
        <param name="location">Jeden z <see cref="T:System.Web.UI.OutputCacheLocation" /> wartości.</param>
        <param name="varyByParam">Rozdzielana średnikami lista odebranych przez metodę GET lub POST zawartość z pamięci podręcznej danych wyjściowych będzie zależeć od parametrów.</param>
        <summary>Inicjuje wyjściowej pamięci podręcznej dla bieżącego żądania strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy wywołać tę metodę. Aby włączyć i manipulowania buforowanie danych wyjściowych strony, należy użyć dyrektywy w pliku aspx lub metody i właściwości <xref:System.Web.HttpCachePolicy> klasy. Te ostatnie są dostępne za pośrednictwem `Response.Cache` składni w kodzie strony. Aby uzyskać więcej informacji, zobacz [stron ASP.NET buforowanie](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono nieprawidłową wartość dla <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.Web.UI.Page.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy strony są przetwarzane asynchronicznie.</summary>
        <value>
          <see langword="true" /> Jeśli strona jest w trybie asynchronicznym; w przeciwnym razie <see langword="false" />;</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.Page.IsAsync%2A> właściwości w celu określenia, czy strona sieci Web jest uruchomiony w trybie asynchronicznym. Informacje te są przydatne, jeśli formanty lub kodu na stronie muszą modyfikowanie ich zachowania w zależności od tego, czy strona jest asynchroniczne. Aby uzyskać więcej informacji na temat programowania asynchronicznego, zobacz [operacji asynchronicznych](~/docs/framework/data/adonet/sql/asynchronous-operations.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCallback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCallback : bool" Usage="System.Web.UI.Page.IsCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie strony jest wynikiem wywołania zwrotnego.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie dostępu do strony jest wynikiem wywołania zwrotnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [implementacja klienta wywołania zwrotne bez ogłaszania zwrotnego](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="page.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz ciągu skryptu klienta do wyszukiwania.</param>
        <summary>Określa, czy ze stroną jest zarejestrowane w bloku skryptu klienta z określonym kluczem.</summary>
        <returns>
          <see langword="true" /> Jeśli blok skryptu jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=nameWithType> w celu uniknięcia niepotrzebnie zebrania skryptu po stronie klienta. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu utworzenia.  
  
 <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> Metoda jest przestarzała. Użyj <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metoda <xref:System.Web.UI.ClientScriptManager> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> w połączeniu z metody <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> metody. Jeśli ECMAScript napisany w bloku kodu deklaracji nie już został zarejestrowany, zgodnie z ustaleniami <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, a następnie <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> nawiązane połączenie.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCrossPagePostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCrossPagePostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCrossPagePostBack : bool" Usage="System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy strona jest używany w funkcji odświeżania strony między stronami.</summary>
        <value>
          <see langword="true" /> Jeśli strona bierze udział w żądaniu między stronami; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program ASP.NET udostępnia dwa mechanizmy przesyłania kontroli z jedną stronę. Można użyć <xref:System.Web.HttpServerUtility.Transfer%2A> metody transferu przetwarzania między stronami, lub można utworzyć żądanie między stronami, przypisując adres URL strony do <xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A> właściwości kontrolki przycisku, który implementuje <xref:System.Web.UI.WebControls.IButtonControl> interfejsu.  
  
 W obu przypadkach <xref:System.Web.UI.Page.PreviousPage%2A> właściwości strony będzie zawierać obiekt, który reprezentuje poprzednią lub osoba tworząca stronę. Jeśli na przykład, A strona przesyła je strony B, A strona <xref:System.Web.UI.Page.IsCrossPagePostBack%2A> właściwości (dostępny za pośrednictwem <xref:System.Web.UI.Page.PreviousPage%2A> właściwości) będzie `true` i strona B <xref:System.Web.UI.Page.PreviousPage%2A> właściwość będzie mieć nazwę strony a.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.IButtonControl.PostBackUrl" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostBack : bool" Usage="System.Web.UI.Page.IsPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy strona jest renderowany po raz pierwszy lub jest ładowany w odpowiedzi na odświeżenie strony.</summary>
        <value>
          <see langword="true" /> Jeśli strona jest ładowany w odpowiedzi na odświeżenie strony klienta; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opis różnicy między ogłaszania zwrotnego i wywołania zwrotne, zawiera [implementacja klienta wywołania zwrotne bez ogłaszania zwrotnego](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób testowania wartości <xref:System.Web.UI.Page.IsPostBack%2A> właściwości podczas ładowania strony w celu ustalenia, czy strona jest renderowany po raz pierwszy lub odpowiada na odświeżenie strony. Jeśli strona jest renderowany po raz pierwszy, kod wywołuje <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> metody.  
  
 Znaczników (tego nie pokazano) zawiera <xref:System.Web.UI.WebControls.RequiredFieldValidator> formanty, które wyświetlają gwiazdek, jeśli wpis nie jest wymagane pola wejściowego. Wywołanie <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> powoduje, że gwiazdek, który będzie wyświetlany natychmiast po wyrenderowaniu strony, zamiast czekać, aż użytkownik kliknie przycisk przesyłania. Po odświeżeniu strony, nie trzeba wywołać <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>, ponieważ ta metoda jest wywoływana w ramach <xref:System.Web.UI.Page> cyklu życia.  
  
 [!code-csharp[System.Web.UI.Page.Validate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.Page.IsCallback" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBackEventControlRegistered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBackEventControlRegistered { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostBackEventControlRegistered : bool" Usage="System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontrolki na stronie, które wykonuje ogłaszania zwrotnego został zarejestrowany.</summary>
        <value>
          <see langword="true" /> czy formant ma został zarejestrowany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReusable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReusable : bool" Usage="System.Web.UI.Page.IsReusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.IHttpHandler.IsReusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Web.UI.Page" /> obiektu mogą być ponownie używane.</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.IHttpHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="page.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ciąg klucz uruchomienia skryptu do wyszukania.</param>
        <summary>Określa, czy skrypt uruchamiania klienta jest zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli skrypt uruchamiania jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody przed wywołaniem <xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=nameWithType> w celu uniknięcia niepotrzebnie zebrania skryptu po stronie klienta. Jest to szczególnie ważne, jeśli skrypt wymaga dużej ilości zasobów serwera w celu utworzenia.  
  
 <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> Metoda jest przestarzała. Użyj <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metoda <xref:System.Web.UI.ClientScriptManager> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.Page.RegisterStartupScript%2A> w połączeniu z metody <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> metody. Jeśli ECMAScript napisany w bloku kodu deklaracji nie już został zarejestrowany, zgodnie z ustaleniami <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>, a następnie <xref:System.Web.UI.Page.RegisterStartupScript%2A> nawiązane połączenie.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValid : bool" Usage="System.Web.UI.Page.IsValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy strona Sprawdzanie poprawności zakończyło się pomyślnie.</summary>
        <value>
          <see langword="true" /> Jeśli strona Sprawdzanie poprawności zakończyło się pomyślnie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla tej właściwości zwrócić `true`, pomyślnie sprawdzić wszystkie kontrolki serwera weryfikacji w bieżącej grupie sprawdzania poprawności. Należy sprawdzić tę właściwość, tylko po wywołaniu <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> metody lub zestawu `CausesValidation` właściwości `true` w `OnServerClick` programu obsługi zdarzeń dla formantu serwera ASP.NET, który inicjuje przetwarzania formularza. Są dostępne następujące kontrolki serwera <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.HtmlControls.HtmlButton>, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, <xref:System.Web.UI.WebControls.ImageButton>, i <xref:System.Web.UI.WebControls.LinkButton> klasy.  
  
 Jeśli wymusisz sprawdzania poprawności grupy weryfikacji przy użyciu <xref:System.Web.UI.Page.Validate%2A> metody, a następnie wszystkie formanty walidacji w grupie weryfikacji określonego zweryfikować pomyślnie również.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Web.UI.Page.IsValid%2A> właściwości do skonfigurowania instrukcji warunkowej. Jeśli właściwość zwraca `true`, `Text` właściwość `lblOutput` formantu ma ustawioną wartość "Strony jest nieprawidłowy"! W przeciwnym razie wartość jest równa "Niektóre z wymaganych pól są puste."  
  
 [!code-csharp[System.Web.UI.Page.Validate#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.UI.Page.IsValid" /> Właściwości jest wywoływana przed podczas sprawdzania poprawności.</exception>
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="M:System.Web.UI.Page.Validate" />
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.UI.Page.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę obiektów przechowywanych w kontekście strony.</summary>
        <value>Odwołanie do <see cref="T:System.Collections.IDictionary" /> zawierające obiekty przechowywane w kontekście strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.Page.Items%2A> właściwość, aby przechowywać obiekty z tym samym okresem istnienia jako żądania strony. Ta właściwość jest tylko do odczytu. można jednak dodać obiekty do <xref:System.Collections.IDictionary> obiekt zwraca.  
  
 Obiekty dodane do <xref:System.Web.UI.Page.Items%2A> właściwości są dostępne przez cały okres istnienia strony, dzięki czemu można dodać obiekty do <xref:System.Web.UI.Page.Items%2A> właściwość w zdarzeniach wczesnym etapie cyklu życia strony cyklu i dostęp do tych obiektów w późniejszym zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberSignature Language="VB.NET" Value="Public Property LCID As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LCID { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.LCID : int with get, set" Usage="System.Web.UI.Page.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa identyfikator ustawień regionalnych dla <see cref="T:System.Threading.Thread" /> obiekt skojarzony ze stroną.</summary>
        <value>Identyfikator ustawień regionalnych, które zostaną przekazane do <see cref="T:System.Threading.Thread" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. `LCID` Atrybut można określać w dyrektywie plików .aspx, jednak preferowaną metodą ustalenia identyfikator ustawień regionalnych jest za pośrednictwem <xref:System.Web.UI.Page.Culture%2A> i <xref:System.Web.UI.Page.UICulture%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
        <altmember cref="P:System.Web.UI.Page.UICulture" />
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LoadComplete;" />
      <MemberSignature Language="F#" Value="member this.LoadComplete : EventHandler " Usage="member this.LoadComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu etapu obciążenia cyklu życia strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadComplete> Po wszystkich odświeżania strony danych wystąpienia zdarzenia i dane stanu widoku są ładowane do strony oraz po <xref:System.Web.UI.Control.OnLoad%2A> dla wszystkich kontrolek na stronie zostanie wywołana metoda.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [NIB: Korzystanie z zdarzenia](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function LoadPageStateFromPersistenceMedium () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ LoadPageStateFromPersistenceMedium();" />
      <MemberSignature Language="F#" Value="abstract member LoadPageStateFromPersistenceMedium : unit -&gt; obj&#xA;override this.LoadPageStateFromPersistenceMedium : unit -&gt; obj" Usage="page.LoadPageStateFromPersistenceMedium " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ładunki dowolne zapisane informacje o stanie widoku <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Stan zapisanego widoku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> Używa metody <xref:System.Web.UI.PageStatePersister.Load%2A> metody <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> zawiera odwołanie do obiektu <xref:System.Web.UI.Page.PageStatePersister%2A> właściwość, aby załadować dowolne zapisane informacje o stanie widoku <xref:System.Web.UI.Page> obiektu.  
  
 Program ASP.NET zawiera dwa potomków <xref:System.Web.UI.PageStatePersister> klasy <xref:System.Web.UI.HiddenFieldPageStatePersister> klasy, która zapisuje informacje o stanie w ukrytym polu objęte strony ASP.NET i <xref:System.Web.UI.SessionPageStatePersister> klasy, która zapisuje stan w <xref:System.Web.UI.Page.Session%2A> obiekt skojarzony z żądanie.  
  
 Aby zapisać stan w wybranej lokalizacji, należy utworzyć nowy podrzędny <xref:System.Web.UI.PageStatePersister> klasy, która zapisuje i ładuje stan średni trwałości wybranych przez użytkownika. Na przykład tworzenia nowego <xref:System.Web.UI.PageStatePersister> obiektów, zobacz <xref:System.Web.UI.PageStatePersister> klasy.  
  
 Jeśli używasz programu .NET Framework w wersji 1.0 lub 1.1 przesłonić tę metodę, jeśli chcesz załadować <xref:System.Web.UI.Page> stanu z innym niż ukryte pole. Jeśli wybierzesz to zrobić, należy również zmienić <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="VB.NET" Value="Public Property MaintainScrollPositionOnPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaintainScrollPositionOnPostBack { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MaintainScrollPositionOnPostBack : bool with get, set" Usage="System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy mają być zwracane użytkownika do tej samej pozycji w przeglądarce klienta po odświeżeniu strony. Ta właściwość zastępuje przestarzałe <see cref="P:System.Web.UI.Page.SmartNavigation" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli pozycja klienta należy utrzymywać; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy stron sieci Web są przesyłana z powrotem na serwer, użytkownika jest zwracana do górnej części strony. Na stronach sieci Web długie oznacza to, że użytkownik będzie musiał przewiń stronę do ostatniej pozycji na stronie.  
  
 Gdy <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> właściwość jest ustawiona na `true`, użytkownik jest zamiast tego zwracany do ostatniej pozycji na stronie.  
  
 Możesz ustawić <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> właściwości w [@ Page](http://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) dyrektywy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="page.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">A <see cref="T:System.String" /> reprezentujący ścieżkę wirtualną.</param>
        <summary>Pobiera ścieżkę fizyczną, mapowana na ścieżkę wirtualną bezwzględny lub względny lub ścieżka względna aplikacji.</summary>
        <returns>Ścieżka fizyczna skojarzonego ze ścieżki wirtualnej lub ścieżki względnej aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.UI.Page.MapPath%2A> Właściwość potencjalnie mogą zawierać poufne informacje o środowisku macierzystym. Wartość zwracana powinna niewidoczne dla użytkowników.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Web.UI.Page.MapPath%2A> metody uzyskanie ścieżkę fizyczną podfolderu. Następnie dołącza nazwy pliku, który zostanie odczytany z <xref:System.Web.UI.WebControls.TextBox.Text%2A> właściwość <xref:System.Web.UI.WebControls.TextBox> formantu. Wynik jest bezwzględna ścieżka fizyczna do tego pliku.  
  
 [!code-csharp[Page_MapPath_ResponseEncoding#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page_MapPath_ResponseEncoding#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Master As MasterPage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::MasterPage ^ Master { System::Web::UI::MasterPage ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Master : System.Web.UI.MasterPage" Usage="System.Web.UI.Page.Master" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera określający ogólny wygląd strony strony wzorcowej.</summary>
        <value>
          <see cref="T:System.Web.UI.MasterPage" /> Skojarzone z tą stroną, jeśli istnieje; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Master%2A> Zwraca <xref:System.Web.UI.MasterPage> obiekt skojarzony z tą stroną. Ta właściwość jest tylko do odczytu. jednak można ustawić właściwości na <xref:System.Web.UI.MasterPage> obiekt zwraca.  
  
 <xref:System.Web.UI.Page.Master%2A> Właściwość jest prawidłowa tylko dla stron, które odwołują się do strony głównej w <xref:System.Web.UI.Page.MasterPageFile%2A> właściwości. Jeśli dostęp do <xref:System.Web.UI.Page.Master%2A> właściwości na stronie, która nie odwołuje się do strony głównej `null` jest zwracany. Zawartość strony wzorcowej nie są dostępne dopiero po <xref:System.Web.UI.Page.PreInit> zdarzeń został zgłoszony.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.MasterPageFile" />
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MasterPageFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ MasterPageFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MasterPageFile : string with get, set" Usage="System.Web.UI.Page.MasterPageFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę wirtualną strony wzorcowej.</summary>
        <value>Wirtualna ścieżka strony wzorcowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.MasterPageFile%2A> Właściwość jest ścieżki wirtualnej (w katalogu głównym aplikacji) skojarzone z tą stroną pliku strony wzorcowej. <xref:System.Web.UI.Page.MasterPageFile%2A> Właściwości można ustawić tylko w <xref:System.Web.UI.Page.PreInit> zdarzeń; próba skonfigurowania <xref:System.Web.UI.Page.MasterPageFile%2A> właściwości po <xref:System.Web.UI.Page.PreInit> zgłosi zdarzeń <xref:System.InvalidOperationException> wyjątku. Jeśli <xref:System.Web.UI.Page.MasterPageFile%2A> właściwość jest nieprawidłowa, wyjątek typu <xref:System.Web.HttpException> jest zgłaszany w dalszej części cyklu życia strony, ale żaden wyjątek jest zgłaszany, gdy właściwość jest ustawiona <xref:System.Web.UI.Page.PreInit> zdarzeń.  
  
 Stron, które mają <xref:System.Web.UI.Page.MasterPageFile%2A> zestaw właściwości strony zawartości i dlatego mogą zawierać tylko najwyższego poziomu kontrolki, których <xref:System.Web.UI.WebControls.Content> kontrolki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.MasterPageFile" /> Właściwości jest ustawiany po <see cref="E:System.Web.UI.Page.PreInit" /> zdarzeń jest pełny.</exception>
        <exception cref="T:System.Web.HttpException">Plik określony w <see cref="P:System.Web.UI.Page.MasterPageFile" /> właściwość nie istnieje.  \- lub - stronie nie ma <see cref="T:System.Web.UI.WebControls.Content" /> formant jako formant najwyższego poziomu.</exception>
        <altmember cref="P:System.Web.UI.Page.Master" />
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPageStateFieldLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPageStateFieldLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPageStateFieldLength : int with get, set" Usage="System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną długość pola stanu strony.</summary>
        <value>Maksymalna długość w bajtach dla pola stanu strony. Wartość domyślna to -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> właściwość jest ustawiona na wartość dodatnią, wysyłany do przeglądarki klienta, stan widoku jest dzielony na wielu ukryte pola i wartość każdego pola jest mniejsza niż rozmiar określony we <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> właściwości.  
  
 Ustawienie <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> właściwość ujemnej liczby (ustawienie domyślne) wskazuje, czy pole stanu widoku nie powinna być oddzielona na fragmenty o różnych. Ustawienie <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> do małą liczbą może spowodować obniżenie wydajności.  
  
 Ustaw wartość <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> właściwości w pliku Web.config.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> Właściwość nie jest równa -1 lub liczbą dodatnią.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> Właściwość została ustawiona po stronie został zainicjowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MetaDescription : string with get, set" Usage="System.Web.UI.Page.MetaDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość "opis" <see langword="meta" /> elementu.</summary>
        <value>Zawartość "opis" <see langword="meta" /> elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` elementów może służyć do poprawy listy aparatu wyszukiwania. "Opis" `meta` element jest używany przez wyszukiwarki zwiększające podglądy listy.  
  
 Jeśli istnieje "opis" `meta` element `head` element znaczników, `meta` element zostanie dodany do strony podczas renderowania strony. Jeśli już znaczników "opis" `meta` elementu, ta właściwość pobiera lub ustawia `content` atrybutu `meta` elementu.  
  
 Tę właściwość można też ustawić w dyrektywie.  
  
   
  
## Examples  
 Jeśli ustawisz <xref:System.Web.UI.Page.MetaDescription%2A> właściwości strony "Platformy ASP.NET — omówienie", następujący element pojawi się w renderowanym HTML:  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strona nie ma formantu nagłówka ( <see langword="head" /> element z <see langword="runat" /> określić dla atrybutu "server").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaKeywords" />
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaKeywords As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaKeywords { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MetaKeywords : string with get, set" Usage="System.Web.UI.Page.MetaKeywords" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość "słów kluczowych" <see langword="meta" /> elementu.</summary>
        <value>Zawartość "słów kluczowych" <see langword="meta" /> elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` elementów może służyć do poprawy listy aparatu wyszukiwania. "Słów kluczowych" `meta` elementu albo nie jest używany w ogóle lub znajduje się bardzo mało wagi przez aparaty wyszukiwania głównych.  
  
 Jeśli nie istnieje "słów kluczowych" `meta` element `head` element znaczników, `meta` element zostanie dodany do strony podczas renderowania strony. Jeśli już znaczników "słów kluczowych" `meta` elementu, ta właściwość pobiera lub ustawia `content` atrybutu `meta` elementu.  
  
 Tę właściwość można też ustawić w dyrektywie.  
  
   
  
## Examples  
 Jeśli ustawisz <xref:System.Web.UI.Page.MetaKeywords%2A> właściwości strony "HTML, CSS, XML, JavaScript", następujący element pojawi się w renderowanym HTML:  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strona nie ma formantu nagłówka ( <see langword="head" /> element z <see langword="runat" /> określić dla atrybutu "server").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaDescription" />
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelBindingExecutionContext As ModelBindingExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelBindingExecutionContext ^ ModelBindingExecutionContext { System::Web::ModelBinding::ModelBindingExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ModelBindingExecutionContext : System.Web.ModelBinding.ModelBindingExecutionContext" Usage="System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kontekst realizacji powiązania modelu.</summary>
        <value>Kontekst realizacji powiązania modelu. Jeśli kontekst realizacji powiązania modelu jest <see langword="null" />, nowy jednego nie zostanie utworzona i zwrócona.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelState As ModelStateDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelStateDictionary ^ ModelState { System::Web::ModelBinding::ModelStateDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ModelState : System.Web.ModelBinding.ModelStateDictionary" Usage="System.Web.UI.Page.ModelState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt słownika stanów modelu, który zawiera stan modelu i sprawdzanie poprawności powiązania modelu.</summary>
        <value>Obiekt słownika stanów modelu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Samouczek serii na użyciu wiązania modelu formularzy sieci Web, zobacz [wiązania modelu i formularzy sieci Web](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="page.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Web.UI.Control.Init" /> zdarzeń do zainicjowania strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInit%2A> Metoda wykonuje kroki inicjowania i ustawienia wymagane do utworzenia <xref:System.Web.UI.Page> wystąpienia. Na tym etapie cyklu życia strony zainicjowaniem kontrolek serwera zadeklarowane na stronie do stanu domyślnego; jednak stan widoku każdego formantu nie jest jeszcze wypełniona. Kontrolki na stronie nie ma dostępu do innych kontrolek serwera na stronie podczas `Page_Init` fazy, niezależnie od tego, czy kontrolki podrzędnej lub nadrzędnej inne formanty. Inne formanty serwera nie ma gwarancji utworzony i gotowa do dostępu.  
  
 <xref:System.Web.UI.Page.OnInit%2A> Metoda jest wywoływana po wykonaniu <xref:System.Web.UI.Page.OnPreInit%2A> — metoda i przed <xref:System.Web.UI.Page.OnInitComplete%2A> metody.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Web.UI.Page.OnInit%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitComplete : EventArgs -&gt; unit&#xA;override this.OnInitComplete : EventArgs -&gt; unit" Usage="page.OnInitComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Web.UI.Page.InitComplete" /> zdarzeń po zainicjowaniu strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInitComplete%2A> Metoda jest wywoływana po zakończeniu inicjowania strony. Na tym etapie cyklu życia strony zadeklarowany wszystkie kontrolki na stronie są inicjowane, ale nie jest jeszcze wypełniona stan widoku danej strony. Formanty serwera można uzyskać dostęp, ale ich nie będą jeszcze zawierać informacje zwracane przez użytkownika.  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A> Metody występuje na końcu <xref:System.Web.UI.Page> etapie inicjalizacji i przed etapem obciążenia.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadComplete : EventArgs -&gt; unit&#xA;override this.OnLoadComplete : EventArgs -&gt; unit" Usage="page.OnLoadComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Web.UI.Page.LoadComplete" /> zdarzeń po zakończeniu etapu ładowania strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnLoadComplete%2A> Metoda jest wywoływana po zakończeniu etapu ładowania strony. W tym momencie w cyklu życia strony, wszystkich danych odświeżania strony i stan widoku danych została załadowana do formantów na stronie.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Web.UI.Page.OnLoadComplete%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreInit : EventArgs -&gt; unit&#xA;override this.OnPreInit : EventArgs -&gt; unit" Usage="page.OnPreInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Web.UI.Page.PreInit" /> zdarzeń na początku inicjowania strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreInit%2A> Metoda jest wywoływana na początku fazie inicjowania strony.  
  
 Po <xref:System.Web.UI.Page.OnPreInit%2A> metoda jest wywoływana, załadowanie informacji personalizacji i motywu strony, jeśli istnieje, jest zainicjowany. Jest preferowanym etap do definiowania dynamicznie <xref:System.Web.UI.PageTheme> lub <xref:System.Web.UI.MasterPage> dla strony.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Web.UI.Page.OnPreInit%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreLoad : EventArgs -&gt; unit&#xA;override this.OnPreLoad : EventArgs -&gt; unit" Usage="page.OnPreLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Web.UI.Page.PreLoad" /> zdarzenia po odświeżania strony danych jest ładowany do formantów strony serwera, ale przed wysłaniem <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreLoad%2A> Metoda jest wywoływana po wszystkich odświeżania strony danych zwróconych przez użytkownika jest ładowany. Na tym etapie cyklu życia strony stan widoku informacje i dane odświeżania strony zadeklarowane jako formantów i formanty utworzone w fazie inicjowania są ładowane do formantów strony.  
  
 Formanty utworzone w <xref:System.Web.UI.Page.OnPreLoad%2A> metody również zostanie załadowany z danymi stan widoku oraz odświeżania strony.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Web.UI.Page.OnPreLoad%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreRenderComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreRenderComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRenderComplete : EventArgs -&gt; unit&#xA;override this.OnPreRenderComplete : EventArgs -&gt; unit" Usage="page.OnPreRenderComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Web.UI.Page.PreRenderComplete" /> zdarzeń po <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> zdarzeń i przed realizacją strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A> Metoda jest wywoływana po zakończeniu prerendering etap cyklu życia strony. Na tym etapie cyklu życia strony wszystkie formanty są tworzone, a strona jest gotowy do renderowania danych wyjściowych.  
  
 Jest to ostatnie zdarzenie wywoływana przed zapisaniem stanu widoku strony.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSaveStateComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSaveStateComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSaveStateComplete : EventArgs -&gt; unit&#xA;override this.OnSaveStateComplete : EventArgs -&gt; unit" Usage="page.OnSaveStateComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> obiekt zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Web.UI.Page.SaveStateComplete" /> zdarzeń po zapisaniu stanu strony średni trwałości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A> Metoda jest wywoływana, gdy informacje o stanie dla formantu został zapisany na średni trwałości dla strony. Informacje o stanie są zapisywane na średni trwałości przez wywołanie metody <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> metody.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Page.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera karty, która renderuje stronę dla określonych przeglądarki.</summary>
        <value>
          <see cref="T:System.Web.UI.Adapters.PageAdapter" /> Która renderuje stronę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PageAdapter%2A> Właściwość zwraca konkretnym <xref:System.Web.UI.Adapters.PageAdapter> obiektu, która zmienia zachowanie <xref:System.Web.UI.Page> obiektu dla przeglądarki.  
  
 Konkretnym <xref:System.Web.UI.Adapters.PageAdapter> obiektu jest określana przez sprawdzenie właściwości przychodzącego <xref:System.Web.UI.Page.Request%2A> obiektu. Gdy adapter jest wybierany dla żądania, zdarzenia cyklu życia na <xref:System.Web.UI.Adapters.PageAdapter> obiektu Zastąp pokrewnych zdarzeń w <xref:System.Web.UI.Page> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property PageStatePersister As PageStatePersister" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::PageStatePersister ^ PageStatePersister { System::Web::UI::PageStatePersister ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageStatePersister : System.Web.UI.PageStatePersister" Usage="System.Web.UI.Page.PageStatePersister" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.UI.PageStatePersister" /> obiekt skojarzony ze stroną.</summary>
        <value>A <see cref="T:System.Web.UI.PageStatePersister" /> skojarzony ze stroną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądań i odpowiedzi HTTP są z założenia bezstanowe. Aby zachować stan między żądaniami HTTP, strony serwera ASP.NET mogą przechowywać <xref:System.Web.UI.Page> stanu. Ten stan, nazywany stan widoku składa się z strony i kontrola ustawień i danych, strony i formanty pojawiają się tak, jakby są takie same, jak, które użytkownik był wyświetlany i interakcji z na ich ostatniego obiegu do strony. Istnieje kilka mechanizmów do przechowywania stanu widoku między kolejnych żądań do tej samej strony. Abstract <xref:System.Web.UI.PageStatePersister> klasa reprezentuje klasę podstawową dla tych mechanizmów magazynu stanu.  
  
 Deweloperzy strony zwykle nie trzeba używać <xref:System.Web.UI.Page.PageStatePersister%2A> właściwości. <xref:System.Web.UI.Page.PageStatePersister%2A> Właściwość jest używana głównie przez deweloperów kontroli rozszerza funkcjonalność <xref:System.Web.UI.Page> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventArgumentID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventArgumentID;" />
      <MemberSignature Language="F#" Value="val mutable postEventArgumentID : string" Usage="System.Web.UI.Page.postEventArgumentID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ciąg, który definiuje ukryte pole EVENTARGUMENT na renderowanej stronie.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventSourceID" />
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventSourceID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventSourceID;" />
      <MemberSignature Language="F#" Value="val mutable postEventSourceID : string" Usage="System.Web.UI.Page.postEventSourceID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ciąg, który definiuje ukryte pole EVENTTARGET na renderowanej stronie.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventArgumentID" />
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreInit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreInit;" />
      <MemberSignature Language="F#" Value="member this.PreInit : EventHandler " Usage="member this.PreInit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed inicjowania strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia sprawdzenie warunków żądania strony, na przykład czy strony są ładowane w odpowiedzi na odświeżenie strony. Można również sprawdzić wartości właściwości profilu.  
  
 Zdarzenia można ustawić wartości, które są używane w dalszej części cyklu życia strony. Możesz dynamicznie strony wzorcowej lub motyw dla żądanej strony i utworzyć formantów dynamicznych.  
  
 Aby uzyskać więcej informacji na temat sposobu <xref:System.Web.UI.Page.PreInit> zdarzeń znajdzie się w cyklu życia ASP.NET, zobacz [Przegląd cyklu życia strony ASP.NET](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreLoad As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreLoad;" />
      <MemberSignature Language="F#" Value="member this.PreLoad : EventHandler " Usage="member this.PreLoad : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed stroną <see cref="E:System.Web.UI.Control.Load" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreLoad> Zdarzenie jest wywoływane po wszystkich ogłaszanie przetwarzania danych i przed <xref:System.Web.UI.Control.Load> zdarzeń. Brak druga próba załadowania odświeżania strony danych przed <xref:System.Web.UI.Page.OnLoadComplete%2A> zdarzeń. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [NIB: Korzystanie z zdarzenia](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRenderComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRenderComplete;" />
      <MemberSignature Language="F#" Value="member this.PreRenderComplete : EventHandler " Usage="member this.PreRenderComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed wyświetleniem zawartości strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreRenderComplete> Zdarzenie jest wywoływane po ukończeniu renderowania wstępnego etap cyklu życia strony. Na tym etapie cyklu życia strony wszystkie formanty są tworzone, wszelkie podział na strony wymagany jest ukończone i strona jest gotowy do renderowania danych wyjściowych.  
  
 Jest to ostatnie zdarzenie wywoływane przed zapisaniem stanu widoku strony.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [NIB: Korzystanie z zdarzenia](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousPage As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Page ^ PreviousPage { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousPage : System.Web.UI.Page" Usage="System.Web.UI.Page.PreviousPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strony, który przenosić formant do bieżącej strony.</summary>
        <value>
          <see cref="T:System.Web.UI.Page" /> Reprezentujący strony, który przenosić formant do bieżącej strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz <xref:System.Web.HttpServerUtility.Transfer%2A> metody lub użyj między stronami publikowanie do transferu przetwarzania z jednej strony ASP.NET do innego, źródłowego strona zawiera informacje o żądaniu, które mogą być wymagane dla strony docelowej. Można użyć <xref:System.Web.UI.Page.PreviousPage%2A> właściwość, aby dostęp do tych informacji.  
  
 Jeśli bieżąca strona jest renderowany w wyniku żądania bezpośredniego (nie transferu lub cross-post z innej strony), <xref:System.Web.UI.Page.PreviousPage%2A> zawiera właściwość `null`.  
  
   
  
## Examples  
 Poniższy przykład pochodzi z dwóch części. Pierwsza to strona ASP.NET używa <xref:System.Web.HttpServerUtility.Transfer%2A> metody widoczne w modelu strony jako `Server.Transfer("path")`. Druga część to strony docelowej, który używa <xref:System.Web.UI.Page.PreviousPage%2A> właściwości do pobrania tytuł pierwszej strony.  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący użytkownik nie może uzyskać dostępu do poprzedniej strony.  - lub - routingu platformy ASP.NET jest w użyciu i poprzedniej strony adres URL jest kierowany adresu URL. Aplikacja ASP.NET sprawdza uprawnienia dostępu, zakłada, że adres URL jest rzeczywistej ścieżce do pliku. Ponieważ nie jest to w przypadku routingiem adres URL, sprawdzenie nie powiedzie się.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ProcessRequest (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessRequest(System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ProcessRequest : System.Web.HttpContext -&gt; unit&#xA;override this.ProcessRequest : System.Web.HttpContext -&gt; unit" Usage="page.ProcessRequest context" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.IHttpHandler.ProcessRequest(System.Web.HttpContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Obiekt, który zawiera odwołania do wewnętrznych obiektów serwera (na przykład <see cref="P:System.Web.HttpContext.Request" />, <see cref="P:System.Web.HttpContext.Response" />, i <see cref="P:System.Web.HttpContext.Session" />) używane do obsługi żądań HTTP.</param>
        <summary>Ustawia wewnętrznych obiektów serwera z <see cref="T:System.Web.UI.Page" /> obiektów, takich jak <see cref="P:System.Web.UI.Page.Context" />, <see cref="P:System.Web.UI.Page.Request" />, <see cref="P:System.Web.UI.Page.Response" />, i <see cref="P:System.Web.UI.Page.Application" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy wywołać tę metodę.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Context" />
        <altmember cref="P:System.Web.UI.Page.Request" />
        <altmember cref="P:System.Web.UI.Page.Response" />
        <altmember cref="P:System.Web.UI.Page.Application" />
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (sourceControl As IPostBackEventHandler, eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::Web::UI::IPostBackEventHandler ^ sourceControl, System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : System.Web.UI.IPostBackEventHandler * string -&gt; unit&#xA;override this.RaisePostBackEvent : System.Web.UI.IPostBackEventHandler * string -&gt; unit" Usage="page.RaisePostBackEvent (sourceControl, eventArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">Formant serwera ASP.NET, który spowodował ogłaszania zwrotnego. Ten formant musi implementować <see cref="T:System.Web.UI.IPostBackEventHandler" /> interfejsu.</param>
        <param name="eventArgument">Argument odświeżania strony.</param>
        <summary>Powiadamia formantu serwera, który spowodował ogłaszania zwrotnego, który ma obsługiwać zdarzenia odświeżania strony przychodzącego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page> Obiektu wywołania <xref:System.Web.UI.Page.RaisePostBackEvent%2A> metody podczas odświeżania strony. To wywołanie występuje w cyklu życia strony po zakończeniu ładowania i zmień powiadomienie, ale przed prerendering występuje.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Web.UI.Page.RaisePostBackEvent%2A> metodę, aby powiadomić ASP.NET, czy zdarzenie po zwrotnego jest wywoływane, gdy niestandardowego `userButton` serwera formant zostanie kliknięty.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="page.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Nazwa tablicy, w której ma zostać deklaruje wartość.</param>
        <param name="arrayValue">Wartość można umieścić w tablicy.</param>
        <summary>Deklaruje wartość, która jest zadeklarowana jako deklarację tablicy ECMAScript podczas renderowania strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia przez formanty opartych na skryptach zgłosiły w macierzy tak, aby biblioteka skryptu klienta może współpracować z wszystkich kontrolek tego samego typu.  
  
 <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> Metoda jest przestarzała. Użyj <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metoda <xref:System.Web.UI.ClientScriptManager> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> metodę, aby zadeklarować tablicę, `myArray`, który zawiera trzy obiekty o nazwie `x`, `y`, i `z`. W przykładzie definiuje i rejestruje skryptu uruchamiania przy użyciu <xref:System.Web.UI.Page.RegisterStartupScript%2A> metody. Gdy ECMAScript `doClick` funkcja jest wywoływana ze strony, który zawiera ten kod, są inicjowane tablicy i jej obiektów.  
  
 [!code-csharp[Page_RegisterArrayDeclaration#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page_RegisterArrayDeclaration#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAsyncTask (task As PageAsyncTask)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAsyncTask(System::Web::UI::PageAsyncTask ^ task);" />
      <MemberSignature Language="F#" Value="member this.RegisterAsyncTask : System.Web.UI.PageAsyncTask -&gt; unit" Usage="page.RegisterAsyncTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" />
      </Parameters>
      <Docs>
        <param name="task">A <see cref="T:System.Web.UI.PageAsyncTask" /> definiuje zadanie asynchroniczne.</param>
        <summary>Rejestruje nowe zadanie asynchroniczne ze stroną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdefiniuj zadanie asynchroniczne przy użyciu <xref:System.Web.UI.PageAsyncTask> klasy. Jeśli zadanie jest zdefiniowana, należy użyć <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metodę, aby zarejestrować zadania ze stroną. Po zarejestrowaniu zadania, należy wywołać <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metody, aby rozpocząć zadanie asynchroniczne.  
  
 <xref:System.Web.UI.Page.RegisterAsyncTask%2A> Metody można używać ze stronami synchroniczne i asynchroniczne.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.Page.AsyncTimeout%2A> właściwości o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> i <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metody. Zwróć uwagę na użycie początku, kończenie i limit czasu obsługi. W tym przykładzie sztuczne opóźnienie wprowadzane do pokazują sytuacji zadanie asynchroniczne przekroczenia limitu czasu przydzielonego do zadania, jak określono w <xref:System.Web.UI.Page.AsyncTimeout%2A> właściwości. W rzeczywistych scenariuszy zadanie asynchroniczne może posłużyć do wykonania wywołania bazy danych lub generowania obrazu, na przykład i obsługi limitu czasu udostępnia bezpieczne degradacji, jeśli zadanie nie jest wykonywane w określonym czasie.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Zadanie asynchroniczne jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterClientScriptBlock (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterClientScriptBlock(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScriptBlock : string * string -&gt; unit&#xA;override this.RegisterClientScriptBlock : string * string -&gt; unit" Usage="page.RegisterClientScriptBlock (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy klucz, który identyfikuje blok skryptu.</param>
        <param name="script">Zawartość skryptu, który jest wysyłany do klienta.</param>
        <summary>Emituje blokach skryptu po stronie klienta do odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt po stronie klienta jest emitowany zaraz po znaczniku otwierającym <xref:System.Web.UI.Page> obiektu `<form runat= server>` elementu. Należy uwzględnić otwierające i zamykające `<script>` elementy wokół skrypt zablokować ciąg określony w `script` parametru.  
  
 Ponieważ ta metoda korzysta z klucza, aby zidentyfikować blok skryptu, blok skryptu nie ma być emitowane do strumienia wyjściowego za każdym razem, gdy jest żądany przez wystąpienie kontrolki inny serwer. Ponadto przy użyciu klucza zmniejsza prawdopodobieństwo wzajemnie zakłócać blokach skryptu inne formanty.  
  
 Dowolny skrypt bloki o takim samym `key` wartości parametrów są traktowane jako duplikaty.  
  
> [!NOTE]
>  Pamiętaj, aby uwzględnić tagi komentarza HTML wokół skryptu, dzięki czemu będzie można renderowane nie, jeśli przeglądarki nie obsługuje skryptów.  
  
 <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> Metoda jest przestarzała. Użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metoda <xref:System.Web.UI.ClientScriptManager> zamiast klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> w połączeniu z metody <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> metody. Jeśli używany język ECMAScript w bloku kodu deklaracji nie już został zarejestrowany, zgodnie z ustaleniami <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> nawiązane połączenie.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="abstract member RegisterHiddenField : string * string -&gt; unit&#xA;override this.RegisterHiddenField : string * string -&gt; unit" Usage="page.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Unikatowa nazwa pola ukrytego do renderowania.</param>
        <param name="hiddenFieldInitialValue">Wartość do emitować w formularzu ukryte.</param>
        <summary>Umożliwia kontrolki serwera do automatycznego rejestrowania ukryte pole formularza. Pole, które zostaną wysłane do <see cref="T:System.Web.UI.Page" /> obiektu podczas <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> renderowania formantu serwera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterHiddenField%2A> Metoda jest przestarzała. Użyj <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metoda <xref:System.Web.UI.ClientScriptManager> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.UI.Page.RegisterHiddenField%2A> metody w celu tworzenia ECMAScript kodu, który jest przekazywany do przeglądarki. Ustawiono nazwę pola ukrytego `myHiddenField` i jego wartość jest równa "Wprowadzenie do programu Microsoft!" <xref:System.Web.UI.Page.RegisterStartupScript%2A> Wywołania metody `myHiddenField` wartość, gdy użytkownik kliknie przycisk na stronie.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola ukrytego, która jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie należy sprawdzić, czy wartość pola ukrytego jak w przypadku wartości pola tekstowego. Strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page_RegisterHiddenField#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterOnSubmitStatement (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : string * string -&gt; unit" Usage="page.RegisterOnSubmitStatement (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy klucz, który identyfikuje blok skryptu.</param>
        <param name="script">Skrypt po stronie klienta do wysłania do klienta.</param>
        <summary>Umożliwia dostęp klienta do strony <see langword="OnSubmit" /> zdarzeń. Skrypt powinna być wywołanie funkcji kod klienta w zarejestrowany w innym miejscu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> Metoda jest przestarzała. Użyj <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metoda <xref:System.Web.UI.ClientScriptManager> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> do skryptu, który odpowiada po kliknięciu przycisku Prześlij po stronie klienta. Po wystąpieniu tego zdarzenia, zarejestrowany kod języka ECMAScript jest wykonywany na komputerze klienckim.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola ukrytego, która jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie należy sprawdzić, czy wartość pola ukrytego jak w przypadku wartości pola tekstowego. Strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page_RegisterHiddenField#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresControlState : System.Web.UI.Control -&gt; unit" Usage="page.RegisterRequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Formant do zarejestrowania.</param>
        <summary>Rejestruje formant jako musi zostać utrwalony, których stan formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niestandardowe kontrolki serwera korzystających z kontroli stanu należy wywołać <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> metody dla każdego żądania ponieważ rejestracji dla kontroli stanu nie jest przenoszona z żądania do żądania podczas zdarzenia odświeżania strony. Zaleca się, że rejestracja występują w <xref:System.Web.UI.Control.Init> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wywoływanie formantu niestandardowego serwera <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> metody.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Formant do zarejestrowania jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" /> Metodę można wywołać tylko przed lub podczas <see cref="E:System.Web.UI.Control.PreRender" /> zdarzeń.</exception>
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresPostBack(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresPostBack : System.Web.UI.Control -&gt; unit" Usage="page.RegisterRequiresPostBack control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który ma zostać zarejestrowany.</param>
        <summary>Rejestruje formant jako wymaga obsługi odświeżania strony, gdy strona jest przesyłana z powrotem do serwera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formant, który ma zostać zarejestrowany musi implementować <xref:System.Web.UI.IPostBackDataHandler> interfejsu lub <xref:System.Web.HttpException> jest wywoływane. Po zaimplementowaniu przez kontrolkę, <xref:System.Web.UI.IPostBackDataHandler> interfejs umożliwia obsługę danych post Wstecz i wywoływanie dowolnego punktu kopii zdarzenia zmienione dane. Aby uzyskać więcej informacji o modelu zdarzeń formantu serwera, zobacz [Model kontroli zdarzeń serwera formularzy sieci Web ASP.NET](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
 Zarejestruj elementy sterujące ze stroną, w tym miejscu lub przed `Page_PreRender` zdarzeń cyklu życia strony.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.UI.Page.RegisterRequiresPostBack%2A> metodę, aby wymagać formantu pola tekstowego `myTextBox`, zaksięgowania wstecz przed kod skojarzony z polem tekstowym może zostać uruchomiony. <xref:System.Web.UI.WebControls.TextBox> Formanty zaimplementować <xref:System.Web.UI.IPostBackDataHandler> interfejsu.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterRequiresPostBack#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page_RegisterRequiresPostBack#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Formant do rejestrowania nie implementuje <see cref="T:System.Web.UI.IPostBackDataHandler" /> interfejsu.</exception>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterRequiresRaiseEvent (control As IPostBackEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterRequiresRaiseEvent(System::Web::UI::IPostBackEventHandler ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterRequiresRaiseEvent : System.Web.UI.IPostBackEventHandler -&gt; unit&#xA;override this.RegisterRequiresRaiseEvent : System.Web.UI.IPostBackEventHandler -&gt; unit" Usage="page.RegisterRequiresRaiseEvent control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">Formant do zarejestrowania.</param>
        <summary>Rejestruje kontrolka serwerowa ASP.NET jako wymagające jednego zdarzenia wywoływane, gdy formant jest przetwarzane na <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na żądanie dostępu do strony można zarejestrować tylko jeden serwer kontroli. <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> Musi być używany, gdy formant nie ma jej kontrolą dane post identyfikator w formularzu. Ponadto musi implementować kontrolkę, która jest zarejestrowana <xref:System.Web.UI.IPostBackEventHandler> interfejsu.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> metodę, aby zarejestrować <xref:System.Web.UI.WebControls.Button> kontrolki serwera jako wymagające się zdarzenia w sieci Web. Po zarejestrowaniu pierwszy <xref:System.Web.UI.WebControls.Button> kontrola, mogą powodować drugi <xref:System.Web.UI.WebControls.Button> sterowania zadeklarowany w kodzie można opublikować wyniki przycisku pierwszej kliknij zdarzenie do strony.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterRequiresViewStateEncryption ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresViewStateEncryption();" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresViewStateEncryption : unit -&gt; unit" Usage="page.RegisterRequiresViewStateEncryption " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rejestruje formantu na stronie jako jeden wymagające szyfrowania stan widoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli tworzysz kontrolkę niestandardową, która zajmuje się potencjalnie wrażliwe informacje, należy wywołać <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A> metodę, aby zarejestrować formant ze stroną i zapewnić stan widoku formantu jest zaszyfrowany.  
  
 Stan całej strony będą szyfrowane, gdy <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> ustawiono <xref:System.Web.UI.ViewStateEncryptionMode.Auto> lub <xref:System.Web.UI.ViewStateEncryptionMode.Always>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ustawienie Tryb szyfrowania stan widoku <xref:System.Web.UI.Page> obiektu i żądania szyfrowania stanu widoku za pośrednictwem <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>. W tym przykładzie stan widoku będą szyfrowane, gdy informacje o kliencie są pobierane z bazy danych.  
  
 [!code-aspx-csharp[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" /> Metoda musi zostać wywołana przed lub w trakcie strony <see langword="PreRender" /> fazy cyklu życia strony.</exception>
        <altmember cref="P:System.Web.UI.Page.ViewStateEncryptionMode" />
        <altmember cref="T:System.Web.UI.WebControls.GridView" />
        <altmember cref="T:System.Web.UI.WebControls.DetailsView" />
        <altmember cref="T:System.Web.UI.WebControls.FormView" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterStartupScript (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterStartupScript(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="abstract member RegisterStartupScript : string * string -&gt; unit&#xA;override this.RegisterStartupScript : string * string -&gt; unit" Usage="page.RegisterStartupScript (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy klucz, który identyfikuje blok skryptu.</param>
        <param name="script">Zawartość skryptu, który zostanie wysłany do klienta.</param>
        <summary>Emituje blok skryptu po stronie klienta w odpowiedzi strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podobnie jak <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> metody, <xref:System.Web.UI.Page.RegisterStartupScript%2A> metody emituje skryptu bezpośrednio przed zamykającym tagu <xref:System.Web.UI.Page> obiektu `<form runat= server>` elementu. Należy uwzględnić otwierające i zamykające `<script>` elementy wokół skrypt zablokować ciąg określony w `script` parametru.  
  
 Ponieważ ta metoda korzysta z klucza, aby zidentyfikować blok skryptu, blok skryptu nie ma być emitowane do strumienia wyjściowego za każdym razem, gdy jest żądany przez wystąpienie kontrolki innego serwera  
  
 Dowolny skrypt bloki o takim samym `key` wartości parametrów są traktowane jako duplikaty.  
  
> [!NOTE]
>  Pamiętaj, aby uwzględnić tagi komentarza HTML wokół skryptu, dzięki czemu będzie można renderowane nie, jeśli przeglądarki nie obsługuje skryptów.  
  
 <xref:System.Web.UI.Page.RegisterStartupScript%2A> Metoda jest przestarzała. Użyj <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metoda <xref:System.Web.UI.ClientScriptManager> zamiast klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.Page.RegisterStartupScript%2A> w połączeniu z metody <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> metody. Jeśli ECMAScript napisany w bloku kodu deklaracji nie już został zarejestrowany, zgodnie z ustaleniami <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> metody, a następnie <xref:System.Web.UI.Page.RegisterStartupScript%2A> wywołanie.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterViewStateHandler ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterViewStateHandler();" />
      <MemberSignature Language="F#" Value="member this.RegisterViewStateHandler : unit -&gt; unit" Usage="page.RegisterViewStateHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że stan widoku strony utrwalenia, jeśli wywołany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterViewStateHandler%2A> Automatycznie wywoływana jest metoda, za pomocą <xref:System.Web.UI.HtmlControls.HtmlForm> kontrolki serwera. Jeśli ta metoda nie jest wywoływana, stan widoku strony nie zostaną utrwalone.  
  
> [!NOTE]
>  Zwykle tylko <xref:System.Web.UI.HtmlControls.HtmlForm> kontrolki serwera dla strony wywołuje tę metodę.  
  
   
  
## Examples  
 [!code-csharp[Page_RegisterViewStateHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page_RegisterViewStateHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="page.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> Który odbiera zawartość strony.</param>
        <summary>Inicjuje <see cref="T:System.Web.UI.HtmlTextWriter" /> obiektu i połączeń na formanty podrzędne <see cref="T:System.Web.UI.Page" /> do renderowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Render%2A> Metoda jest odpowiedzialna za tworzenie tekstu i kod znaczników, który jest wysyłany do przeglądarki klienta. Wartość domyślna <xref:System.Web.UI.Page.Render%2A> wywołania metody <xref:System.Web.UI.Control.RenderChildren%2A> zapisu tekst i znacznik dla formantów znajdujących się na stronie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.UI.Page.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.HttpRequest" /> obiektu dla żądanej strony.</summary>
        <value>Bieżący <see cref="T:System.Web.HttpRequest" /> skojarzony ze stroną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest> Zawiera informacje o bieżącym żądaniu HTTP.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób uzyskiwania <xref:System.Web.HttpRequest.Headers%2A> kolekcji z <xref:System.Web.HttpRequest> obiektu i zapisać go do strony ASP.NET.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Występuje, gdy <see cref="T:System.Web.HttpRequest" /> obiekt nie jest dostępny.</exception>
        <altmember cref="T:System.Web.HttpException" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RequiresControlState : System.Web.UI.Control -&gt; bool" Usage="page.RequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> Do sprawdzenia wymagań stan formantu.</param>
        <summary>Określa, czy określony <see cref="T:System.Web.UI.Control" /> uczestniczyć w kontroli Zarządzanie stanem obiektu jest zarejestrowany.</summary>
        <returns>
          <see langword="true" /> Jeśli określony <see cref="T:System.Web.UI.Control" /> wymaga formantu stanu; w przeciwnym razie <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan kontrolki jest obiektem składa się z krytyczne dane stanu widoku, które kontrolki serwera sieci Web muszą działać; jest on zawarty w oddzielny obiekt ze stanu widoku normalnym.  
  
 Formanty niestandardowe przy użyciu kontroli stanu należy wywołać <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> metoda przed zapisaniem stanu formantu. Użyj <xref:System.Web.UI.Page.RequiresControlState%2A> metodę sprawdzania, czy formanty, które są zarejestrowane na stronie jako wymagające stan formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.PageStatePersister.ControlState" />
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.UI.Page.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.HttpResponse" /> obiekt skojarzony z <see cref="T:System.Web.UI.Page" /> obiektu. Ten obiekt umożliwia wysyłanie danych odpowiedzi HTTP do klienta i zawiera informacje o tej odpowiedzi.</summary>
        <value>Bieżący <see cref="T:System.Web.HttpResponse" /> skojarzony ze stroną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie kodu pokazano tworzenie pliku cookie i dodanie go do wyjścia strony HTTP przy użyciu <xref:System.Web.HttpResponse> obiektu.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="T:System.Web.HttpResponse" /> Obiekt nie jest dostępny.</exception>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ResponseEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseEncoding : string with get, set" Usage="System.Web.UI.Page.ResponseEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia bieżący język kodowania <see cref="T:System.Web.HttpResponse" /> obiektu.</summary>
        <value>Ciąg zawierający kodowania języka dla bieżącego <see cref="T:System.Web.HttpResponse" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw `ResponseEncoding` atrybutu wartości przy użyciu dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RouteData As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteData ^ RouteData { System::Web::Routing::RouteData ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RouteData : System.Web.Routing.RouteData" Usage="System.Web.UI.Page.RouteData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="P:System.Web.Routing.RequestContext.RouteData" /> wartość bieżącej klasy <see cref="T:System.Web.Routing.RequestContext" /> wystąpienia.</summary>
        <value>
          <see cref="P:System.Web.Routing.RequestContext.RouteData" /> Wartość bieżącej klasy <see cref="T:System.Web.Routing.RequestContext" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli strona jest uruchomiona w odpowiedzi na żądanie za pomocą routingu platformy ASP.NET, ta właściwość zapewnia dostęp do wartości parametru URL, które zostały przekazane jako dane trasy. Jeśli strona jest uruchamiany w odpowiedzi do fizycznego adresu URL zamiast adresu URL trasy, ta właściwość jest `null`. Poniższy przykład przedstawia sposób wyodrębnienie wartości parametru URL o nazwie `year`.  
  
```vb  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
```csharp  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 Jeśli trasa jest zdefiniowana za pomocą wzorca adresu URL `{locale}/{year}` dla domeny `contoso.com`, a Jeśli żądany adres URL jest `contoso.com/US/2010`, `year` będzie zawierał wartość "2010" po uruchomieniu tego kodu.  
  
 Aby uzyskać więcej informacji o routingu platformy ASP.NET, zobacz [routingu platformy ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Routing.RequestContext.RouteData" />
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual void SavePageStateToPersistenceMedium (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub SavePageStateToPersistenceMedium (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SavePageStateToPersistenceMedium(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePageStateToPersistenceMedium : obj -&gt; unit&#xA;override this.SavePageStateToPersistenceMedium : obj -&gt; unit" Usage="page.SavePageStateToPersistenceMedium state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> Do przechowywania informacji o stanie widoku.</param>
        <summary>Zapisuje wszystkie informacje na stronie Stan widoku oraz stan formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> Używa metody <xref:System.Web.UI.PageStatePersister.Save%2A> metody <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> zawiera odwołanie do obiektu <xref:System.Web.UI.Page.PageStatePersister%2A> właściwości do przechowywania informacji o stanie widoku i stan kontrolki na stronie.  
  
 Program ASP.NET zawiera dwa potomków <xref:System.Web.UI.PageStatePersister> klasy <xref:System.Web.UI.HiddenFieldPageStatePersister> klasy, która zapisuje informacje o stanie w ukrytym polu objęte strony ASP.NET i <xref:System.Web.UI.SessionPageStatePersister> klasy, która zapisuje stan w <xref:System.Web.UI.Page.Session%2A> obiekt skojarzony z żądanie. Należy pamiętać, że przy użyciu <xref:System.Web.UI.SessionPageStatePersister> klasy ukryte pole stanu WIDOKU jest nadal renderowany, ponieważ jest on używany do określenia ogłaszanie zwrotne.  
  
 Aby zapisać stan w wybranej lokalizacji, należy utworzyć nowy podrzędny <xref:System.Web.UI.PageStatePersister> klasy, która zapisuje i ładuje stan średni trwałości wybranych przez użytkownika. Na przykład tworzenia nowego <xref:System.Web.UI.PageStatePersister> obiektów, zobacz <xref:System.Web.UI.PageStatePersister> klasy.  
  
 Jeśli używasz programu .NET Framework w wersji 1.0 lub 1.1 przesłonić tę metodę, jeśli chcesz zapisać <xref:System.Web.UI.Page> stanu w innym niż ukryte pole. Jeśli wybierzesz to zrobić, należy również zmienić <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SaveStateComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SaveStateComplete;" />
      <MemberSignature Language="F#" Value="member this.SaveStateComplete : EventHandler " Usage="member this.SaveStateComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po stronie zapisywania wszystkich widok stanu i kontroli stanu informacji dla strony i kontrolki na stronie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje o stanie formantów na stronie sieci Web jest zapisywane po <xref:System.Web.UI.Page.PreRenderComplete> zdarzeń. <xref:System.Web.UI.Page.SaveStateComplete> Zdarzenie jest wywoływane po wykonaniu stan widoku oraz stan formantu strony i kontrolki na stronie są zapisywane na średni trwałości.  
  
 Jest to ostatnie zdarzenie wywoływane przed realizacją strony do przeglądarki.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.UI.Page.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see langword="Server" /> obiektu, który jest wystąpieniem programu <see cref="T:System.Web.HttpServerUtility" /> klasy.</summary>
        <value>Bieżący <see langword="Server" /> obiekt skojarzony ze stroną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia dostęp do często używanych <xref:System.Web.HttpServerUtility.HtmlEncode%2A> i <xref:System.Web.HttpServerUtility.MapPath%2A> metod, między innymi.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak dostęp do informacji o błędach z serwera przy użyciu `Server` obiektu. W szczególności przykładzie pobiera żądanego adresu URL z `Request` obiekt, od ostatniego błędu `Server` obiektu (za pomocą <xref:System.Web.HttpServerUtility.GetLastError%2A> metody) i konwertuje je na ciągi, które mogą być wyświetlane przez klienta. Raz `message` zmiennej jest zapisywane w kliencie, błąd jest usuwana za <xref:System.Web.HttpServerUtility.ClearError%2A> metody.  
  
 [!code-csharp[System.Web.UI.Page_Error method#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page_Error method#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpServerUtility" />
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.UI.Page.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see langword="Session" /> obiekt udostępniany przez platformę ASP.NET.</summary>
        <value>Bieżące dane stanu sesji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera informacje dotyczące sesji bieżącego żądania. A `Session` jest obsługiwany obiekt dla każdego użytkownika, który żąda strony lub dokument z aplikacji ASP.NET. Zmienne są przechowywane w `Session` obiektu nie są usuwane, gdy użytkownik przeniesie strony w aplikacji; zamiast tego zmienne te są przechowywane tak długo, jak długo użytkownik uzyskuje dostęp do stron w aplikacji. Aby uzyskać więcej informacji dotyczących stanu sesji, zobacz [przegląd stanu sesji ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy `GetStyle` funkcja, która pobiera klucza przechowywanego w stanie sesji, strony formularzy sieci Web i konwertuje wartość na ciąg.  
  
 [!code-csharp[Page.Session_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Występuje, gdy ustawiono informacji o sesji <see langword="null" />.</exception>
        <altmember cref="T:System.Web.HttpException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia fokus przeglądarki do określonego formantu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="page.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">Identyfikator formantu ustawić fokus na.</param>
        <summary>Ustawia fokus przeglądarki do formantu o podanym identyfikatorze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.Page.SetFocus%2A> metodę, aby nadać formantowi o określonym identyfikatorze ciągu aktywny formant wyświetlanej w przeglądarce strony sieci Web. <xref:System.Web.UI.Page.SetFocus%2A> Metoda musi zostać wywołana przed strony jest gotowy do renderowania na kliencie w <xref:System.Web.UI.Control.PreRender> zdarzeń.  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A> — Metoda będzie działać tylko na przeglądarki wspierające ECMAScript w wersji 1.3 lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia fokus na drugie pole tekstowe na stronie sieci Web.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-aspx-vb[PageSetFocus#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clientID" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> jest wywoływane, gdy formant nie jest częścią strony formularzy sieci Web.  \- lub - <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> jest wywoływana po wykonaniu <see cref="E:System.Web.UI.Control.PreRender" /> zdarzeń.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="page.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Formant fokusu.</param>
        <summary>Ustawia fokus przeglądarki do określonego formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.Page.SetFocus%2A> metodę, aby wprowadzić określony formant aktywny formant na stronie sieci Web wyświetlanej w przeglądarce. <xref:System.Web.UI.Page.SetFocus%2A> Metoda musi zostać wywołana przed strony jest gotowy do renderowania na kliencie w <xref:System.Web.UI.Control.PreRender> zdarzeń.  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A> — Metoda będzie działać tylko na przeglądarki wspierające ECMAScript w wersji 1.3 lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia fokus na drugie pole tekstowe na stronie sieci Web.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-aspx-vb[PageSetFocus#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> jest wywoływane, gdy formant nie jest częścią strony formularzy sieci Web.  \- lub - <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> jest wywoływana po wykonaniu <see cref="E:System.Web.UI.Control.PreRender" /> zdarzeń.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipFormActionValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipFormActionValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipFormActionValidation : bool with get, set" Usage="System.Web.UI.Page.SkipFormActionValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wartość ciągu zapytania jest zweryfikowany.</summary>
        <value>
          <see langword="true" /> Jeśli sprawdzanie poprawności ciągów zapytań, które ma być pomijana (ciąg zapytania powinien nie można sprawdzić poprawności); w przeciwnym razie <see langword="false" /> Trwa sprawdzanie poprawności ciągów zapytań umieść normalnego. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Property SmartNavigation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SmartNavigation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SmartNavigation : bool with get, set" Usage="System.Web.UI.Page.SmartNavigation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy włączono inteligentne nawigacji. Ta właściwość jest przestarzała.</summary>
        <value>
          <see langword="true" /> Jeśli włączono inteligentne nawigacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw `SmartNavigation` atrybutu `true` w dyrektywie w plik .aspx. Gdy strona jest pobierana, klasa dynamicznie generowanym ustawia tę właściwość.  
  
> [!NOTE]
>  W programie ASP.NET w wersji 2.0 <xref:System.Web.UI.Page.SmartNavigation%2A> właściwość jest przestarzała. Użyj <xref:System.Web.UI.Page.SetFocus%2A> — metoda i <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> właściwości zamiast tego.  
  
 Jeśli strona jest wymagany przez przeglądarka Microsoft Internet Explorer 5.5 lub nowszego, inteligentne nawigacji podnosi poziom obsługi użytkownika strony, wykonując następujące czynności:  
  
-   Wyeliminowanie flash spowodowane nawigacji.  
  
-   Utrwalanie jego położenie przewijania podczas przenoszenia między stronami.  
  
-   Utrwalanie fokus elementu między nawigacji.  
  
-   Zachowywanie tylko ostatni stan strony w historii przeglądarki.  
  
 Inteligentna nawigacja najlepiej nadaje się ze stronami ASP.NET, które wymagają częstego ogłaszania zwrotnego, ale nie zmienia się znacznie przy powrocie zawartość visual. Zastanów się to przy podejmowaniu decyzji ustawić tę właściwość `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.Page.SetFocus" />
        <altmember cref="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property StyleSheetTheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StyleSheetTheme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StyleSheetTheme : string with get, set" Usage="System.Web.UI.Page.StyleSheetTheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę motywu, który jest stosowany do strony wczesnym etapie cyklu życia strony.</summary>
        <value>Nazwa motywu, który jest stosowany do strony wczesnym etapie cyklu życia strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie odwołuje się bezpośrednio do kaskadowy arkusz stylów (CSS). Ta właściwość zawiera nazwę motywu ASP.NET, która może obejmować pliki CSS w niej.  
  
 <xref:System.Web.UI.Page.StyleSheetTheme%2A> Właściwość określa nazwę motywu stosowany do strony wczesnym etapie cyklu życia strony, podczas gdy <xref:System.Web.UI.Page.Theme%2A> właściwość określa nazwę motywu stosowany do strony później w cyklu życia strony. Oznacza to, że ustawienia na stronie mają pierwszeństwo przed ustawieniami w motyw arkusza stylów. Aby uzyskać więcej informacji, zobacz [kompozycji ASP.NET i karnacji](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 W dyrektywie strony lub przez zastąpienie właściwości zwykle ustawić wartość tej właściwości. Aby uzyskać informacje zobacz następujące tematy:  
  
-   [Porady: motywy ASP.NET](http://msdn.microsoft.com/library/f9d72364-4d77-4b73-84be-7630dc63e0fe)  
  
-   [Porady: programowane stosować motywy ASP.NET](http://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148))  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> właściwości po <see cref="M:System.Web.UI.Page.FrameworkInitialize" /> wywołano metodę.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> ustawiono nazwę motywu nieprawidłowy. Ten wyjątek jest zgłaszany, gdy <see cref="M:System.Web.UI.Page.FrameworkInitialize" /> wywoływana jest metoda nie przez metodę ustawiającą właściwość.</exception>
        <altmember cref="P:System.Web.UI.Page.Theme" />
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Theme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Theme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Theme : string with get, set" Usage="System.Web.UI.Page.Theme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę motywu strony.</summary>
        <value>Nazwa motywu strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Theme%2A> Właściwość ustawia nazwę motywu używanego dla strony. Na stronie ustawienia do mają pierwszeństwo względem ustawień w motywie, należy użyć <xref:System.Web.UI.Page.StyleSheetTheme%2A> właściwości. Aby uzyskać więcej informacji, zobacz [kompozycji ASP.NET i karnacji](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 <xref:System.Web.UI.Page.Theme%2A> Musi być ustawiona właściwość przed <xref:System.Web.UI.Page.PreInit> zdarzeń; ustawienie <xref:System.Web.UI.Page.Theme%2A> właściwości po <xref:System.Web.UI.Page.PreInit> spowoduje, że zdarzenie <xref:System.InvalidOperationException> wyjątku.  
  
 Określony motyw musi istnieć jako aplikacja lub motyw globalny. Jeśli motyw nie istnieje, <xref:System.Web.HttpException> wyjątku.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Web.UI.Page.Theme%2A> właściwość o nazwie przekazany ciąg zapytania.  
  
 [!code-csharp[PageTheme#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić <see cref="P:System.Web.UI.Page.Theme" /> po <see cref="E:System.Web.UI.Page.PreInit" /> wystąpiło zdarzenie.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.Theme" /> ustawiono nazwę motywu nieprawidłowy.</exception>
        <altmember cref="P:System.Web.UI.Page.StyleSheetTheme" />
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Web.UI.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tytuł strony.</summary>
        <value>Tytuł strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.Page.Title%2A> właściwości można ustawić tytułu strony w nagłówku HTML wysyłany do przeglądarki.  
  
> [!NOTE]
>  Strona musi zawierać `head` element, który ma atrybut `runat="server"`, w przeciwnym razie nie będą zawierały tytuł.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.Title" /> Właściwości wymaga formantu nagłówka na stronie.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlTitle" />
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.UI.Page.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.TraceContext" /> dla bieżącego żądania sieci Web.</summary>
        <value>Dane z <see cref="T:System.Web.TraceContext" /> dla bieżącego żądania sieci Web.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Śledzenie śledzi i przedstawia wykonywania szczegóły żądania sieci Web. Dla danych śledzenia, która będzie widoczna w renderowanej strony należy włączyć śledzenie na poziomie strony lub aplikacji.  
  
 Śledzenie na stronie jest domyślnie wyłączona. Aby włączyć śledzenie dla strony, należy użyć dyrektywy `<% @ Page trace="true" %>`. Aby włączyć śledzenie dla całej aplikacji, należy włączyć ją w pliku konfiguracji aplikacji, Web.config, który znajduje się w katalogu głównym aplikacji. Aby uzyskać więcej informacji, zobacz [omówienie śledzenia ASP.NET](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, uzyskiwanie dostępu do <xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=nameWithType> właściwości i <xref:System.Web.TraceContext.Write%2A?displayProperty=nameWithType> formę <xref:System.Web.UI.Page.Trace%2A> właściwości. Ten kod wywołuje <xref:System.Diagnostics.Trace.Write%2A> metody tylko wtedy, gdy śledzenie jest włączone dla <xref:System.Web.UI.Page> obiektu. Jeśli nie jest włączone, ten kod nie będzie działać, która pomaga zmniejszyć obciążenie dla aplikacji.  
  
 [!code-csharp[System.Web.UI.Page.Trace#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TraceEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TraceEnabled : bool with get, set" Usage="System.Web.UI.Page.TraceEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia wartość wskazującą, czy śledzenie jest włączone dla <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <value>
          <see langword="true" /> Jeśli śledzenie jest włączone dla strony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw `Trace` atrybutu `true` w dyrektywie w plik .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceModeValue" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceModeValue As TraceMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceMode TraceModeValue { System::Web::TraceMode get(); void set(System::Web::TraceMode value); };" />
      <MemberSignature Language="F#" Value="member this.TraceModeValue : System.Web.TraceMode with get, set" Usage="System.Web.UI.Page.TraceModeValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia tryb, w którym śledzenia instrukcje są wyświetlane na stronie.</summary>
        <value>Jeden z <see cref="T:System.Web.TraceMode" /> elementy członkowskie wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw `TraceMode` atrybutu dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceEnabled" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property TransactionMode As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int TransactionMode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionMode : int with get, set" Usage="System.Web.UI.Page.TransactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia poziom transakcji obsługę strony.</summary>
        <value>Liczba całkowita, która reprezentuje jeden z <see cref="T:System.EnterpriseServices.TransactionOption" /> elementy członkowskie wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków nie należy ustawiać tej właściwości w kodzie. Ustaw `Transaction` atrybutu dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje określone wystąpienie modelu przy użyciu wartości z dostawcy wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Samouczek serii na użyciu wiązania modelu formularzy sieci Web, zobacz [wiązania modelu i formularzy sieci Web](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model);" />
      <MemberSignature Language="F#" Value="abstract member TryUpdateModel : 'Model -&gt; bool (requires 'Model : null)&#xA;override this.TryUpdateModel : 'Model -&gt; bool (requires 'Model : null)" Usage="page.TryUpdateModel model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Typ modelu.</typeparam>
        <param name="model">Model.</param>
        <summary>Aktualizuje określone wystąpienie modelu przy użyciu wartości z formantu powiązanego z danymi.</summary>
        <returns>
          <see langword="true" /> Jeśli wiązanie modelu przebiegło pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana tylko z metodą określoną przez formant powiązany z danymi `UpdateMethod` lub `InsertMethod` właściwości.  
  
 Samouczek serii na użyciu wiązania modelu formularzy sieci Web, zobacz [wiązania modelu i formularzy sieci Web](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberSignature Language="F#" Value="abstract member TryUpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; bool (requires 'Model : null)&#xA;override this.TryUpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; bool (requires 'Model : null)" Usage="page.TryUpdateModel (model, valueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Typ modelu.</typeparam>
        <param name="model">Model.</param>
        <param name="valueProvider">Dostawca wartości.</param>
        <summary>Aktualizuje wystąpienie modelu, używając wartości z określonego dostawcę wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli wiązanie modelu przebiegło pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Samouczek serii na użyciu wiązania modelu formularzy sieci Web, zobacz [wiązania modelu i formularzy sieci Web](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property UICulture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UICulture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UICulture : string with get, set" Usage="System.Web.UI.Page.UICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia identyfikator interfejsu użytkownika dla <see cref="T:System.Threading.Thread" /> obiekt skojarzony ze stroną.</summary>
        <value>Identyfikator interfejsu użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest skrót <xref:System.Threading.Thread.CurrentThread%2A> właściwości. Kultura jest właściwością wykonywania wątku  
  
 Ustaw `UICulture` atrybutu dyrektywy w pliku .aspx. Po zażądaniu strony dynamicznie wygenerowana klasa ustawia wartość tej właściwości. Ponadto można również jawnie ustawić wartość <xref:System.Web.UI.Page.UICulture%2A> właściwości w pliku Web.config.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected internal virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property UniqueFilePathSuffix As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::String ^ UniqueFilePathSuffix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueFilePathSuffix : string" Usage="System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy sufiks do dołączenia do tej ścieżki pliku pamięci podręcznej przeglądarki.</summary>
        <value>Unikatowy sufiks dołączany do ścieżki pliku. Wartość domyślna to "__ufps =" oraz unikatowy 6-cyfrowy numer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A> Właściwość zwraca ciąg, który jest dołączany na końcu ścieżki pliku, gdy jest to wymagane dla pamięci podręcznej przeglądarki. Ten ciąg jest używany do identyfikowania ścieżkę pliku skojarzony z określonym żądaniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property UnobtrusiveValidationMode As UnobtrusiveValidationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::UnobtrusiveValidationMode UnobtrusiveValidationMode { System::Web::UI::UnobtrusiveValidationMode get(); void set(System::Web::UI::UnobtrusiveValidationMode value); };" />
      <MemberSignature Language="F#" Value="member this.UnobtrusiveValidationMode : System.Web.UI.UnobtrusiveValidationMode with get, set" Usage="System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do weryfikacji po stronie klienta jest używany dyskretny kod JavaScript.</summary>
        <value>
          <see langword="true" /> Jeśli jest używany dyskretny kod JavaScript; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.UnregisterRequiresControlState : System.Web.UI.Control -&gt; unit" Usage="page.UnregisterRequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> Do których chcesz zatrzymać trwałości stan formantu.</param>
        <summary>Zatrzymuje trwałości stanu formantu do określonego formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niestandardowe kontrolki serwera korzystających z kontroli stanu należy wywołać <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> na każdym żądaniu podczas przed stanu jest trwały. Rejestracja stanu formantu nie jest przenoszona z żądania do żądania podczas odświeżania strony. Użyj <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> metody, aby upewnić się, stan formantu nie jest trwały dla formantów, które nie są już potrzebne utrwalenia dla ogłaszania zwrotnego.  
  
 Wewnętrznie <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> metoda jest wywoływana, gdy przy użyciu <xref:System.Web.UI.Control.RemovedControl%2A> metody, aby usunąć formant z kolekcji formantów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Web.UI.Control" /> Jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje określone wystąpienie modelu przy użyciu wartości z dostawcy wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Samouczek serii na użyciu wiązania modelu formularzy sieci Web, zobacz [wiązania modelu i formularzy sieci Web](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model);" />
      <MemberSignature Language="F#" Value="abstract member UpdateModel : 'Model -&gt; unit (requires 'Model : null)&#xA;override this.UpdateModel : 'Model -&gt; unit (requires 'Model : null)" Usage="page.UpdateModel model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Typ modelu.</typeparam>
        <param name="model">Model.</param>
        <summary>Aktualizuje określone wystąpienie modelu przy użyciu wartości z formantu powiązanego z danymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana tylko z metodą określoną przez formant powiązany z danymi `UpdateMethod` lub `InsertMethod` właściwości.  
  
 Samouczek serii na użyciu wiązania modelu formularzy sieci Web, zobacz [wiązania modelu i formularzy sieci Web](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberSignature Language="F#" Value="abstract member UpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; unit (requires 'Model : null)&#xA;override this.UpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; unit (requires 'Model : null)" Usage="page.UpdateModel (model, valueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Typ modelu.</typeparam>
        <param name="model">Model.</param>
        <param name="valueProvider">Dostawca wartości.</param>
        <summary>Aktualizuje określone wystąpienie modelu przy użyciu wartości z dostawcy określonej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Samouczek serii na użyciu wiązania modelu formularzy sieci Web, zobacz [wiązania modelu i formularzy sieci Web](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal" Usage="System.Web.UI.Page.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o użytkowniku zgłoszenia żądania strony.</summary>
        <value>
          <see cref="T:System.Security.Principal.IPrincipal" /> Reprezentujący użytkownika zgłaszającego żądanie dostępu do strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Principal.IPrincipal> Obiekt reprezentuje kontekst zabezpieczeń użytkownika w imieniu którego wykonywany jest kod, w tym tej tożsamości użytkownika i żadnych ról, do których należą.  
  
 Ta właściwość używa <xref:System.Web.HttpContext> obiektu <xref:System.Web.HttpContext.User%2A> właściwości w celu określenia, w której pochodzi żądanie.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.UI.Page.User%2A> właściwości uwierzytelnianie i tożsamość informacje dotyczące dostępu do bieżącego użytkownika. Jeśli użytkownik nie jest uwierzytelniony, zostanie przekierowany do strony logowania.  
  
 [!code-csharp[Page_User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page_User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Security.Principal.IPrincipal" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że wszystkie formanty walidacji się na stronie Sprawdzanie poprawności ich przypisane.</summary>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate();" />
      <MemberSignature Language="F#" Value="abstract member Validate : unit -&gt; unit&#xA;override this.Validate : unit -&gt; unit" Usage="page.Validate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wszystkie formanty walidacji się na stronie Sprawdzanie poprawności ich przypisane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy użytkownik kliknie żadnego formantu serwera ASP.NET, który ma `CausesValidation` ustawioną właściwość `true`, co jest ustawieniem domyślnym. Obejmują one <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, i <xref:System.Web.UI.WebControls.LinkButton> kontrolki serwera sieci Web <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, i <xref:System.Web.UI.HtmlControls.HtmlButton> kontrolek serwera HTML i formantów, które można automatycznie post do serwera, takich jak <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, i <xref:System.Web.UI.WebControls.BulletedList> kontrolki.  
  
 Aby wyłączyć sprawdzanie poprawności dla każdego formantu przycisku na stronie, ustaw formantu przycisku `CausesValidation` właściwości `false`.  
  
 Gdy ta metoda jest wywoływana, iteruje formanty walidacji zawarte w <xref:System.Web.UI.ValidatorCollection> obiekt skojarzony z <xref:System.Web.UI.Page.Validators%2A?displayProperty=nameWithType> właściwości i wywołuje logikę weryfikacji dla każdego formantu weryfikacji w bieżącej grupie sprawdzania poprawności. Grupy sprawdzania poprawności jest określana przez kontrolkę, która opublikowane strony do serwera. Jeśli zostanie określona żadna grupa sprawdzania poprawności, jest używana żadna grupa sprawdzania poprawności.  
  
> [!NOTE]
>  Działanie sprawdzania poprawności strony została zmieniona. W [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], kontroluje już wywołanie <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> metody; zakres ich używać <xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=nameWithType> metody zamiast tego. Jeśli używasz <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> metoda [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] strony, grup sprawdzania poprawności są ignorowane, a wszystkie formanty są weryfikowane.  
  
   
  
## Examples  
 Poniższy kod przykładowy wywołania <xref:System.Web.UI.Page.Validate%2A> definicja metody na stronie w scenariuszu z kilku grup różnych sprawdzania poprawności.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Web.UI.Page.Validate" /> — Metoda nie jest używany przez [! INCLUDE[vstecasplong](~/includes/vstecasplong-MD.MD)]. Jeśli korzystasz z [! INCLUDE[vstecasplong](~/includes/vstecasplong-MD.MD)] Zastąp <see cref="M:System.Web.UI.Page.Validate(System.String)" /> metodę, aby zmienić zachowanie sprawdzania poprawności strony.</para>
        </block>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate (validationGroup As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate(System::String ^ validationGroup);" />
      <MemberSignature Language="F#" Value="abstract member Validate : string -&gt; unit&#xA;override this.Validate : string -&gt; unit" Usage="page.Validate validationGroup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Nazwa grupy walidacji służy do sprawdzania poprawności.</param>
        <summary>Powoduje, że formanty walidacji w grupie określony weryfikacji można sprawdzić poprawności informacji o ich przypisanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy użytkownik kliknie żadnego formantu serwera ASP.NET, który ma `CausesValidation` ustawioną właściwość `true`, co jest ustawieniem domyślnym. Obejmują one <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, i <xref:System.Web.UI.WebControls.LinkButton> kontrolki serwera sieci Web <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, i <xref:System.Web.UI.HtmlControls.HtmlButton> kontrolek serwera HTML i formantów, które można automatycznie post do serwera, takich jak <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, i <xref:System.Web.UI.WebControls.BulletedList> kontrolki.  
  
 Aby wyłączyć sprawdzanie poprawności dla każdego formantu przycisku na stronie, ustaw formantu przycisku `CausesValidation` właściwości `false`.  
  
 <xref:System.Web.UI.Page.Validate%2A> Metoda sprawdza grupy określonej sprawdzania poprawności. Po wywołaniu <xref:System.Web.UI.Page.Validate%2A> metody dla grupy sprawdzania poprawności, <xref:System.Web.UI.Page.IsValid%2A> metoda zwróci `true` tylko wtedy, gdy zarówno grupy określonej sprawdzania poprawności i sprawdzania poprawności grupy formant, który spowodował stronę, aby można opublikować na serwerze są prawidłowe.  
  
   
  
## Examples  
 Poniższy kod przykładowy wywołania <xref:System.Web.UI.Page.Validate%2A> definicja metody na stronie w scenariuszu z kilku grup różnych sprawdzania poprawności.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Page.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy strona sprawdza klienta dane wejściowe przeglądarki pod kątem potencjalnie niebezpiecznych wartości.</summary>
        <value>Wartość, która wskazuje, czy strona sprawdza dane wejściowe klienta. Wartość domyślna to <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Web.UI.ValidateRequestMode.Inherit> nie jest używany w <xref:System.Web.UI.Page> klasy, ponieważ nie ma nic do dziedziczyć.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Validators As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ValidatorCollection ^ Validators { System::Web::UI::ValidatorCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Validators : System.Web.UI.ValidatorCollection" Usage="System.Web.UI.Page.Validators" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkich kontrolek sprawdzania poprawności znajdujących się na żądanej strony.</summary>
        <value>Kolekcja formantów sprawdzania poprawności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do manipulowania metody i właściwości <xref:System.Web.UI.ValidatorCollection> obiekt skojarzony z bieżącym <xref:System.Web.UI.Page> wystąpienia. Ta kolekcja zawiera wszystkich kontrolek serwera weryfikacji znajdują się na stronie.  
  
 Wywoływanie <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> metoda powoduje logikę weryfikacji ma być wykonywana dla każdej kontrolki serwera weryfikacji w bieżącej grupie sprawdzania poprawności. Jeśli którykolwiek z tych formantów nie są przekazywane, <xref:System.Web.UI.Page.IsValid%2A?displayProperty=nameWithType> zwraca właściwość `false`.  
  
 Aby uzyskać więcej informacji na formanty walidacji, zobacz [formanty walidacji ASP.NET](http://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void VerifyRenderingInServerForm(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member VerifyRenderingInServerForm : System.Web.UI.Control -&gt; unit&#xA;override this.VerifyRenderingInServerForm : System.Web.UI.Control -&gt; unit" Usage="page.VerifyRenderingInServerForm control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka serwerowa ASP.NET, która jest wymagana w <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> formantu.</param>
        <summary>Potwierdza, że <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> renderowania formantu określona kontrolka serwerowa ASP.NET w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formanty, które muszą być wewnątrz `<form runat=server>` tagi tę metodę można wywołać przed renderują, dzięki czemu komunikat o błędzie jest wyświetlany, jeśli zostały one umieszczone poza tagi. Formanty, które zależą od blokach skryptu zarejestrowany lub post wstecz powinny wywoływać tej metody w zastępująca <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metody. Stron, które ma innego sposobu renderowania elementu form serwera mogą przesłaniać tę metodę, aby zgłosić wyjątek w różnych warunkach.  
  
 Formanty serwera, które post wstecz lub użyj skryptu po stronie klienta nie będzie działać, jeśli nie są one ujęte w <xref:System.Web.UI.HtmlControls.HtmlForm> kontrolki serwera (<`form runat="server">`) tagów. Tych kontrolek można wywołać tę metodę, gdy renderują Podaj komunikat o błędzie Wyczyść, gdy nie są one ujęte w <xref:System.Web.UI.HtmlControls.HtmlForm> formantu.  
  
 Podczas opracowywania formantu niestandardowego serwera jest często, aby wywołać tę metodę, aby zastąpić `Render` metody dla dowolnego rodzaju tagu wejściowego. Jest to szczególnie ważne, jeśli wywołuje kontrolki wprowadzania <xref:System.Web.UI.Page.GetPostBackEventReference%2A>, lub jeśli jego emituje skrypt po stronie klienta. Formantu złożonego serwera nie trzeba wykonać to połączenie.  
  
   
  
## Examples  
 Poniższy kod przykładowy zastąpienia <xref:System.Web.UI.Page.Render%2A?displayProperty=nameWithType> metody formantu niestandardowego serwera. Gdy ten formant zapisuje zawartość do strony, używa <xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A> metody, aby upewnić się, czy formant jest widoczny pomiędzy otwierającym, a zamykającym tagiem elementu <xref:System.Web.UI.HtmlControls.HtmlForm> formantu.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Formant określony serwer nie znajduje się pomiędzy otwierającym, a zamykającym tagiem elementu <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> kontrolki serwera w czasie wykonywania.</exception>
        <exception cref="T:System.ArgumentNullException">Formant można zweryfikować jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateEncryptionMode As ViewStateEncryptionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ViewStateEncryptionMode ViewStateEncryptionMode { System::Web::UI::ViewStateEncryptionMode get(); void set(System::Web::UI::ViewStateEncryptionMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateEncryptionMode : System.Web.UI.ViewStateEncryptionMode with get, set" Usage="System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb szyfrowania stanu widoku.</summary>
        <value>Jeden z <see cref="T:System.Web.UI.ViewStateEncryptionMode" /> wartości. Wartość domyślna to <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> Nie można ustawić właściwości w kodzie. Może być ustawiony tylko, w dyrektywie lub w < elementu w pliku konfiguracji. Wartości określona w przesłonięciu dyrektywy wszelkie wartości ustawione w pliku konfiguracji.  
  
 Ustawienie tej właściwości w dyrektywie składnia jest następująca:  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 Ustawienie dla tej właściwości w pliku konfiguracyjnym składnia jest następująca:  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 Kontrolka niestandardowa deweloperzy mogą chcieć Sprawdź wartość tej właściwości w kodzie przed zapisaniem potencjalnie poufnych danych, aby wyświetlić stan w formancie ich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość nie jest elementem członkowskim <see cref="T:System.Web.UI.ViewStateEncryptionMode" /> wyliczenia.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" /> Właściwość można ustawić tylko w tym miejscu lub przed strony <see langword="PreRender" /> fazy cyklu życia strony.</exception>
        <altmember cref="T:System.Web.UI.ViewStateEncryptionMode" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateUserKey As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ViewStateUserKey { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateUserKey : string with get, set" Usage="System.Web.UI.Page.ViewStateUserKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przypisuje identyfikator użytkownika w zmiennej stanu widoku skojarzony z bieżącą stroną.</summary>
        <value>Identyfikator dla poszczególnych użytkowników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.Web.UI.Page.ViewStateUserKey%2A> właściwości mogą pomóc zapobiegać atakom na aplikacji przed złośliwymi użytkownikami. Dzieje się tak, ponieważ można przypisać identyfikator do zmiennej stanu widoku dla poszczególnych użytkowników, tak aby zmienna nie mogą użyć do wygenerowania atak. Aby uzyskać więcej informacji o atakami z sieci Web i co można zrobić, aby zapobiec ich, zobacz [zająć korzystać z ASP.NET wbudowane funkcje w celu zapobieżenia poza atakami z sieci Web](http://go.microsoft.com/fwlink/?LinkId=163557).  
  
 Tę właściwość można ustawić dowolną wartość ciągu, takich jak uwierzytelniona nazwa użytkownika lub <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> wartość.  
  
> [!NOTE]
>  Należy ustawić tę właściwość podczas `Page_Init` faza przetwarzania strony. Ustawienie tej właściwości podczas `Page_Load` fazy zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.UI.Page.ViewStateUserKey" /> Właściwość uzyskano za późno podczas przetwarzania strony.</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Page.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="T:System.Web.UI.Page" /> renderowaniem obiektu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Web.UI.Page" /> ma być renderowany; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie <xref:System.Web.UI.Page.Visible%2A> właściwości `false` ukrycia renderowanej zawartości strony. Po zażądaniu tej strony źródła danych jest wypełniane i wyświetlane na stronie. Gdy użytkownik kliknie przycisk `HideButton_Click` obsługi zdarzeń ukrywa całą renderowana zawartość strony.  
  
 [!code-csharp[Page_Visible#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page_Visible#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.UI.TemplateControl" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ScriptManager" FullName="System.Web.UI.ScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d5b19d1d87956a08523d6245afd2181f062d2d63" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69387317" /></Metadata><TypeSignature Language="C#" Value="public class ScriptManager : System.Web.UI.Control, System.Web.UI.IPostBackDataHandler, System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScriptManager extends System.Web.UI.Control implements class System.Web.UI.IPostBackDataHandler, class System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ScriptManager&#xA;Inherits Control&#xA;Implements IPostBackDataHandler, IPostBackEventHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScriptManager : System::Web::UI::Control, System::Web::UI::IPostBackDataHandler, System::Web::UI::IPostBackEventHandler" />
  <TypeSignature Language="F#" Value="type ScriptManager = class&#xA;    inherit Control&#xA;    interface IPostBackDataHandler&#xA;    interface IPostBackEventHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackDataHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackEventHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Scripts")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(EmbeddedResourceFinder), "System.Web.Resources.ScriptManager.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zarządza bibliotekami skryptów AJAX ASP.NET i plikami skryptów, renderowaniem częściowej strony oraz generowaniem klasy serwera proxy klienta dla usług sieci Web i aplikacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym temacie:  
  
-   [Wprowadzenie](#introduction)  
  
-   [Częściowe renderowanie strony](#partial_page_rendering)  
  
-   [Używanie kontrolki ScriptManager z stronami wzorcowymi, kontrolkami użytkownika i innymi składnikami podrzędnymi](#using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components)  
  
-   [Zarządzanie skryptami i rejestracja](#script_management_and_registration)  
  
-   [Odwołania do usługi sieci Web](#web_service_references)  
  
-   [Lokalizacja](#localization)  
  
-   [Obsługa błędów](#error_handling)  
  
-   [Składnia deklaracyjne](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>Wprowadzenie  
 <xref:System.Web.UI.ScriptManager> Formant jest centralną funkcją AJAX w ASP.NET. Kontrolka zarządza wszystkimi zasobami ASP.NET AJAX na stronie. Obejmuje to pobieranie skryptów biblioteki Microsoft Ajax do przeglądarki i koordynowanie aktualizacji stron częściowych, które są włączone przy użyciu <xref:System.Web.UI.UpdatePanel> kontrolek. Ponadto <xref:System.Web.UI.ScriptManager> kontrolka umożliwia wykonywanie następujących czynności:  
  
-   Zarejestruj skrypt zgodny z aktualizacjami części strony. Aby zarządzać zależnościami między skryptem a biblioteką podstawową, każdy zarejestrowany skrypt jest ładowany po skrypcie biblioteki Microsoft Ajax.  
  
-   Określ, czy skrypty wersji lub debugowania mają być wysyłane do przeglądarki.  
  
-   Zapewnianie dostępu do metod usługi sieci Web ze skryptu przez zarejestrowanie usług <xref:System.Web.UI.ScriptManager> sieci Web z kontrolką.  
  
-   Zapewnianie dostępu do ASP.NET uwierzytelniania, roli i profilu usług aplikacji ze skryptu klienta przez zarejestrowanie tych usług z <xref:System.Web.UI.ScriptManager> kontrolką.  
  
-   Włącz w przeglądarce funkcję wyświetlania języków ECMAScript (JavaScript), i [ciągów](https://msdn.microsoft.com/library/517a1992-3295-484e-9b9c-07ebfd8fe4db) specyficznych dla kultury.  
  
-   Dostęp do zasobów lokalizacyjnych w osadzonych plikach skryptów lub dla plików skryptów autonomicznych przy <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> użyciu właściwości <xref:System.Web.UI.ScriptReference> formantu.  
  
-   Zarejestruj kontrolki serwera, które <xref:System.Web.UI.IExtenderControl> implementują interfejsy lub <xref:System.Web.UI.ScriptManager> <xref:System.Web.UI.IScriptControl> z kontrolką, tak aby skrypt wymagany przez składniki i zachowania klienta był renderowany.  
  
<a name="partial_page_rendering"></a>   
## <a name="partial-page-rendering"></a>Częściowe renderowanie strony  
 Zdolność strony ASP.NET do obsługi renderowania częściowej strony jest kontrolowana przez następujące czynniki:  
  
-   Właściwość kontrolki musi być `true` (wartość domyślna). <xref:System.Web.UI.ScriptManager> <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A>  
  
-   Na stronie musi być co najmniej <xref:System.Web.UI.UpdatePanel> jedna kontrolka.  
  
-   Właściwość musi być `true` (wartość domyślna). <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> Jeśli właściwość nie zostanie ustawiona jawnie, jej wartość jest oparta na możliwościach przeglądarki.  
  
 Można zastąpić wartość <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> właściwości w czasie wykonywania w trakcie lub przed <xref:System.Web.UI.Control.Init> zdarzeniem strony. Jeśli spróbujesz zmienić tę właściwość po wystąpieniu <xref:System.Web.UI.Control.Init> zdarzenia strony <xref:System.InvalidOperationException> , zostanie zgłoszony wyjątek.  
  
 Gdy renderowanie części strony jest obsługiwane, <xref:System.Web.UI.ScriptManager> formant renderuje skrypt, aby umożliwić asynchroniczne ogłaszanie zwrotne i aktualizacje częściowej strony. Regiony strony do zaktualizowania są wyznaczane przy użyciu <xref:System.Web.UI.UpdatePanel> kontrolek. <xref:System.Web.UI.ScriptManager> Kontrolka obsługuje asynchroniczne ogłaszanie zwrotne i odświeża tylko regiony strony, które mają zostać zaktualizowane. Aby uzyskać więcej informacji na temat renderowania stron częściowych, zobacz [Omówienie renderowania części strony](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49). Aby uzyskać więcej informacji na temat warunków, które powodują aktualizację, zobacz temat [formant UpdatePanel — Omówienie](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a).  
  
<a name="using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components"></a>   
## <a name="using-the-scriptmanager-control-with-master-pages-user-controls-and-other-child-components"></a>Używanie formantu ScriptManager w stronach wzorcowych, formantach użytkownika i innych składnikach podrzędnych  
 Strona może zawierać tylko jeden <xref:System.Web.UI.ScriptManager> formant w swojej hierarchii. Aby zarejestrować usługi i skrypty dla zagnieżdżonych stron, kontrolek użytkownika lub składników, gdy strona nadrzędna ma <xref:System.Web.UI.ScriptManager> już kontrolkę, <xref:System.Web.UI.ScriptManagerProxy> użyj kontrolki. Aby uzyskać więcej informacji, zobacz [Używanie kontrolki UpdatePanel ze stronami wzorcowymi](https://msdn.microsoft.com/library/b1c974d5-a6b2-4bb3-a3cc-61dd9dc0e1d6)  
  
<a name="script_management_and_registration"></a>   
## <a name="script-management-and-registration"></a>Zarządzanie skryptem i rejestracja  
 <xref:System.Web.UI.ScriptManager> Kontrolka umożliwia zarejestrowanie skryptu, który jest następnie renderowany jako część strony. Metody <xref:System.Web.UI.ScriptManager> rejestracji formantów można podzielić na następujące trzy kategorie:  
  
-   Metody rejestracji, które gwarantują, że są utrzymywane zależności skryptu w bibliotece Microsoft Ajax.  
  
-   Metody rejestracji, które nie są zależne od biblioteki Microsoft Ajax, ale są zgodne z <xref:System.Web.UI.UpdatePanel> kontrolkami.  
  
-   Metody rejestracji obsługujące pracę z <xref:System.Web.UI.UpdatePanel> kontrolkami.  
  
 Aby uzyskać więcej informacji na temat tworzenia i używania skryptu AJAX w programie ASP.NET, zobacz [Tworzenie niestandardowego skryptu klienta przy użyciu biblioteki Microsoft Ajax](https://msdn.microsoft.com/library/285e3a65-b42e-42c5-952d-baf184057899).  
  
### <a name="registering-script-that-is-dependent-on-the-microsoft-ajax-library"></a>Rejestrowanie skryptu, który jest zależny od biblioteki Microsoft Ajax  
 Przy użyciu poniższych metod można rejestrować pliki skryptów w taki sposób, aby zagwarantować, że wszystkie zależności w bibliotece Microsoft Ajax są utrzymywane.  
  
|Metoda|Definicja|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>|Rejestruje formant serwera, który implementuje <xref:System.Web.UI.IScriptControl> interfejs, który jest używany do definiowania obiektu klienta [sys. Component](https://msdn.microsoft.com/library/6fba3595-e425-4e48-b4e9-fc16a0272381) . <xref:System.Web.UI.ScriptManager> Kontrolka renderuje skrypt, który obsługuje obiekt Client.|  
|<xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A>|Rejestruje formant serwera, który implementuje <xref:System.Web.UI.IExtenderControl> interfejs, który jest używany do definiowania obiektu klienta [sys. Component](https://msdn.microsoft.com/library/6fba3595-e425-4e48-b4e9-fc16a0272381) . <xref:System.Web.UI.ScriptManager> Kontrolka renderuje skrypt, który obsługuje obiekt Client.|  
  
### <a name="registering-partial-page-update-compatible-scripts"></a>Rejestrowanie skryptów zgodnych z aktualizacją strony częściowej  
 Przy użyciu poniższych metod można rejestrować pliki skryptów, które nie są zależne od biblioteki Microsoft Ajax, ale które są zgodne z <xref:System.Web.UI.UpdatePanel> kontrolkami. Metody te odpowiadają podobnym metodom <xref:System.Web.UI.ClientScriptManager> formantu. Jeśli tworzysz skrypt do użycia wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, upewnij się, że wywołujesz metody <xref:System.Web.UI.ScriptManager> kontrolki.  
  
|Metoda|Definicja|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>|Dodaje wartość do tablicy JavaScript. Jeśli tablica nie istnieje, zostanie utworzona.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>|Renderuje `<form>` element po tagu otwierającym strony. `script` Skrypt jest określony jako parametr ciągu.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>|Renderuje `<form>` element po tagu otwierającym strony. `script` Zawartość skryptu jest określana przez ustawienie `src` atrybutu na adres URL wskazujący plik skryptu.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>|Renderuje `<form>` element po tagu otwierającym strony. `script` Zawartość skryptu jest określana za pomocą nazwy zasobu w zestawie. Ten `src` atrybut jest automatycznie wypełniany adresem URL przez wywołanie procedury obsługi HTTP, która pobiera nazwany skrypt z zestawu.|  
|<xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>|Renderuje niestandardową parę atrybutów nazw/wartości (Expand) w znaczniku dla określonej kontrolki.|  
|<xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>|Renderuje ukryte pole.|  
|<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>|Rejestruje skrypt, który jest wykonywany w odpowiedzi na `form` `submit` zdarzenie elementu. Ten `onSubmit` atrybut odwołuje się do określonego skryptu.|  
|<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>|Renderuje blok skryptu uruchamiania tuż przed tagiem zamykającym `</form>` strony. Skrypt do renderowania jest określony jako parametr ciągu.|  
  
 Podczas rejestrowania metod należy określić parę typ/klucz dla tego skryptu. Jeśli skrypt o tej samej parze typu/klucza jest już zarejestrowany, nowy skrypt nie jest zarejestrowany. Podobnie w przypadku zarejestrowania skryptu z parą nazwa typu/zasobu, która już istnieje, `script` element, który odwołuje się do zasobu, nie zostanie ponownie dodany. Podczas rejestrowania atrybutu expand poprzednio zarejestrowanego atrybutu zostanie zgłoszony wyjątek. Dozwolona jest zduplikowana Rejestracja wartości tablicy.  
  
 Po wywołaniu <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> metody lub należy unikać rejestrowania skryptu, który wykonuje funkcje wbudowane. Zamiast tego Zarejestruj skrypt, który zawiera definicje funkcji, takie jak programy obsługi zdarzeń lub niestandardowe definicje klas dla aplikacji.  
  
### <a name="registration-methods-for-updatepanel-controls"></a>Metody rejestracji formantów UpdatePanel  
 Korzystając z poniższych metod, można dostosować aktualizacje części strony podczas korzystania <xref:System.Web.UI.UpdatePanel> z kontrolek.  
  
|Metoda|Definicja|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>|Rejestruje formant jako wyzwalacz dla asynchronicznych ogłoszeń zwrotnych.|  
|<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>|Wysyła niestandardowe dane do kontrolek podczas renderowania części strony.|  
|<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>|Rejestruje skrypt Dispose dla kontrolki, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki. Skrypt jest wykonywany, gdy <xref:System.Web.UI.UpdatePanel> kontrolka jest aktualizowana lub usuwana. Metoda Dispose jest używana dla składników klienta, które są częścią biblioteki Microsoft Ajax i które mają zwolnić zasoby, gdy składnik nie jest już używany.|  
|<xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A>|Rejestruje formant jako wyzwalacz do pełnego ogłaszania zwrotnego. Ta metoda jest używana w przypadku formantów wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, które w przeciwnym razie mogłyby wykonywać asynchroniczne ogłaszanie zwrotne.|  
  
<a name="web_service_references"></a>   
## <a name="web-service-references"></a>Odwołania do usługi sieci Web  
 Można zarejestrować usługę sieci Web, która ma zostać wywołana z skryptu klienta przez utworzenie <xref:System.Web.UI.ServiceReference> obiektu i dodanie go <xref:System.Web.UI.ScriptManager.Services%2A> do kolekcji <xref:System.Web.UI.ScriptManager> kontrolki. ASP.NET generuje obiekt serwera proxy klienta dla każdego <xref:System.Web.UI.ServiceReference> obiektu <xref:System.Web.UI.ScriptManager.Services%2A> w kolekcji. Można programowo dodać <xref:System.Web.UI.ServiceReference> obiekty <xref:System.Web.UI.ScriptManager.Services%2A> do kolekcji w celu zarejestrowania usług sieci Web w czasie wykonywania.  
  
 Aby uzyskać więcej informacji o sposobach uzyskiwania dostępu do usług sieci Web w skrypcie, zobacz [udostępnianie usług sieci Web w skrypcie klienta w ASP.NET AJAX](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8) i [wywoływanie usług sieci Web ze skryptu klienta w ASP.NET AJAX](https://msdn.microsoft.com/library/fc06c224-f01a-45be-94af-bd71afbc07b0).  
  
<a name="localization"></a>   
## <a name="localization"></a>Lokalizacja  
 <xref:System.Web.UI.ScriptManager> Kontrolka generuje odwołania na renderowanej stronie, która wskazuje odpowiednie zlokalizowane pliki skryptów, które są plikami skryptów osadzonymi w zestawach lub autonomicznych plikach skryptów.  
  
 Gdy właściwość jest ustawiona na `true`, <xref:System.Web.UI.ScriptManager> formant pobiera zlokalizowane zasoby (takie jak zlokalizowane ciągi) dla bieżącej kultury, jeśli istnieją. <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> <xref:System.Web.UI.ScriptManager> Kontrolka zapewnia następujące funkcje do korzystania z zlokalizowanych zasobów:  
  
-   **Pliki skryptów, które są osadzone w zestawie**. <xref:System.Web.UI.ScriptManager> Formant określa plik skryptu specyficzny dla kultury lub kultury rezerwowej do wysłania do przeglądarki. Robi to przy użyciu atrybutu zestawu specyficznego <xref:System.Resources.NeutralResourcesLanguageAttribute> dla kultury, zasobów spakowanych z zestawem i kultury interfejsu użytkownika przeglądarki (jeśli istnieje).  
  
-   **Pliki skryptów autonomicznych**. Kontrolka definiuje listę kultur interfejsu użytkownika, które są obsługiwane przy <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> użyciu właściwości <xref:System.Web.UI.ScriptReference> obiektu. <xref:System.Web.UI.ScriptManager>  
  
-   **W trybie debugowania**. <xref:System.Web.UI.ScriptManager> Kontrolka próbuje renderować plik skryptu specyficzny dla kultury, który zawiera informacje o debugowaniu. Na przykład jeśli strona jest w trybie debugowania, a bieżąca kultura jest ustawiona na en-MX, formant renderuje plik skryptu o nazwie takiej jak `scriptname`. en-MX. Debug. js, jeśli plik istnieje. Jeśli plik nie istnieje, jest renderowany plik debugowania dla odpowiedniej kultury rezerwowej  
  
 Więcej informacji o sposobie lokalizowania zasobów znajduje się w temacie [Lokalizowanie zasobów dla bibliotek składników — Omówienie](https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb).  
  
<a name="error_handling"></a>   
## <a name="error-handling"></a>Obsługa błędów  
 Gdy błąd strony wystąpi podczas asynchronicznego ogłaszania zwrotnego, <xref:System.Web.UI.ScriptManager.AsyncPostBackError> zdarzenie jest zgłaszane. <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> Sposób<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> , w jaki błędy na serwerze są wysyłane do klienta, zależy od właściwości, właściwości i sekcji błędy niestandardowe w pliku Web. config. Aby uzyskać więcej informacji, zobacz [Dostosowywanie obsługi błędów dla formantów UpdatePanel](https://msdn.microsoft.com/library/e15e7ffb-e4b2-4a89-b99e-16624a5861d0).  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>Składnia deklaracyjna  
  
```  
<asp:ScriptManager  
    AllowCustomErrorsRedirect="True|False"  
    AsyncPostBackErrorMessage="string"  
    AsyncPostBackTimeout="integer"  
    AuthenticationService-Path="uri"  
    EnablePageMethods="True|False"  
    EnablePartialRendering="True|False"  
    EnableScriptGlobalization="True|False"  
    EnableScriptLocalization="True|False"  
    EnableTheming="True|False"  
    EnableViewState="True|False"  
    ID="string"  
    LoadScriptsBeforeUI="True|False"  
    OnAsyncPostBackError="AsyncPostBackError event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnResolveScriptReference="ResolveScriptReference event handler"  
    OnUnload="Unload event handler"  
    ProfileService-LoadProperties="string"  
    ProfileService-Path="uri"  
    RoleService-LoadRoles="True|False"  
    RoleService-Path="uri"  
    runat="server"  
    ScriptMode="Auto|Inherit|Debug|Release"  
    ScriptPath="string"  
    SkinID="string"  
    SupportsPartialRendering="True|False"  
    Visible="True|False"  
>  
        <AuthenticationService  
            Path="uri"  
        />  
        <ProfileService  
            LoadProperties="string"  
            Path="uri"  
        />  
        <RoleService  
            LoadRoles="True|False"  
            Path="uri"  
        />  
        <Scripts>  
            <asp:ScriptReference  
                Assembly="string"  
                IgnoreScriptPath="True|False"  
                Name="string"  
                NotifyScriptLoaded="True|False"  
                Path="string"  
                ResourceUICultures="string"  
                ScriptMode="Auto|Debug|Inherit|Release"  
            />  
        </Scripts>  
        <Services>  
            <asp:ServiceReference  
                InlineScript="True|False"  
                Path="string"  
            />  
        </Services>  
</asp:ScriptManager>  
```  
  
   
  
## Examples  
 W poniższych przykładach przedstawiono różne scenariusze korzystania z <xref:System.Web.UI.ScriptManager> formantu.  
  
 **Włączanie aktualizacji strony częściowej**  
  
 Poniższy przykład pokazuje, jak używać formantu, <xref:System.Web.UI.ScriptManager> aby włączyć aktualizacje części strony. W tym przykładzie, <xref:System.Web.UI.WebControls.Calendar> <xref:System.Web.UI.WebControls.DropDownList> a i kontrolka znajdują się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki. Domyślnie wartość <xref:System.Web.UI.UpdatePanel.UpdateMode%2A> właściwości jest <xref:System.Web.UI.UpdatePanelUpdateMode.Always>, <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> a wartość właściwości to `true`. W związku z tym formanty podrzędne panelu powodują asynchroniczne ogłaszanie zwrotne.  
  
 [!code-aspx-csharp[System.Web.UI.UpdatePanel#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/CS/UpdatePanelExample1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.UpdatePanel#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/VB/UpdatePanelExample1VB.aspx#1)]  
  
 **Obsługa błędów aktualizacji częściowej strony i rejestrowanie skryptu**  
  
 Poniższy przykład pokazuje, jak zapewnić niestandardową obsługę błędów podczas aktualizacji strony częściowej. Domyślnie po wystąpieniu błędu podczas aktualizacji częściowej strony wyświetlane jest okno komunikatu JavaScript. W tym przykładzie pokazano, jak używać niestandardowej obsługi błędów, dostarczając procedurę obsługi dla <xref:System.Web.UI.ScriptManager.AsyncPostBackError> zdarzenia i <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> ustawiając właściwość w programie obsługi zdarzeń. Można również ustawić <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> właściwość, aby określić, jak sekcja błędy niestandardowe w pliku Web. config jest używana w przypadku wystąpienia błędu podczas aktualizacji częściowej strony. W tym przykładzie zostanie użyta wartość <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> domyślna właściwości. Oznacza to, że jeśli plik Web. config zawiera element [customErrors](https://msdn.microsoft.com/library/6c3b53ec-00df-4967-b0fb-351c02867650) , ten element określa sposób wyświetlania błędów. Aby uzyskać więcej informacji, zobacz [element CustomErrors (Schemat ustawień ASP.NET)](https://msdn.microsoft.com/library/288c32e2-df1f-4548-abda-de6b4cb989a6).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/VB/default.aspx#1)]  
  
 **Globalizacja daty i godziny wyświetlanej w przeglądarce**  
  
 Poniższy przykład pokazuje, jak ustawić <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> Właściwość tak, aby skrypt klienta mógł wyświetlić w przeglądarce datę i godzinę specyficzną dla kultury. W przykładzie `Culture` atrybut dyrektywy [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) jest ustawiony na `auto`. W związku z tym pierwszy język określony w bieżącej przeglądarce określa kulturę i kulturę interfejsu użytkownika dla strony. Aby uzyskać więcej informacji, zobacz [jak: Określ kulturę i kulturę interfejsu użytkownika dla globalizacji](https://msdn.microsoft.com/library/76091f86-f967-4687-a40f-de87bd8cc9a0)strony sieci Web ASP.NET.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/VB/default.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.ScriptManagerProxy" />
    <altmember cref="T:System.Web.UI.UpdatePanel" />
    <altmember cref="T:System.Web.UI.ClientScriptManager" />
    <altmember cref="T:System.Web.UI.ScriptMode" />
    <altmember cref="T:System.Web.UI.ScriptReference" />
    <altmember cref="T:System.Web.UI.ServiceReference" />
    <related type="Article" href="https://msdn.microsoft.com/library/fceeb3c5-c59f-46a9-af4f-b0d7155a1efc">Sys. WebForms. PageRequestManager — Klasa</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScriptManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScriptManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.ScriptManager" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje pola wewnętrzne, które są używane przez <xref:System.Web.UI.ScriptManager> formant do śledzenia informacji o stronie, kontroli i wdrożeniach.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHistoryPoint">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy punkt historii i dodaje go do stosu historii przeglądarki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te przeciążenia metod umożliwiają zdefiniowanie stanu serwera i opcjonalnie tytuł wpisu historii w przeglądarce. Podczas tworzenia punktu historii dane serializowane i zaszyfrowane są dołączane do adresu URL strony sieci Web, a wpis jest umieszczany w stosie historii przeglądarki. Możesz użyć danych stanu, aby ponownie utworzyć stronę po podniesieniu dowolnego kolejnego zdarzenia nawigacji serwera. Aby uzyskać więcej informacji, zobacz [Zarządzanie historią przeglądarki przy użyciu kontrolek serwera](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (System.Collections.Specialized.NameValueCollection state, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(class System.Collections.Specialized.NameValueCollection state, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.Collections.Specialized.NameValueCollection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (state As NameValueCollection, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::Collections::Specialized::NameValueCollection ^ state, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : System.Collections.Specialized.NameValueCollection * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (state, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="state">Kolekcja par klucz/wartość, które zawierają dane dla stanu.</param>
        <param name="title">Tekst, który zostanie dodany do stosu historii przeglądarki jako tytuł tego stanu.</param>
        <summary>Tworzy punkt historii i dodaje go do stosu historii przeglądarki przy użyciu określonego stanu zbierania danych i tytułu stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby utworzyć punkt historii, gdy chcesz zapisać więcej niż jedną parę klucz/wartość dla danych stanu. Podczas tworzenia punktu historii dane serializowane i zaszyfrowane są dołączane do adresu URL strony sieci Web, a wpis jest umieszczany w stosie historii przeglądarki. Jeśli parametrem jest `null`, tytuł strony sieci Web jest używany jako tytuł wpisu stanu w stosie historii. `title`  
  
 Możesz użyć danych stanu, aby ponownie utworzyć stronę po podniesieniu dowolnego kolejnego zdarzenia nawigacji serwera. Aby uzyskać więcej informacji, zobacz [Zarządzanie historią przeglądarki przy użyciu kontrolek serwera](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Kluczowa część pary klucz/wartość, która identyfikuje stan strony sieci Web.</param>
        <param name="value">Część wartości pary klucz/wartość, która identyfikuje stan strony sieci Web.</param>
        <summary>Tworzy punkt historii i dodaje go do stosu historii przeglądarki, przy użyciu określonego klucza stanu i wartości stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby utworzyć punkt historii, gdy chcesz zapisać wartość w celu zidentyfikowania stanu. Podczas tworzenia punktu historii dane serializowane i zaszyfrowane są dołączane do adresu URL strony sieci Web, a wpis jest umieszczany w stosie historii przeglądarki. Tytuł strony sieci Web jest używany jako tytuł wpisu stanu w stosie historii.  
  
 Możesz użyć danych stanu, aby ponownie utworzyć stronę po podniesieniu dowolnego kolejnego zdarzenia nawigacji serwera. Aby uzyskać więcej informacji, zobacz [Zarządzanie historią przeglądarki przy użyciu kontrolek serwera](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Kluczowa część pary klucz/wartość, która identyfikuje stan strony sieci Web.</param>
        <param name="value">Część wartości pary klucz/wartość, która identyfikuje stan strony sieci Web.</param>
        <param name="title">Tekst, który zostanie dodany do stosu historii przeglądarki jako tytuł tego stanu.</param>
        <summary>Tworzy punkt historii i dodaje go do stosu historii przeglądarki, przy użyciu określonego klucza stanu, wartości stanu i tytułu stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby utworzyć punkt historii, gdy chcesz zapisać wartość w celu zidentyfikowania stanu i tytułu stanu. Podczas tworzenia punktu historii dane serializowane i zaszyfrowane są dołączane do adresu URL strony sieci Web, a wpis jest umieszczany w stosie historii przeglądarki. Jeśli parametrem jest `null`, tytuł strony sieci Web jest używany jako tytuł wpisu stanu w stosie historii. `title`  
  
 Możesz użyć danych stanu, aby ponownie utworzyć stronę po podniesieniu dowolnego kolejnego zdarzenia nawigacji serwera. Aby uzyskać więcej informacji, zobacz [Zarządzanie historią przeglądarki przy użyciu kontrolek serwera](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly AjaxFrameworkAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly AjaxFrameworkAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AjaxFrameworkAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ AjaxFrameworkAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkAssembly : System.Reflection.Assembly" Usage="System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw AJAX Framework, którego składniki są używane na stronie.</summary>
        <value>Zestaw AJAX Framework.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AjaxFrameworkMode As AjaxFrameworkMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AjaxFrameworkMode AjaxFrameworkMode { System::Web::UI::AjaxFrameworkMode get(); void set(System::Web::UI::AjaxFrameworkMode value); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkMode : System.Web.UI.AjaxFrameworkMode with get, set" Usage="System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AjaxFrameworkMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą sposób, w jaki skrypty klienta biblioteki klienckiej Microsoft Ajax zostaną uwzględnione na kliencie.</summary>
        <value>Wartość <see cref="T:System.Web.UI.AjaxFrameworkMode" /> wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> Właściwość umożliwia włączenie wszystkich plików skryptów Microsoft Ajax, wyłączenie wszystkich plików skryptów Microsoft Ajax lub jawne uwzględnienie poszczególnych plików skryptów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> właściwość na `Explicit` w celu wskazania, że można jawnie określić skrypty.  
  
```  
<asp:ScriptManager ID="sm1" AjaxFrameworkMode="Explicit" runat="server">   
<Scripts>   
    <asp:ScriptReference Name="MicrosoftAjaxCore.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxComponentModel.js" />    
    <asp:ScriptReference Name="MicrosoftAjaxSerialization.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxNetwork.js" />       
</Scripts>   
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.AjaxFrameworkMode" />
      </Docs>
    </Member>
    <Member MemberName="AllowCustomErrorsRedirect">
      <MemberSignature Language="C#" Value="public bool AllowCustomErrorsRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCustomErrorsRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCustomErrorsRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCustomErrorsRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowCustomErrorsRedirect : bool with get, set" Usage="System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy sekcja błędy niestandardowe w pliku Web. config jest używana podczas błędu w asynchronicznym ogłaszaniu zwrotnym.</summary>
        <value><see langword="true" />Jeśli niestandardowe ustawienia błędów w pliku Web. config są używane do określania zachowania błędów podczas asynchronicznego ogłaszania zwrotnego; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> Zdarzenie jest zgłaszane w przypadku błędu strony podczas asynchronicznego ogłaszania zwrotnego. <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> Sposób<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> , w jaki błędy na serwerze są wysyłane do klienta, zależy od właściwości, właściwości i sekcji błędy niestandardowe w pliku Web. config.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AsyncPostBackError As EventHandler(Of AsyncPostBackErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::AsyncPostBackErrorEventArgs ^&gt; ^ AsyncPostBackError;" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackError : EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " Usage="member this.AsyncPostBackError : System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wystąpi błąd strony podczas asynchronicznego ogłaszania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> Zdarzenie jest zgłaszane w przypadku błędu strony podczas asynchronicznego ogłaszania zwrotnego. <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> Sposób<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> , w jaki błędy na serwerze są wysyłane do klienta, zależy od właściwości, właściwości i sekcji błędy niestandardowe w pliku Web. config.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Web.UI.ScriptManager.AsyncPostBackError> jak obsłużyć zdarzenie w celu <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> ustawienia właściwości (wysyłanej do klienta) na komunikat o błędzie wyjątku serwera.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackErrorMessage">
      <MemberSignature Language="C#" Value="public string AsyncPostBackErrorMessage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackErrorMessage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackErrorMessage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackErrorMessage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackErrorMessage : string with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia komunikat o błędzie wysyłany do klienta, gdy wystąpi wyjątek nieobsługiwanego serwera podczas asynchronicznego ogłaszania zwrotnego.</summary>
        <value>Komunikat o błędzie. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> Zdarzenie jest zgłaszane w przypadku błędu strony podczas asynchronicznego ogłaszania zwrotnego. <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> Sposób<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> , w jaki błędy na serwerze są wysyłane do klienta, zależy od właściwości, właściwości i sekcji błędy niestandardowe w pliku Web. config.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Web.UI.ScriptManager.AsyncPostBackError> jak obsłużyć zdarzenie w celu <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> ustawienia właściwości (wysyłanej do klienta) na komunikat o błędzie wyjątku serwera.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackSourceElementID">
      <MemberSignature Language="C#" Value="public string AsyncPostBackSourceElementID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackSourceElementID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncPostBackSourceElementID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackSourceElementID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackSourceElementID : string" Usage="System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.AsyncPostBackSourceElementID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator kontrolki, która spowodowała asynchroniczne ogłaszanie zwrotne.</summary>
        <value>Unikatowy identyfikator kontrolki, Jeśli kontrolka ma identyfikator; w przeciwnym razie, pusty ciąg ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID%2A> Właściwość zawiera wartość identyfikatora formantu, który spowodował asynchroniczne ogłaszanie zwrotne, które może być jedną z następujących:  
  
-   Ogłaszanie zwrotne z kontrolki, która <xref:System.Web.UI.UpdatePanel> znajduje się <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> wewnątrz kontrolki, `true` której właściwość jest ustawiona na (wartość domyślna).  
  
-   Ogłaszanie zwrotne z kontrolki, która jest wyzwalaczem dla <xref:System.Web.UI.UpdatePanel> kontrolki.  
  
-   Ogłoszenie zwrotne z kontrolki, która jest zarejestrowana <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> przez wywołanie metody <xref:System.Web.UI.ScriptManager> kontrolki.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackTimeout">
      <MemberSignature Language="C#" Value="public int AsyncPostBackTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AsyncPostBackTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AsyncPostBackTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackTimeout : int with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(90)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czas (w sekundach), po upływie którego zostanie przekroczony limit czasu asynchronicznego ogłaszania zwrotnego, jeśli odpowiedź nie zostanie odebrana.</summary>
        <value>Liczba całkowita, która reprezentuje limit czasu w sekundach. Wartość domyślna to 90 sekund.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationService">
      <MemberSignature Language="C#" Value="public System.Web.UI.AuthenticationServiceManager AuthenticationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.AuthenticationServiceManager AuthenticationService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AuthenticationService As AuthenticationServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AuthenticationServiceManager ^ AuthenticationService { System::Web::UI::AuthenticationServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationService : System.Web.UI.AuthenticationServiceManager" Usage="System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AuthenticationServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który jest skojarzony z bieżącym <see cref="T:System.Web.UI.ScriptManager" /> wystąpieniem. <see cref="T:System.Web.UI.AuthenticationServiceManager" /></summary>
        <value>Obiekt dla bieżącego <see cref="T:System.Web.UI.ScriptManager" />wystąpienia. <see cref="T:System.Web.UI.AuthenticationServiceManager" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.AuthenticationServiceManager> Obiekt, który jest zwracany przez tę właściwość, reprezentuje usługę uwierzytelniania, która jest zarejestrowana na stronie. Usługę uwierzytelniania można zdefiniować w <xref:System.Web.UI.ScriptManager> formancie lub w skojarzonym <xref:System.Web.UI.ScriptManagerProxy> formancie.  
  
 Możesz użyć usługi uwierzytelniania ASP.NET lub użyć niestandardowej usługi uwierzytelniania. Możesz dodać usługę niestandardową w znaczniku, dołączając `AuthenticationService` element `asp:ScriptManager` wewnątrz elementu na stronie, jak pokazano w poniższym przykładzie.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <AuthenticationService Path="MyAuthenticationService.asmx" />  
</asp:ScriptManager>  
```  
  
 Można również programowo skonfigurować <xref:System.Web.UI.AuthenticationServiceManager> obiekt. Usługi są zarejestrowane w <xref:System.Web.UI.ScriptManager> kontrolce na etapie cyklu <xref:System.Web.UI.Control.PreRender> życia strony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientNavigateHandler">
      <MemberSignature Language="C#" Value="public string ClientNavigateHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientNavigateHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientNavigateHandler As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientNavigateHandler { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientNavigateHandler : string with get, set" Usage="System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę metody, która obsługuje zdarzenie <see href="https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93">sys. Application. Nawiguj</see> na kliencie.</summary>
        <value>Nazwa metody, która obsługuje zdarzenie [sys. Application. Nawiguj](https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93) na kliencie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositeScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.CompositeScriptReference CompositeScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.CompositeScriptReference CompositeScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.CompositeScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositeScript As CompositeScriptReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::CompositeScriptReference ^ CompositeScript { System::Web::UI::CompositeScriptReference ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositeScript : System.Web.UI.CompositeScriptReference" Usage="System.Web.UI.ScriptManager.CompositeScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.CompositeScriptReference</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do skryptu złożonego, który obsługuje stronę sieci Web.</summary>
        <value>Odwołanie do skryptu złożonego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Łączenie skryptów klienta ze skryptem złożonym](https://msdn.microsoft.com/library/d0f608d0-b4c8-4795-990b-ede68c1239b3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyPageUrl">
      <MemberSignature Language="C#" Value="public virtual string EmptyPageUrl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EmptyPageUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EmptyPageUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EmptyPageUrl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EmptyPageUrl : string with get, set" Usage="System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor(typeof(System.Web.UI.Design.UrlEditor), typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.UrlProperty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia adres URL pustej strony sieci Web.</summary>
        <value>Adres URL, który ma być używany, jeśli docelowa strona sieci Web jest pusta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.EmptyPageUrl%2A> Właściwość obsługuje historię przeglądarki AJAX.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdn">
      <MemberSignature Language="C#" Value="public bool EnableCdn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdn" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdn" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdn { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdn : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy bieżąca strona ładuje odwołania skryptu klienta ze ścieżek sieci CDN (Content Delivery Network).</summary>
        <value><see langword="true" />Jeśli odwołania do skryptu klienta są ładowane ze ścieżek usługi CDN, <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie ustawiaj tej właściwości na `true` , jeśli została <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> ustawiona `true` na już.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdnFallback">
      <MemberSignature Language="C#" Value="public bool EnableCdnFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdnFallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdnFallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdnFallback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdnFallback : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Włącza lokalną kopię skryptu do załadowania w przypadku, gdy Usługa CDN (Content Delivery Network) jest niedostępna.</summary>
        <value><see langword="true" />Jeśli rezerwowa wartość CDN jest włączona; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableHistory">
      <MemberSignature Language="C#" Value="public bool EnableHistory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableHistory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableHistory" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableHistory As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableHistory { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableHistory : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableHistory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy strona sieci Web obsługuje zarządzanie punktami historii.</summary>
        <value><see langword="true" />Jeśli strona sieci Web obsługuje dodawanie punktów historii do stosu historii przeglądarki; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości <xref:System.Web.UI.ScriptManager.EnableHistory%2A> , aby włączyć zarządzanie historiami na stronie sieci Web.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePageMethods">
      <MemberSignature Language="C#" Value="public bool EnablePageMethods { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePageMethods" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePageMethods As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePageMethods { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePageMethods : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy publiczne metody strony statycznej na stronie ASP.NET mogą być wywoływane z poziomu skryptu klienta.</summary>
        <value><see langword="true" />Jeśli statyczne metody strony na stronie ASP.NET można wywołać z skryptu klienta jako metody sieci Web; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można dodać statyczne metody strony do strony ASP.NET i oznaczyć je jako metody sieci Web. Następnie można wywołać te metody ze skryptu, tak jakby były częścią usługi sieci Web, ale bez tworzenia oddzielnego pliku. asmx. Aby utworzyć metody sieci Web na stronie, zaimportuj <xref:System.Web.Services> przestrzeń nazw i <xref:System.Web.Services.WebMethodAttribute> Dodaj atrybut do każdej statycznej metody, którą chcesz uwidocznić. Metody muszą być oznaczone jako publiczne.  
  
 Aby uzyskać więcej informacji, zobacz [udostępnianie usług sieci Web w skrypcie klienta w ASP.NET AJAX](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePartialRendering">
      <MemberSignature Language="C#" Value="public bool EnablePartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość umożliwiającą częściowe renderowanie strony, która z kolei umożliwia aktualizowanie regionów strony indywidualnie przy użyciu <see cref="T:System.Web.UI.UpdatePanel" /> kontrolek.</summary>
        <value><see langword="true" />Jeśli renderowanie częściowe jest włączone, a aktualizacje na całej stronie są pomijane; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawet jeśli <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> właściwość jest `true`, renderowanie części strony może nie wystąpić. Przeglądarka może nie obsługiwać renderowania częściowej strony lub <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> właściwość jest ustawiona na. `false`  
  
 Można zastąpić wartość <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> właściwości w czasie wykonywania w trakcie lub przed <xref:System.Web.UI.Control.Init> zdarzeniem strony. Jeśli spróbujesz zmienić tę właściwość po wystąpieniu <xref:System.Web.UI.Control.Init> zdarzenia strony <xref:System.InvalidOperationException> , zostanie zgłoszony wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiona po wystąpieniu <see cref="E:System.Web.UI.Control.Init" /> zdarzenia strony. <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /></exception>
        <altmember cref="T:System.Web.UI.UpdatePanel" />
        <altmember cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="EnableScriptGlobalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptGlobalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptGlobalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptGlobalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptGlobalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptGlobalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.ScriptManager" /> formant renderuje skrypt obsługujący analizowanie i formatowanie informacji specyficznych dla kultury.</summary>
        <value><see langword="true" />Jeśli można wyświetlić informacje specyficzne dla kultury; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy właściwość jest ustawiona na `true`, globalne funkcje języka ECMAScript (JavaScript `Date.localeFormat` ), takie jak metoda wyświetlania informacji specyficznych dla kultury. <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> Kulturę można ustawić w przeglądarce, w kodzie serwera lub w pliku konfiguracji witryny sieci Web.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/69b34e6d-d590-4d03-a763-b7ae54b47d74">Lokalizowanie daty przy użyciu skryptu klienta</related>
      </Docs>
    </Member>
    <Member MemberName="EnableScriptLocalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptLocalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptLocalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptLocalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptLocalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptLocalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.ScriptManager" /> kontrolka renderuje zlokalizowane wersje plików skryptów.</summary>
        <value><see langword="true" />Jeśli zlokalizowane pliki skryptów będą renderowane; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy właściwość jest ustawiona na `true`, <xref:System.Web.UI.ScriptManager> obiekt będzie pobierać pliki skryptów dla bieżącej kultury, jeśli istnieją. <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> Na przykład strona może określić plik skryptu o nazwie CustomScript. js. Jeśli kultura jest ustawiona na fr-CA, <xref:System.Web.UI.ScriptManager> obiekt spróbuje pobrać plik skryptu o nazwie CustomScript.fr-CA. js.  
  
> [!NOTE]
>  Aby uniemożliwić renderowanie pliku skryptu dwa razy, <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> właściwość nie może być modyfikowana podczas asynchronicznego ogłaszania zwrotnego.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb">Omówienie lokalizowania zasobów dla bibliotek składników</related>
      </Docs>
    </Member>
    <Member MemberName="EnableSecureHistoryState">
      <MemberSignature Language="C#" Value="public bool EnableSecureHistoryState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSecureHistoryState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSecureHistoryState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSecureHistoryState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableSecureHistoryState : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ma być szyfrowany ciąg stanu historii.</summary>
        <value><see langword="true" />Jeśli ciąg stanu historii powinien być szyfrowany; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Ta właściwość ***nigdy nie*** powinna być ustawiona `false` na wartość w produkcyjnej witrynie sieci Web.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptManager GetCurrent (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.ScriptManager GetCurrent(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetCurrent(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::ScriptManager ^ GetCurrent(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrent : System.Web.UI.Page -&gt; System.Web.UI.ScriptManager" Usage="System.Web.UI.ScriptManager.GetCurrent page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">Wystąpienie strony, z którego <see cref="T:System.Web.UI.ScriptManager" /> ma zostać pobrane.</param>
        <summary>Pobiera wystąpienie dla danego <see cref="T:System.Web.UI.Page" /> obiektu. <see cref="T:System.Web.UI.ScriptManager" /></summary>
        <returns>Bieżące <see cref="T:System.Web.UI.ScriptManager" /> wystąpienie dla wybranego <see cref="T:System.Web.UI.Page" /> obiektu lub <see langword="null" /> Jeśli żadne wystąpienie nie jest zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody statycznej, aby określić <xref:System.Web.UI.ScriptManager> , czy kontrolka znajduje się na stronie, czy też uzyskiwać dostęp do właściwości <xref:System.Web.UI.ScriptManager> i metod kontrolki, gdy nie znasz jej identyfikatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredArrayDeclarations">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredArrayDeclarations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredArrayDeclarations () As ReadOnlyCollection(Of RegisteredArrayDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredArrayDeclaration ^&gt; ^ GetRegisteredArrayDeclarations();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredArrayDeclarations : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;" Usage="scriptManager.GetRegisteredArrayDeclarations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tablicową ECMAScript (JavaScript) w trybie tylko do odczytu, które zostały wcześniej zarejestrowane przy <see cref="T:System.Web.UI.Page" /> użyciu obiektu.</summary>
        <returns>Ogólna kolekcja zawierająca deklaracje tablicy.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterArrayDeclaration" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredClientScriptBlocks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredClientScriptBlocks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredClientScriptBlocks () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredClientScriptBlocks();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredClientScriptBlocks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredClientScriptBlocks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tylko do odczytu bloków skryptu klienta, które zostały wcześniej zarejestrowane w <see cref="T:System.Web.UI.ScriptManager" /> kontrolce.</summary>
        <returns>Ogólna kolekcja zawierająca bloki skryptu klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bloki skryptu klienta są rejestrowane przy użyciu <xref:System.Web.UI.ScriptManager> kontrolki do użycia z kontrolką znajdującą się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredDisposeScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredDisposeScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredDisposeScripts () As ReadOnlyCollection(Of RegisteredDisposeScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredDisposeScript ^&gt; ^ GetRegisteredDisposeScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredDisposeScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;" Usage="scriptManager.GetRegisteredDisposeScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję <see langword="dispose" /> skryptów tylko do odczytu, które zostały wcześniej zarejestrowane <see cref="T:System.Web.UI.Page" /> przy użyciu obiektu.</summary>
        <returns>Ogólna kolekcja zawierająca <see langword="dispose" /> skrypty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt jest wykonywany, <xref:System.Web.UI.UpdatePanel> gdy kontrolka jest aktualizowana lub usuwana. `dispose`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredExpandoAttributes">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredExpandoAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredExpandoAttributes () As ReadOnlyCollection(Of RegisteredExpandoAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredExpandoAttribute ^&gt; ^ GetRegisteredExpandoAttributes();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredExpandoAttributes : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;" Usage="scriptManager.GetRegisteredExpandoAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję elementów niestandardowych (Expand) tylko do odczytu, które zostały wcześniej zarejestrowane przy użyciu <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Ogólna kolekcja zawierająca atrybuty niestandardowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut niestandardowy to para nazwa/wartość, którą można odczytać i ustawić przez skrypt klienta.  
  
   
  
## Examples  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.RegisteredExpandoAttribute>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredHiddenFields">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredHiddenFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredHiddenFields () As ReadOnlyCollection(Of RegisteredHiddenField)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredHiddenField ^&gt; ^ GetRegisteredHiddenFields();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredHiddenFields : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;" Usage="scriptManager.GetRegisteredHiddenFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tylko do odczytu pól ukrytych, które zostały wcześniej zarejestrowane przy użyciu <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Ogólna kolekcja zawierająca ukryte pola.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.UI.RegisteredHiddenField" />
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterHiddenField" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredOnSubmitStatements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredOnSubmitStatements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredOnSubmitStatements () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredOnSubmitStatements();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredOnSubmitStatements : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredOnSubmitStatements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję <see langword="onsubmit" /> instrukcji tylko do odczytu, które zostały wcześniej zarejestrowane <see cref="T:System.Web.UI.Page" /> przy użyciu obiektu.</summary>
        <returns>Ogólna kolekcja zawierająca <see langword="onsubmit" /> instrukcje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `onsubmit` Instrukcja to ECMAScript (JavaScript), która jest wykonywana po przesłaniu formularza.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredStartupScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredStartupScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredStartupScripts () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredStartupScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredStartupScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredStartupScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję autotylko do odczytu skryptów uruchomieniowych, które zostały wcześniej zarejestrowane przy <see cref="T:System.Web.UI.Page" /> użyciu obiektu.</summary>
        <returns>Ogólna kolekcja zawierająca skrypty uruchamiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt uruchamiania jest skryptem klienta skojarzonym z kontrolką, która jest wykonywana po rozpoczęciu kontroli.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ScriptManager.GetRegisteredStartupScripts%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStateString">
      <MemberSignature Language="C#" Value="public string GetStateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetStateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetStateString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetStateString();" />
      <MemberSignature Language="F#" Value="member this.GetStateString : unit -&gt; string" Usage="scriptManager.GetStateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ciąg, który zawiera pary klucz/wartość reprezentujące stan strony sieci Web.</summary>
        <returns>Ciąg zawierający pary klucz/wartość, które reprezentują stan strony sieci Web.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsDebuggingEnabled</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wersje debugowania bibliotek skryptów klienta będą renderowane.</summary>
        <value><see langword="true" />Jeśli bieżące żądanie jest wykonywane w trybie debugowania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> zwraca`false` , gdy spełniony jest dowolny z następujących warunków:  
  
-   W elemencie [Deployment](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) pliku `retail` konfiguracji atrybut jest ustawiony na `true`. Spowoduje to zastąpienie wszystkich innych ustawień.  
  
-   Właściwość jest ustawiona na `Auto` lub `Inherit` na`compilation` , a debugowanie nie jest włączone w sekcji pliku Web. config aplikacji głównej. <xref:System.Web.UI.ScriptManager.ScriptMode%2A>  
  
-   Właściwość jest ustawiona na `Release`. <xref:System.Web.UI.ScriptManager.ScriptMode%2A>  
  
    > [!NOTE]
    >  Atrybut dyrektywy @ Page nie ma wpływu na aplikacje ASP.NET z włączoną obsługą technologii AJAX. [](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) `debug` Formant używa tylko ustawień w pliku Web. config oraz <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> we właściwościach i, aby <xref:System.Web.UI.ScriptManager.ScriptMode%2A> określić, czy mają być renderowane skrypty debugowania. <xref:System.Web.UI.ScriptManager>  
  
 Aby uzyskać więcej informacji, zobacz [debugowanie i śledzenie aplikacji Ajax — Omówienie](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.IsDebuggingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsInAsyncPostBack">
      <MemberSignature Language="C#" Value="public bool IsInAsyncPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInAsyncPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInAsyncPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInAsyncPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInAsyncPostBack : bool" Usage="System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsInAsyncPostBack</InterfaceMember>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.IsInAsyncPostBack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące ogłaszanie zwrotne jest wykonywane w trybie renderowania częściowego.</summary>
        <value><see langword="true" />Jeśli bieżące ogłaszanie zwrotne jest wykonywane w trybie renderowania częściowego; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.Load> <xref:System.Web.UI.Control.PreRender> <xref:System.Web.UI.Page.InitComplete>Użyj właściwości w połączeniu <xref:System.Web.UI.Page.IsPostBack%2A> z właściwością w celu rozróżnienia początkowego ładowania strony, aktualizacji częściowej strony i aktualizacji pełnej strony w,, lub zdarzenia. <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="IsNavigating">
      <MemberSignature Language="C#" Value="public bool IsNavigating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNavigating" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsNavigating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNavigating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNavigating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNavigating : bool" Usage="System.Web.UI.ScriptManager.IsNavigating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="E:System.Web.UI.ScriptManager.Navigate" /> zdarzenie jest aktualnie obsługiwane.</summary>
        <value><see langword="true" />Jeśli jest obsługiwany; w przeciwnym razie <see langword="false" />. <see cref="E:System.Web.UI.ScriptManager.Navigate" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości <xref:System.Web.UI.ScriptManager.IsNavigating%2A> , aby określić, <xref:System.Web.UI.ScriptManager.Navigate> czy zdarzenie zostało zgłoszone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPostData">
      <MemberSignature Language="C#" Value="protected virtual bool LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection);" />
      <MemberSignature Language="F#" Value="abstract member LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool&#xA;override this.LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool" Usage="scriptManager.LoadPostData (postDataKey, postCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">Identyfikator klucza dla kontrolki.</param>
        <param name="postCollection">Kolekcja wszystkich przychodzących danych post.</param>
        <summary>Odczytuje dane formularza, które są publikowane z przeglądarki na serwerze i określa źródło asynchronicznego ogłaszania zwrotnego.</summary>
        <returns><see langword="true" />Jeśli stan <see langword="false" />kontrolki został zmieniony w wyniku ogłaszania zwrotnego; w przeciwnym razie. <see cref="T:System.Web.UI.ScriptManager" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wykorzystywana głównie przez deweloperów formantów do rozszerania funkcjonalności <xref:System.Web.UI.ScriptManager> formantu. <xref:System.Web.UI.ScriptManager.LoadPostData%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="LoadScriptsBeforeUI">
      <MemberSignature Language="C#" Value="public bool LoadScriptsBeforeUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadScriptsBeforeUI" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadScriptsBeforeUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadScriptsBeforeUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadScriptsBeforeUI : bool with get, set" Usage="System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy skrypty są ładowane przed lub po załadowaniu znacznika dla interfejsu użytkownika strony.</summary>
        <value><see langword="true" />Jeśli skrypty są ładowane przed załadowaniem znaczników dla interfejsu użytkownika; <see langword="false" /> Jeśli skrypty są ładowane po załadowaniu znacznika dla interfejsu użytkownika. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość określa sposób ładowania skryptów <xref:System.Web.UI.ScriptManager.Scripts%2A> w kolekcji względem znaczników dla interfejsu użytkownika strony. <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A>  
  
 Gdy właściwość jest `true` ,`script` element jest renderowany przed załadowaniem znacznika interfejsu użytkownika strony. <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> W tym scenariuszu, jeśli elementy interfejsu użytkownika są zdefiniowane w skryptach, interfejs użytkownika będzie w pełni funkcjonalny podczas ładowania. Jeśli jednak skrypt uzyskuje dostęp do elementów interfejsu użytkownika w znacznikach, dla których wystąpienia nie zostały jeszcze utworzone, może wystąpić błąd. Aby upewnić się, że elementy interfejsu użytkownika są ładowane przed uzyskaniem dostępu `load` do nich, `Sys.Application` należy obsłużyć zdarzenie klasy.  
  
 Gdy właściwość jest `false` ,`script` element jest renderowany po wyrenderowaniu znacznika interfejsu użytkownika strony. <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> W tym scenariuszu interfejs użytkownika jest ładowany szybciej, ale może nie być w pełni funkcjonalny, jeśli skrypty, które definiują dodatkowe elementy interfejsu użytkownika, nie zakończyły ładowania.  
  
 Nie ustawiaj tej właściwości na `true` , jeśli została <xref:System.Web.UI.ScriptManager.EnableCdn%2A> ustawiona `true` na już.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.Scripts" />
        <altmember cref="T:System.Web.UI.ScriptReference" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; Navigate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.HistoryEventArgs&gt; Navigate" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.Navigate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigate As EventHandler(Of HistoryEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::HistoryEventArgs ^&gt; ^ Navigate;" />
      <MemberSignature Language="F#" Value="member this.Navigate : EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " Usage="member this.Navigate : System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie przycisk **Wstecz** lub **do przodu** w przeglądarce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy użytkownik kliknie przycisk **Wstecz** przeglądarki, przeglądarka nawiguje przez wcześniej przeglądane adresy URL, które mogą zawierać adresy URL zawierające dane stanu punktu historii. Jeśli kod klienta na stronie sieci Web wykryje, że adres URL zawiera dane stanu historii, wysyła żądanie do strony serwera. Ta wartość działa jako zdarzenie ogłaszania zwrotnego <xref:System.Web.UI.ScriptManagerProxy> , a formant serwera `Navigate` zgłasza zdarzenie. Możesz obsłużyć to zdarzenie i ponownie utworzyć stronę zgodnie z wymaganiami aplikacji sieci Web przy użyciu danych stanu, które są przesyłane ze zdarzeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAsyncPostBackError">
      <MemberSignature Language="C#" Value="protected internal virtual void OnAsyncPostBackError (System.Web.UI.AsyncPostBackErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnAsyncPostBackError(class System.Web.UI.AsyncPostBackErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnAsyncPostBackError (e As AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnAsyncPostBackError(System::Web::UI::AsyncPostBackErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit&#xA;override this.OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit" Usage="scriptManager.OnAsyncPostBackError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.AsyncPostBackErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia błędu.</param>
        <summary><see cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> Zdarzenie jest zgłaszane w przypadku błędu strony podczas asynchronicznego ogłaszania zwrotnego. <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> Sposób<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> , w jaki błędy na serwerze są wysyłane do klienta, zależy od właściwości, właściwości i sekcji błędy niestandardowe w pliku Web. config.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Web.UI.ScriptManager.AsyncPostBackError> jak obsłużyć zdarzenie w celu <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> ustawienia właściwości (wysyłanej do klienta) na komunikat o błędzie wyjątku serwera.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="scriptManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Podnosi zdarzenie i upewnia się, że na stronie <see cref="T:System.Web.UI.ScriptManager" /> istnieje tylko jedna kontrolka. <see cref="E:System.Web.UI.Control.Init" /></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Na stronie <see cref="T:System.Web.UI.ScriptManager" /> istnieje więcej niż jedno wystąpienie.</exception>
        <block subset="none" type="overrides"><para>Podczas zastępowania tej metody Wywołaj metodę <see cref="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" /> podstawową, aby pliki skryptów były prawidłowo obsługiwane dla renderowania części strony.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Cykl życia strony ASP.NET — Omówienie</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="scriptManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary><see cref="E:System.Web.UI.Control.PreRender" /> Podnosi zdarzenie i rejestruje pliki skryptów i usługi dla aktualizacji częściowej strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje o modelu DOM, zobacz [specyfikację Level 1 Document Object Model (dom)](https://go.microsoft.com/fwlink/?LinkId=73305) w witrynie sieci Web organizacja World Wide Web Consortium (W3C).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Przeglądarka, która wprowadziła żądanie częściowej strony, nie obsługuje co najmniej modelu DOM o poziomie 1,0.</exception>
        <block subset="none" type="overrides"><para>Podczas zastępowania tej metody Wywołaj metodę <see cref="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" /> podstawową, aby bloki skryptów i usługi były prawidłowo obsługiwane dla renderowania częściowej strony.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Cykl życia strony ASP.NET — Omówienie</related>
      </Docs>
    </Member>
    <Member MemberName="OnResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveCompositeScriptReference (System.Web.UI.CompositeScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveCompositeScriptReference(class System.Web.UI.CompositeScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveCompositeScriptReference(System.Web.UI.CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveCompositeScriptReference (e As CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveCompositeScriptReference(System::Web::UI::CompositeScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveCompositeScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.CompositeScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt, który reprezentuje odwołanie do skryptu złożonego.</param>
        <summary><see cref="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveScriptReference (System.Web.UI.ScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveScriptReference(class System.Web.UI.ScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveScriptReference(System.Web.UI.ScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveScriptReference (e As ScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveScriptReference(System::Web::UI::ScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.ScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt, który reprezentuje bieżący skrypt.</param>
        <summary>Podnosi zdarzenie dla każdego odwołania do skryptu, które jest zarządzane <see cref="T:System.Web.UI.ScriptManager" /> przez formant. <see cref="E:System.Web.UI.ScriptManager.ResolveScriptReference" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Web.UI.ScriptManager.OnPreRender%2A> program obsługi zdarzeń jeden raz dla każdego <xref:System.Web.UI.ScriptReference> elementu w <xref:System.Web.UI.ScriptManager.Scripts%2A> kolekcji.  
  
 <xref:System.Web.UI.ScriptManager.ResolveScriptReference> Zdarzenie jest zgłaszane po rozwiązaniu zduplikowanych wpisów skryptu.  
  
 Zastąp tę metodę, aby mieć wpływ na zachowania poszczególnych bloków skryptu na stronie ogłaszania zwrotnego lub podczas aktualizacji częściowej strony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProfileService">
      <MemberSignature Language="C#" Value="public System.Web.UI.ProfileServiceManager ProfileService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ProfileServiceManager ProfileService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ProfileService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProfileService As ProfileServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ProfileServiceManager ^ ProfileService { System::Web::UI::ProfileServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProfileService : System.Web.UI.ProfileServiceManager" Usage="System.Web.UI.ScriptManager.ProfileService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ProfileServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który jest skojarzony z bieżącym <see cref="T:System.Web.UI.ScriptManager" /> wystąpieniem. <see cref="T:System.Web.UI.ProfileServiceManager" /></summary>
        <value>Obiekt dla bieżącego <see cref="T:System.Web.UI.ScriptManager" />wystąpienia. <see cref="T:System.Web.UI.ProfileServiceManager" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ProfileServiceManager> Obiekt, który jest zwracany przez tę właściwość, reprezentuje usługę profilu, która jest zarejestrowana na stronie. Usługę profilu można zdefiniować w <xref:System.Web.UI.ScriptManager> formancie lub w skojarzonym <xref:System.Web.UI.ScriptManagerProxy> formancie.  
  
 Możesz użyć usługi profilu ASP.NET lub użyć usługi profilu niestandardowego. Możesz dodać usługę niestandardową w znaczniku, dołączając `ProfileService` element `asp:ScriptManager` wewnątrz elementu na stronie, jak pokazano w poniższym przykładzie.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <ProfileService LoadProperties="propertyA,propertyB"  
    Path="MyProfileService.asmx" />  
</asp:ScriptManager>  
```  
  
 Można również programowo skonfigurować <xref:System.Web.UI.ProfileServiceManager> obiekt. Usługi są zarejestrowane w <xref:System.Web.UI.ScriptManager> kontrolce na etapie cyklu <xref:System.Web.UI.Control.PreRender> życia strony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : string -&gt; unit&#xA;override this.RaisePostBackEvent : string -&gt; unit" Usage="scriptManager.RaisePostBackEvent eventArgument" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">Ciąg par klucz/wartość, które reprezentują stan historii strony sieci Web.</param>
        <summary>Przetwarza zdarzenie ogłaszania zwrotnego wywoływane <see cref="T:System.Web.UI.ScriptManager" /> przez formant i ładuje stan historii strony sieci Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostDataChangedEvent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostDataChangedEvent();" />
      <MemberSignature Language="F#" Value="abstract member RaisePostDataChangedEvent : unit -&gt; unit&#xA;override this.RaisePostDataChangedEvent : unit -&gt; unit" Usage="scriptManager.RaisePostDataChangedEvent " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje zdarzenia dla kontrolki, <see cref="T:System.Web.UI.ScriptManager" /> gdy zapisuje je na serwerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wykorzystywana głównie przez deweloperów formantów do rozszerania funkcjonalności <xref:System.Web.UI.ScriptManager> formantu. <xref:System.Web.UI.ScriptManager.RaisePostDataChangedEvent%2A> Dla domyślnej implementacji <xref:System.Web.UI.ScriptManager> kontrolki nie są zgłaszane żadne zdarzenia.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterArrayDeclaration">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje deklarację tablicową ECMAScript (JavaScript) z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką znajdującą się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki i dodaje tablicę do strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (control, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje tablicę.</param>
        <param name="arrayName">Nazwa tablicy do zarejestrowania.</param>
        <param name="arrayValue">Wartość lub wartości tablicy do zarejestrowania.</param>
        <summary>Rejestruje deklarację tablicową ECMAScript (JavaScript) z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką znajdującą się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki i dodaje tablicę do strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> Metoda służy do rejestrowania tablicy skryptu klienta, która jest zgodna z renderowaniem częściowej strony i która nie ma zależności biblioteki Microsoft Ajax. Ta metoda rejestruje tablicę, `control` gdy reprezentuje kontrolkę znajdującą się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki, która jest aktualizowana. Aby zarejestrować tablicę za każdym razem, gdy odbywa się asynchroniczne ogłaszanie <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> zwrotne, Użyj przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować tablicę, która nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować tablicę tylko raz podczas wstępnego renderowania strony, użyj <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 Metoda <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> określa, czy tablica o nazwie określonej `arrayName` w parametrze jest już zarejestrowana. Jeśli tak, Metoda dodaje wartości określone w `arrayValue`. Ponieważ tablica, która ma zostać zarejestrowana, jest <xref:System.Collections.ArrayList> oparta na klasie, duplikaty są dozwolone. Jeśli zarejestrowana tablica o nazwie w `arrayName` nie istnieje, tablica zostanie utworzona i `arrayValue` zostaną do niej dodane wartości.  
  
 Aby dołączyć literały ciągu do tablicy, użyj znaków pojedynczego cudzysłowu (') lub podwójnego znaku cudzysłowu (\\") w `arrayValue`.  
  
 Należy zauważyć, że kod JavaScript traktuje przecinek (,) jako ogranicznik w tablicy. Można określić wiele wartości tablicy, przekazując ciąg rozdzielany przecinkami w `arrayValue`. Rozdzielenie dwóch elementów z przecinkiem `arrayValue` jest równoważne <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> wywołaniu metody dwa razy, jeden raz dla każdego elementu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Page page, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Page page, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Page ^ page, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (page, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje tablicę.</param>
        <param name="arrayName">Nazwa tablicy do zarejestrowania.</param>
        <param name="arrayValue">Wartość lub wartości tablicy do zarejestrowania.</param>
        <summary>Rejestruje deklarację tablicową ECMAScript (JavaScript) z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką znajdującą się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki i dodaje tablicę do strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> Metoda służy do rejestrowania tablicy skryptu klienta, która jest zgodna z renderowaniem częściowej strony i która nie ma zależności biblioteki Microsoft Ajax. Ta metoda rejestruje tablicę za każdym razem, gdy odbywa się asynchroniczne ogłaszanie zwrotne. Aby zarejestrować tablicę kontrolki, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, aby tablica była zarejestrowana tylko w przypadku, gdy panel zostanie zaktualizowany <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> , Użyj przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować tablicę, która nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować tablicę tylko raz podczas wstępnego renderowania strony, użyj <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterAsyncPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAsyncPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAsyncPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterAsyncPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterAsyncPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka, która ma zostać zarejestrowana w celu asynchronicznego ogłaszania zwrotnego.</param>
        <summary>Rejestruje formant jako wyzwalacz dla asynchronicznych ogłoszeń zwrotnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> Metoda umożliwia rejestrację formantów serwera sieci Web jako wyzwalaczy, tak aby wykonywały asynchroniczne ogłaszanie zwrotne zamiast synchronicznego ogłaszania zwrotnego. `true` <xref:System.Web.UI.UpdatePanel> Gdy właściwość <xref:System.Web.UI.UpdatePanel>kontrolki jest ustawiona na (co jest ustawieniem domyślnym), kontrolki ogłaszania zwrotnego wewnątrz formantu są automatycznie rejestrowane jako asynchroniczne kontrolki ogłaszania zwrotnego. <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A>  
  
 Użyj metody <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> , aby zarejestrować kontrolki <xref:System.Web.UI.UpdatePanel> poza kontrolką jako wyzwalacze dla asynchronicznego ogłaszania zwrotnego i potencjalnie zaktualizować zawartość panelu aktualizacji. Aby programowo zaktualizować <xref:System.Web.UI.UpdatePanel> kontrolkę, <xref:System.Web.UI.UpdatePanel.Update%2A> Wywołaj metodę.  
  
 Wyzwalacz można dodać deklaratywnie przy użyciu `Triggers` elementu <xref:System.Web.UI.UpdatePanel> formantu. W programie Visual Studio Użyj okna dialogowego **edytora kolekcji UpdatePanelTrigger** projektanta.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> jak wywołać metodę w celu <xref:System.Web.UI.WebControls.Button> zarejestrowania kontrolki, aby <xref:System.Web.UI.UpdatePanel> spowodowało ona aktualizację zawartości kontrolki. Formant nie należy do <xref:System.Web.UI.UpdatePanel> kontrolki. <xref:System.Web.UI.WebControls.Button> Pokazywane są dwa przyciski `Button1` : `Button2`i. `Button1`odświeża zawartość panelu, a `Button2` następnie odświeża całą stronę.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager1VB.aspx#1)]  
  
 Poniższy przykład pokazuje, <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> jak wywołać metodę w celu zarejestrowania kontrolki użytkownika, aby spowodować aktualizację <xref:System.Web.UI.UpdatePanel> zawartości kontrolki. Pierwszy przykład przedstawia stronę przy użyciu kontrolki użytkownika. Drugi przykład pokazuje kontrolkę użytkownika.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager2CS.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager2VB.aspx#2)]  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Strona jest zarejestrowana jako asynchroniczny formant ogłaszania zwrotnego.
—lub—

Zarejestrowany formant nie implementuje <see cref="T:System.Web.UI.INamingContainer" />interfejsów, <see cref="T:System.Web.UI.IPostBackDataHandler" />, ani <see cref="T:System.Web.UI.IPostBackEventHandler" /> .</exception>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
        <altmember cref="M:System.Web.UI.UpdatePanel.Update" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje blok skryptu klienta z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką znajdującą się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki, a następnie dodaje do strony blok skryptu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje blok skryptu klienta.</param>
        <param name="type">Typ bloku skryptu klienta. Ten parametr jest zwykle określany za pomocą <see langword="typeof" /> operatora (C#) lub <see langword="GetType" /> operatora (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="key">Unikatowy identyfikator bloku skryptu.</param>
        <param name="script">Skrypt.</param>
        <param name="addScriptTags"><see langword="true" />aby ująć blok skryptu w <see langword="&lt;script&gt;" /> i <see langword="&lt;/script&gt;" /> Tagi; w przeciwnym razie, <see langword="false" />.</param>
        <summary>Rejestruje blok skryptu klienta z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką znajdującą się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki, a następnie dodaje do strony blok skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> Metoda służy do rejestrowania bloku skryptu klienta, który jest zgodny z renderowaniem częściowej strony i który nie ma zależności biblioteki Microsoft Ajax. Bloki skryptu klienta zarejestrowane za pomocą tej metody są wysyłane na stronę tylko wtedy, gdy `control` reprezentuje kontrolkę znajdującą się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki, która jest aktualizowana. Aby zarejestrować blok skryptu za każdym razem, gdy następuje asynchroniczne ogłaszanie zwrotne <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> , Użyj przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować blok skryptu tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 Jeśli `addScriptTags` jest `true`, Metoda<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> dodaje`<script>` Tagi wokół bloku skryptu. Przekaż `false` , jeśli chcesz samodzielnie tworzyć `<script>` Tagi, na przykład gdy chcesz ustawić atrybuty określonych `<script>` tagów. Jeśli `addScriptTags` jest `false` i`script` parametr zawiera wiele bloków skryptu, zostanie zgłoszony wyjątek.  
  
 Metoda dodaje blok skryptu do strony po tagu otwierającym `<form>`. <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> Bloki skryptu nie są gwarantowane w takiej samej kolejności, w jakiej zostały zarejestrowane. Jeśli kolejność bloków skryptu jest ważna, Połącz bloki skryptów w jeden ciąg (na przykład przy użyciu <xref:System.Text.StringBuilder> obiektu), a następnie zarejestruj je jako pojedynczy blok skryptu klienta.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/CS/ScriptManager_RegisterClientScriptBlockCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/vb/ScriptManager_RegisterClientScriptBlockVB.aspx#1)]  
  
 [!code-xml[System.Web.UI.ScriptManager.RegisterClientScriptBlock#2](~/samples/snippets/common/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/Common/App_Data/Contacts.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Blok <paramref name="type" /> skryptu klienta to <see langword="null" />.  
  
—lub— 
Formant, który rejestruje blok skryptu, to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kontrolka rejestrująca blok skryptu nie znajduje się w drzewie formantów strony.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje blok skryptu klienta.</param>
        <param name="type">Typ bloku skryptu klienta. Ten parametr jest zwykle określany za pomocą <see langword="typeof" /> operatora (C#) lub <see langword="GetType" /> operatora (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="key">Unikatowy identyfikator bloku skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <param name="addScriptTags"><see langword="true" />aby ująć blok skryptu w <see langword="&lt;script&gt;" /> i <see langword="&lt;/script&gt;" /> Tagi; w przeciwnym razie, <see langword="false" />.</param>
        <summary>Rejestruje blok skryptu klienta z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką znajdującą się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki, a następnie dodaje do strony blok skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zarejestrowaniu bloku skryptu przy użyciu tej metody skrypt jest renderowany za każdym razem, gdy odbywa się asynchroniczne ogłaszanie zwrotne. Aby zarejestrować blok skryptu dla kontrolki, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, tak aby skrypt był zarejestrowany tylko <xref:System.Web.UI.UpdatePanel> podczas aktualizowania kontrolki, użyj <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować blok skryptu tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Blok <paramref name="type" /> skryptu to <see langword="null" />.  
  
—lub— 
Strona rejestrująca blok skryptu ma wartość <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje plik skryptu klienta z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką znajdującą się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki, a następnie dodaje do strony odwołanie do pliku skryptu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (control, type, key, url)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje plik skryptu klienta.</param>
        <param name="type">Typ pliku skryptu klienta. Ten parametr jest zwykle określany za pomocą operatora typeof (C#) lub GetType (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="key">Unikatowy identyfikator pliku skryptu.</param>
        <param name="url">Adres URL pliku skryptu.</param>
        <summary>Rejestruje plik skryptu klienta z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką znajdującą się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki, a następnie dodaje do strony odwołanie do pliku skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> Metoda służy do rejestrowania pliku skryptu klienta dla strony lub części strony, która uczestniczy w aktualizacjach części strony. Pliki skryptów klienta zarejestrowane przy użyciu tej metody są wysyłane do strony tylko wtedy, `control` gdy reprezentuje kontrolkę znajdującą się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki, która jest aktualizowana. Aby zarejestrować plik skryptu za każdym razem, gdy następuje asynchroniczne ogłaszanie zwrotne <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> , Użyj przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować blok skryptu tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 Metoda rejestruje plik skryptu klienta na stronie przez `script` renderowanie elementu, `src` którego tag otwierającego zawiera atrybut. <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> Parametr jest używany do `src` ustawiania atrybutu. `url` Aby rozwiązać adresy URL, użyj <xref:System.Web.UI.Control.ResolveClientUrl%2A> metody. Ta metoda używa kontekstu adresu URL, dla którego jest wywoływana, aby rozpoznać ścieżkę.  
  
 Obie metody <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> i renderują pliki skryptów do przeglądarki. <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> Jeśli skrypt z tym samym typem i kluczem (dla pliku skryptu) lub tego samego typu i nazwy zasobu (dla zasobu osadzonego) jest już renderowany, skrypt nie zostanie ponownie renderowany.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptInclude#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/ScriptManager_RegisterClientScriptIncludeCS.aspx#1)]  
  
 [!code-javascript[System.Web.UI.ScriptManager.RegisterClientScriptInclude#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/scripts/script_alertdiv.js#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Plik <paramref name="type" /> skryptu klienta to <see langword="null" />.  
  
—lub— 
Formant, który rejestruje plik skryptu, to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kontrolka rejestrująca plik skryptu nie znajduje się w drzewie formantów strony.  
  
—lub— 
 <paramref name="url" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="url" />jest puste.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Page page, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Page page, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (page, type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje plik skryptu klienta.</param>
        <param name="type">Typ pliku skryptu klienta. Ten parametr jest zwykle określany za pomocą operatora typeof (C#) lub GetType (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="key">Unikatowy identyfikator pliku skryptu.</param>
        <param name="url">Adres URL pliku skryptu.</param>
        <summary>Rejestruje skrypt klienta z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką za każdym razem, gdy odbywa się asynchroniczne ogłaszanie zwrotne, a następnie dodaje do strony odwołanie do pliku skryptu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zarejestrowaniu pliku skryptu za pomocą tej metody skrypt jest renderowany za każdym razem, gdy następuje asynchroniczne ogłaszanie zwrotne. Aby zarejestrować plik skryptu dla kontrolki znajdującej się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, tak aby skrypt był rejestrowany tylko <xref:System.Web.UI.UpdatePanel> podczas aktualizacji kontrolki, użyj <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować blok skryptu tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Plik <paramref name="type" /> skryptu klienta to <see langword="null" />.  
  
—lub— 
Strona, która rejestruje plik skryptu, to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="url" />jest puste.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje skrypt klienta osadzony w zestawie z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką, która uczestniczy w renderowaniu częściowej strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Control * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (control, type, resourceName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje skrypt.</param>
        <param name="type">Typ skryptu klienta. Ten parametr jest zwykle określany za pomocą operatora typeof (C#) lub GetType (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="resourceName">Identyfikator zasobu.</param>
        <summary>Rejestruje skrypt klienta osadzony w zestawie z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką, która uczestniczy w renderowaniu częściowej strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> Metoda służy do rejestrowania skryptu zgodnego z renderowaniem częściowej strony i nie ma zależności biblioteki Microsoft Ajax. Zasoby skryptów, które są zarejestrowane przy użyciu tej metody, są rejestrowane `control` tylko wtedy, gdy reprezentuje kontrolkę <xref:System.Web.UI.UpdatePanel> znajdującą się wewnątrz kontrolki, która jest aktualizowana. Aby zarejestrować skrypt za każdym razem, gdy następuje asynchroniczne ogłaszanie zwrotne <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> , Użyj przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować blok skryptu tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> Metoda jest używana podczas uzyskiwania dostępu do zasobów z zestawów za pośrednictwem programu obsługi protokołu HTTP. Ta metoda obejmuje zawartość adresu URL zasobu w `script` elemencie.  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> Zarówno ,<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> jak i Metoda ładowania plików skryptów do przeglądarki. Jeśli skrypt z tym samym typem i kluczem (dla pliku skryptu) lub tego samego typu i nazwy zasobu (dla zasobu osadzonego) jest już załadowany, skrypt nie zostanie ponownie załadowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Zasób <paramref name="type" /> klienta ma <see langword="null" />wartość.  
  
—lub— 
Formant, który rejestruje skrypt, to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kontrolka rejestrująca skrypt nie znajduje się w drzewie formantów strony.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Page page, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Page page, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Page ^ page, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Page * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (page, type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje skrypt.</param>
        <param name="type">Typ skryptu klienta. Ten parametr jest zwykle określany za pomocą operatora typeof (C#) lub GetType (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="resourceName">Identyfikator zasobu.</param>
        <summary>Rejestruje plik skryptu klienta osadzony w zestawie z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką za każdym razem, gdy następuje ogłaszanie zwrotne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zarejestrowaniu pliku skryptu za pomocą tej metody skrypt jest renderowany za każdym razem, gdy następuje asynchroniczne ogłaszanie zwrotne. Aby zarejestrować skrypt kontrolki, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, tak aby skrypt był zarejestrowany tylko <xref:System.Web.UI.UpdatePanel> podczas aktualizowania kontrolki, użyj <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować blok skryptu tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Zasób <paramref name="type" /> klienta ma <see langword="null" />wartość.  
  
—lub— 
Strona, która rejestruje skrypt, to <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterDataItem">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła niestandardowe dane do kontrolek podczas renderowania części strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka, która otrzymuje dane.</param>
        <param name="dataItem">Dane, które są wysyłane do kontrolki.</param>
        <summary>Wysyła dane niestandardowe do kontrolki podczas renderowania części strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody do wysyłania danych z serwera do klienta podczas asynchronicznego ogłaszania zwrotnego, niezależnie od tego, czy formant otrzymujący dane znajduje się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki. <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>  
  
 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> Metodę można wywołać tylko podczas asynchronicznego ogłaszania zwrotnego. Aby określić, czy ogłaszanie zwrotne jest asynchroniczne <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> , użyj właściwości. Ta metoda wywołuje Przeciążenie, które przyjmuje parametr o nazwie `isJsonSerialized` , który jest ustawiony `false`na. Gdy parametr jest ustawiony na `false`, ciąg nie jest serializowany jako JavaScript Object Notation (JSON). `isJsonSerialized` Aby uzyskać więcej informacji na temat formatu JSON, zobacz witrynę sieci Web w formacie [JSON](https://go.microsoft.com/fwlink/?LinkId=77297) .  
  
 Do elementów danych, które są zarejestrowane za <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> pomocą metody `pageLoading`, można uzyskać dostęp w skrypcie klienta podczas `pageLoaded`, i `endRequest` zdarzeń `PageRequestManager` obiektu. Podczas obsługi tych zdarzeń dane niestandardowe są przesyłane w obiekcie argumentu zdarzenia. Na przykład jeśli podano procedurę obsługi dla `pageLoading` zdarzenia, dane niestandardowe są przesyłane `PageLoadingEventArgs` w klasie, która uwidacznia właściwość.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wysyłać dane do dwóch <xref:System.Web.UI.WebControls.Label> kontrolek na stronie podczas asynchronicznego ogłaszania zwrotnego. Kontrolki nie znajdują się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki. <xref:System.Web.UI.WebControls.Label>  
  
> [!NOTE]
>  Dane wysyłane w tym przykładzie są przeznaczone tylko dla ilustracji. W rzeczywistej aplikacji należy użyć <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> metody do wysyłania danych niestandardowych z serwera.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> Metoda jest wywoływana podczas ogłaszania zwrotnego.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dataItem" />jest już zarejestrowany dla <paramref name="control" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem, bool isJsonSerialized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string * bool -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem, isJsonSerialized)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
        <Parameter Name="isJsonSerialized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka strony, która otrzymuje dane.</param>
        <param name="dataItem">Dane, które są wysyłane do kontrolki.</param>
        <param name="isJsonSerialized"><see langword="true" />Aby wskazać, <paramref name="dataItem" /> że jest serializowana jako JSON; <see langword="false" />w przeciwnym razie,.</param>
        <summary>Wysyła dane niestandardowe do kontrolki podczas renderowania części strony i wskazuje, czy dane są w formacie JavaScript Object Notation (JSON).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używasz metody do wysyłania danych z serwera do klienta podczas asynchronicznego ogłaszania zwrotnego, niezależnie od tego, czy formant otrzymujący dane znajduje się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki. <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>  
  
 Jeśli parametr rejestrowany dla programu `control` nie jest serializowany `isJsonSerialized` jako JSON, ustaw parametr na `false`. `dataItem` Pozwala to uniknąć konieczności używania `eval` funkcji dla każdego ciągu, który jest wysyłany do klienta. Aby uzyskać więcej informacji na temat formatu JSON, zobacz witrynę sieci Web w formacie [JSON](https://go.microsoft.com/fwlink/?LinkId=77297) .  
  
 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> Metodę można wywołać tylko podczas asynchronicznego ogłaszania zwrotnego. Aby określić, czy ogłaszanie zwrotne jest asynchroniczne <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> , użyj właściwości.  
  
 Do elementów danych, które są rejestrowane za pomocą <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> metody `pageLoading`, można uzyskać dostęp w skrypcie klienta podczas, `pageLoaded`i `endRequest` zdarzeń `PageRequestManager` obiektu. Podczas obsługi tych zdarzeń dane niestandardowe są przesyłane w obiekcie argumentu zdarzenia. Na przykład jeśli podano procedurę obsługi dla `pageLoading` zdarzenia, dane niestandardowe są przesyłane `PageLoadingEventArgs` w klasie, która uwidacznia właściwość.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wysyłać dane do dwóch <xref:System.Web.UI.WebControls.Label> kontrolek na stronie podczas asynchronicznego ogłaszania zwrotnego. Kontrolki nie znajdują się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki. <xref:System.Web.UI.WebControls.Label> Ten przykład pokazuje Przeciążenie, które nie przyjmuje `isJsonSerialized` parametru. W przeciwnym razie procedura pobierania `dataItems` właściwości `PageLoadingEventArgs` obiektu jest taka sama jak w przypadku, gdy nie użyto tego przeciążenia.  
  
> [!NOTE]
>  Dane wysyłane w tym przykładzie są przeznaczone tylko dla ilustracji. W rzeczywistej aplikacji należy użyć <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> metody do wysyłania danych niestandardowych z serwera. Na przykład można użyć elementu danych do wysłania informacji o tym, czy ukryć lub pokazać elementy klienta, które nie znajdują się <xref:System.Web.UI.UpdatePanel> wewnątrz kontrolki.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> Metoda jest wywoływana podczas ogłaszania zwrotnego.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dataItem" />jest już zarejestrowany dla <paramref name="control" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDispose">
      <MemberSignature Language="C#" Value="public void RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript);" />
      <MemberSignature Language="F#" Value="member this.RegisterDispose : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDispose (control, disposeScript)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterDispose(System.Web.UI.Control,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, dla którego <see langword="dispose" /> jest skrypt.</param>
        <param name="disposeScript"><see langword="dispose" /> Skrypt.</param>
        <summary>Rejestruje skrypt dla kontrolki, która znajduje się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki. <see langword="dispose" /> Skrypt jest wykonywany, gdy <see cref="T:System.Web.UI.UpdatePanel" /> kontrolka jest aktualizowana lub usuwana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody do rejestrowania `dispose` skryptów dla <xref:System.Web.UI.UpdatePanel> formantów, które znajdują się wewnątrz kontrolki. <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> Podczas asynchronicznego ogłaszania zwrotnego <xref:System.Web.UI.UpdatePanel> można aktualizować, usuwać lub tworzyć formanty. Gdy panel zostanie zaktualizowany lub usunięty, wszystkie `dispose` skrypty, które są zarejestrowane dla formantów, które znajdują się <xref:System.Web.UI.UpdatePanel> wewnątrz są wywoływane. W typowych scenariuszach tworzenia stron nie ma potrzeby wywoływania <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> metody.  
  
 Metoda jest przeznaczona do użytku przez deweloperów kontrolujących, aby rejestrować skrypty lub tworzyć kontrolki dziedziczące <xref:System.Web.UI.IScriptControl> z interfejsu. <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> Można na przykład użyć `dispose` skryptu, jeśli tworzysz kontrolkę klienta przy użyciu kompozycji. W formancie są implementowane <xref:System.Web.UI.IScriptControl> i renderowane poszczególne kontrolki. Należy zarejestrować `dispose` metodę dowolnego elementu, który nie odpowiada zdefiniowanemu składnikowi `Sys.TextBox`klienta, na przykład. Jeśli kontrolka niestandardowa składa elementy, które odpowiadają składnikom klienta w bibliotece Microsoft Ajax, nie trzeba rejestrować `dispose` skryptu, ponieważ `dispose` jest on wywoływany automatycznie. W związku z tym <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> należy użyć metody dla składników klienta, które są częścią biblioteki Microsoft Ajax, i które mają zwolnić zasoby, gdy składnik nie jest już używany.  
  
 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> Metodę można wywołać wiele razy dla kontrolki. Wiele skryptów jest agregowanych. Kolejność usuwania skryptów jest zgodna z kolejnością, w której skrypty zostały zarejestrowane.  
  
 Po zarejestrowaniu `dispose` skryptu dla kontrolki, która nie znajduje się <xref:System.Web.UI.UpdatePanel> w kontrolce, zostanie zgłoszony wyjątek. Skrypt jest wywoływany `pageLoading` między zdarzeniami `pageLoaded` `PageRequestManager` i klasy. `dispose`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="disposeScript" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />nie znaleziono na stronie.  
  
—lub— 
 <paramref name="control" />nie znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> kontrolki.</exception>
        <altmember cref="T:System.Web.UI.IScriptControl" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public static void RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="static member RegisterExpandoAttribute : System.Web.UI.Control * string * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterExpandoAttribute (control, controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje atrybut expand.</param>
        <param name="controlId">Formant, który zawiera atrybut niestandardowy na stronie.</param>
        <param name="attributeName">Nazwa atrybutu niestandardowego do zarejestrowania.</param>
        <param name="attributeValue">Wartość atrybutu niestandardowego.</param>
        <param name="encode"><see langword="true" />aby zakodować atrybut niestandardowy, który jest rejestrowany; w przeciwnym razie. <see langword="false" /></param>
        <summary>Rejestruje parę nazwa/wartość z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką jako atrybut niestandardowy (Expand) określonej kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> Metoda jest używana do rejestrowania niestandardowej właściwości kontrolki, która jest zgodna z renderowaniem częściowej strony i która nie ma zależności biblioteki Microsoft Ajax.  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> Metoda rejestruje parę nazwa/wartość jako atrybut niestandardowy dla określonej kontrolki. Właściwość jest ustawiana dynamicznie z ECMAScript (JavaScript), aby zachować zgodność XHTML dla renderowanego znacznika kontrolki. Ustaw `encode` na`true` , jeśli chcesz, aby wszystkie znaki w wartości właściwości dynamicznej były wyprowadzane.  
  
 Jeśli nie zostanie znaleziona kontrolka, do której zostanie dodana właściwość dynamiczna, wystąpi błąd skryptu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />nie znajduje się w drzewie formantów strony.  
  
—lub— 
 <paramref name="controlId" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="controlId" />jest puste.  
  
—lub— 
 <paramref name="attributeName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="attributeName" />jest puste.  
  
—lub— 
 <paramref name="attributeName" />jest już zarejestrowany.</exception>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExtenderControl&lt;TExtenderControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterExtenderControl&lt;TExtenderControl&gt; (TExtenderControl extenderControl, System.Web.UI.Control targetControl) where TExtenderControl : System.Web.UI.Control, System.Web.UI.IExtenderControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterExtenderControl&lt;(class System.Web.UI.Control, class System.Web.UI.IExtenderControl) TExtenderControl&gt;(!!TExtenderControl extenderControl, class System.Web.UI.Control targetControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExtenderControl(Of TExtenderControl As {Control, IExtenderControl}) (extenderControl As TExtenderControl, targetControl As Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TExtenderControl&gt;&#xA; where TExtenderControl : System::Web::UI::Control, System::Web::UI::IExtenderControl virtual void RegisterExtenderControl(TExtenderControl extenderControl, System::Web::UI::Control ^ targetControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)&#xA;override this.RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)" Usage="scriptManager.RegisterExtenderControl (extenderControl, targetControl)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterExtenderControl``1(``0,System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TExtenderControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IExtenderControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="extenderControl" Type="TExtenderControl" />
        <Parameter Name="targetControl" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <typeparam name="TExtenderControl">Kontrolka, która implementuje <see cref="T:System.Web.UI.IExtenderControl" /> interfejs.</typeparam>
        <param name="extenderControl">Kontrolka rozszerzenia do zarejestrowania.</param>
        <param name="targetControl">Formant skryptu rozciągany przez formant rozszerzający.</param>
        <summary>Rejestruje formant rozszerzający z bieżącym <see cref="T:System.Web.UI.ScriptManager" /> wystąpieniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest głównie używana przez deweloperów kontroli. Wywoływanie `onInit` metody z niestandardowej kontrolki rozszerzenia AJAX ASP.NET podczas obsługi zdarzeń w celu zarejestrowania tego formantu ze stroną. <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> Kontrolka rozszerzenia AJAX ASP.NET musi być zarejestrowana w celu uczestniczenia w renderowaniu części strony.  
  
 <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> Metoda dodaje określoną kontrolkę Extender do wewnętrznej listy formantów rozszerzających i docelową kontrolki skryptu. Ta lista jest przetwarzana podczas <xref:System.Web.UI.Control.PreRender> zdarzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="extenderControl" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="targetControl" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterHiddenField">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje pole ukryte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (control, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje pole ukryte.</param>
        <param name="hiddenFieldName">Nazwa ukrytego pola do zarejestrowania.</param>
        <param name="hiddenFieldInitialValue">Początkowa wartość pola ukrytego.</param>
        <summary>Rejestruje pole ukryte z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką kontrolki, która znajduje się <see cref="T:System.Web.UI.UpdatePanel" /> wewnątrz kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> Metoda służy do rejestrowania ukrytego pola, które jest zgodne z renderowaniem częściowej strony i która nie ma zależności biblioteki Microsoft Ajax. Ta metoda rejestruje pole ukryte, gdy formant, który rejestruje pole znajduje się w <xref:System.Web.UI.UpdatePanel> kontrolce, która jest aktualizowana. Aby zarejestrować pole ukryte za każdym razem, gdy następuje asynchroniczne ogłaszanie zwrotne <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> , Użyj przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować ukryte pole, które nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować ukryte pole tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 Metoda tworzy element ukryty `input` na renderowanej stronie HTML. <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="hiddenFieldName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />nie znajduje się w drzewie formantów strony.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Page ^ page, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (page, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje pole ukryte.</param>
        <param name="hiddenFieldName">Nazwa ukrytego pola do zarejestrowania.</param>
        <param name="hiddenFieldInitialValue">Początkowa wartość pola ukrytego.</param>
        <summary>Rejestruje ukryte pole z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką podczas każdego asynchronicznego ogłaszania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> Metoda służy do rejestrowania ukrytego pola, które jest zgodne z renderowaniem częściowej strony i która nie ma zależności biblioteki Microsoft Ajax. Ta metoda rejestruje pole ukryte za każdym razem, gdy odbywa się asynchroniczne ogłaszanie zwrotne. Aby zarejestrować pole ukryte dla formantu znajdującego się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, tak aby pole było rejestrowane tylko w przypadku, gdy panel zostanie zaktualizowany, <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> Użyj przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować ukryte pole, które nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować ukryte pole tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="hiddenFieldName" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterNamedClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje skrypt klienta według nazwy zasobu osadzone w zestawie z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką, która uczestniczy w renderowaniu częściowej strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Control control, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Control control, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Control ^ control, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Control * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (control, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje skrypt.</param>
        <param name="resourceName">Identyfikator zasobu.</param>
        <summary>Rejestruje skrypt klienta według nazwy zasobu osadzone w zestawie z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką, która uczestniczy w renderowaniu częściowej strony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Page page, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Page page, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Page,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Page ^ page, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Page * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (page, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje skrypt.</param>
        <param name="resourceName">Identyfikator zasobu.</param>
        <summary>Rejestruje skrypt klienta według nazwy zasobu osadzone w zestawie z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką do użycia z kontrolką, która uczestniczy w renderowaniu częściowej strony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterOnSubmitStatement">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje kod ECMAScript (JavaScript), który jest wykonywany podczas przesyłania formularza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (control, type, key, script)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje <see langword="onsubmit" /> instrukcję.</param>
        <param name="type">Typ instrukcji skryptu klienta. Ten parametr jest zwykle określany za pomocą operatora typeof (C#) lub GetType (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="key">Unikatowy identyfikator instrukcji skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <summary>Rejestruje kod ECMAScript (JavaScript) z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką kontrolki, która jest używana <see cref="T:System.Web.UI.UpdatePanel" /> z kontrolką wykonywaną podczas przesyłania formularza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> Dodaje skrypt, który jest wykonywany przed przesłaniem formularza, co pozwala na modyfikowanie przesyłania lub anulowanie go.  
  
 Używasz metody do `onsubmit` renderowania instrukcji, która jest zgodna z renderowaniem częściowej strony i która nie ma zależności biblioteki Microsoft Ajax. <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> Kod JavaScript zarejestrowany przy użyciu tej metody jest wysyłany na stronę tylko wtedy, gdy formant, który rejestruje instrukcję, znajduje się w <xref:System.Web.UI.UpdatePanel> kontrolce, która jest aktualizowana. Aby zarejestrować kod przy każdym asynchronicznym ogłaszaniu zwrotnym, użyj <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować kod JavaScript, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować kod tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 Parametr<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> *skryptu* metody może zawierać wiele poleceń skryptu, które są rozdzielane za pomocą średników (;).  
  
 Aby uzyskać więcej informacji na temat formularzy HTML `onsubmit` i zdarzenia, zobacz [witrynę sieci Web organizacja World Wide Web Consortium (W3C)](https://go.microsoft.com/fwlink/?linkid=37125).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />nie znajduje się w drzewie formantów strony.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Page page, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Page page, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (page, type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje <see langword="onsubmit" /> instrukcję.</param>
        <param name="type">Typ instrukcji skryptu klienta. Ten parametr jest zwykle określany za pomocą operatora typeof (C#) lub GetType (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="key">Unikatowy identyfikator instrukcji skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <summary>Rejestruje kod ECMAScript (JavaScript) z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką kontrolki, która jest używana <see cref="T:System.Web.UI.UpdatePanel" /> z kontrolką wykonywaną podczas przesyłania formularza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarejestrowanie kodu JavaScript przy użyciu tej metody powoduje, że skrypt ma być dołączany za każdym razem, gdy następuje asynchroniczne ogłaszanie zwrotne.  
  
> [!NOTE]
>  Kod ze wszystkich wcześniejszych asynchronicznych ogłoszeń zwrotnych nie został usunięty. Nowe asynchroniczne ogłaszanie zwrotne dołącza kod do dowolnego istniejącego kodu `onsubmit` dla instrukcji.  
  
 Aby zarejestrować kod kontrolki, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, tak aby kod był zarejestrowany tylko wtedy <xref:System.Web.UI.UpdatePanel> , gdy kontrolka <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> jest aktualizowana, Użyj przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować kod JavaScript, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować kod tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="type" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka, która ma zostać zarejestrowana w celu odświeżenia.</param>
        <summary>Rejestruje formant jako wyzwalacz do ogłaszania zwrotnego. Ta metoda służy do konfigurowania kontrolek ogłaszania zwrotnego wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> kontrolki, która w przeciwnym razie będzie wykonywała asynchroniczne ogłaszanie zwrotne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby zarejestrować kontrolki ogłaszania <xref:System.Web.UI.UpdatePanel> zwrotnego w kontrolce jako wyzwalacze. <xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A> Kontrolki zarejestrowane przy użyciu tej metody aktualizują całą stronę zamiast aktualizować tylko <xref:System.Web.UI.UpdatePanel> zawartość kontrolki. Rejestracja kontrolki ogłaszania zwrotnego za pomocą <xref:System.Web.UI.UpdatePanel> tej metody poza kontrolką nie ma wpływu, ponieważ domyślnie te kontrolki nie wykonują asynchronicznych zwrotów.  
  
 Wyzwalacz można dodać deklaratywnie przy użyciu `Triggers` elementu <xref:System.Web.UI.UpdatePanel> formantu. W programie Visual Studio Użyj okna dialogowego **edytora kolekcji UpdatePanelTrigger** projektanta.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptControl&lt;TScriptControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterScriptControl&lt;TScriptControl&gt; (TScriptControl scriptControl) where TScriptControl : System.Web.UI.Control, System.Web.UI.IScriptControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptControl&lt;(class System.Web.UI.Control, class System.Web.UI.IScriptControl) TScriptControl&gt;(!!TScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptControl(Of TScriptControl As {Control, IScriptControl}) (scriptControl As TScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TScriptControl&gt;&#xA; where TScriptControl : System::Web::UI::Control, System::Web::UI::IScriptControl virtual void RegisterScriptControl(TScriptControl scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)&#xA;override this.RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)" Usage="scriptManager.RegisterScriptControl scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptControl``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TScriptControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IScriptControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="scriptControl" Type="TScriptControl" />
      </Parameters>
      <Docs>
        <typeparam name="TScriptControl">Kontrolka, która implementuje <see cref="T:System.Web.UI.IScriptControl" /> interfejs.</typeparam>
        <param name="scriptControl">Kontrolka skryptu do zarejestrowania.</param>
        <summary>Rejestruje formant skryptu z bieżącym <see cref="T:System.Web.UI.ScriptManager" /> wystąpieniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest głównie używana przez deweloperów kontroli. Wywoływanie `onInit` metody z niestandardowej kontrolki skryptu ASP.NET AJAX podczas obsługi zdarzeń w celu zarejestrowania tego formantu ze stroną. <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> Kontrolka skryptu ASP.NET AJAX musi być zarejestrowana w celu uczestniczenia w renderowaniu części strony.  
  
 Metoda dodaje określony formant Extender do wewnętrznej listy formantów skryptu, które są przetwarzane <xref:System.Web.UI.Control.PreRender> podczas zdarzenia. <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scriptControl" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterScriptDescriptors">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Instruuje <see cref="T:System.Web.UI.ScriptControl" /> <see cref="T:System.Web.UI.ExtenderControl" /> formant, aby wywoływać z powrotem do klas lub w celu zwracania skryptów, które obsługują obiekt klienta, który reprezentuje kontrolkę klienta, składnik lub zachowanie. <see cref="T:System.Web.UI.ScriptManager" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IExtenderControl extenderControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IExtenderControl extenderControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (extenderControl As IExtenderControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IExtenderControl ^ extenderControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors extenderControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extenderControl" Type="System.Web.UI.IExtenderControl" />
      </Parameters>
      <Docs>
        <param name="extenderControl">Formant rozszerzający, dla którego zostaną zarejestrowane deskryptory skryptu.</param>
        <summary>Wywołuje z powrotem do <see cref="T:System.Web.UI.ExtenderControl" /> klasy, aby zwracała skrypty wystąpienia, które muszą być renderowane do obsługi obiektu klienta, który reprezentuje kontrolkę klienta, składnik lub zachowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa wywołuje metodę w<xref:System.Web.UI.Control.Render%2A>metodzie. <xref:System.Web.UI.ExtenderControl> <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli pochodzi z <see cref="T:System.Web.UI.ExtenderControl" /> klasy i <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> zastąpi metodę, ale nie wywołasz metody klasy bazowej <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" /> , musisz wywołać metodę. Dzięki <see cref="T:System.Web.UI.ScriptManager" /> temu formant może renderować skrypty wystąpienia, które obsługują obiekt klienta, który reprezentuje formant.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IScriptControl scriptControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (scriptControl As IScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IScriptControl ^ scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IScriptControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptControl" Type="System.Web.UI.IScriptControl" />
      </Parameters>
      <Docs>
        <param name="scriptControl">Kontrolka skryptu, dla której zostaną zarejestrowane deskryptory skryptu.</param>
        <summary><see cref="T:System.Web.UI.ScriptControl" /> Wywołuje klasę, aby zwracała skrypty wystąpienia, które muszą być renderowane do obsługi obiektu klienta, który reprezentuje kontrolkę klienta, składnik lub zachowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa wywołuje metodę w trakcie jego <xref:System.Web.UI.Control.Render%2A> zdarzenia. <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> <xref:System.Web.UI.ScriptControl>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli pochodzi z <see cref="T:System.Web.UI.ScriptControl" /> klasy i <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> zastąpi metodę, ale nie wywołasz metody klasy bazowej <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" /> , musisz wywołać metodę. Dzięki <see cref="T:System.Web.UI.ScriptManager" /> temu formant może renderować skrypty wystąpienia, które obsługują obiekt klienta, który reprezentuje formant.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje blok skryptu uruchamiania z <see cref="T:System.Web.UI.ScriptManager" /> kontrolką i dodaje blok skryptu do strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje blok skryptu klienta.</param>
        <param name="type">Typ bloku skryptu klienta. Ten parametr jest zwykle określany za pomocą operatora typeof (C#) lub GetType (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="key">Unikatowy identyfikator bloku skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <param name="addScriptTags"><see langword="true" />Aby umieścić blok skryptu z <see langword="&lt;script&gt;" /> tagami i <see langword="&lt;/script&gt;" /> ; w przeciwnym razie, <see langword="false" />.</param>
        <summary>Rejestruje blok skryptu uruchamiania dla kontrolki, która znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> elementu <see cref="T:System.Web.UI.ScriptManager" /> przy użyciu kontrolki i dodaje blok skryptu do strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> Metoda służy do rejestrowania bloku skryptu uruchamiania dla strony, która jest zgodna z renderowaniem częściowej strony i która nie ma zależności biblioteki Microsoft Ajax. Bloki skryptów uruchamiania, które są zarejestrowane za pomocą tej metody są wysyłane do strony tylko wtedy, gdy formant, który rejestruje blok, znajduje się <xref:System.Web.UI.UpdatePanel> w kontrolce, która jest aktualizowana. Aby zarejestrować blok skryptu uruchomieniowego za każdym razem, gdy następuje asynchroniczne ogłaszanie zwrotne, użyj <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować skrypt uruchamiania, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować skrypt tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 Blok skryptu, który jest renderowany przez <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> metodę, jest wykonywany po zakończeniu ładowania strony, ale przed podniesieniem zdarzenia klienta `onload` strony. Bloki skryptów uruchamiania znajdują się u dołu renderowanej strony ASP.NET tuż przed `</form>` tagiem.  
  
 Bloki skryptów uruchamiania, które są zarejestrowane przy <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> użyciu, nie powinny być wyprowadzane w takiej samej kolejności, w jakiej zostały zarejestrowane. Jeśli kolejność bloków skryptów uruchamiania jest ważna, użyj <xref:System.Text.StringBuilder> obiektu do zbierania bloków skryptów w jednym ciągu, a następnie zarejestruj je wszystkie jako jeden skrypt uruchamiania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />nie znajduje się w drzewie formantów strony.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje blok skryptu klienta.</param>
        <param name="type">Typ bloku skryptu klienta. Ten parametr jest zwykle określany za pomocą operatora typeof (C#) lub GetType (Visual Basic) do pobrania typu formantu, który rejestruje skrypt.</param>
        <param name="key">Unikatowy identyfikator bloku skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <param name="addScriptTags"><see langword="true" />Aby umieścić blok skryptu z <see langword="&lt;script&gt;" /> tagami i <see langword="&lt;/script&gt;" /> ; w przeciwnym razie, <see langword="false" />.</param>
        <summary>Rejestruje blok skryptu uruchamiania dla każdego asynchronicznego ogłaszania zwrotnego <see cref="T:System.Web.UI.ScriptManager" /> przy użyciu kontrolki i dodaje blok skryptu do strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do rejestrowania bloku skryptu uruchamiania, który jest dołączany za każdym razem, gdy odbywa się asynchroniczne ogłaszanie zwrotne. Aby zarejestrować blok skryptu dla kontrolki, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, tak aby blok skryptu był zarejestrowany tylko wtedy <xref:System.Web.UI.UpdatePanel> , gdy kontrolka <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> jest aktualizowana, Użyj przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować skrypt uruchamiania, który nie odnosi się do aktualizacji częściowej strony, a jeśli chcesz zarejestrować skrypt tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu <xref:System.Web.UI.Page.ClientScript%2A> ze właściwości strony.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="scriptManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Obiekt, który odbiera zawartość kontrolki do zapisu na stronie.</param>
        <summary>Renderuje zawartość <see cref="T:System.Web.UI.HtmlTextWriter" /> kontrolkidoprzeglądarkiprzy<see cref="T:System.Web.UI.ScriptManager" /> użyciu określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do sterowania deweloperami w celu rozszerania <xref:System.Web.UI.ScriptManager> formantu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania tej metody należy wywołać metodę <see cref="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" /> bazową, aby skrypt klienta `Sys.WebForms.PageRequestManager` definiujący klasę został renderowany na stronie.</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveCompositeScriptReference As EventHandler(Of CompositeScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::CompositeScriptReferenceEventArgs ^&gt; ^ ResolveCompositeScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveCompositeScriptReference : EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " Usage="member this.ResolveCompositeScriptReference : System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy skrypt złożony jest zarejestrowany w <see cref="T:System.Web.UI.ScriptManager" /> kontrolce.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveScriptReference As EventHandler(Of ScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::ScriptReferenceEventArgs ^&gt; ^ ResolveScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveScriptReference : EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " Usage="member this.ResolveScriptReference : System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Web.UI.ScriptManager.Scripts" /> <see cref="T:System.Web.UI.ScriptManager" /> gdy element członkowski kolekcji zostanie zarejestrowany z kontrolką.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane jednokrotnie dla każdego elementu członkowskiego <xref:System.Web.UI.ScriptManager.Scripts%2A> kolekcji podczas <xref:System.Web.UI.Control.PreRender> zdarzenia strony. Użyj tego zdarzenia, aby wykonać wszystkie aktualizacje przed renderowaniem skryptu na stronie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoleService">
      <MemberSignature Language="C#" Value="public System.Web.UI.RoleServiceManager RoleService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.RoleServiceManager RoleService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.RoleService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RoleService As RoleServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::RoleServiceManager ^ RoleService { System::Web::UI::RoleServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RoleService : System.Web.UI.RoleServiceManager" Usage="System.Web.UI.ScriptManager.RoleService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.RoleServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który jest skojarzony z bieżącym <see cref="T:System.Web.UI.ScriptManager" /> wystąpieniem. <see cref="T:System.Web.UI.RoleServiceManager" /></summary>
        <value>Obiekt dla bieżącego <see cref="T:System.Web.UI.ScriptManager" />wystąpienia. <see cref="T:System.Web.UI.RoleServiceManager" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.RoleServiceManager> Obiekt, który jest zwracany przez tę właściwość, reprezentuje usługę roli, która jest zarejestrowana na stronie. Usługę roli można zdefiniować w <xref:System.Web.UI.ScriptManager> formancie lub w skojarzonym <xref:System.Web.UI.ScriptManagerProxy> formancie. Możesz użyć usługi roli ASP.NET lub użyć niestandardowej usługi roli. Możesz dodać usługę niestandardową w znaczniku, dołączając `RoleService` element `asp:ScriptManager` wewnątrz elementu na stronie, jak pokazano w następującym przykładzie:  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <RoleService Path="MyRoleService.asmx" LoadRoles="True" />  
</asp:ScriptManager>  
```  
  
 Można również programowo skonfigurować <xref:System.Web.UI.RoleServiceManager> obiekt. Usługi są zarejestrowane w <xref:System.Web.UI.ScriptManager> kontrolce na etapie cyklu <xref:System.Web.UI.Control.PreRender> życia strony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptMode ScriptMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ScriptMode ScriptMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptMode As ScriptMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptMode ScriptMode { System::Web::UI::ScriptMode get(); void set(System::Web::UI::ScriptMode value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptMode : System.Web.UI.ScriptMode with get, set" Usage="System.Web.UI.ScriptManager.ScriptMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy są renderowane debugowanie lub wydanie wersji bibliotek skryptów klienta.</summary>
        <value>Wartość wyliczenia wskazująca bieżący tryb. Wartość domyślna to <see cref="F:System.Web.UI.ScriptMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość określa, <xref:System.Web.UI.ScriptManager> czy kontrolka ma renderować wersje debugowania czy wydania bibliotek skryptów klienta. <xref:System.Web.UI.ScriptManager.ScriptMode%2A> Tę wartość można zastąpić wartościami ustawionymi w pliku konfiguracji i w dyrektywie page.  
  
 Poniższa tabela zawiera listę prawidłowych wartości dla tej właściwości.  
  
|Wartość|Definicja|  
|-----------|----------------|  
|<xref:System.Web.UI.ScriptMode.Auto>|Wersje debugowania bibliotek skryptów klienta są używane na stronie sieci Web, gdy `retail` atrybut elementu konfiguracji [wdrożenia](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) jest ustawiony na. `false` W przeciwnym razie używane są wersje wersji bibliotek skryptów klienta.|  
|<xref:System.Web.UI.ScriptMode.Inherit>|Ta wartość jest taka <xref:System.Web.UI.ScriptManager.ScriptMode%2A> sama jak <xref:System.Web.UI.ScriptMode.Auto>w <xref:System.Web.UI.ScriptManager> przypadku zastosowania do właściwości obiektu.|  
|<xref:System.Web.UI.ScriptMode.Debug>|Wersje debugowania bibliotek skryptów klienta są używane na stronie sieci Web, chyba że `retail` atrybut elementu konfiguracji [wdrożenia](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) jest ustawiony na `true`.|  
|<xref:System.Web.UI.ScriptMode.Release>|Wersja wydania bibliotek skryptów klienta jest używana na stronie sieci Web, chyba że `retail` atrybut elementu konfiguracji [wdrożenia](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) jest ustawiony na `false`.|  
  
> [!NOTE]
>  Atrybut dyrektywy @ Page nie ma wpływu na aplikacje ASP.NET z włączoną obsługą technologii AJAX. [](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) `debug` Formant używa tylko ustawień w pliku Web. config oraz <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> we właściwościach i, aby <xref:System.Web.UI.ScriptManager.ScriptMode%2A> określić, czy mają być renderowane skrypty debugowania. <xref:System.Web.UI.ScriptManager>  
  
 Aby uzyskać więcej informacji, zobacz [debugowanie i śledzenie aplikacji Ajax — Omówienie](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Właściwość nie jest jedną <see cref="T:System.Web.UI.ScriptMode" /> z wartości. <see cref="P:System.Web.UI.ScriptManager.ScriptMode" /></exception>
        <altmember cref="T:System.Web.UI.ScriptMode" />
      </Docs>
    </Member>
    <Member MemberName="ScriptPath">
      <MemberSignature Language="C#" Value="public string ScriptPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScriptPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptPath" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ScriptPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptPath : string with get, set" Usage="System.Web.UI.ScriptManager.ScriptPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This property is obsolete. Set the Path property on each individual ScriptReference instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę katalogu głównego lokalizacji, która jest używana do tworzenia ścieżek do ASP.NET AJAX i niestandardowych plików skryptów.</summary>
        <value>Lokalizacja, w której są przechowywane pliki skryptów. Wartość domyślna to ciąg pusty (""), który jest interpretowany jako ścieżka względna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> Właściwość pozwala określić bezwzględny, względny lub względny dla aplikacji adres URL dla wszystkich bloków skryptu na stronie. Obejmuje to niestandardowe i niezależne bloki skryptów, które są zarejestrowane w bieżącym <xref:System.Web.UI.ScriptManager> wystąpieniu. Właściwość jest zazwyczaj ustawiana jako atrybut `ScriptManager` elementu na stronie, ale można ją również ustawić w kodzie. <xref:System.Web.UI.ScriptManager.ScriptPath%2A>  
  
 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> Jeśli atrybut lub <xref:System.Web.UI.ScriptReferenceBase.Path%2A> Właściwośćjest<xref:System.Web.UI.ScriptReference> ustawiona dla obiektu w <xref:System.Web.UI.ScriptManager.Scripts%2A> kolekcji, wartość ścieżki zastępuje wartość dla tego wystąpienia. <xref:System.Web.UI.ScriptReference> `path`  
  
 Jeśli żadna <xref:System.Web.UI.ScriptReferenceBase.Path%2A> wartość nie zostanie określona <xref:System.Web.UI.ScriptManager> , formant przeszukuje katalog zdefiniowany przez <xref:System.Web.UI.ScriptManager.ScriptPath%2A> Właściwość i rozwiązuje odwołania do skryptu według ich <xref:System.Web.UI.ScriptReference.Name%2A> lub <xref:System.Web.UI.ScriptReference.Assembly%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptResourceMapping">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptResourceMapping ScriptResourceMapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.UI.ScriptResourceMapping ScriptResourceMapping" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScriptResourceMapping As ScriptResourceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::UI::ScriptResourceMapping ^ ScriptResourceMapping { System::Web::UI::ScriptResourceMapping ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScriptResourceMapping : System.Web.UI.ScriptResourceMapping" Usage="System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptResourceMapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.ScriptResourceMapping" /> Pobiera obiekt.</summary>
        <value>Element <see cref="T:System.Web.UI.ScriptResourceMapping" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość statyczna <xref:System.Web.UI.ScriptManager.ScriptResourceMapping%2A> <xref:System.Web.UI.ScriptResourceMapping> zwraca obiekt, który może zawierać kolekcję mapowań reprezentujących lokalizację zasobu skryptu (przekierowanie skryptu). Ta kolekcja mapowań może być mapowana na podstawie nazw, par nazw/zestawów i może wskazywać na <xref:System.Web.UI.ScriptResourceDefinition> obiekt.  
  
   
  
## Examples  
 W poniższych przykładach pokazano, jak dodać <xref:System.Web.UI.ScriptResourceDefinition> obiekt, do którego może odwoływać <xref:System.Web.UI.ScriptManager> się obiekt. Dodaj następujący kod do pliku Global. asax w `Application_Start` zdarzeniu.  
  
```csharp  
ScriptResourceDefinition myScriptResDef = new ScriptResourceDefinition();  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js";  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js";  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js";  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js";  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", null, myScriptResDef);  
```  
  
```vb  
Dim myScriptResDef As New ScriptResourceDefinition()  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js"  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js"  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js"  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js"  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", Nothing, myScriptResDef)  
```  
  
 Na stronie znaczniki dla ASP.NET Web Forms (plik. aspx) Dodaj następujące znaczniki wewnątrz `form` elementu i przed wszelkimi elementami lub kodem korzystającym ze skryptu jQuery.  
  
```  
<asp:ScriptManager ID="sm1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="jquery"/>  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scripts">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptReferenceCollection Scripts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ScriptReferenceCollection Scripts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Scripts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scripts As ScriptReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptReferenceCollection ^ Scripts { System::Web::UI::ScriptReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scripts : System.Web.UI.ScriptReferenceCollection" Usage="System.Web.UI.ScriptManager.Scripts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który zawiera obiekty, z których każdy reprezentuje plik skryptu renderowany klientowi. <see cref="T:System.Web.UI.ScriptReference" /> <see cref="T:System.Web.UI.ScriptReferenceCollection" /></summary>
        <value><see cref="T:System.Web.UI.ScriptReferenceCollection" /> Obiekt<see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który jest zwracany przez tę właściwość, jest <xref:System.Web.UI.ScriptReference> kolekcją obiektów, z których każdy reprezentuje plik skryptu. <xref:System.Web.UI.ScriptReferenceCollection> Kolekcja zawiera odwołania do wszystkich plików skryptów, które ASP.NET potrzebują dla funkcji AJAX, oraz niestandardowych plików skryptów. Pliki skryptów niestandardowych do renderowania można definiować w <xref:System.Web.UI.ScriptManager> formancie lub w skojarzonym <xref:System.Web.UI.ScriptManagerProxy> formancie.  
  
 Możesz dodać pliki skryptów do kolekcji w znacznikach, dodając `asp:ScriptReference` elementy `Scripts` do węzła wewnątrz `asp:ScriptManager` elementu na stronie, jak pokazano w poniższym przykładzie.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="Script.js" />  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 Możesz również dodać <xref:System.Web.UI.ScriptReference> obiekt <xref:System.Web.UI.ScriptManager.Scripts%2A> do <xref:System.Collections.ObjectModel.Collection%601.Add%2A> kolekcji programowo przy <xref:System.Web.UI.ScriptReferenceCollection> użyciu metody klasy.  
  
 Kontrolka rejestruje pliki skryptów podczas <xref:System.Web.UI.Control.PreRender> zdarzenia kontrolki. <xref:System.Web.UI.ScriptManager>  
  
 <xref:System.Web.UI.ScriptManager.Scripts%2A> Kolekcja nie zawiera podstawowych skryptów biblioteki Microsoft Ajax. Skrypty w bibliotece podstawowej są renderowane automatycznie; nie muszą być zarejestrowane z <xref:System.Web.UI.ScriptManager> kontrolką. Jeśli jednak chcesz zastąpić skrypt podstawowy lub dowolny skrypt kontrolny i zastąpić inną wersję skryptu, możesz dodać swoją wersję do <xref:System.Web.UI.ScriptManager.Scripts%2A> kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Services">
      <MemberSignature Language="C#" Value="public System.Web.UI.ServiceReferenceCollection Services { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ServiceReferenceCollection Services" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Services" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Services As ServiceReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ServiceReferenceCollection ^ Services { System::Web::UI::ServiceReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Services : System.Web.UI.ServiceReferenceCollection" Usage="System.Web.UI.ScriptManager.Services" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.ServiceReferenceCollectionEditor, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ServiceReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który zawiera obiekt dla każdej usługi sieci Web, która ASP.NET uwidacznia na kliencie dla funkcji AJAX. <see cref="T:System.Web.UI.ServiceReference" /> <see cref="T:System.Web.UI.ServiceReferenceCollection" /></summary>
        <value>Obiekt dla bieżącego <see cref="T:System.Web.UI.ScriptManager" />wystąpienia. <see cref="T:System.Web.UI.ServiceReferenceCollection" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który jest zwracany przez tę właściwość, jest <xref:System.Web.UI.ServiceReference> kolekcją obiektów, z których każdy reprezentuje usługę sieci Web <xref:System.Web.UI.ScriptManager> , która jest zarejestrowana w kontrolce. <xref:System.Web.UI.ServiceReferenceCollection> Możesz definiować usługi w <xref:System.Web.UI.ScriptManager> formancie lub w skojarzonym <xref:System.Web.UI.ScriptManagerProxy> formancie.  
  
 Można dodać usługi do kolekcji w znacznikach przez dodanie `asp:ServiceReference` elementu `Services` do elementu wewnątrz `asp:ScriptManager` wystąpienia na stronie, jak pokazano w poniższym przykładzie.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Services>  
    <asp:ServiceReference Path="Service.asmx" />  
  </Services>  
</asp:ScriptManager>  
```  
  
 Można również programowo <xref:System.Web.UI.ServiceReference> dodać obiekt <xref:System.Web.UI.ScriptManager.Services%2A> do kolekcji przy <xref:System.Web.UI.ServiceReferenceCollection> użyciu <xref:System.Collections.ObjectModel.Collection%601.Add%2A> metody klasy.  
  
 Usługi są rejestrowane <xref:System.Web.UI.ScriptManager> na etapie cyklu <xref:System.Web.UI.Control.PreRender> życia strony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia fokus przeglądarki na określoną kontrolkę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="scriptManager.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">Identyfikator formantu, który ma zostać ustawiony fokus.</param>
        <summary>Ustawia fokus przeglądarki na kontrolkę określoną przez identyfikator.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda działa jak metoda dla <xref:System.Web.UI.Page>klasy. <xref:System.Web.UI.Page.SetFocus%2A> <xref:System.Web.UI.ScriptManager.SetFocus%2A> Obie metody sprawiają, że formant z określonym IDENTYFIKATORem jest aktywnym formantem na stronie sieci Web. <xref:System.Web.UI.ScriptManager.SetFocus%2A> Metoda<xref:System.Web.UI.ScriptManager> klasy służy do ustawiania fokusu podczas asynchronicznego ogłaszania zwrotnego. Podczas ogłaszania zwrotnego i gdy strona jest najpierw renderowana <xref:System.Web.UI.ScriptManager.SetFocus%2A> , Metoda <xref:System.Web.UI.Page.SetFocus%2A> wywołuje metodę <xref:System.Web.UI.Page> klasy.  
  
 Jeśli istnieje wiele wywołań <xref:System.Web.UI.ScriptManager.SetFocus%2A> metody, formant w ostatnim wywołaniu otrzymuje fokus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.String)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="scriptManager.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka, na którą ma zostać ustawiony fokus.</param>
        <summary>Ustawia fokus przeglądarki na określoną kontrolkę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda działa jak metoda dla <xref:System.Web.UI.Page>klasy. <xref:System.Web.UI.Page.SetFocus%2A> <xref:System.Web.UI.ScriptManager.SetFocus%2A> Obie metody kontrolują kontrolkę aktywny formant na stronie sieci Web. <xref:System.Web.UI.ScriptManager.SetFocus%2A> Metoda<xref:System.Web.UI.ScriptManager> klasy służy do ustawiania fokusu podczas asynchronicznego ogłaszania zwrotnego. Podczas ogłaszania zwrotnego i gdy strona jest najpierw renderowana <xref:System.Web.UI.ScriptManager.SetFocus%2A> , Metoda <xref:System.Web.UI.Page.SetFocus%2A> wywołuje metodę <xref:System.Web.UI.Page> klasy.  
  
 Jeśli istnieje wiele wywołań <xref:System.Web.UI.ScriptManager.SetFocus%2A> metody, formant określony w ostatnim wywołaniu otrzymuje fokus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SupportsPartialRendering">
      <MemberSignature Language="C#" Value="public bool SupportsPartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsPartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property SupportsPartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsPartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SupportsPartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy klient obsługuje renderowanie części strony.</summary>
        <value><see langword="true" />Jeśli klient obsługuje funkcję renderowania części strony; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest ustawiona na `false`, <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> Właściwość zwraca `false`. <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A>  
  
 Domyślna kontrola określająca, czy obsługiwane jest renderowanie częściowe strony zwraca `true` , gdy są spełnione następujące warunki:  
  
-   Wartość <xref:System.Web.Configuration.HttpCapabilitiesBase.W3CDomVersion%2A> właściwości musi być większa lub równa 1,0.  
  
-   Wartość <xref:System.Web.Configuration.HttpCapabilitiesBase.EcmaScriptVersion%2A> właściwości musi być większa lub równa 1,0.  
  
-   Wartość właściwości musi być ustawiona na `true`. <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>  
  
 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> Gdy właściwość jest ustawiona jawnie, te sprawdzenia nie są używane.  
  
 Deweloperzy formantów powinni używać właściwości <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> , aby określić, czy mają być obsługiwane renderowanie części strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="true" />Właściwość jest <see langword="false" /> i<see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> właściwość została ustawiona na. <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />  
  
—lub— 
Właściwość została ustawiona <see cref="E:System.Web.UI.Control.Init" /> po zdarzeniu. <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /></exception>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.LoadPostData">
      <MemberSignature Language="C#" Value="bool IPostBackDataHandler.LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Web.UI.IPostBackDataHandler.LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean Implements IPostBackDataHandler.LoadPostData" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Web.UI.IPostBackDataHandler.LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection) = System::Web::UI::IPostBackDataHandler::LoadPostData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">Identyfikator klucza dla kontrolki.</param>
        <param name="postCollection">Kolekcja wszystkich przychodzących danych post.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />Zobacz.</summary>
        <returns><see langword="true" />Jeśli stan <see langword="false" />kontrolki został zmieniony w wyniku ogłaszania zwrotnego; w przeciwnym razie. <see cref="T:System.Web.UI.ScriptManager" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Web.UI.ScriptManager> gdy wystąpienie jest rzutowane <xref:System.Web.UI.IPostBackDataHandler> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="void IPostBackDataHandler.RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostDataChangedEvent () Implements IPostBackDataHandler.RaisePostDataChangedEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() = System::Web::UI::IPostBackDataHandler::RaisePostDataChangedEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Web.UI.ScriptManager> gdy wystąpienie jest rzutowane <xref:System.Web.UI.IPostBackDataHandler> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackEventHandler.RaisePostBackEvent">
      <MemberSignature Language="C#" Value="void IPostBackEventHandler.RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackEventHandler#RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostBackEvent (eventArgument As String) Implements IPostBackEventHandler.RaisePostBackEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System::String ^ eventArgument) = System::Web::UI::IPostBackEventHandler::RaisePostBackEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">Ciąg par klucz/wartość, które reprezentują stan historii strony sieci Web.</param>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> Umożliwia formantowi przetworzenie zdarzenia ogłaszania zwrotnego i załadowanie stanu historii strony sieci Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.IsSecureConnection">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IScriptManager.IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSecureConnection As Boolean Implements IScriptManager.IsSecureConnection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IScriptManager::IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsSecureConnection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue) = System::Web::UI::IScriptManager::RegisterArrayDeclaration;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="arrayName">To be added.</param>
        <param name="arrayValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterClientScriptBlock;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url) = System::Web::UI::IScriptManager::RegisterClientScriptInclude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="url">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName) = System::Web::UI::IScriptManager::RegisterClientScriptResource;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="resourceName">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterDispose">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript) = System::Web::UI::IScriptManager::RegisterDispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterDispose(System.Web.UI.Control,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="disposeScript">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode) = System::Web::UI::IScriptManager::RegisterExpandoAttribute;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="controlId">To be added.</param>
        <param name="attributeName">To be added.</param>
        <param name="attributeValue">To be added.</param>
        <param name="encode">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterHiddenField">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldValue) = System::Web::UI::IScriptManager::RegisterHiddenField;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="hiddenFieldName">To be added.</param>
        <param name="hiddenFieldValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script) = System::Web::UI::IScriptManager::RegisterOnSubmitStatement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterPostBackControl">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterPostBackControl(System::Web::UI::Control ^ control) = System::Web::UI::IScriptManager::RegisterPostBackControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterStartupScript">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterStartupScript;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.SetFocusInternal">
      <MemberSignature Language="C#" Value="void IScriptManager.SetFocusInternal (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.SetFocusInternal(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#SetFocusInternal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetFocusInternal (clientID As String) Implements IScriptManager.SetFocusInternal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.SetFocusInternal(System::String ^ clientID) = System::Web::UI::IScriptManager::SetFocusInternal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.SetFocusInternal(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.ScriptManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przesłania właściwość, która jest dziedziczona z klasy bazowej <see cref="T:System.Web.UI.Control" /> , aby zapobiec ustawianiu tej wartości. <see cref="P:System.Web.UI.Control.Visible" /></summary>
        <value><see langword="true" />we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość została przesłonięta w <xref:System.Web.UI.ScriptManager> klasie, aby zapobiec ustawianiu tej wartości. <xref:System.Web.UI.Control.Visible%2A> Jeśli wartość jest przypisana do tej właściwości, występuje błąd.<xref:System.NotImplementedException>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Wartość jest przypisana do <see cref="P:System.Web.UI.ScriptManager.Visible" /> właściwości.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="ScriptManager" FullName="System.Web.UI.ScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ae997d3bdb19b9c463dc6854265ec7399b60179b" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57920131" /></Metadata><TypeSignature Language="C#" Value="public class ScriptManager : System.Web.UI.Control, System.Web.UI.IPostBackDataHandler, System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScriptManager extends System.Web.UI.Control implements class System.Web.UI.IPostBackDataHandler, class System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ScriptManager&#xA;Inherits Control&#xA;Implements IPostBackDataHandler, IPostBackEventHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScriptManager : System::Web::UI::Control, System::Web::UI::IPostBackDataHandler, System::Web::UI::IPostBackEventHandler" />
  <TypeSignature Language="F#" Value="type ScriptManager = class&#xA;    inherit Control&#xA;    interface IPostBackDataHandler&#xA;    interface IPostBackEventHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackDataHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackEventHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Scripts")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(EmbeddedResourceFinder), "System.Web.Resources.ScriptManager.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zarządza ASP.NET Ajax, biblioteki skryptów i plików skryptów, częściowe renderowanie strony i generowania klasy serwera proxy klienta dla sieci Web i aplikacji usługi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym temacie:  
  
-   [Wprowadzenie](#introduction)  
  
-   [Częściowe renderowanie strony](#partial_page_rendering)  
  
-   [Używanie formantu ScriptManager za pomocą stron wzorcowych, formantach użytkownika i innych składnikach podrzędnych](#using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components)  
  
-   [Zarządzanie skryptem i rejestracja](#script_management_and_registration)  
  
-   [Odwołania do usług sieci Web](#web_service_references)  
  
-   [Lokalizacja](#localization)  
  
-   [Obsługa błędów](#error_handling)  
  
-   [Składni deklaratywnej](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>Wprowadzenie  
 <xref:System.Web.UI.ScriptManager> Kontroli stanowi podstawę do funkcji interfejsu Ajax w programie ASP.NET. Kontrolka zarządza wszystkie zasoby ASP.NET Ajax, na stronie. Obejmuje to pobieranie Microsoft Ajax Library skryptów do przeglądarki i koordynowania aktualizacji stron częściowych, które są włączone za pomocą <xref:System.Web.UI.UpdatePanel> kontrolki. Ponadto <xref:System.Web.UI.ScriptManager> control umożliwia wykonaj następujące czynności:  
  
-   Rejestrowanie skryptu, który jest zgodny z aktualizacji stron częściowych. Aby można było zarządzać zależności między skryptu i podstawowej biblioteki, dowolny skrypt, który należy zarejestrować jest ładowany po skrypcie Microsoft Ajax Library.  
  
-   Określ czy wydania lub debugowania skryptów są wysyłane do przeglądarki.  
  
-   Zapewniają dostęp do metody usługi sieci Web ze skryptu, rejestrując usług sieci Web za pomocą <xref:System.Web.UI.ScriptManager> kontroli.  
  
-   Zapewniają dostęp do uwierzytelniania platformy ASP.NET, roli i profilu usługi aplikacji z skrypt po stronie klienta, rejestrując te usługi z <xref:System.Web.UI.ScriptManager> kontroli.  
  
-   Włącz wyświetlanie specyficzne dla kultury ECMAScript (JavaScript) i funkcje w przeglądarce.  
  
-   Dostęp do lokalizacji zasobów osadzonych skryptów, plików lub pliki skryptów autonomicznego przy użyciu <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> właściwość <xref:System.Web.UI.ScriptReference> kontroli.  
  
-   Rejestrowanie formantów serwera, które implementują <xref:System.Web.UI.IExtenderControl> lub <xref:System.Web.UI.IScriptControl> z interfejsem <xref:System.Web.UI.ScriptManager> kontrolki skryptu wymaganego przez składniki klienta i zachowań jest renderowany.  
  
<a name="partial_page_rendering"></a>   
## <a name="partial-page-rendering"></a>Częściowe renderowanie strony  
 Możliwość obsługi częściowe renderowanie strony strony ASP.NET, zależy od następujących czynników:  
  
-   <xref:System.Web.UI.ScriptManager> Kontrolki <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> właściwość musi być `true` (wartość domyślna).  
  
-   Musi istnieć co najmniej jeden <xref:System.Web.UI.UpdatePanel> formantu na stronie.  
  
-   <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> Właściwość musi być `true` (wartość domyślna). Jeśli <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> właściwość nie została jawnie ustawiona, jej wartość zależy od możliwości przeglądarki.  
  
 Możesz zastąpić wartość <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> właściwości w czasie wykonywania, ciągu lub przed strony <xref:System.Web.UI.Control.Init> zdarzeń. Jeśli spróbujesz zmienić tę właściwość po stronie <xref:System.Web.UI.Control.Init> wystąpiło zdarzenie <xref:System.InvalidOperationException> wyjątku.  
  
 Częściowe renderowanie strony jest obsługiwany, <xref:System.Web.UI.ScriptManager> kontrolka renderuje skrypt, aby włączyć asynchroniczne odświeżenia strony i aktualizacji stron częściowych. Regiony strony do zaktualizowania zostały oznaczone za pomocą <xref:System.Web.UI.UpdatePanel> kontrolki. <xref:System.Web.UI.ScriptManager> Kontroli obsługuje asynchroniczne odświeżenia strony i odświeża tylko regiony strony, które mają zostać zaktualizowane. Aby uzyskać więcej informacji na temat częściowe renderowanie strony zobacz [Przegląd renderowanie części strony](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49). Aby uzyskać więcej informacji o warunkach, które powodują aktualizację, zobacz [UpdatePanel informacje o formancie](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a).  
  
<a name="using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components"></a>   
## <a name="using-the-scriptmanager-control-with-master-pages-user-controls-and-other-child-components"></a>Używanie formantu ScriptManager w stronach wzorcowych, formantach użytkownika i innych składnikach podrzędnych  
 Strona może zawierać tylko jeden <xref:System.Web.UI.ScriptManager> kontrolki w jego hierarchii. Aby zarejestrować usług i skryptów na potrzeby zagnieżdżone strony, kontrolek użytkownika lub składniki, gdy strona nadrzędna jest już <xref:System.Web.UI.ScriptManager> kontrolować, należy użyć <xref:System.Web.UI.ScriptManagerProxy> kontroli. Aby uzyskać więcej informacji, zobacz [za pomocą stron wzorcowych przy użyciu kontrolki UpdatePanel](https://msdn.microsoft.com/library/b1c974d5-a6b2-4bb3-a3cc-61dd9dc0e1d6)  
  
<a name="script_management_and_registration"></a>   
## <a name="script-management-and-registration"></a>Zarządzanie skryptem i rejestracja  
 <xref:System.Web.UI.ScriptManager> Control umożliwia zarejestrowania skrypt, który jest następnie renderowany jako część strony. <xref:System.Web.UI.ScriptManager> Metody rejestracji kontroli może można podzielić na następujące trzy kategorie:  
  
-   Metody rejestracji, które gwarantują utrzymania skryptu zależności w bibliotece Microsoft Ajax Library.  
  
-   Metody rejestracji, które nie są zależne od biblioteki Microsoft Ajax, ale które są zgodne z <xref:System.Web.UI.UpdatePanel> kontrolki.  
  
-   Metody rejestracji obsługują pracę <xref:System.Web.UI.UpdatePanel> kontrolki.  
  
 Aby uzyskać więcej informacji o sposobie tworzenia i używania skryptów Ajax w ASP.NET, zobacz [tworząc niestandardowy skrypt po stronie klienta za pomocą biblioteki Microsoft Ajax Library](https://msdn.microsoft.com/library/285e3a65-b42e-42c5-952d-baf184057899).  
  
### <a name="registering-script-that-is-dependent-on-the-microsoft-ajax-library"></a>Rejestrowanie skryptu, który jest zależny od biblioteki Microsoft Ajax  
 Można użyć następujących metod do zarejestrowania skrypt pliki w sposób, który gwarantuje, że wszystkie zależności w bibliotece Microsoft Ajax Library są utrzymywane.  
  
|Metoda|Definicja|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>|Rejestruje formant serwera, który implementuje <xref:System.Web.UI.IScriptControl> interfejs, który jest używany do definiowania obiektu klienta. <xref:System.Web.UI.ScriptManager> Kontrolka renderuje skrypt, który obsługuje obiektu klienta.|  
|<xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A>|Rejestruje formant serwera, który implementuje <xref:System.Web.UI.IExtenderControl> interfejs, który jest używany do definiowania obiektu klienta. <xref:System.Web.UI.ScriptManager> Kontrolka renderuje skrypt, który obsługuje obiektu klienta.|  
  
### <a name="registering-partial-page-update-compatible-scripts"></a>Rejestrowanie skryptów zgodnych z aktualizacją strony częściowej  
 Można użyć następujących metod można zarejestrować pliki skryptów, które nie są zależne od biblioteki Microsoft Ajax, ale które są zgodne z <xref:System.Web.UI.UpdatePanel> kontrolki. Te metody odpowiadają podobne metody <xref:System.Web.UI.ClientScriptManager> kontroli. Jeśli skrypt renderowania do użytku wewnątrz <xref:System.Web.UI.UpdatePanel> sterowania, upewnij się, że wywołanie metody <xref:System.Web.UI.ScriptManager> kontroli.  
  
|Metoda|Definicja|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>|Dodaje wartość do tablicy języka JavaScript. Jeśli tablica nie istnieje, zostanie utworzony.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>|Renderuje `script` elementu po otwarciu strony `<form>` tagu. Skrypt jest określony jako parametr ciągu.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>|Renderuje `script` elementu po otwarciu strony `<form>` tagu. Zawartość skryptu jest określany przez ustawienie `src` atrybutu do adresu URL, który wskazuje plik skryptu.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>|Renderuje `script` elementu po otwarciu strony `<form>` tagu. Zawartość skryptu jest określony z nazwą zasobu w zestawie. `src` Atrybut jest wypełniane automatycznie przy użyciu adresu URL za pomocą wywołania programu obsługi HTTP, która pobiera skrypt o nazwie z zestawu.|  
|<xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>|Renderuje pary atrybut niestandardowy nazwa/wartość (expando) w znaczniku dla określonego formantu.|  
|<xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>|Renderuje ukryte pole.|  
|<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>|Rejestruje skryptu, który jest wykonywany w odpowiedzi na `form` elementu `submit` zdarzeń. `onSubmit` Atrybut odwołuje się określony skrypt.|  
|<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>|Renderuje blok skryptu uruchamiania tuż przed zamknięciem strony `</form>` tagu. Skrypt w celu renderowania jest określony jako parametr ciągu.|  
  
 Po zarejestrowaniu metody, należy określić pary klucz/typu dla tego skryptu. Jeśli skrypt przy użyciu tej samej pary klucz/typu jest już zarejestrowany, nowy skrypt nie jest zarejestrowany. Podobnie, jeśli rejestrujesz się skrypt przy użyciu pary nazwa typu/zasobu już istnieje, `script` element, który odwołuje się do zasobu nie zostanie ponownie dodane. Po zarejestrowaniu atrybut expando wcześniej zarejestrowanego atrybutu, jest zgłaszany wyjątek. Rejestracja zduplikowane wartości tablicy jest dozwolone.  
  
 Gdy wywołujesz <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> lub <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> metody uniknąć, rejestrowanie skryptu, który jest wykonywany wbudowane funkcje. Zamiast tego Zarejestruj skrypt, który zawiera definicje funkcji, takich jak programy obsługi zdarzeń lub definicji klas niestandardowych dla aplikacji.  
  
### <a name="registration-methods-for-updatepanel-controls"></a>Metody rejestracji formantów UpdatePanel  
 Można użyć następujących metod dostosowywania aktualizacji stron częściowych, gdy używasz <xref:System.Web.UI.UpdatePanel> kontrolki.  
  
|Metoda|Definicja|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>|Rejestruje formantu jako wyzwalacza dla asynchroniczne odświeżenia strony.|  
|<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>|Wysyła dane niestandardowe formanty podczas częściowe renderowanie strony.|  
|<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>|Rejestruje skrypt metodę dispose dla formantu, który znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontroli. Skrypt zostanie wykonany po <xref:System.Web.UI.UpdatePanel> formantu zostanie zaktualizowany lub usunięty. Metoda dispose jest używana dla składników klienta, które są częścią biblioteki Microsoft Ajax i mają zwolnienia zasobów, gdy składnik nie jest już używana.|  
|<xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A>|Rejestruje formantu jako wyzwalacza dla pełnego zwrotu. Ta metoda jest używana dla formantów wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, które w przeciwnym razie będzie wykonywać asynchroniczne odświeżenia strony.|  
  
<a name="web_service_references"></a>   
## <a name="web-service-references"></a>Odwołania do usługi sieci Web  
 Możesz zarejestrować usługę sieci Web i być wywoływana ze skryptu klienta, tworząc <xref:System.Web.UI.ServiceReference> obiektu i dodanie go do <xref:System.Web.UI.ScriptManager.Services%2A> zbiór <xref:System.Web.UI.ScriptManager> kontroli. Program ASP.NET generuje obiekt serwera proxy klienta dla każdego <xref:System.Web.UI.ServiceReference> obiektu <xref:System.Web.UI.ScriptManager.Services%2A> kolekcji. Możesz programowo dodać <xref:System.Web.UI.ServiceReference> obiekty do <xref:System.Web.UI.ScriptManager.Services%2A> kolekcji do rejestrowania usług sieci Web w czasie wykonywania.  
  
 Aby uzyskać więcej informacji o tym, jak uzyskać dostęp do usług sieci Web w skrypcie, zobacz [udostępnianie usług sieci Web, aby skrypt po stronie klienta w technologii ASP.NET AJAX](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8) i [podczas wywoływania usługi sieci Web ze skryptu klienta w technologii ASP.NET AJAX](https://msdn.microsoft.com/library/fc06c224-f01a-45be-94af-bd71afbc07b0).  
  
<a name="localization"></a>   
## <a name="localization"></a>Lokalizacja  
 <xref:System.Web.UI.ScriptManager> Kontroli generuje odwołania na renderowanej stronie wskazujące pliki odpowiedni skrypt zlokalizowane, które są pliki skryptów, albo osadzony w zestawy lub pliki skryptów autonomicznych.  
  
 Gdy <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> właściwość jest ustawiona na `true`, <xref:System.Web.UI.ScriptManager> kontroli pobiera zlokalizowanych zasobów (na przykład zlokalizowanych ciągów) dla bieżącej kultury, jeśli istnieją. <xref:System.Web.UI.ScriptManager> Control oferuje następujące funkcje dotyczące korzystania z zlokalizowanych zasobów:  
  
-   **Pliki, które są osadzone w zestawie skryptów**. <xref:System.Web.UI.ScriptManager> Kontroli określa plik skryptu specyficzne dla kultury lub kultury rezerwowe, który wysyłany do przeglądarki. Jest to realizowane przy użyciu dla kultury <xref:System.Resources.NeutralResourcesLanguageAttribute> atrybutu zestawu, zasoby wchodzących w skład zestawu i kultura interfejsu użytkownika przeglądarki (jeśli istnieje).  
  
-   **Pliki skryptów autonomicznej**. <xref:System.Web.UI.ScriptManager> Kontroli definiuje listę kultury interfejsu użytkownika, które są obsługiwane przy użyciu <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> właściwość <xref:System.Web.UI.ScriptReference> obiektu.  
  
-   **W trybie debugowania**. <xref:System.Web.UI.ScriptManager> Kontroli próbuje renderowania pliku skryptu specyficzne dla kultury, która zawiera informacje o debugowaniu. Na przykład, jeśli strona jest w trybie debugowania, a bieżąca kultura jest równa en MX, kontrolka renderuje plik skryptu, który ma nazwę `scriptname`.en-MX.debug.js, jeśli plik istnieje. Jeśli plik nie istnieje, plik debugowania dla odpowiednich kultury rezerwowego jest renderowany.  
  
 Aby uzyskać więcej informacji o sposobie lokalizowania zasobów, zobacz [lokalizowanie zasobów biblioteki składniku](https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb).  
  
<a name="error_handling"></a>   
## <a name="error-handling"></a>Obsługa błędów  
 Po wystąpieniu błędu strony podczas asynchroniczne odświeżenia strony, <xref:System.Web.UI.ScriptManager.AsyncPostBackError> zdarzenie jest wywoływane. Sposób, w którym błędy na serwerze są wysyłane do klienta zależy od <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> właściwości <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> właściwości i sekcję błędy niestandardowe w pliku Web.config. Aby uzyskać więcej informacji, zobacz [Dostosowywanie obsługę błędów dla kontrolki UpdatePanel](https://msdn.microsoft.com/library/e15e7ffb-e4b2-4a89-b99e-16624a5861d0).  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>Składnia deklaracyjna  
  
```  
<asp:ScriptManager  
    AllowCustomErrorsRedirect="True|False"  
    AsyncPostBackErrorMessage="string"  
    AsyncPostBackTimeout="integer"  
    AuthenticationService-Path="uri"  
    EnablePageMethods="True|False"  
    EnablePartialRendering="True|False"  
    EnableScriptGlobalization="True|False"  
    EnableScriptLocalization="True|False"  
    EnableTheming="True|False"  
    EnableViewState="True|False"  
    ID="string"  
    LoadScriptsBeforeUI="True|False"  
    OnAsyncPostBackError="AsyncPostBackError event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnResolveScriptReference="ResolveScriptReference event handler"  
    OnUnload="Unload event handler"  
    ProfileService-LoadProperties="string"  
    ProfileService-Path="uri"  
    RoleService-LoadRoles="True|False"  
    RoleService-Path="uri"  
    runat="server"  
    ScriptMode="Auto|Inherit|Debug|Release"  
    ScriptPath="string"  
    SkinID="string"  
    SupportsPartialRendering="True|False"  
    Visible="True|False"  
>  
        <AuthenticationService  
            Path="uri"  
        />  
        <ProfileService  
            LoadProperties="string"  
            Path="uri"  
        />  
        <RoleService  
            LoadRoles="True|False"  
            Path="uri"  
        />  
        <Scripts>  
            <asp:ScriptReference  
                Assembly="string"  
                IgnoreScriptPath="True|False"  
                Name="string"  
                NotifyScriptLoaded="True|False"  
                Path="string"  
                ResourceUICultures="string"  
                ScriptMode="Auto|Debug|Inherit|Release"  
            />  
        </Scripts>  
        <Services>  
            <asp:ServiceReference  
                InlineScript="True|False"  
                Path="string"  
            />  
        </Services>  
</asp:ScriptManager>  
```  
  
   
  
## Examples  
 W poniższych przykładach pokazano różne scenariusze użycia <xref:System.Web.UI.ScriptManager> kontroli.  
  
 **Włączanie aktualizacji stron częściowych**  
  
 Poniższy przykład pokazuje, jak używać <xref:System.Web.UI.ScriptManager> kontroli w celu włączenia aktualizacji stron częściowych. W tym przykładzie <xref:System.Web.UI.WebControls.Calendar> i <xref:System.Web.UI.WebControls.DropDownList> kontrolki znajdują się wewnątrz <xref:System.Web.UI.UpdatePanel> kontroli. Domyślnie wartość <xref:System.Web.UI.UpdatePanel.UpdateMode%2A> właściwość <xref:System.Web.UI.UpdatePanelUpdateMode.Always>i wartość <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> właściwość `true`. W związku z tym formantów podrzędnych panelu spowodować asynchronicznego zwrotu.  
  
 [!code-aspx-csharp[System.Web.UI.UpdatePanel#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/CS/UpdatePanelExample1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.UpdatePanel#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/VB/UpdatePanelExample1VB.aspx#1)]  
  
 **Obsługa błędów w aktualizację części strony i rejestrowanie skryptów**  
  
 Poniższy przykład pokazuje, jak zapewnić niestandardową obsługę podczas aktualizacji stron częściowych błędów. Domyślnie gdy wystąpi błąd podczas aktualizacji stron częściowych, wyświetlane jest okno komunikatu języka JavaScript. W tym przykładzie przedstawiono sposób użycia niestandardową obsługę, zapewniając procedura obsługi błędów <xref:System.Web.UI.ScriptManager.AsyncPostBackError> zdarzenia i ustawiając <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> właściwość w obsłudze zdarzeń. Można również ustawić <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> właściwości w celu określenia, jak błędy niestandardowe części pliku Web.config jest używany, gdy wystąpi błąd podczas aktualizacji stron częściowych. W tym przykładzie wartość domyślną <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> właściwość jest używana. Oznacza to, że jeśli plik Web.config zawiera element, ten element określa sposób wyświetlania błędów. Aby uzyskać więcej informacji, zobacz [customErrors — Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/288c32e2-df1f-4548-abda-de6b4cb989a6).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/VB/default.aspx#1)]  
  
 **Globalizacja datę i godzinę, które są wyświetlane w przeglądarce**  
  
 Poniższy przykład pokazuje, jak ustawić <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> właściwości, więc ten skrypt po stronie klienta można wyświetlić w przeglądarce specyficzne dla kultury daty i godziny. W tym przykładzie `Culture` atrybutu [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) dyrektywa jest ustawiona na `auto`. Co w efekcie Określa pierwszy język, który jest określony w bieżące ustawienia przeglądarki, kultury i kultury interfejsu użytkownika dla strony. Aby uzyskać więcej informacji, zobacz [jak: Ustawianie kultury i kultury UI dla globalizacji strony sieci Web platformy ASP.NET](https://msdn.microsoft.com/library/76091f86-f967-4687-a40f-de87bd8cc9a0).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/VB/default.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.ScriptManagerProxy" />
    <altmember cref="T:System.Web.UI.UpdatePanel" />
    <altmember cref="T:System.Web.UI.ClientScriptManager" />
    <altmember cref="T:System.Web.UI.ScriptMode" />
    <altmember cref="T:System.Web.UI.ScriptReference" />
    <altmember cref="T:System.Web.UI.ServiceReference" />
    <related type="Article" href="https://msdn.microsoft.com/library/fceeb3c5-c59f-46a9-af4f-b0d7155a1efc">Sys.WebForms.PageRequestManager Class</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScriptManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScriptManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.ScriptManager" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje wewnętrzne pola, które są używane przez <xref:System.Web.UI.ScriptManager> formantu, aby śledzić strony, kontroli i informacje o wdrożeniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHistoryPoint">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy punkt historii i dodaje go do przeglądarki historię stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te przeciążenia metody umożliwiają definiowanie stanu serwera oraz, opcjonalnie tytuł wpisu historii w przeglądarce. Podczas tworzenia punktów historii serializacji i zaszyfrowane dane są dołączane do adresu URL strony sieci Web i wpis znajduje się w stosie historii w przeglądarce. Dane o stanie służy do ponownego tworzenia tej strony, gdy zostanie wywołane dowolne zdarzenie nawigacji kolejny serwer. Aby uzyskać więcej informacji, zobacz [Zarządzanie kontrolek przy użyciu serwera programu przeglądarki historii](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (System.Collections.Specialized.NameValueCollection state, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(class System.Collections.Specialized.NameValueCollection state, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.Collections.Specialized.NameValueCollection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (state As NameValueCollection, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::Collections::Specialized::NameValueCollection ^ state, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : System.Collections.Specialized.NameValueCollection * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (state, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="state">Kolekcja par klucz/wartość, które zawierają dane stanu.</param>
        <param name="title">Tekst, który zostanie dodany do stosu historii przeglądarki jako tytuł dla tego stanu.</param>
        <summary>Tworzy punkt historii i dodaje go do stosu historii w przeglądarce, za pomocą zbierania danych w określonym stanie i stanu tytuł.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia tworzenie punktu historii, gdy użytkownik chce zapisać więcej niż jedną parę klucza i wartości dla danych o stanie. Podczas tworzenia punktów historii serializacji i zaszyfrowane dane są dołączane do adresu URL strony sieci Web i wpis znajduje się w stosie historii w przeglądarce. Jeśli `title` parametr jest `null`, tytuł strony sieci Web jest używana jako tytuł wpisu stanu stosu historii.  
  
 Dane o stanie służy do ponownego tworzenia tej strony, gdy zostanie wywołane dowolne zdarzenie nawigacji kolejny serwer. Aby uzyskać więcej informacji, zobacz [Zarządzanie kontrolek przy użyciu serwera programu przeglądarki historii](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Kluczowym elementem pary klucz/wartość, który określa stan strony sieci Web.</param>
        <param name="value">Część wartości pary klucz/wartość, który określa stan strony sieci Web.</param>
        <summary>Tworzy punkt historii i dodaje go do stosu historii w przeglądarce, za pomocą określonego stanu klucz i wartość stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia tworzenie punktów historii zapisać wartość, aby zidentyfikować stanu. Podczas tworzenia punktów historii serializacji i zaszyfrowane dane są dołączane do adresu URL strony sieci Web i wpis znajduje się w stosie historii w przeglądarce. Tytuł strony sieci Web jest używana jako tytuł wpisu stanu stosu historii.  
  
 Dane o stanie służy do ponownego tworzenia tej strony, gdy zostanie wywołane dowolne zdarzenie nawigacji kolejny serwer. Aby uzyskać więcej informacji, zobacz [Zarządzanie kontrolek przy użyciu serwera programu przeglądarki historii](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Kluczowym elementem pary klucz/wartość, który określa stan strony sieci Web.</param>
        <param name="value">Część wartości pary klucz/wartość, który określa stan strony sieci Web.</param>
        <param name="title">Tekst, który zostanie dodany do stosu historii przeglądarki jako tytuł dla tego stanu.</param>
        <summary>Tworzy punkt historii i dodaje go do stosu historii w przeglądarce, za pomocą klucza określonego stanu, wartość stanu i tytuł stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia tworzenie punktu historii, gdy użytkownik chce zapisać wartość, aby zidentyfikować stan i tytułu, stanu. Podczas tworzenia punktów historii serializacji i zaszyfrowane dane są dołączane do adresu URL strony sieci Web i wpis znajduje się w stosie historii w przeglądarce. Jeśli `title` parametr jest `null`, tytuł strony sieci Web jest używana jako tytuł wpisu stanu stosu historii.  
  
 Dane o stanie służy do ponownego tworzenia tej strony, gdy zostanie wywołane dowolne zdarzenie nawigacji kolejny serwer. Aby uzyskać więcej informacji, zobacz [Zarządzanie kontrolek przy użyciu serwera programu przeglądarki historii](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly AjaxFrameworkAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly AjaxFrameworkAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AjaxFrameworkAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ AjaxFrameworkAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkAssembly : System.Reflection.Assembly" Usage="System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw framework Ajax przez składniki przy użyciu strony.</summary>
        <value>Zestaw framework Ajax.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AjaxFrameworkMode As AjaxFrameworkMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AjaxFrameworkMode AjaxFrameworkMode { System::Web::UI::AjaxFrameworkMode get(); void set(System::Web::UI::AjaxFrameworkMode value); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkMode : System.Web.UI.AjaxFrameworkMode with get, set" Usage="System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AjaxFrameworkMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, jak skrypty klienta biblioteki klienta usługi Microsoft Ajax zostaną uwzględnione na komputerze klienckim.</summary>
        <value><see cref="T:System.Web.UI.AjaxFrameworkMode" /> Wartość wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> właściwością pozwalającą włączyć wszystkie pliki skryptów Microsoft Ajax: Wyłącz wszystkie pliki skryptów Microsoft Ajax lub jawnie dołączyć pliki poszczególnych skryptów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> właściwość `Explicit` w celu wskazania, że skrypty może być jawnie określone.  
  
```  
<asp:ScriptManager ID="sm1" AjaxFrameworkMode="Explicit" runat="server">   
<Scripts>   
    <asp:ScriptReference Name="MicrosoftAjaxCore.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxComponentModel.js" />    
    <asp:ScriptReference Name="MicrosoftAjaxSerialization.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxNetwork.js" />       
</Scripts>   
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.AjaxFrameworkMode" />
      </Docs>
    </Member>
    <Member MemberName="AllowCustomErrorsRedirect">
      <MemberSignature Language="C#" Value="public bool AllowCustomErrorsRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCustomErrorsRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCustomErrorsRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCustomErrorsRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowCustomErrorsRedirect : bool with get, set" Usage="System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy błędy niestandardowe części pliku Web.config jest używane podczas wystąpił błąd podczas asynchronicznego zwrotu.</summary>
        <value><see langword="true" /> Jeśli błędy niestandardowe ustawienia w pliku Web.config będzie używana do określania zachowania błędu podczas asynchroniczne odświeżenia strony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> Zdarzenie jest wywoływane, gdy występuje błąd strony podczas asynchroniczne odświeżenia strony. Jak błędy na serwerze zostaną wysłane do klienta jest zależna od <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> właściwości <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> właściwości i sekcję błędy niestandardowe w pliku Web.config.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AsyncPostBackError As EventHandler(Of AsyncPostBackErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::AsyncPostBackErrorEventArgs ^&gt; ^ AsyncPostBackError;" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackError : EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " Usage="member this.AsyncPostBackError : System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy występuje błąd strony podczas odświeżania asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> Zdarzenie jest wywoływane, gdy występuje błąd strony podczas asynchroniczne odświeżenia strony. Jak błędy na serwerze zostaną wysłane do klienta jest zależna od <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> właściwości <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> właściwości i sekcję błędy niestandardowe w pliku Web.config.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak obsługiwać <xref:System.Web.UI.ScriptManager.AsyncPostBackError> zdarzenie, aby ustawić <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> właściwości (który jest wysyłany do klienta) komunikat o błędzie dla wyjątku serwera.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackErrorMessage">
      <MemberSignature Language="C#" Value="public string AsyncPostBackErrorMessage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackErrorMessage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackErrorMessage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackErrorMessage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackErrorMessage : string with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia komunikat o błędzie, który jest wysyłana do klienta, gdy wystąpi wyjątek nieobsługiwany serwera podczas odświeżania asynchronicznego.</summary>
        <value>Komunikat o błędzie. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> Zdarzenie jest wywoływane, gdy występuje błąd strony podczas asynchroniczne odświeżenia strony. Jak błędy na serwerze zostaną wysłane do klienta jest zależna od <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> właściwości <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> właściwości i sekcję błędy niestandardowe w pliku Web.config.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak obsługiwać <xref:System.Web.UI.ScriptManager.AsyncPostBackError> zdarzenie, aby ustawić <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> właściwości (który jest wysyłany do klienta) komunikat o błędzie dla wyjątku serwera.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackSourceElementID">
      <MemberSignature Language="C#" Value="public string AsyncPostBackSourceElementID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackSourceElementID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncPostBackSourceElementID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackSourceElementID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackSourceElementID : string" Usage="System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.AsyncPostBackSourceElementID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator formantu, który spowodował asynchronicznego zwrotu.</summary>
        <value>Unikatowy identyfikator kontrolki, jeśli kontrolka ma identyfikator; w przeciwnym razie pusty ciąg ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID%2A> Właściwość zawiera wartość Identyfikator formantu, który spowodował asynchronicznego zwrotu, który może być jednym z następujących czynności:  
  
-   Ogłaszania zwrotnego w kontrolce, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> formant, którego <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> właściwość jest ustawiona na `true` (ustawienie domyślne).  
  
-   Ogłaszania zwrotnego w kontrolce, który jest dostępny wyzwalacz dla <xref:System.Web.UI.UpdatePanel> kontroli.  
  
-   Ogłaszania zwrotnego w kontrolce, która jest zarejestrowana przez wywołanie metody <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> metody <xref:System.Web.UI.ScriptManager> kontroli.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackTimeout">
      <MemberSignature Language="C#" Value="public int AsyncPostBackTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AsyncPostBackTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AsyncPostBackTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackTimeout : int with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(90)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czas w sekundach limit czasu asynchroniczne odświeżenia strony, jeśli odpowiedź nie zostanie odebrana.</summary>
        <value>Liczba całkowita, która reprezentuje limit czasu w sekundach. Wartość domyślna to 90 sekund.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationService">
      <MemberSignature Language="C#" Value="public System.Web.UI.AuthenticationServiceManager AuthenticationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.AuthenticationServiceManager AuthenticationService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AuthenticationService As AuthenticationServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AuthenticationServiceManager ^ AuthenticationService { System::Web::UI::AuthenticationServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationService : System.Web.UI.AuthenticationServiceManager" Usage="System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AuthenticationServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.UI.AuthenticationServiceManager" /> obiektu, który jest skojarzony z bieżącym <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</summary>
        <value><see cref="T:System.Web.UI.AuthenticationServiceManager" /> Obiektu dla bieżącego <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.AuthenticationServiceManager> Obiekt, który jest zwracany przez tę właściwość reprezentuje usługę uwierzytelniania, która jest zarejestrowana na stronie. Usługa uwierzytelniania można zdefiniować w <xref:System.Web.UI.ScriptManager> kontroli lub skojarzoną <xref:System.Web.UI.ScriptManagerProxy> kontroli.  
  
 Można korzystać z usługi uwierzytelniania platformy ASP.NET lub użyć niestandardowej usłudze uwierzytelniania. Niestandardowe usługi można dodawać w znaczniku, umieszczając `AuthenticationService` element wewnątrz `asp:ScriptManager` elementu na stronie, jak pokazano w poniższym przykładzie.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <AuthenticationService Path="MyAuthenticationService.asmx" />  
</asp:ScriptManager>  
```  
  
 Możesz też programowo skonfigurować <xref:System.Web.UI.AuthenticationServiceManager> obiektu. Usługi są zarejestrowane w usłudze <xref:System.Web.UI.ScriptManager> sterowania podczas strony <xref:System.Web.UI.Control.PreRender> etap cyklu życia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientNavigateHandler">
      <MemberSignature Language="C#" Value="public string ClientNavigateHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientNavigateHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientNavigateHandler As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientNavigateHandler { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientNavigateHandler : string with get, set" Usage="System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę metody, która obsługuje <see href="https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93">Sys.Application.navigate</see> zdarzeń na komputerze klienckim.</summary>
        <value>Nazwa metody, która obsługuje [Sys.Application.navigate](https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93) zdarzeń na komputerze klienckim.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositeScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.CompositeScriptReference CompositeScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.CompositeScriptReference CompositeScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.CompositeScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositeScript As CompositeScriptReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::CompositeScriptReference ^ CompositeScript { System::Web::UI::CompositeScriptReference ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositeScript : System.Web.UI.CompositeScriptReference" Usage="System.Web.UI.ScriptManager.CompositeScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.CompositeScriptReference</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do skryptu złożony, który obsługuje strony sieci Web.</summary>
        <value>Odwołanie do skryptu złożonego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [łączenia skryptów klienta w skrypcie złożonego](https://msdn.microsoft.com/library/d0f608d0-b4c8-4795-990b-ede68c1239b3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyPageUrl">
      <MemberSignature Language="C#" Value="public virtual string EmptyPageUrl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EmptyPageUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EmptyPageUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EmptyPageUrl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EmptyPageUrl : string with get, set" Usage="System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor(typeof(System.Web.UI.Design.UrlEditor), typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.UrlProperty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia adres URL do pustej strony sieci Web.</summary>
        <value>Adres URL do użycia, jeśli strona sieci Web docelowych jest pusta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.EmptyPageUrl%2A> Właściwość obsługuje historię przeglądania Ajax.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdn">
      <MemberSignature Language="C#" Value="public bool EnableCdn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdn" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdn" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdn { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdn : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy bieżąca strona ładuje odwołania do skryptu klienta ze ścieżek sieci CDN (Content Delivery Network).</summary>
        <value><see langword="true" /> Jeśli odwołania do skryptu klienta są ładowane z usługi CDN ścieżki, w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest ustawiona `true` Jeśli ustawisz <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> do `true` już.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdnFallback">
      <MemberSignature Language="C#" Value="public bool EnableCdnFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdnFallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdnFallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdnFallback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdnFallback : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Umożliwia lokalną kopię skryptu w celu załadowania w przypadku, gdy niedostępności sieci CDN (Content Delivery Network).</summary>
        <value><see langword="true" /> Jeśli wartość rezerwowa sieć CDN jest włączone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableHistory">
      <MemberSignature Language="C#" Value="public bool EnableHistory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableHistory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableHistory" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableHistory As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableHistory { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableHistory : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableHistory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy strony sieci Web obsługuje Historia punktu zarządzania.</summary>
        <value><see langword="true" /> Jeśli strona sieci Web obsługuje dodawanie punktów historii w przeglądarce historii stosu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.ScriptManager.EnableHistory%2A> właściwością pozwalającą włączyć zarządzanie historią na stronie sieci Web.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePageMethods">
      <MemberSignature Language="C#" Value="public bool EnablePageMethods { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePageMethods" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePageMethods As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePageMethods { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePageMethods : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy można wywołać metody publicznej statycznej strony na stronie ASP.NET z skrypt po stronie klienta.</summary>
        <value><see langword="true" /> Jeśli można wywołać metody statycznej strony na stronie ASP.NET z skrypt po stronie klienta jako metody sieci Web; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można dodać metody statycznej strony do strony ASP.NET i oznacz je jako metody sieci Web. Następnie możesz wywołać tych metod ze skryptu tak, jakby były część usługi sieci Web, ale bez tworzenia plików .asmx oddzielne. Aby utworzyć metody sieci Web, na stronie, należy go zaimportować <xref:System.Web.Services> przestrzeni nazw i Dodaj <xref:System.Web.Services.WebMethodAttribute> atrybut do każdej metody statyczne, który chcesz udostępnić. Metody musi być oznaczona jako publiczna.  
  
 Aby uzyskać więcej informacji, zobacz [udostępnianie usług sieci Web, aby skrypt po stronie klienta w technologii ASP.NET AJAX](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePartialRendering">
      <MemberSignature Language="C#" Value="public bool EnablePartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która umożliwia częściowe renderowanie strony, która z kolei umożliwia indywidualnie zaktualizować regionów strony za pomocą <see cref="T:System.Web.UI.UpdatePanel" /> kontrolki.</summary>
        <value><see langword="true" /> Jeśli włączono częściowe renderowanie, a cała strona aktualizacje będą pomijane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nawet wtedy, gdy <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> właściwość `true`, częściowe renderowanie strony może nastąpić. Przeglądarka może nie obsługiwać częściowe renderowanie strony, lub <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> właściwość jest ustawiona na `false`.  
  
 Możesz zastąpić wartość <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> właściwości w czasie wykonywania, ciągu lub przed strony <xref:System.Web.UI.Control.Init> zdarzeń. Jeśli spróbujesz zmienić tę właściwość po stronie <xref:System.Web.UI.Control.Init> wystąpiło zdarzenie <xref:System.InvalidOperationException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> Właściwość jest ustawiona po stronie <see cref="E:System.Web.UI.Control.Init" /> wystąpi zdarzenie.</exception>
        <altmember cref="T:System.Web.UI.UpdatePanel" />
        <altmember cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="EnableScriptGlobalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptGlobalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptGlobalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptGlobalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptGlobalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptGlobalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.ScriptManager" /> kontrolka renderuje skrypt, który obsługuje formatowanie specyficzne dla kultury informacje i analizowanie.</summary>
        <value><see langword="true" /> Jeśli informacje specyficzne dla kultury może być wyświetlana; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> właściwość jest ustawiona na `true`, globalizowana ECMAScript (JavaScript) funkcje, takie jak `Date.localeFormat` metoda wyświetlania charakterystyczne dla kultury informacje. Kultura można ustawić w przeglądarce, w kodzie serwera lub w pliku konfiguracji witryny sieci Web.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/69b34e6d-d590-4d03-a763-b7ae54b47d74">Lokalizowanie datę przy użyciu skryptu klienta</related>
      </Docs>
    </Member>
    <Member MemberName="EnableScriptLocalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptLocalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptLocalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptLocalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptLocalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptLocalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Web.UI.ScriptManager" /> kontrolka renderuje zlokalizowane wersje plików skryptów.</summary>
        <value><see langword="true" /> Jeśli skrypt zlokalizowane pliki będą renderowane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> właściwość jest ustawiona na `true`, <xref:System.Web.UI.ScriptManager> obiektu pobierze pliki skryptów dla bieżącej kultury, jeśli takie istnieją. Na przykład strony może określić plik skryptu, który nosi nazwę CustomScript.js. Jeśli ustawiono kultury fr-CA <xref:System.Web.UI.ScriptManager> podejmie próbę pobrania pliku skryptu, który nosi nazwę CustomScript.fr CA.js obiektu.  
  
> [!NOTE]
>  Aby zapobiec renderowanego dwa razy w pliku skryptu <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> nie można zmodyfikować właściwości podczas odświeżania asynchronicznego.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb">Zasoby lokalizacyjne dla biblioteki — informacje o składniku</related>
      </Docs>
    </Member>
    <Member MemberName="EnableSecureHistoryState">
      <MemberSignature Language="C#" Value="public bool EnableSecureHistoryState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSecureHistoryState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSecureHistoryState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSecureHistoryState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableSecureHistoryState : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy należy szyfrować ciąg stanu historii.</summary>
        <value><see langword="true" /> Jeśli powinien być zaszyfrowany ciąg stanu historii; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Ta właściwość powinna ***nigdy nie*** można ustawić `false` w witrynie sieci web w środowisku produkcyjnym.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptManager GetCurrent (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.ScriptManager GetCurrent(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetCurrent(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::ScriptManager ^ GetCurrent(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrent : System.Web.UI.Page -&gt; System.Web.UI.ScriptManager" Usage="System.Web.UI.ScriptManager.GetCurrent page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">Wystąpienie strony, aby pobrać <see cref="T:System.Web.UI.ScriptManager" /> z.</param>
        <summary>Pobiera <see cref="T:System.Web.UI.ScriptManager" /> wystąpienie danego <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Bieżący <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia dla wybranego <see cref="T:System.Web.UI.Page" /> obiektu lub <see langword="null" /> Jeśli nie zdefiniowano żadnego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyć tej metody statyczne do określenia czy <xref:System.Web.UI.ScriptManager> formant znajduje się na stronie lub dostęp do właściwości i metod <xref:System.Web.UI.ScriptManager> sterowania, jeśli nie znasz jego identyfikator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredArrayDeclarations">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredArrayDeclarations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredArrayDeclarations () As ReadOnlyCollection(Of RegisteredArrayDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredArrayDeclaration ^&gt; ^ GetRegisteredArrayDeclarations();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredArrayDeclarations : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;" Usage="scriptManager.GetRegisteredArrayDeclarations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tylko do odczytu deklaracje tablicy ECMAScript (JavaScript), które zostały wcześniej zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Ogólna kolekcja zawiera deklaracje tablicy.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterArrayDeclaration" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredClientScriptBlocks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredClientScriptBlocks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredClientScriptBlocks () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredClientScriptBlocks();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredClientScriptBlocks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredClientScriptBlocks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tylko do odczytu w blokach skryptu klienta, które zostały wcześniej zarejestrowane w usłudze <see cref="T:System.Web.UI.ScriptManager" /> kontroli.</summary>
        <returns>Ogólna kolekcja zawiera bloki skryptu klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bloki skryptu klienta zostały zarejestrowane przy użyciu <xref:System.Web.UI.ScriptManager> kontrolki do użycia z kontrolką, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontroli.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredDisposeScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredDisposeScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredDisposeScripts () As ReadOnlyCollection(Of RegisteredDisposeScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredDisposeScript ^&gt; ^ GetRegisteredDisposeScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredDisposeScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;" Usage="scriptManager.GetRegisteredDisposeScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tylko do odczytu <see langword="dispose" /> skrypty, które zostały wcześniej zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Ogólna kolekcja, który zawiera <see langword="dispose" /> skryptów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `dispose` skrypt jest wykonywany, gdy <xref:System.Web.UI.UpdatePanel> formantu zostanie zaktualizowany lub usunięty.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredExpandoAttributes">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredExpandoAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredExpandoAttributes () As ReadOnlyCollection(Of RegisteredExpandoAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredExpandoAttribute ^&gt; ^ GetRegisteredExpandoAttributes();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredExpandoAttributes : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;" Usage="scriptManager.GetRegisteredExpandoAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tylko do odczytu atrybuty niestandardowe (expando), które zostały wcześniej zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Ogólna kolekcja atrybutów niestandardowych, które zawiera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut niestandardowy jest pary nazwa/wartość, która może być odczytywana i ustawiona przez skrypt po stronie klienta.  
  
   
  
## Examples  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.RegisteredExpandoAttribute>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredHiddenFields">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredHiddenFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredHiddenFields () As ReadOnlyCollection(Of RegisteredHiddenField)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredHiddenField ^&gt; ^ GetRegisteredHiddenFields();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredHiddenFields : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;" Usage="scriptManager.GetRegisteredHiddenFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tylko do odczytu ukryte pola, które zostały wcześniej zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Ogólna kolekcja zawiera ukrytych pól.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.UI.RegisteredHiddenField" />
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterHiddenField" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredOnSubmitStatements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredOnSubmitStatements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredOnSubmitStatements () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredOnSubmitStatements();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredOnSubmitStatements : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredOnSubmitStatements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tylko do odczytu <see langword="onsubmit" /> instrukcji, które zostały wcześniej zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Ogólna kolekcja, który zawiera <see langword="onsubmit" /> instrukcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `onsubmit` Instrukcja jest ECMAScript (JavaScript), który jest wykonywany po przesłaniu formularza.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredStartupScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredStartupScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredStartupScripts () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredStartupScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredStartupScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredStartupScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję tylko do odczytu skrypty uruchamiania, które zostały wcześniej zarejestrowane w usłudze <see cref="T:System.Web.UI.Page" /> obiektu.</summary>
        <returns>Ogólna kolekcja zawiera skrypty uruchamiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrypt uruchamiania to skrypt klienta, który jest skojarzony z formantem, który jest wykonywany po uruchomieniu formantu.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ScriptManager.GetRegisteredStartupScripts%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStateString">
      <MemberSignature Language="C#" Value="public string GetStateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetStateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetStateString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetStateString();" />
      <MemberSignature Language="F#" Value="member this.GetStateString : unit -&gt; string" Usage="scriptManager.GetStateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ciąg, który zawiera pary klucz/wartość, które reprezentują stan strony sieci Web.</summary>
        <returns>Ciąg zawierający pary klucz/wartość, które reprezentują stanu strony sieci Web.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsDebuggingEnabled</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wersje do debugowania biblioteki skryptów klienta będzie renderowana.</summary>
        <value><see langword="true" /> Jeśli bieżące żądanie jest wykonywane w trybie debugowania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> Właściwość zwraca `false` gdy jeden z następujących warunków jest spełniony:  
  
-   W [wdrożenia](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) element pliku konfiguracji `retail` ma ustawioną wartość atrybutu `true`. Ustawienie to zastępuje wszystkie inne ustawienia.  
  
-   <xref:System.Web.UI.ScriptManager.ScriptMode%2A> Właściwość jest ustawiona na `Auto` lub `Inherit`, a debugowanie nie jest włączone w `compilation` sekcja pliku Web.config katalog główny aplikacji.  
  
-   <xref:System.Web.UI.ScriptManager.ScriptMode%2A> Właściwość jest ustawiona na `Release`.  
  
    > [!NOTE]
    >  `debug` Atrybutu [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) dyrektywy nie wpływa na aplikacje ASP.NET z włączoną obsługą technologii Ajax. <xref:System.Web.UI.ScriptManager> Kontroli używa tylko ustawienia w pliku Web.config, a w jego <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> i <xref:System.Web.UI.ScriptManager.ScriptMode%2A> właściwości w celu określenia, czy do renderowania debugowania skryptów.  
  
 Aby uzyskać więcej informacji, zobacz [debugowanie i śledzenie Ajax aplikacji — omówienie](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.IsDebuggingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsInAsyncPostBack">
      <MemberSignature Language="C#" Value="public bool IsInAsyncPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInAsyncPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInAsyncPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInAsyncPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInAsyncPostBack : bool" Usage="System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsInAsyncPostBack</InterfaceMember>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.IsInAsyncPostBack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący zwrot jest wykonywana w trybie częściowego renderowania.</summary>
        <value><see langword="true" /> Jeśli bieżący zwrot jest wykonywane w trybie częściowego renderowania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> właściwość w połączeniu z <xref:System.Web.UI.Page.IsPostBack%2A> właściwość rozróżnienie między ładowania strony początkowej, aktualizacji stron częściowych i cała strona aktualizacji w <xref:System.Web.UI.Control.Load>, <xref:System.Web.UI.Page.InitComplete>, lub <xref:System.Web.UI.Control.PreRender> zdarzenia.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="IsNavigating">
      <MemberSignature Language="C#" Value="public bool IsNavigating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNavigating" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsNavigating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNavigating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNavigating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNavigating : bool" Usage="System.Web.UI.ScriptManager.IsNavigating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="E:System.Web.UI.ScriptManager.Navigate" /> zdarzenie jest obecnie obsługiwane.</summary>
        <value><see langword="true" /> Jeśli <see cref="E:System.Web.UI.ScriptManager.Navigate" /> jest obsługiwany, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.ScriptManager.IsNavigating%2A> właściwości, aby określić, czy <xref:System.Web.UI.ScriptManager.Navigate> spowodował zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPostData">
      <MemberSignature Language="C#" Value="protected virtual bool LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection);" />
      <MemberSignature Language="F#" Value="abstract member LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool&#xA;override this.LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool" Usage="scriptManager.LoadPostData (postDataKey, postCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">Identyfikator klucza dla formantu.</param>
        <param name="postCollection">Kolekcja wszystkich przychodzących danych post.</param>
        <summary>Odczytuje dane formularza, opublikowaniu z przeglądarki do serwera, która określa źródło asynchronicznego zwrotu.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Web.UI.ScriptManager" /> stan formantu został zmieniony w wyniku zwrotu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.LoadPostData%2A> Metoda jest używana głównie przez programistów sterowania do rozszerzenia funkcji <xref:System.Web.UI.ScriptManager> kontroli.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="LoadScriptsBeforeUI">
      <MemberSignature Language="C#" Value="public bool LoadScriptsBeforeUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadScriptsBeforeUI" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadScriptsBeforeUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadScriptsBeforeUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadScriptsBeforeUI : bool with get, set" Usage="System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy skrypty są załadowane przed lub po znaczników dla żądanej strony interfejsu użytkownika.</summary>
        <value><see langword="true" /> Jeśli skrypty są załadowane przed załadowaniem znaczników dla interfejsu użytkownika; <see langword="false" /> Jeśli skrypty są ładowane po załadowaniu kodu znaczników dla interfejsu użytkownika. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> Właściwość określa, jak skrypty w <xref:System.Web.UI.ScriptManager.Scripts%2A> kolekcji są ładowane względem znaczników dla strony interfejsu użytkownika.  
  
 Gdy <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> właściwość `true`, `script` element jest renderowany przed załadowaniem strony interfejsu użytkownika znaczników. W tym scenariuszu jeśli elementy interfejsu użytkownika są zdefiniowane w skryptach, interfejs użytkownika będzie w pełni funkcjonalne podczas ładowania. Jednakże jeśli skrypt uzyskuje dostęp do elementów interfejsu użytkownika w znaczniku, dla którego wystąpienia nie zostały jeszcze utworzone, może wystąpić błąd. Aby upewnić się, że elementy interfejsu użytkownika są ładowane, zanim można uzyskiwać do nich dostęp, obsługi `load` zdarzenia `Sys.Application` klasy.  
  
 Gdy <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> właściwość `false`, `script` element jest renderowany po renderowania kodu znaczników interfejsu użytkownika strony. W tym scenariuszu interfejsu użytkownika ładuje się szybciej, ale może nie być w pełni funkcjonalne w przypadku skryptów, które określają dodatkowe elementy interfejsu użytkownika nie zakończono ładowania.  
  
 Ta właściwość nie jest ustawiona `true` Jeśli ustawisz <xref:System.Web.UI.ScriptManager.EnableCdn%2A> do `true` już.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.Scripts" />
        <altmember cref="T:System.Web.UI.ScriptReference" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; Navigate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.HistoryEventArgs&gt; Navigate" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.Navigate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigate As EventHandler(Of HistoryEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::HistoryEventArgs ^&gt; ^ Navigate;" />
      <MemberSignature Language="F#" Value="member this.Navigate : EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " Usage="member this.Navigate : System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie w przeglądarce **ponownie** lub **do przodu** przycisku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy użytkownik kliknie w przeglądarce **ponownie** przycisku przeglądarki nawiguje wcześniej wyświetlać adresy URL obejmujące adresy URL, które zawierają dane o stanie punktu w historii. Jeśli kod klienta, na stronie sieci Web wykryje, że adres URL zawiera dane o stanie historii, kieruje żądanie do strony serwera. Jest to zabezpieczenie zwrotu zdarzenia i <xref:System.Web.UI.ScriptManagerProxy> zgłasza kontrolki serwera `Navigate` zdarzeń. Można obsługiwać to zdarzenie i odtworzenie strony zgodnie z wymaganiami aplikacji sieci Web przy użyciu danych stanu, który jest przekazywany ze zdarzeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAsyncPostBackError">
      <MemberSignature Language="C#" Value="protected internal virtual void OnAsyncPostBackError (System.Web.UI.AsyncPostBackErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnAsyncPostBackError(class System.Web.UI.AsyncPostBackErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnAsyncPostBackError (e As AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnAsyncPostBackError(System::Web::UI::AsyncPostBackErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit&#xA;override this.OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit" Usage="scriptManager.OnAsyncPostBackError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.AsyncPostBackErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Błąd danych zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> Zdarzenie jest wywoływane, gdy występuje błąd strony podczas asynchroniczne odświeżenia strony. Jak błędy na serwerze zostaną wysłane do klienta jest zależna od <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> właściwości <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> właściwości i sekcję błędy niestandardowe w pliku Web.config.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak obsługiwać <xref:System.Web.UI.ScriptManager.AsyncPostBackError> zdarzenie, aby ustawić <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> właściwości (który jest wysyłany do klienta) komunikat o błędzie dla wyjątku serwera.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="scriptManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Web.UI.Control.Init" /> zdarzeń i upewnia się, że tylko jeden <see cref="T:System.Web.UI.ScriptManager" /> formant istnieje na tej stronie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Więcej niż jedno wystąpienie <see cref="T:System.Web.UI.ScriptManager" /> istnieje na tej stronie.</exception>
        <block subset="none" type="overrides"><para>W przypadku przesłaniania tej metody należy wywołać base <see cref="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" /> metody, które pliki skryptów są poprawnie obsługiwane dla częściowe renderowanie strony.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Przegląd cyklu życia strony ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="scriptManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Web.UI.Control.PreRender" /> zdarzeń i rejestrów skryptów, plików i usług aktualizacji stron częściowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje na temat modelu DOM, zobacz [Specyfikacja poziomu 1 modelu DOM (Document Object)](https://go.microsoft.com/fwlink/?LinkId=73305) w witrynie sieci Web konsorcjum World Wide Web Consortium (W3C).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Przeglądarka, który zgłosił żądanie stron częściowych nie obsługuje co najmniej poziom DOM w wersji 1.0.</exception>
        <block subset="none" type="overrides"><para>W przypadku przesłaniania tej metody należy wywołać base <see cref="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" /> metody, która skrypt bloków i usług są poprawnie obsługiwane dla częściowe renderowanie strony.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Przegląd cyklu życia strony ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveCompositeScriptReference (System.Web.UI.CompositeScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveCompositeScriptReference(class System.Web.UI.CompositeScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveCompositeScriptReference(System.Web.UI.CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveCompositeScriptReference (e As CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveCompositeScriptReference(System::Web::UI::CompositeScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveCompositeScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.CompositeScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt, który reprezentuje odwołanie do skryptu złożonego.</param>
        <summary>Wywołuje <see cref="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveScriptReference (System.Web.UI.ScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveScriptReference(class System.Web.UI.ScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveScriptReference(System.Web.UI.ScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveScriptReference (e As ScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveScriptReference(System::Web::UI::ScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.ScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt, który reprezentuje bieżący skrypt.</param>
        <summary>Wywołuje <see cref="E:System.Web.UI.ScriptManager.ResolveScriptReference" /> zdarzenia dla każdego odwołanie do skryptu, który jest zarządzany przez <see cref="T:System.Web.UI.ScriptManager" /> kontroli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana <xref:System.Web.UI.ScriptManager.OnPreRender%2A> programu obsługi zdarzeń, jeden raz dla każdego <xref:System.Web.UI.ScriptReference> w <xref:System.Web.UI.ScriptManager.Scripts%2A> kolekcji.  
  
 <xref:System.Web.UI.ScriptManager.ResolveScriptReference> Zdarzenie jest wywoływane po skryptu zduplikowane wpisy zostały rozwiązane.  
  
 Zastępuje tę metodę, aby wpłynąć na zachowania Bloki skryptu poszczególnych zwrotu lub podczas aktualizacji stron częściowych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProfileService">
      <MemberSignature Language="C#" Value="public System.Web.UI.ProfileServiceManager ProfileService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ProfileServiceManager ProfileService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ProfileService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProfileService As ProfileServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ProfileServiceManager ^ ProfileService { System::Web::UI::ProfileServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProfileService : System.Web.UI.ProfileServiceManager" Usage="System.Web.UI.ScriptManager.ProfileService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ProfileServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.UI.ProfileServiceManager" /> obiektu, który jest skojarzony z bieżącym <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</summary>
        <value><see cref="T:System.Web.UI.ProfileServiceManager" /> Obiektu dla bieżącego <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ProfileServiceManager> Obiekt, który jest zwracany przez tę właściwość reprezentuje usługę profilu, który jest zarejestrowany na stronie. Usługa profilu można zdefiniować w <xref:System.Web.UI.ScriptManager> kontroli lub skojarzoną <xref:System.Web.UI.ScriptManagerProxy> kontroli.  
  
 Można użyć z usługą profilów platformy ASP.NET lub użyć usługi profilu niestandardowego. Niestandardowe usługi można dodawać w znaczniku, umieszczając `ProfileService` element wewnątrz `asp:ScriptManager` elementu na stronie, jak pokazano w poniższym przykładzie.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <ProfileService LoadProperties="propertyA,propertyB"  
    Path="MyProfileService.asmx" />  
</asp:ScriptManager>  
```  
  
 Możesz też programowo skonfigurować <xref:System.Web.UI.ProfileServiceManager> obiektu. Usługi są zarejestrowane w usłudze <xref:System.Web.UI.ScriptManager> sterowania podczas strony <xref:System.Web.UI.Control.PreRender> etap cyklu życia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : string -&gt; unit&#xA;override this.RaisePostBackEvent : string -&gt; unit" Usage="scriptManager.RaisePostBackEvent eventArgument" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">Ciąg par klucz/wartość, które reprezentują stan historii strony sieci Web.</param>
        <summary>Przetwarza zwrotu zdarzenia wygenerowane przez <see cref="T:System.Web.UI.ScriptManager" /> kontroli i ładuje stan historii strony sieci Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostDataChangedEvent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostDataChangedEvent();" />
      <MemberSignature Language="F#" Value="abstract member RaisePostDataChangedEvent : unit -&gt; unit&#xA;override this.RaisePostDataChangedEvent : unit -&gt; unit" Usage="scriptManager.RaisePostDataChangedEvent " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje zdarzenia dla <see cref="T:System.Web.UI.ScriptManager" /> kontroli, gdy wysyła on żądanie POST na serwerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RaisePostDataChangedEvent%2A> Metoda jest używana głównie przez programistów sterowania do rozszerzenia funkcji <xref:System.Web.UI.ScriptManager> kontroli. Do wykonania domyślnej <xref:System.Web.UI.ScriptManager> formantu, zdarzenia nie są wywoływane.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterArrayDeclaration">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje deklaracja tablicy ECMAScript (JavaScript) za pomocą <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką, która znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> kontrolować i dodaje tablicy ze stroną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (control, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje tablicy.</param>
        <param name="arrayName">Nazwa tablicy do zarejestrowania.</param>
        <param name="arrayValue">Tablica wartości lub wartości, które można zarejestrować.</param>
        <summary>Rejestruje deklaracja tablicy ECMAScript (JavaScript) za pomocą <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką, która znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> kontrolować i dodaje tablicy ze stroną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> metodę, aby zarejestrować tablica skryptu klienta, która jest zgodna z częściowe renderowanie strony i czy nie ma żadnych zależności biblioteki Microsoft Ajax Library. Ta metoda rejestruje tablicy po `control` reprezentuje kontrolkę, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, która jest aktualizowana. Aby zarejestrować tablicę za każdym razem występuje asynchronicznego zwrotu, użyj <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować tablicę, która nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania stronę początkową tablicy użyj <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> Metoda określa, czy tablica nie zawierająca nazwę, która została określona w `arrayName` parametru jest już zarejestrowany. Jeśli tak, metoda dodaje wartości określone w `arrayValue`. Ponieważ tablicy do zarejestrowania opiera się na <xref:System.Collections.ArrayList> klasy, duplikaty są dozwolone. Jeśli zarejestrowane tablicy o nazwie w `arrayName` nie istnieje, tablica jest tworzona i wartości w `arrayValue` są dodawane do niego.  
  
 Aby uwzględnić literały ciągów znaków w tablicy, należy użyć znaki pojedynczego cudzysłowu (') lub poprzedzone znakiem zmiany znaczenia podwójnego cudzysłowu (\\") w `arrayValue`.  
  
 Należy pamiętać, że JavaScript traktuje przecinek (,) jako ogranicznika w tablicy. Można określić wiele wartości tablicy, przekazując ciąg rozdzielanym przecinkami w `arrayValue`. Oddziel dwa elementy przecinka w `arrayValue` jest równoważne z wywoływaniem <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> metodę dwa razy, jeden raz dla każdego elementu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Page page, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Page page, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Page ^ page, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (page, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje tablicy.</param>
        <param name="arrayName">Nazwa tablicy do zarejestrowania.</param>
        <param name="arrayValue">Tablica wartości lub wartości, które można zarejestrować.</param>
        <summary>Rejestruje deklaracja tablicy ECMAScript (JavaScript) za pomocą <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką, która znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> kontrolować i dodaje tablicy ze stroną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> metodę, aby zarejestrować tablica skryptu klienta, która jest zgodna z częściowe renderowanie strony i czy nie ma żadnych zależności biblioteki Microsoft Ajax Library. Ta metoda rejestruje tablicy za każdym razem, występujący asynchronicznego zwrotu. Aby zarejestrować się tablica formant, który znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki tablicy jest zarejestrowany, tylko wtedy, gdy zostanie zaktualizowany panel, należy użyć <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować tablicę, która nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania stronę początkową tablicy użyj <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterAsyncPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAsyncPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAsyncPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterAsyncPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterAsyncPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka rejestracji asynchroniczne odświeżenia strony.</param>
        <summary>Rejestruje formantu jako wyzwalacza dla asynchroniczne odświeżenia strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> Metoda umożliwia rejestrowanie formantów serwera sieci Web jako wyzwalacze tak, aby wykonują asynchronicznego zwrotu zamiast synchronicznych zwrotu. Gdy <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> właściwość <xref:System.Web.UI.UpdatePanel> kontrolki jest ustawiona na `true` (co jest ustawieniem domyślnym), ogłaszanie zwrotne formanty <xref:System.Web.UI.UpdatePanel> kontrolki są automatycznie rejestrowane jako formanty asynchroniczne ogłaszania wstecznego.  
  
 Użyj <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> metodę, aby zarejestrować kontrolki poza <xref:System.Web.UI.UpdatePanel> formant jako wyzwalaczy dla asynchroniczne odświeżenia strony oraz potencjalnie aktualizowania zawartości panelu aktualizacji. Aby zaktualizować <xref:System.Web.UI.UpdatePanel> sterowania programowo, wywołaj <xref:System.Web.UI.UpdatePanel.Update%2A> metody.  
  
 Dodaj wyzwalacz deklaratywne przy użyciu `Triggers` elementu <xref:System.Web.UI.UpdatePanel> kontroli. W programie Visual Studio, za pomocą projektanta **UpdatePanelTrigger — Edytor kolekcji** okno dialogowe.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób wywoływania <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> metodę, aby zarejestrować <xref:System.Web.UI.WebControls.Button> sterowania, co sprawia, że aktualizacja <xref:System.Web.UI.UpdatePanel> zawartość formantu. <xref:System.Web.UI.WebControls.Button> Formant nie znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontroli. Są wyświetlane dwa przyciski: `Button1` i `Button2`. `Button1` Odświeża zawartość panelu i `Button2` odświeża całą stronę.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager1VB.aspx#1)]  
  
 Poniższy przykład pokazuje sposób wywoływania <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> metodę, aby zarejestrować użytkownika sterowania, co sprawia, że aktualizacja <xref:System.Web.UI.UpdatePanel> zawartość formantu. Pierwszy przykład pokazuje stronę za pomocą kontrolki użytkownika. Drugi przykład przedstawia kontrolkę użytkownika.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager2CS.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager2VB.aspx#2)]  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Strona jest zarejestrowany jako formant asynchronicznego zwrotu.
—lub—

Zarejestrowane formantu nie implementuje <see cref="T:System.Web.UI.INamingContainer" />, <see cref="T:System.Web.UI.IPostBackDataHandler" />, lub <see cref="T:System.Web.UI.IPostBackEventHandler" /> interfejsów.</exception>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
        <altmember cref="M:System.Web.UI.UpdatePanel.Update" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje bloku skryptu klienta za pomocą <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką, która znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> sterowania, a następnie dodanie bloku skryptu do strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje bloku skryptu klienta.</param>
        <param name="type">Typ bloku skryptu klienta. Ten parametr jest zwykle określony za pomocą <see langword="typeof" /> — operator (C#) lub <see langword="GetType" /> — operator (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="key">Unikatowy identyfikator bloku skryptu.</param>
        <param name="script">Skrypt.</param>
        <param name="addScriptTags"><see langword="true" /> Aby załączyć blok skryptu <see langword="&lt;script&gt;" /> i <see langword="&lt;/script&gt;" /> tagów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rejestruje bloku skryptu klienta za pomocą <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką, która znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> sterowania, a następnie dodanie bloku skryptu do strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> metodę, aby zarejestrować bloku skryptu klienta zgodnego z częściowe renderowanie strony i czy nie ma żadnych zależności biblioteki Microsoft Ajax Library. Bloki skryptu klienta, które są zarejestrowane przy użyciu tej metody są wysyłane do strony tylko wtedy, gdy `control` reprezentuje kontrolkę, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, która jest aktualizowana. Aby zarejestrować blok skryptu za każdym razem występuje asynchronicznego zwrotu, użyj <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania strony początkowej w bloku skryptu użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 Jeśli `addScriptTags` jest `true`, <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> metoda dodaje `<script>` tagi wokół bloku skryptu. Przekaż `false` Jeśli chcesz tworzyć `<script>` tagów samodzielnie, np. Jeśli chcesz ustawić atrybuty określonego `<script>` tagów. Jeśli `addScriptTags` jest `false` i `script` parametr zawiera wiele bloków skryptu, zgłaszany jest wyjątek.  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> Metoda dodaje blok skryptu do strony po otwarciu `<form>` tagu. Bloki skryptu nie musi być danych wyjściowych w tej samej kolejności, w którym są rejestrowane. Jeśli kolejność Bloki skryptu jest ważne, połącz swoje blokach skryptu w jeden ciąg (na przykład za pomocą <xref:System.Text.StringBuilder> obiektu), a następnie zarejestruj je jako blok skryptu jednego klienta.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/CS/ScriptManager_RegisterClientScriptBlockCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/vb/ScriptManager_RegisterClientScriptBlockVB.aspx#1)]  
  
 [!code-xml[System.Web.UI.ScriptManager.RegisterClientScriptBlock#2](~/samples/snippets/common/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/Common/App_Data/Contacts.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">W bloku skryptu klienta <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
Formant, który rejestruje blok skryptu jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Formant, który rejestruje blok skryptu nie jest w drzewie kontrolki strony.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje bloku skryptu klienta.</param>
        <param name="type">Typ bloku skryptu klienta. Ten parametr jest zwykle określony za pomocą <see langword="typeof" /> — operator (C#) lub <see langword="GetType" /> — operator (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="key">Unikatowy identyfikator bloku skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <param name="addScriptTags"><see langword="true" /> Aby załączyć blok skryptu <see langword="&lt;script&gt;" /> i <see langword="&lt;/script&gt;" /> tagów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rejestruje bloku skryptu klienta za pomocą <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką, która znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> sterowania, a następnie dodanie bloku skryptu do strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zarejestrowaniu blok skryptu za pomocą tej metody, skrypt jest renderowany w każdym wystąpieniu asynchronicznego zwrotu. Aby zarejestrować blok skryptu dla formantu, który znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> taki sposób, aby skrypt został zarejestrowany tylko wtedy, gdy <xref:System.Web.UI.UpdatePanel> formantu zostanie zaktualizowany, należy użyć <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania strony początkowej w bloku skryptu użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Blok skryptu <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
Strona, która rejestruje blok skryptu jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje klienta pliku skryptu, <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką, która znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> kontrolować, a następnie dodaje odwołanie do pliku skryptu, na stronie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (control, type, key, url)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje w pliku skryptu klienta.</param>
        <param name="type">Typ pliku skryptu klienta. Ten parametr jest zwykle określony za pomocą typeof — operator (C#) lub operator GetType (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="key">Unikatowy identyfikator pliku skryptu.</param>
        <param name="url">Adres URL pliku skryptu.</param>
        <summary>Rejestruje klienta pliku skryptu, <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką, która znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> kontrolować, a następnie dodaje odwołanie do pliku skryptu, na stronie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> metodę, aby zarejestrować plik skryptu klienta dla strony lub części strony, która uczestniczy w aktualizacji stron częściowych. Pliki skryptów klienta, które są zarejestrowane przy użyciu tej metody są wysyłane do strony tylko wtedy, gdy `control` reprezentuje kontrolkę, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, która jest aktualizowana. Aby zarejestrować plik skryptu za każdym razem występuje asynchronicznego zwrotu, użyj <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania strony początkowej w bloku skryptu użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> Metoda rejestruje plik skryptu klienta na stronie przez renderowanie `script` elementu, którego otwierający tag zawiera `src` atrybutu. `url` Parametr służy do ustawiania `src` atrybutu. Aby rozpoznawać adresy URL, należy użyć <xref:System.Web.UI.Control.ResolveClientUrl%2A> metody. Ta metoda używa kontekstu jest wywoływana dla, aby rozpoznać ścieżki adresu URL.  
  
 Zarówno <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> i <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> metody renderowania pliki skryptów w przeglądarce. Jeśli skrypt za pomocą tego samego typu i klucz (dla pliku skryptu) lub tego samego typu i nazwy zasobu (dla zasobu osadzonego) jest już renderowana, skrypt nie jest renderowany ponownie.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptInclude#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/ScriptManager_RegisterClientScriptIncludeCS.aspx#1)]  
  
 [!code-javascript[System.Web.UI.ScriptManager.RegisterClientScriptInclude#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/scripts/script_alertdiv.js#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Plik skryptu klienta <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
Formant, który rejestruje w pliku skryptu jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Formant, który rejestruje w pliku skryptu nie jest w drzewie kontrolki strony.  
  
—lub— 
 <paramref name="url" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="url" /> jest pusty.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Page page, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Page page, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (page, type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje w pliku skryptu klienta.</param>
        <param name="type">Typ pliku skryptu klienta. Ten parametr jest zwykle określony za pomocą typeof — operator (C#) lub operator GetType (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="key">Unikatowy identyfikator pliku skryptu.</param>
        <param name="url">Adres URL pliku skryptu.</param>
        <summary>Rejestruje skrypt po stronie klienta za pomocą <see cref="T:System.Web.UI.ScriptManager" /> kontrolować każdym razem, gdy występuje asynchronicznego zwrotu, a następnie dodaje odwołanie do pliku skryptu, na stronie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zarejestrowaniu plik skryptu przy użyciu tej metody, skrypt jest renderowany w każdym wystąpieniu asynchronicznego zwrotu. Aby zarejestrować plik skryptu dla formantu, który znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> taki sposób, aby skrypt został zarejestrowany tylko wtedy, gdy <xref:System.Web.UI.UpdatePanel> formantu zostanie zaktualizowany, należy użyć <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania strony początkowej w bloku skryptu użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Plik skryptu klienta <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
Strona, która rejestruje w pliku skryptu jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="url" /> jest pusty.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje skryptu klienta, który jest osadzony w zestawie przy użyciu <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką będącej częściowe renderowanie strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Control * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (control, type, resourceName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje skryptu.</param>
        <param name="type">Typ skryptu klienta. Ten parametr jest zwykle określony za pomocą typeof — operator (C#) lub operator GetType (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="resourceName">Identyfikator zasobu.</param>
        <summary>Rejestruje skrypt klienta, który jest osadzony w zestawie przy użyciu <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką będącej częściowe renderowanie strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> metodę rejestrowania skryptu, który jest zgodny z częściowe renderowanie strony, która nie ma żadnych zależności biblioteki Microsoft Ajax Library. Zarejestrowano zasoby skryptu, które są zarejestrowane przy użyciu tej metody tylko wtedy, gdy `control` reprezentuje kontrolkę, która znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, która jest aktualizowana. Aby zarejestrować skrypt za każdym razem występuje asynchronicznego zwrotu, użyj <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania strony początkowej w bloku skryptu użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> Metoda jest używana, gdy zasoby z zestawów są dostępne za pośrednictwem programu obsługi HTTP. Ta metoda dołącza zawartość adresu URL zasobu w `script` elementu.  
  
 Zarówno <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> i <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> pliki skryptów obciążenia metody do przeglądarki. Jeśli skrypt za pomocą tego samego typu i klucz (dla pliku skryptu) lub tego samego typu i nazwy zasobu (dla zasobu osadzonego) jest już załadowany, skrypt nie będą ładowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Zasób klienta <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
Formant, który rejestruje skryptu jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Formant, który rejestruje skrypt nie jest w drzewie kontrolki strony.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Page page, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Page page, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Page ^ page, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Page * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (page, type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje skryptu.</param>
        <param name="type">Typ skryptu klienta. Ten parametr jest zwykle określony za pomocą typeof — operator (C#) lub operator GetType (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="resourceName">Identyfikator zasobu.</param>
        <summary>Rejestruje plik skryptu klienta, który jest osadzony w zestawie przy użyciu <see cref="T:System.Web.UI.ScriptManager" /> kontrolować co godzinę ogłaszania zwrotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zarejestrowaniu plik skryptu przy użyciu tej metody, skrypt jest renderowany w każdym wystąpieniu asynchronicznego zwrotu. Do zarejestrowania skrypt dla formantu, który znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> taki sposób, aby skrypt został zarejestrowany tylko wtedy, gdy <xref:System.Web.UI.UpdatePanel> formantu zostanie zaktualizowany, należy użyć <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować blok skryptu, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania strony początkowej w bloku skryptu użyj <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Zasób klienta <paramref name="type" /> jest <see langword="null" />.  
  
—lub— 
Strona która rejestruje skryptu jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterDataItem">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane niestandardowe formanty podczas częściowe renderowanie strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który odbiera dane.</param>
        <param name="dataItem">Dane, które są wysyłane do formantu.</param>
        <summary>Wysyła dane niestandardowe kontrolki podczas częściowe renderowanie strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> metodę, aby wysyłać dane z serwera do klienta podczas asynchroniczne odświeżenia strony, niezależnie od tego, czy kontrolka odbiera dane wewnątrz <xref:System.Web.UI.UpdatePanel> kontroli.  
  
 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> Metodę można wywołać tylko podczas odświeżania asynchronicznego. Aby określić, czy asynchroniczne ogłaszania zwrotnego, użyj <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> właściwości. Ta metoda wywołuje przeciążenia przyjmującego parametr o nazwie `isJsonSerialized` który jest skonfigurowany do `false`. Gdy `isJsonSerialized` parametr ma wartość `false`, ciąg nie jest serializowana jako JavaScript Object Notation (JSON). Aby uzyskać więcej informacji na temat formatu JSON, zobacz [JSON: wprowadzenie](https://go.microsoft.com/fwlink/?LinkId=77297) witryny sieci Web.  
  
 Elementy danych, które są zarejestrowane w usłudze <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> metoda może być dostępne w skrypt po stronie klienta podczas `pageLoading`, `pageLoaded`, i `endRequest` zdarzenia `PageRequestManager` obiektu. Podczas obsługi zdarzenia niestandardowe dane są przekazywane w obiekcie argumentu zdarzenia. Na przykład, jeśli podasz obsługi dla `pageLoading` zdarzenia niestandardowe dane są przekazywane w `PageLoadingEventArgs` klasy, która ujawnia właściwość.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wysyłać dane do dwóch <xref:System.Web.UI.WebControls.Label> formantów na stronie podczas odświeżania asynchronicznego. <xref:System.Web.UI.WebControls.Label> Formanty nie są w obrębie <xref:System.Web.UI.UpdatePanel> kontroli.  
  
> [!NOTE]
>  Dane, które są wysyłane w tym przykładzie jest wyłącznie do celów informacyjnych. W przypadku aplikacji rzeczywistych można użyć <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> metodę, aby wysłać dane niestandardowe z serwera.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> Metoda jest wywoływana podczas ogłaszania zwrotnego.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dataItem" /> jest już zarejestrowany dla <paramref name="control" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem, bool isJsonSerialized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string * bool -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem, isJsonSerialized)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
        <Parameter Name="isJsonSerialized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka strony, która odbiera dane.</param>
        <param name="dataItem">Dane, które są wysyłane do formantu.</param>
        <param name="isJsonSerialized"><see langword="true" /> Aby wskazać, że <paramref name="dataItem" /> jest serializowane jako kod JSON; w przeciwnym razie <see langword="false" />.</param>
        <summary>Wysyła niestandardowe dane do formantu podczas częściowe renderowanie strony i wskazuje, czy dane są w formacie JavaScript Object Notation (JSON).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> metodę, aby wysyłać dane z serwera do klienta podczas asynchroniczne odświeżenia strony, niezależnie od tego, czy kontrolka odbiera dane wewnątrz <xref:System.Web.UI.UpdatePanel> kontroli.  
  
 Jeśli `dataItem` parametr, który zarejestrujesz `control` nie jest serializowany jako dane JSON, ustaw `isJsonSerialized` parametr `false`. Eliminuje to konieczność użycia `eval` funkcji dla każdego ciągu, który jest wysyłany do klienta. Aby uzyskać więcej informacji na temat formatu JSON, zobacz [JSON: wprowadzenie](https://go.microsoft.com/fwlink/?LinkId=77297) witryny sieci Web.  
  
 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> Metodę można wywołać tylko podczas odświeżania asynchronicznego. Aby określić, czy asynchroniczne ogłaszania zwrotnego, użyj <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> właściwości.  
  
 Elementy danych, które są zarejestrowane przy użyciu <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> metoda może być dostępne w skrypt po stronie klienta podczas `pageLoading`, `pageLoaded`, i `endRequest` zdarzenia `PageRequestManager` obiektu. Podczas obsługi zdarzenia niestandardowe dane są przekazywane w obiekcie argumentu zdarzenia. Na przykład, jeśli podasz obsługi dla `pageLoading` zdarzenia niestandardowe dane są przekazywane w `PageLoadingEventArgs` klasy, która ujawnia właściwość.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wysyłać dane do dwóch <xref:System.Web.UI.WebControls.Label> formantów na stronie podczas odświeżania asynchronicznego. <xref:System.Web.UI.WebControls.Label> Formanty nie są w obrębie <xref:System.Web.UI.UpdatePanel> kontroli. W tym przykładzie przedstawiono przeciążenia, które nie przyjmuje `isJsonSerialized` parametru. W przeciwnym razie procedura pobierania `dataItems` właściwość `PageLoadingEventArgs` obiekt jest taki sam, jakby nie używasz tego przeciążenia.  
  
> [!NOTE]
>  Dane, które są wysyłane w tym przykładzie jest wyłącznie do celów informacyjnych. W przypadku aplikacji rzeczywistych można użyć <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> metodę, aby wysłać dane niestandardowe z serwera. Na przykład można użyć elementu danych do wysyłania informacji o tym, czy ukryć lub pokazać klienta elementy, które nie są w obrębie <xref:System.Web.UI.UpdatePanel> kontroli.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> Metoda jest wywoływana podczas ogłaszania zwrotnego.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dataItem" /> jest już zarejestrowany dla <paramref name="control" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDispose">
      <MemberSignature Language="C#" Value="public void RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript);" />
      <MemberSignature Language="F#" Value="member this.RegisterDispose : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDispose (control, disposeScript)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterDispose(System.Web.UI.Control,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka, <see langword="dispose" /> skrypt jest przeznaczony.</param>
        <param name="disposeScript"><see langword="dispose" /> Skryptu.</param>
        <summary>Rejestruje <see langword="dispose" /> skryptu dla formantu, który znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> kontroli. Skrypt zostanie wykonany po <see cref="T:System.Web.UI.UpdatePanel" /> formantu zostanie zaktualizowany lub usunięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> metodę, aby zarejestrować `dispose` skryptów dla formantów, które znajdują się wewnątrz <xref:System.Web.UI.UpdatePanel> kontroli. Podczas asynchroniczne odświeżenia strony <xref:System.Web.UI.UpdatePanel> kontrolki mogą zostać zaktualizowane, usunięty lub utworzony. Po zaktualizowano lub usunięto którykolwiek typ panelu `dispose` skrypty, które są zarejestrowane dla formantów, które znajdują się wewnątrz <xref:System.Web.UI.UpdatePanel> są wywoływane. W stronę typowe scenariusze programowania, nie trzeba wywołać <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> metody.  
  
 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> Metoda jest przeznaczona do użytku przez programistów sterowania do zarejestrowania skrypt lub tworzyć formanty, które dziedziczą z <xref:System.Web.UI.IScriptControl> interfejsu. Na przykład, można na przykład `dispose` skryptu tworzenia kontroli klienta przy użyciu kompozycji. Pod kontrolą użytkownika, możesz wdrożyć <xref:System.Web.UI.IScriptControl> i pojedynczych kontrolek Renderuj. Możesz zarejestrować `dispose` metoda dowolny element, który nie odpowiada żadnemu składnik klienta zdefiniowanych takich jak `Sys.TextBox`. Jeśli niestandardową kontrolkę Redaguj elementy, które odnoszą się do składników klienta w bibliotece Microsoft Ajax Library, będą musieli zarejestrować `dispose` skryptu, ponieważ `dispose` jest wywoływana automatycznie. W związku z tym, użyj <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> metody dla składników klienta, które są częścią biblioteki Microsoft Ajax i mają zwolnienia zasobów, gdy składnik nie jest już używana.  
  
 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> Metodę można wywoływać wielokrotnie dla formantu. Wiele skryptów są agregowane. Kolejność usuwania skrypty odpowiada kolejności, w którym zostały zarejestrowane skryptów.  
  
 Jeśli zarejestrujesz odbieranie `dispose` skryptu dla formantu, który nie znajduje się w <xref:System.Web.UI.UpdatePanel> kontrolki, zgłaszany jest wyjątek. `dispose` Skrypt ma nazwę między `pageLoading` i `pageLoaded` zdarzenia `PageRequestManager` klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="disposeScript" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> Nie znaleziono na stronie.  
  
—lub— 
 <paramref name="control" /> nie jest w obrębie <see cref="T:System.Web.UI.UpdatePanel" /> kontroli.</exception>
        <altmember cref="T:System.Web.UI.IScriptControl" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public static void RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="static member RegisterExpandoAttribute : System.Web.UI.Control * string * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterExpandoAttribute (control, controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje atrybut expando.</param>
        <param name="controlId">Formant, który zawiera atrybut niestandardowy na tej stronie.</param>
        <param name="attributeName">Nazwa niestandardowego atrybutu w celu zarejestrowania.</param>
        <param name="attributeValue">Wartość atrybutu niestandardowego.</param>
        <param name="encode"><see langword="true" /> kodowanie atrybutu niestandardowego, który jest rejestrowany; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rejestruje pary nazwa/wartość, przy użyciu <see cref="T:System.Web.UI.ScriptManager" /> kontroli jako atrybut niestandardowy (expando) określonego formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> metodę, aby zarejestrować właściwość niestandardową (expando) dla formantu, który jest zgodny z częściowe renderowanie strony, która nie ma żadnych zależności biblioteki Microsoft Ajax Library.  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> Metoda rejestruje pary nazwa/wartość jako atrybut niestandardowy dla określonej kontrolki. Dla właściwości ustawiono dynamicznie z ECMAScript (JavaScript) w celu zachowania zgodności XHTML dla kodu znaczników kontrolki renderowany. Ustaw `encode` do `true` w przypadku jako znak ucieczki dla znaków w wartości właściwości dynamicznych.  
  
 Jeśli formant, do którego zostanie dodana właściwość dynamiczna nie zostanie znaleziony, wystąpi błąd skryptu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> nie ma strony formantu drzewa.  
  
—lub— 
 <paramref name="controlId" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="controlId" /> jest pusty.  
  
—lub— 
 <paramref name="attributeName" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="attributeName" /> jest pusty.  
  
—lub— 
 <paramref name="attributeName" /> jest już zarejestrowany.</exception>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExtenderControl&lt;TExtenderControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterExtenderControl&lt;TExtenderControl&gt; (TExtenderControl extenderControl, System.Web.UI.Control targetControl) where TExtenderControl : System.Web.UI.Control, System.Web.UI.IExtenderControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterExtenderControl&lt;(class System.Web.UI.Control, class System.Web.UI.IExtenderControl) TExtenderControl&gt;(!!TExtenderControl extenderControl, class System.Web.UI.Control targetControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExtenderControl(Of TExtenderControl As {Control, IExtenderControl}) (extenderControl As TExtenderControl, targetControl As Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TExtenderControl&gt;&#xA; where TExtenderControl : System::Web::UI::Control, System::Web::UI::IExtenderControl virtual void RegisterExtenderControl(TExtenderControl extenderControl, System::Web::UI::Control ^ targetControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)&#xA;override this.RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)" Usage="scriptManager.RegisterExtenderControl (extenderControl, targetControl)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterExtenderControl``1(``0,System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TExtenderControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IExtenderControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="extenderControl" Type="TExtenderControl" />
        <Parameter Name="targetControl" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <typeparam name="TExtenderControl">Formant, który implementuje <see cref="T:System.Web.UI.IExtenderControl" /> interfejsu.</typeparam>
        <param name="extenderControl">Kontrolka rozszerzenia do zarejestrowania.</param>
        <param name="targetControl">Formant skryptu, który rozszerza rozszerzenie formantu.</param>
        <summary>Rejestruje rozszerzenie formantu z bieżącymi <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest głównie do użycia przez deweloperów kontroli. Wywołaj <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> metody w niestandardowym formancie rozszerzeń ASP.NET Ajax, podczas jego `onInit` program obsługi zdarzeń do zarejestrowania tej kontrolki na stronie. Kontrolka rozszerzenia ASP.NET Ajax musi być zarejestrowana do wzięcia udziału w częściowe renderowanie strony.  
  
 <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> Metoda dodaje określony rozszerzenie formantu do wewnętrznej listy rozszerzeń kontrolki oraz docelowy skryptu rozszerzają. Ta lista jest przetwarzany <xref:System.Web.UI.Control.PreRender> zdarzeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="extenderControl" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="targetControl" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterHiddenField">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje ukryte pole.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (control, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje ukryte pole.</param>
        <param name="hiddenFieldName">Nazwa pola ukrytego do zarejestrowania.</param>
        <param name="hiddenFieldInitialValue">Początkowa wartość ukryte pole.</param>
        <summary>Rejestruje ukryte pole z <see cref="T:System.Web.UI.ScriptManager" /> kontroli dla formantu, który znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> kontroli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> metodę, aby zarejestrować ukryte pola, które jest zgodne z częściowe renderowanie strony, które nie ma żadnych zależności biblioteki Microsoft Ajax Library. Ta metoda rejestruje pole ukryte, gdy formant, który rejestruje pola znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, która jest aktualizowana. Aby zarejestrować ukrytego pola w każdym wystąpieniu asynchronicznego zwrotu, użyj <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować ukryte pole, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować ukryte pole tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> Metoda tworzy ukryty `input` element na renderowanej stronie HTML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="hiddenFieldName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> nie ma strony formantu drzewa.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Page ^ page, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (page, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje ukryte pole.</param>
        <param name="hiddenFieldName">Nazwa pola ukrytego do zarejestrowania.</param>
        <param name="hiddenFieldInitialValue">Początkowa wartość ukryte pole.</param>
        <summary>Rejestruje ukryte pole z <see cref="T:System.Web.UI.ScriptManager" /> sterowania podczas każdego asynchronicznego zwrotu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> metodę, aby zarejestrować ukryte pola, które jest zgodne z częściowe renderowanie strony, które nie ma żadnych zależności biblioteki Microsoft Ajax Library. Ta metoda rejestruje pole ukryte za każdym razem, występujący asynchronicznego zwrotu. Aby zarejestrować ukryte pole dla formantu, który znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki pola jest zarejestrowany, tylko wtedy, gdy zostanie zaktualizowany panel, należy użyć <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować ukryte pole, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować ukryte pole tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="hiddenFieldName" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterNamedClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje skrypt po stronie klienta przez nazwę zasobu, która jest osadzony w zestawie przy użyciu <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką będącej częściowe renderowanie strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Control control, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Control control, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Control ^ control, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Control * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (control, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje skryptu.</param>
        <param name="resourceName">Identyfikator zasobu.</param>
        <summary>Rejestruje skrypt po stronie klienta przez nazwę zasobu, która jest osadzony w zestawie przy użyciu <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką będącej częściowe renderowanie strony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Page page, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Page page, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Page,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Page ^ page, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Page * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (page, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje skryptu.</param>
        <param name="resourceName">Identyfikator zasobu.</param>
        <summary>Rejestruje skrypt po stronie klienta przez nazwę zasobu, która jest osadzony w zestawie przy użyciu <see cref="T:System.Web.UI.ScriptManager" /> kontrolki do użycia z kontrolką będącej częściowe renderowanie strony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterOnSubmitStatement">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje kod ECMAScript (JavaScript), który jest wykonywany po przesłaniu formularza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (control, type, key, script)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje <see langword="onsubmit" /> instrukcji.</param>
        <param name="type">Typ instrukcji skryptu klienta. Ten parametr jest zwykle określony za pomocą typeof — operator (C#) lub operator GetType (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="key">Unikatowy identyfikator dla instrukcji skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <summary>Rejestruje kod ECMAScript (JavaScript) za pomocą <see cref="T:System.Web.UI.ScriptManager" /> kontroli dla formantu, który jest używany z <see cref="T:System.Web.UI.UpdatePanel" /> formant, który jest wykonywany po przesłaniu formularza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> Dodaje skryptu, który jest wykonywany przed przesłaniem formularza, który umożliwia modyfikowanie przesyłania lub Anuluj ją.  
  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> metody do renderowania `onsubmit` instrukcji, która jest zgodna z częściowe renderowanie strony i ma żadnych zależności w bibliotece Microsoft Ajax Library. Kod JavaScript, która jest zarejestrowana za pomocą tej metody jest wysyłane do strony, tylko wtedy, gdy formant, który rejestruje Instrukcja znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, która jest aktualizowana. Aby zarejestrować kodu za pomocą każdego asynchronicznego zwrotu, należy użyć <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować kod JavaScript, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować kod tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 *Skryptu* parametru <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> metoda może zawierać kilka poleceń skryptu, które są rozdzielane średnikami (;).  
  
 Aby uzyskać więcej informacji na temat formularzy HTML i `onsubmit` zdarzeń, zobacz [witryny sieci Web konsorcjum World Wide Web Consortium (W3C)](https://go.microsoft.com/fwlink/?linkid=37125).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> nie ma strony formantu drzewa.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Page page, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Page page, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (page, type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje <see langword="onsubmit" /> instrukcji.</param>
        <param name="type">Typ instrukcji skryptu klienta. Ten parametr jest zwykle określony za pomocą typeof — operator (C#) lub operator GetType (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="key">Unikatowy identyfikator dla instrukcji skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <summary>Rejestruje kod ECMAScript (JavaScript) za pomocą <see cref="T:System.Web.UI.ScriptManager" /> kontroli dla formantu, który jest używany z <see cref="T:System.Web.UI.UpdatePanel" /> formant, który jest wykonywany po przesłaniu formularza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rejestrowanie kodu JavaScript przy użyciu tej metody powoduje, że skrypt zostanie uwzględniona w każdym wystąpieniu asynchronicznego zwrotu.  
  
> [!NOTE]
>  Kod z dowolnego wcześniej asynchroniczne odświeżenia strony nie zostanie usunięty. Nowe asynchroniczne odświeżenia strony Dołączanie kodu do dowolnego istniejącego kodu dla `onsubmit` instrukcji.  
  
 Aby zarejestrować kodu dla formantu, który znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki kod jest zarejestrowany tylko wtedy, gdy <xref:System.Web.UI.UpdatePanel> formantu zostanie zaktualizowany, należy użyć <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować kod JavaScript, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować kod tylko raz podczas renderowania strony początkowej, użyj <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="type" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Kontrolka rejestracji zwrotu.</param>
        <summary>Rejestruje formantu jako wyzwalacza dla ogłaszania zwrotnego. Ta metoda służy do konfigurowania zwrotu formanty <see cref="T:System.Web.UI.UpdatePanel" /> kontrolki, które w przeciwnym razie będzie wykonywać asynchroniczne odświeżenia strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A> metodę, aby zarejestrować zwrotu formanty <xref:System.Web.UI.UpdatePanel> kontroli jako wyzwalacze. Formanty, które są zarejestrowane przy użyciu tej metody aktualizacji całej strony, zamiast tylko aktualizowania <xref:System.Web.UI.UpdatePanel> zawartość formantu. Rejestrowanie zwrotu kontroli przy użyciu tej metody poza <xref:System.Web.UI.UpdatePanel> kontrolka nie ma wpływu, ponieważ domyślnie tych kontrolek nie wykonuj asynchroniczne odświeżenia strony.  
  
 Dodaj wyzwalacz deklaratywne przy użyciu `Triggers` elementu <xref:System.Web.UI.UpdatePanel> kontroli. W programie Visual Studio, za pomocą projektanta **UpdatePanelTrigger — Edytor kolekcji** okno dialogowe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptControl&lt;TScriptControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterScriptControl&lt;TScriptControl&gt; (TScriptControl scriptControl) where TScriptControl : System.Web.UI.Control, System.Web.UI.IScriptControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptControl&lt;(class System.Web.UI.Control, class System.Web.UI.IScriptControl) TScriptControl&gt;(!!TScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptControl(Of TScriptControl As {Control, IScriptControl}) (scriptControl As TScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TScriptControl&gt;&#xA; where TScriptControl : System::Web::UI::Control, System::Web::UI::IScriptControl virtual void RegisterScriptControl(TScriptControl scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)&#xA;override this.RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)" Usage="scriptManager.RegisterScriptControl scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptControl``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TScriptControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IScriptControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="scriptControl" Type="TScriptControl" />
      </Parameters>
      <Docs>
        <typeparam name="TScriptControl">Formant, który implementuje <see cref="T:System.Web.UI.IScriptControl" /> interfejsu.</typeparam>
        <param name="scriptControl">Kontrolka skryptu do zarejestrowania.</param>
        <summary>Rejestruje kontroli skryptu z bieżącymi <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest głównie do użycia przez deweloperów kontroli. Wywołaj <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> metody z formantu niestandardowego skryptu ASP.NET Ajax podczas jego `onInit` program obsługi zdarzeń do zarejestrowania tej kontrolki na stronie. Formant ASP.NET Ajax skryptu musi być zarejestrowana do wzięcia udziału w częściowe renderowanie strony.  
  
 <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> Metoda dodaje formant określonego urządzenia extender do wewnętrznej listy elementów sterujących skryptu, które jest przetwarzany <xref:System.Web.UI.Control.PreRender> zdarzeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scriptControl" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterScriptDescriptors">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że <see cref="T:System.Web.UI.ScriptManager" /> formantu do wywoływania zwrotnego <see cref="T:System.Web.UI.ScriptControl" /> lub <see cref="T:System.Web.UI.ExtenderControl" /> klasy w celu zwrócenia skrypty, które obsługują klienta obiekt reprezentujący kontroli klienta, składnika lub zachowania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IExtenderControl extenderControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IExtenderControl extenderControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (extenderControl As IExtenderControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IExtenderControl ^ extenderControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors extenderControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extenderControl" Type="System.Web.UI.IExtenderControl" />
      </Parameters>
      <Docs>
        <param name="extenderControl">Urządzenie extender kontroli dla skryptu, które będą rejestrowane deskryptorów.</param>
        <summary>Wywołuje się <see cref="T:System.Web.UI.ExtenderControl" /> klasy w celu zwracania wystąpienia skryptów, które muszą być renderowana na obsługuje obiekt klienta, który reprezentuje kontroli klienta, składnika lub zachowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ExtenderControl> Klasy wywołania <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> method in Class metoda jego <xref:System.Web.UI.Control.Render%2A> metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>W przypadku klasy wyprowadzonej z <see cref="T:System.Web.UI.ExtenderControl" /> klasy, a także Przesłoń <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody, ale nie wywołuj metody klasy bazowej, należy wywołać <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" /> metody. Dzięki temu <see cref="T:System.Web.UI.ScriptManager" /> formantu do renderowania skrypty wystąpienia, które obsługują obiektu klienta, który reprezentuje kontrolkę.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IScriptControl scriptControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (scriptControl As IScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IScriptControl ^ scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IScriptControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptControl" Type="System.Web.UI.IScriptControl" />
      </Parameters>
      <Docs>
        <param name="scriptControl">Skrypt kontroli dla skryptu, które będą rejestrowane deskryptorów.</param>
        <summary>Wywołania <see cref="T:System.Web.UI.ScriptControl" /> klasy w celu zwracania wystąpienia skryptów, które muszą być renderowana na obsługuje obiekt klienta, który reprezentuje kontroli klienta, składnika lub zachowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptControl> Klasy wywołania <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> metody podczas jego <xref:System.Web.UI.Control.Render%2A> zdarzeń.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>W przypadku klasy wyprowadzonej z <see cref="T:System.Web.UI.ScriptControl" /> klasy, a także Przesłoń <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metody, ale nie wywołuj metody klasy bazowej, należy wywołać <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" /> metody. Dzięki temu <see cref="T:System.Web.UI.ScriptManager" /> formantu do renderowania skrypty wystąpienia, które obsługują obiektu klienta, który reprezentuje kontrolkę.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje blok skryptu uruchamiania przy użyciu <see cref="T:System.Web.UI.ScriptManager" /> kontroli i dodaje blok skryptu do strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Formant, który rejestruje bloku skryptu klienta.</param>
        <param name="type">Typ bloku skryptu klienta. Ten parametr jest zwykle określony za pomocą typeof — operator (C#) lub operator GetType (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="key">Unikatowy identyfikator bloku skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <param name="addScriptTags"><see langword="true" /> Aby załączyć blok skryptu za pomocą <see langword="&lt;script&gt;" /> i <see langword="&lt;/script&gt;" /> tagów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rejestruje blok skryptu uruchamiania dla formantu, który znajduje się wewnątrz <see cref="T:System.Web.UI.UpdatePanel" /> przy użyciu <see cref="T:System.Web.UI.ScriptManager" /> sterowania, a następnie dodanie bloku skryptu do strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> metodę, aby zarejestrować blok skryptu uruchamiania strony, na który jest zgodny z częściowe renderowanie strony, która nie ma żadnych zależności biblioteki Microsoft Ajax Library. Bloki skryptu uruchamiania, które są zarejestrowane przy użyciu tej metody są wysyłane do strony, tylko wtedy, gdy formant, który rejestruje bloku znajduje się wewnątrz <xref:System.Web.UI.UpdatePanel> kontrolki, która jest aktualizowana. Aby zarejestrować blok skryptu uruchamiania za każdym razem występuje asynchronicznego zwrotu, użyj <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować skryptu uruchamiania, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania strony początkowej skryptu użyj <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 Blok skryptu, który jest renderowany przez <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> metoda jest wykonywana po zakończenie ładowania strony ale przed strony klienta `onload` zdarzenie jest wywoływane. Bloki skryptu uruchamiania znajdują się w dolnej części renderowanej strony ASP.NET tuż przed `</form>` tagu.  
  
 Bloki skryptu uruchamiania, które są zarejestrowane przy użyciu <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> nie musi być danych wyjściowych w tej samej kolejności, w którym są rejestrowane. Jeśli kolejność uruchamiania Bloki skryptu jest ważne, użyj <xref:System.Text.StringBuilder> do zbierania blokach skryptu w ciągu jednego obiektu, a następnie zarejestrować je wszystkie jako skrypt uruchamiania jednego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> nie ma strony formantu drzewa.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">Obiekt strony, który rejestruje bloku skryptu klienta.</param>
        <param name="type">Typ bloku skryptu klienta. Ten parametr jest zwykle określony za pomocą typeof — operator (C#) lub operator GetType (Visual Basic), można pobrać typu formantu, który rejestruje skryptu.</param>
        <param name="key">Unikatowy identyfikator bloku skryptu.</param>
        <param name="script">Skrypt do zarejestrowania.</param>
        <param name="addScriptTags"><see langword="true" /> Aby załączyć blok skryptu za pomocą <see langword="&lt;script&gt;" /> i <see langword="&lt;/script&gt;" /> tagów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rejestruje blok skryptu uruchamiania dla każdego asynchronicznego zwrotu z <see cref="T:System.Web.UI.ScriptManager" /> kontroli i dodaje blok skryptu do strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia rejestrowanie blok skryptu uruchamiania, dostępnej w każdym wystąpieniu asynchronicznego zwrotu. Aby zarejestrować dla formantu, który znajduje się wewnątrz bloku skryptu <xref:System.Web.UI.UpdatePanel> kontrolki jest zarejestrowany w bloku skryptu tylko wtedy, gdy <xref:System.Web.UI.UpdatePanel> formantu zostanie zaktualizowany, należy użyć <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> przeciążenia tej metody.  
  
 Jeśli chcesz zarejestrować skryptu uruchamiania, które nie odnoszą się do aktualizacji stron częściowych, a jeśli chcesz zarejestrować tylko jeden raz podczas renderowania strony początkowej skryptu użyj <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metody <xref:System.Web.UI.ClientScriptManager> klasy. Możesz uzyskać odwołanie do <xref:System.Web.UI.ClientScriptManager> obiektu z <xref:System.Web.UI.Page.ClientScript%2A> właściwości strony.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="scriptManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Obiekt, który odbiera zawartość formantu, aby zapisywać na stronie.</param>
        <summary>Renderuje <see cref="T:System.Web.UI.ScriptManager" /> kontrolki użytkownika zawartości do przeglądarki przy użyciu określonego <see cref="T:System.Web.UI.HtmlTextWriter" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana przez deweloperów formantu, aby rozszerzyć <xref:System.Web.UI.ScriptManager> kontroli.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>W przypadku przesłaniania tej metody należy wywołać base <see cref="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" /> metoda tak, aby klient skryptu, który definiuje `Sys.WebForms.PageRequestManager` klasy jest renderowany na stronie.</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveCompositeScriptReference As EventHandler(Of CompositeScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::CompositeScriptReferenceEventArgs ^&gt; ^ ResolveCompositeScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveCompositeScriptReference : EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " Usage="member this.ResolveCompositeScriptReference : System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy skrypt złożonego jest zarejestrowane w usłudze <see cref="T:System.Web.UI.ScriptManager" /> kontroli.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveScriptReference As EventHandler(Of ScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::ScriptReferenceEventArgs ^&gt; ^ ResolveScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveScriptReference : EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " Usage="member this.ResolveScriptReference : System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy członek <see cref="P:System.Web.UI.ScriptManager.Scripts" /> kolekcji jest zarejestrowane w usłudze <see cref="T:System.Web.UI.ScriptManager" /> kontroli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane jeden raz dla każdego elementu członkowskiego <xref:System.Web.UI.ScriptManager.Scripts%2A> kolekcję podczas strony <xref:System.Web.UI.Control.PreRender> zdarzeń. To zdarzenie służy do wykonywania wszystkich aktualizacji, przed wyświetleniem skrypt do strony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoleService">
      <MemberSignature Language="C#" Value="public System.Web.UI.RoleServiceManager RoleService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.RoleServiceManager RoleService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.RoleService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RoleService As RoleServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::RoleServiceManager ^ RoleService { System::Web::UI::RoleServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RoleService : System.Web.UI.RoleServiceManager" Usage="System.Web.UI.ScriptManager.RoleService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.RoleServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.UI.RoleServiceManager" /> obiektu, który jest skojarzony z bieżącym <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</summary>
        <value><see cref="T:System.Web.UI.RoleServiceManager" /> Obiektu dla bieżącego <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.RoleServiceManager> Obiekt, który jest zwracany przez tę właściwość reprezentuje usługę roli, która jest zarejestrowana na stronie. Usługa roli można zdefiniować w <xref:System.Web.UI.ScriptManager> kontroli lub skojarzoną <xref:System.Web.UI.ScriptManagerProxy> kontroli. Można użyć usługi roli ASP.NET lub użyć usługi roli niestandardowej. Niestandardowe usługi można dodawać w znaczniku, umieszczając `RoleService` element wewnątrz `asp:ScriptManager` elementu na stronie, jak pokazano w poniższym przykładzie:  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <RoleService Path="MyRoleService.asmx" LoadRoles="True" />  
</asp:ScriptManager>  
```  
  
 Możesz też programowo skonfigurować <xref:System.Web.UI.RoleServiceManager> obiektu. Usługi są zarejestrowane w usłudze <xref:System.Web.UI.ScriptManager> sterowania podczas strony <xref:System.Web.UI.Control.PreRender> etap cyklu życia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptMode ScriptMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ScriptMode ScriptMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptMode As ScriptMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptMode ScriptMode { System::Web::UI::ScriptMode get(); void set(System::Web::UI::ScriptMode value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptMode : System.Web.UI.ScriptMode with get, set" Usage="System.Web.UI.ScriptManager.ScriptMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy debugowanie lub wersji bibliotek klienckich dla skryptu są renderowane.</summary>
        <value>Wartość wyliczenia, która wskazuje bieżący tryb. Wartość domyślna to <see cref="F:System.Web.UI.ScriptMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.ScriptMode%2A> Właściwość określa, czy <xref:System.Web.UI.ScriptManager> formant powinien renderowania debugowania lub wydania wersji bibliotek klienckich dla skryptu. Ta wartość może zostać zastąpiona przez wartości, które są ustawiane w pliku konfiguracji i w dyrektywie page.  
  
 W poniższej tabeli wymieniono prawidłowe wartości dla tej właściwości.  
  
|Wartość|Definicja|  
|-----------|----------------|  
|<xref:System.Web.UI.ScriptMode.Auto>|Debuguj wersje skrypt po stronie klienta biblioteki są używane na stronie sieci Web podczas `retail` atrybutu [wdrożenia](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) element konfiguracji jest ustawiony na wartość `false`. W przeciwnym razie są używane wersje bibliotek skryptu klienta.|  
|<xref:System.Web.UI.ScriptMode.Inherit>|Po zastosowaniu do <xref:System.Web.UI.ScriptManager.ScriptMode%2A> właściwość <xref:System.Web.UI.ScriptManager> obiektu, ta wartość jest taka sama jak <xref:System.Web.UI.ScriptMode.Auto>.|  
|<xref:System.Web.UI.ScriptMode.Debug>|Debuguj wersje skrypt po stronie klienta są używane bibliotek na stronie sieci Web, chyba że `retail` atrybutu [wdrożenia](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) element konfiguracji jest ustawiony na wartość `true`.|  
|<xref:System.Web.UI.ScriptMode.Release>|Wersje biblioteki skryptów klienta są używane na stronie sieci Web, chyba że `retail` atrybutu [wdrożenia](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) element konfiguracji jest ustawiony na wartość `false`.|  
  
> [!NOTE]
>  `debug` Atrybutu [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) dyrektywy nie wpływa na aplikacje ASP.NET z włączoną obsługą technologii Ajax. <xref:System.Web.UI.ScriptManager> Kontroli używa tylko ustawienia w pliku Web.config, a w jego <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> i <xref:System.Web.UI.ScriptManager.ScriptMode%2A> właściwości w celu określenia, czy do renderowania debugowania skryptów.  
  
 Aby uzyskać więcej informacji, zobacz [debugowanie i śledzenie Ajax aplikacji — omówienie](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Web.UI.ScriptManager.ScriptMode" /> Właściwość nie jest jednym z <see cref="T:System.Web.UI.ScriptMode" /> wartości.</exception>
        <altmember cref="T:System.Web.UI.ScriptMode" />
      </Docs>
    </Member>
    <Member MemberName="ScriptPath">
      <MemberSignature Language="C#" Value="public string ScriptPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScriptPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptPath" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ScriptPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptPath : string with get, set" Usage="System.Web.UI.ScriptManager.ScriptPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This property is obsolete. Set the Path property on each individual ScriptReference instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę katalogu głównego lokalizacji, w której jest używany do tworzenia ścieżek do plików skryptu niestandardowego i ASP.NET Ajax.</summary>
        <value>Lokalizacja, w którym są przechowywane pliki skryptów. Wartość domyślna to ciąg pusty (""), który jest interpretowany jako ścieżka względna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> Właściwości można określić bezwzględną względną lub względnego URL aplikacji dla wszystkich skryptów blokuje się na stronie. Obejmuje to bloków skryptów niestandardowych i innych firm, które zostały zarejestrowane przy użyciu bieżącego <xref:System.Web.UI.ScriptManager> wystąpienia. <xref:System.Web.UI.ScriptManager.ScriptPath%2A> Właściwość jest zwykle ustawiana jako atrybut deklaratywne `ScriptManager` elementu na stronie, ale można ustawić w kodzie również.  
  
 Jeśli `path` atrybutu lub <xref:System.Web.UI.ScriptReferenceBase.Path%2A> właściwość jest ustawiona dla <xref:System.Web.UI.ScriptReference> obiektu <xref:System.Web.UI.ScriptManager.Scripts%2A> zastępuje wartość ścieżki w kolekcji, <xref:System.Web.UI.ScriptManager.ScriptPath%2A> wartość, która <xref:System.Web.UI.ScriptReference> wystąpienia.  
  
 Jeśli nie <xref:System.Web.UI.ScriptReferenceBase.Path%2A> wartość jest określona, <xref:System.Web.UI.ScriptManager> kontroli wyszukuje w katalogu, który jest definiowany przez <xref:System.Web.UI.ScriptManager.ScriptPath%2A> odwołuje się do właściwości i rozwiązuje skryptu przez ich <xref:System.Web.UI.ScriptReference.Name%2A> lub <xref:System.Web.UI.ScriptReference.Assembly%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptResourceMapping">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptResourceMapping ScriptResourceMapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.UI.ScriptResourceMapping ScriptResourceMapping" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScriptResourceMapping As ScriptResourceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::UI::ScriptResourceMapping ^ ScriptResourceMapping { System::Web::UI::ScriptResourceMapping ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScriptResourceMapping : System.Web.UI.ScriptResourceMapping" Usage="System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptResourceMapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.UI.ScriptResourceMapping" /> obiektu.</summary>
        <value>Element <see cref="T:System.Web.UI.ScriptResourceMapping" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statyczne <xref:System.Web.UI.ScriptManager.ScriptResourceMapping%2A> właściwość zwraca <xref:System.Web.UI.ScriptResourceMapping> obiekt, który może zawierać zbiór mapowania, które reprezentują lokalizację zasobu skryptu (przekierowywanie skryptu). Ten zbiór mapowania mogą być mapowane na podstawie nazwy lub par nazwa/zestawu i może wskazywać <xref:System.Web.UI.ScriptResourceDefinition> obiektu.  
  
   
  
## Examples  
 Następujące przykłady przedstawiają sposób dodawania <xref:System.Web.UI.ScriptResourceDefinition> obiektów, które mogą być przywoływane przez <xref:System.Web.UI.ScriptManager> obiektu. Dodaj następujący kod do pliku Global.asax `Application_Start` zdarzeń.  
  
```csharp  
ScriptResourceDefinition myScriptResDef = new ScriptResourceDefinition();  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js";  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js";  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js";  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js";  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", null, myScriptResDef);  
```  
  
```vb  
Dim myScriptResDef As New ScriptResourceDefinition()  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js"  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js"  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js"  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js"  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", Nothing, myScriptResDef)  
```  
  
 W znaczniku strony formularzy sieci Web ASP.NET (pliku aspx), Dodaj następujący kod wewnątrz `form` elementu i przed wszystkie elementy lub kod, który używa skryptów jQuery.  
  
```  
<asp:ScriptManager ID="sm1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="jquery"/>  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scripts">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptReferenceCollection Scripts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ScriptReferenceCollection Scripts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Scripts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scripts As ScriptReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptReferenceCollection ^ Scripts { System::Web::UI::ScriptReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scripts : System.Web.UI.ScriptReferenceCollection" Usage="System.Web.UI.ScriptManager.Scripts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.UI.ScriptReferenceCollection" /> obiekt, który zawiera <see cref="T:System.Web.UI.ScriptReference" /> obiektów, z których każdy reprezentuje plik skryptu renderowane do klienta.</summary>
        <value><see cref="T:System.Web.UI.ScriptReferenceCollection" /> Obiektu <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptReferenceCollection> Obiektu, który jest zwracany przez właściwość ta jest kolekcją <xref:System.Web.UI.ScriptReference> obiektów, z których każdy reprezentuje plik skryptu. Kolekcja zawiera odwołania do wszystkich plików skryptów, których potrzebuje, platformy ASP.NET dla funkcji interfejsu Ajax, a do plików skryptu niestandardowego. Pliki skryptu niestandardowego do renderowania można zdefiniować w <xref:System.Web.UI.ScriptManager> kontroli lub skojarzoną <xref:System.Web.UI.ScriptManagerProxy> kontroli.  
  
 Pliki skryptów można dodać do kolekcji w znaczniku, dodając `asp:ScriptReference` elementów `Scripts` węźle `asp:ScriptManager` elementu na stronie, jak pokazano w poniższym przykładzie.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="Script.js" />  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 Można również dodać <xref:System.Web.UI.ScriptReference> obiekt <xref:System.Web.UI.ScriptManager.Scripts%2A> kolekcji programowo przy użyciu <xref:System.Collections.ObjectModel.Collection%601.Add%2A> metody <xref:System.Web.UI.ScriptReferenceCollection> klasy.  
  
 <xref:System.Web.UI.ScriptManager> Kontroli rejestruje pliki skryptów podczas kontroli <xref:System.Web.UI.Control.PreRender> zdarzeń.  
  
 <xref:System.Web.UI.ScriptManager.Scripts%2A> Kolekcja nie zawiera skryptów Microsoft Ajax Library core. Skrypty w podstawowej biblioteki — zostaną zrenderowane automatycznie. nie muszą być zarejestrowane przy użyciu <xref:System.Web.UI.ScriptManager> kontroli. Jednak jeśli chcesz przesłonić skryptu core lub dowolny skrypt kontroli i zastąpić inną wersję skryptu, można dodać wersji tak, aby <xref:System.Web.UI.ScriptManager.Scripts%2A> kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Services">
      <MemberSignature Language="C#" Value="public System.Web.UI.ServiceReferenceCollection Services { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ServiceReferenceCollection Services" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Services" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Services As ServiceReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ServiceReferenceCollection ^ Services { System::Web::UI::ServiceReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Services : System.Web.UI.ServiceReferenceCollection" Usage="System.Web.UI.ScriptManager.Services" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.ServiceReferenceCollectionEditor, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ServiceReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.UI.ServiceReferenceCollection" /> obiekt, który zawiera <see cref="T:System.Web.UI.ServiceReference" /> obiektu dla poszczególnych usług sieci Web, który ASP.NET udostępnia na kliencie dla funkcjonalności interfejsu Ajax.</summary>
        <value><see cref="T:System.Web.UI.ServiceReferenceCollection" /> Obiektu dla bieżącego <see cref="T:System.Web.UI.ScriptManager" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ServiceReferenceCollection> Obiektu, który jest zwracany przez właściwość ta jest kolekcją <xref:System.Web.UI.ServiceReference> obiektów, z których każdy reprezentuje usługi sieci Web, który jest zarejestrowany <xref:System.Web.UI.ScriptManager> kontroli. Można zdefiniować usług w <xref:System.Web.UI.ScriptManager> kontroli lub skojarzoną <xref:System.Web.UI.ScriptManagerProxy> kontroli.  
  
 Można dodać usługi do kolekcji w znaczniku, dodając `asp:ServiceReference` elementu `Services` element wewnątrz `asp:ScriptManager` wystąpienia na stronie, jak pokazano w poniższym przykładzie.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Services>  
    <asp:ServiceReference Path="Service.asmx" />  
  </Services>  
</asp:ScriptManager>  
```  
  
 Możesz też programowo dodać <xref:System.Web.UI.ServiceReference> obiekt <xref:System.Web.UI.ScriptManager.Services%2A> kolekcji przy użyciu <xref:System.Collections.ObjectModel.Collection%601.Add%2A> metody <xref:System.Web.UI.ServiceReferenceCollection> klasy.  
  
 Usługi są zarejestrowane w usłudze <xref:System.Web.UI.ScriptManager> podczas strony <xref:System.Web.UI.Control.PreRender> etap cyklu życia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia fokus przeglądarki określoną kontrolkę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="scriptManager.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">Identyfikator kontrolki, aby przenieść fokus.</param>
        <summary>Ustawia fokus przeglądarki do kontroli, określonego przez identyfikator.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.SetFocus%2A> Metoda działa jak <xref:System.Web.UI.Page.SetFocus%2A> metodę <xref:System.Web.UI.Page> klasy. Obie metody należy formantu o określonym identyfikatorze aktywny formant na stronie sieci Web. <xref:System.Web.UI.ScriptManager.SetFocus%2A> Metody <xref:System.Web.UI.ScriptManager> klasa jest używana do ustawiania fokus podczas odświeżania asynchronicznego. Podczas ogłaszania zwrotnego i po raz pierwszy wyrenderowaniu strony <xref:System.Web.UI.ScriptManager.SetFocus%2A> wywołania metody <xref:System.Web.UI.Page.SetFocus%2A> metody <xref:System.Web.UI.Page> klasy.  
  
 W przypadku wielu wywołań <xref:System.Web.UI.ScriptManager.SetFocus%2A> formantu w ostatnim wywołaniu metody zostanie ustawiony fokus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.String)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="scriptManager.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Formant, aby przenieść fokus.</param>
        <summary>Ustawia fokus przeglądarki określoną kontrolkę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.SetFocus%2A> Metoda działa jak <xref:System.Web.UI.Page.SetFocus%2A> metodę <xref:System.Web.UI.Page> klasy. Obie metody należy określoną kontrolkę aktywny formant na stronie sieci Web. <xref:System.Web.UI.ScriptManager.SetFocus%2A> Metody <xref:System.Web.UI.ScriptManager> klasa jest używana do ustawiania fokus podczas odświeżania asynchronicznego. Podczas ogłaszania zwrotnego i po raz pierwszy wyrenderowaniu strony <xref:System.Web.UI.ScriptManager.SetFocus%2A> wywołania metody <xref:System.Web.UI.Page.SetFocus%2A> metody <xref:System.Web.UI.Page> klasy.  
  
 W przypadku wielu wywołań <xref:System.Web.UI.ScriptManager.SetFocus%2A> kontroli określone w ostatnim wywołaniu metody zostanie ustawiony fokus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SupportsPartialRendering">
      <MemberSignature Language="C#" Value="public bool SupportsPartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsPartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property SupportsPartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsPartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SupportsPartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy klient obsługuje częściowe renderowanie strony.</summary>
        <value><see langword="true" /> Jeśli klient obsługuje częściowe renderowanie strony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> właściwość jest ustawiona na `false`, <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> właściwość zwraca `false`.  
  
 Zwraca sprawdzania domyślnej, aby ustalić, czy obsługiwane jest częściowe renderowanie strony `true` gdy są spełnione następujące warunki:  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.W3CDomVersion%2A> Wartość właściwości musi być większa lub równa 1.0.  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.EcmaScriptVersion%2A> Wartość właściwości musi być większa lub równa 1.0.  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> Musi być równa wartości właściwości `true`.  
  
 Gdy <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> właściwość jest jawnie ustawiona, te testy nie są używane.  
  
 Należy używać kontroli deweloperów <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> właściwości w celu określenia, czy powinien obsługiwać się częściowe renderowanie strony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> Właściwość <see langword="false" /> i <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> właściwość <see langword="true" />.  
  
—lub— 
<see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> Właściwość została ustawiona po <see cref="E:System.Web.UI.Control.Init" /> zdarzeń.</exception>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.LoadPostData">
      <MemberSignature Language="C#" Value="bool IPostBackDataHandler.LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Web.UI.IPostBackDataHandler.LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean Implements IPostBackDataHandler.LoadPostData" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Web.UI.IPostBackDataHandler.LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection) = System::Web::UI::IPostBackDataHandler::LoadPostData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">— Identyfikator klucza dla formantu.</param>
        <param name="postCollection">Kolekcja wszystkich przychodzących danych post.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Web.UI.ScriptManager" /> stan formantu został zmieniony w wyniku zwrotu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Web.UI.ScriptManager> wystąpienia jest rzutowany na <xref:System.Web.UI.IPostBackDataHandler> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="void IPostBackDataHandler.RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostDataChangedEvent () Implements IPostBackDataHandler.RaisePostDataChangedEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() = System::Web::UI::IPostBackDataHandler::RaisePostDataChangedEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Web.UI.ScriptManager> wystąpienia jest rzutowany na <xref:System.Web.UI.IPostBackDataHandler> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackEventHandler.RaisePostBackEvent">
      <MemberSignature Language="C#" Value="void IPostBackEventHandler.RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackEventHandler#RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostBackEvent (eventArgument As String) Implements IPostBackEventHandler.RaisePostBackEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System::String ^ eventArgument) = System::Web::UI::IPostBackEventHandler::RaisePostBackEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">Ciąg par klucz/wartość, które reprezentują stan historii strony sieci Web.</param>
        <summary>Włącza <see cref="T:System.Web.UI.ScriptManager" /> formant, aby przetworzyć zdarzenie ogłaszania wstecznego i ładowania stanu historii strony sieci Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.IsSecureConnection">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IScriptManager.IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSecureConnection As Boolean Implements IScriptManager.IsSecureConnection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IScriptManager::IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsSecureConnection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue) = System::Web::UI::IScriptManager::RegisterArrayDeclaration;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="arrayName">To be added.</param>
        <param name="arrayValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterClientScriptBlock;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url) = System::Web::UI::IScriptManager::RegisterClientScriptInclude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="url">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName) = System::Web::UI::IScriptManager::RegisterClientScriptResource;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="resourceName">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterDispose">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript) = System::Web::UI::IScriptManager::RegisterDispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterDispose(System.Web.UI.Control,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="disposeScript">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode) = System::Web::UI::IScriptManager::RegisterExpandoAttribute;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="controlId">To be added.</param>
        <param name="attributeName">To be added.</param>
        <param name="attributeValue">To be added.</param>
        <param name="encode">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterHiddenField">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldValue) = System::Web::UI::IScriptManager::RegisterHiddenField;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="hiddenFieldName">To be added.</param>
        <param name="hiddenFieldValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script) = System::Web::UI::IScriptManager::RegisterOnSubmitStatement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterPostBackControl">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterPostBackControl(System::Web::UI::Control ^ control) = System::Web::UI::IScriptManager::RegisterPostBackControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterStartupScript">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterStartupScript;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.SetFocusInternal">
      <MemberSignature Language="C#" Value="void IScriptManager.SetFocusInternal (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.SetFocusInternal(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#SetFocusInternal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetFocusInternal (clientID As String) Implements IScriptManager.SetFocusInternal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.SetFocusInternal(System::String ^ clientID) = System::Web::UI::IScriptManager::SetFocusInternal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.SetFocusInternal(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.ScriptManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje <see cref="P:System.Web.UI.Control.Visible" /> właściwość, która jest dziedziczona z podstawy <see cref="T:System.Web.UI.Control" /> klasy, aby uniemożliwić ustawienie tej wartości.</summary>
        <value><see langword="true" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.Visible%2A> Właściwość nie zostanie zastąpiona w <xref:System.Web.UI.ScriptManager> klasy, aby uniemożliwić ustawienie tej wartości. A <xref:System.NotImplementedException> wystąpi błąd, jeśli wartość jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Wartość jest przypisywana do <see cref="P:System.Web.UI.ScriptManager.Visible" /> właściwości.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
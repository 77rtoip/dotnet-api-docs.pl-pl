<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b0374cee2ad12d253ad5ccca07e17fd0740a95ad" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39868088" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia <see cref="T:Microsoft.Win32.RegistryKey" /> obiekty reprezentujące klucze główne w rejestrze systemu Windows, a <see langword="static" /> metodach dostępu pary klucz/wartość.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa udostępnia zestaw standardowych głównego kluczy znaleziony w rejestrze na komputerach z systemem Windows. Rejestr jest składowania, aby uzyskać informacje o aplikacji, użytkowników i ustawienia domyślne systemu. Aplikacje można na przykład za pomocą rejestru do przechowywania informacji, który ma być zachowywane po zamknięciu aplikacji i dostęp do tych samych informacji po załadowaniu aplikacji. Na przykład można przechowywać preferencji koloru, lokalizacje ekranu lub rozmiar okna. Te dane dla każdego użytkownika można kontrolować, umieszczając je w innej lokalizacji w rejestrze.  
  
 Podstawowy lub główny <xref:Microsoft.Win32.RegistryKey> wystąpień, które są dostępne w `Registry` klasy odróżnić przy użyciu magazynu podstawowego mechanizmu podklucze i wartości rejestru. Wszystkie klucze są tylko do odczytu, ponieważ rejestr zależy od ich istnienia. Klucze udostępnianych przez `Registry` są:  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Przechowuje informacje o preferencji użytkownika.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Przechowuje informacje o konfiguracji dla komputera lokalnego.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Przechowuje informacje o typach (i klasy) i ich właściwości.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Przechowuje informacje o domyślnej konfiguracji użytkownika.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Przechowuje informacje o wydajności dla składników oprogramowania.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Przechowuje informacje o sprzęcie bez określonego użytkownika.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Przechowuje dane dynamiczne.  
  
 Po zidentyfikowaniu klucz główny, w którym chcesz przechowywania/pobierania informacji z rejestru, można użyć <xref:Microsoft.Win32.RegistryKey> klasy, aby dodać lub usunąć podkluczy i manipulować wartościami dla danego klucza.  
  
 Urządzenia można umieścić informacje w rejestrze automatycznie przy użyciu interfejsu typu Plug and Play. Oprogramowanie instalowanie sterowników urządzeń można umieścić informacje w rejestrze, zapisując standardowych interfejsów API.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Metody statyczne służące do pobierania i ustawiania wartości  
 W .NET Framework w wersji 2.0 <xref:Microsoft.Win32.Registry> klasa zawiera także `static` <xref:Microsoft.Win32.Registry.GetValue%2A> i <xref:Microsoft.Win32.Registry.SetValue%2A> metody do ustawiania i pobierania wartości z kluczami rejestru. Te metody Otwórz i zamknij klucze każdego czasu są używane, więc nie zostanie wykonana, jak również metody analogiczne w <xref:Microsoft.Win32.RegistryKey> klasy, gdy uzyskujesz dostęp do dużej liczby wartości.  
  
 <xref:Microsoft.Win32.RegistryKey> Klasa udostępnia także metody, które umożliwiają ustawienie Windows kontrolę dostępu do kluczy rejestru, test typ danych wartości przed ich pobraniem i usuń klucze.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. W pierwszym przykładzie pokazano klucze główne, a w drugim przykładzie zademonstrowano `static` <xref:Microsoft.Win32.Registry.GetValue%2A> i <xref:Microsoft.Win32.Registry.SetValue%2A> metody.  
  
 Przykład 1  
  
 Poniższy przykład kodu demonstruje sposób pobierania podkluczy klucza HKEY_USERS i Drukuj ich nazwy na ekranie. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę, aby utworzyć wystąpienie określonego podklucza zainteresowania. Następnie można użyć innych operacji w `RegistryKey` do manipulowania tego klucza.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu zapisuje wartości kilku typów danych, w przykładowym kluczem tworzenia klucza, jak robi to tak, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania pary (pustego) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiuje typy (lub klasy) dokumenty i właściwości skojarzone z tych typów. To pole ma wartość klucza podstawowego HKEY_CLASSES_ROOT rejestru Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje są konwencjonalne funkcje i aplikacje OLE należy użyć danych przechowywanych w ramach tego klucza. Ten klucz także zgodności z poprzednimi wersjami z bazy danych rejestracji Windows 3.1, przechowując informacje dotyczące obsługi DDE i OLE. Przeglądarki plików i rozszerzenia interfejsu użytkownika są przechowywane ich identyfikatorów klasy OLE w ten klucz, a serwery przetwarzania są rejestrowane w tego klucza.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać klucze podrzędne tego klucza i wyświetla ich nazwy na ekranie. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę, aby utworzyć wystąpienie określonego podklucza zainteresowania. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do manipulowania tego klucza.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera informacje o konfiguracji dotyczące sprzętu, który nie jest specyficzne dla użytkownika. To pole ma wartość klucza podstawowego rejestru HKEY_CURRENT_USER Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski jest mapowany do podklucza w ramach <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Przykład użycia tego elementu członkowskiego jest aplikacja, która przechowuje inną nazwę serwera dla swoich danych w zależności od tego, czy system jest dołączony do sieci.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać klucze podrzędne tego klucza i wyświetla ich nazwy na ekranie. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę, aby utworzyć wystąpienie określonego podklucza zainteresowania. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do manipulowania tego klucza.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera informacje o bieżącym preferencji użytkownika. To pole ma wartość klucza podstawowego rejestru HKEY_CURRENT_USER Windows</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje przechowywane w tym kluczu obejmuje ustawienia zmiennych środowiskowych i dane dotyczące grupy programów, kolory, drukarki, połączenia sieciowe i preferencje. Ten klucz ułatwia ustalenie ustawień bieżącego użytkownika. W tym kluczu dostawców oprogramowania przechowywać bieżące preferencje specyficzne dla użytkownika do użycia w aplikacjach. Microsoft, na przykład tworzy klucz HKEY_CURRENT_USER\Software\Microsoft dla swojej aplikacji za pomocą, każdej aplikacji, tworząc własne podklucz w kluczu firmy Microsoft.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać klucze podrzędne tego klucza i wyświetla ich nazwy na ekranie. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę, aby utworzyć wystąpienie określonego podklucza zainteresowania. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do manipulowania tego klucza.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera dane dynamiczne rejestru. To pole ma wartość klucza podstawowego HKEY_DYN_DATA rejestru Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rejestr Windows 98/Windows Me obsługuje zarówno dane statyczne, (które są przechowywane na dysku w rejestrze), jak i dane dynamiczne, (który zmienia się często, takich jak statystyki wydajności). Ten obszar danych dynamicznych jest mechanizm, który umożliwia sterowniki urządzeń wirtualnych urządzenia (vxd) do dostarczania danych w czasie rzeczywistym do aplikacji Win32, które mogą być uruchamiane zdalnie, a także lokalnie. Umożliwia także Monitora systemu, aby zapewnić statystyk wydajności Windows 98/Windows Me systemów zdalnych.  
  
 Urządzenia vxd nie są ograniczone do danych dotyczących wydajności. Zapewniają one wszystkich danych, które mają być przekazać z pierścień 0 do 3 pierścień efektywnie bez monopolizowaniu przez procesor CPU. Rejestr obsługuje dane dynamiczne, umieszczając wskaźnik do funkcji, która zwraca wartość (lub wiele wartości). Kiedy wartości rejestru wywołanie zapytania skojarzoną z kluczem dynamiczne, że funkcja jest wywoływana w celu zwrócenia żądaną wartość lub wartości.  
  
> [!NOTE]
>  Dynamiczne klucze zostały wprowadzone w systemie Microsoft Windows 95 do obsługi danych rejestru dynamicznych. Są one obsługiwane tylko w Windows 98/Windows Me.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać klucze podrzędne tego klucza i wyświetla ich nazwy na ekranie. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę, aby utworzyć wystąpienie określonego podklucza zainteresowania. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do manipulowania tego klucza. Należy pamiętać, że w tym przykładzie można zwracała żadnych wyników, ponieważ nie może być dane dynamiczne dostępne lub nie może działać Windows 98 / usługę. Przy użyciu tego klucza może spowodować wystąpienie błędu w innych systemach.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">System operacyjny nie obsługuje dane dynamiczne; oznacza to, że nie jest Windows 98, Windows 98 Wydanie drugie lub Windows Millennium Edition (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Ścieżka rejestru pełną klucza, począwszy od katalogu głównego rejestru prawidłową, takie jak "HKEY_CURRENT_USER".</param>
        <param name="valueName">Nazwa pary nazwa/wartość.</param>
        <param name="defaultValue">Wartość zwracana, jeśli <c>valueName</c> nie istnieje.</param>
        <summary>Pobiera wartość skojarzoną z określoną nazwą, w określonym kluczu rejestru. Jeśli nazwa nie zostanie znaleziony w określonym kluczu, zwraca wartość domyślną, który podasz, lub <see langword="null" /> Jeśli określony klucz nie istnieje.</summary>
        <returns>
          <see langword="null" /> Jeśli podklucza który jest określony przez <paramref name="keyName" /> nie istnieje; w przeciwnym razie wartość skojarzonych z <paramref name="valueName" />, lub <paramref name="defaultValue" /> Jeśli <paramref name="valueName" /> nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg `valueName` nie jest rozróżniana wielkość liter.  
  
> [!NOTE]
>  Klucz rejestru może zawierać jedną wartość, która nie jest skojarzona z żadną nazwą. Gdy ta nienazwana wartość jest wyświetlana w Edytorze rejestru, zamiast nazwy pojawia się ciąg „(Domyślna)”. Aby pobrać, ta Nienazwana wartość, określ `null` lub pustym ciągiem ("") dla `valuName`.  
  
 Nazwy główne są HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_USER i HKEY_DYN_DATA. Na przykład w języku Visual Basic ciąg "HKEY_CURRENT_USER\MyTestKey" uzyskuje dostęp do pary klucz/wartość podklucza "MyTestKey", która znajduje się w katalogu głównym HKEY_CURRENT_USER.  
  
 Gdy <xref:Microsoft.Win32.RegistryKey.GetValue%2A> metoda pobiera wartości ciągu rozwijalnego (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), rozszerza on zmiennych środowiskowych przy użyciu danych ze środowiska lokalnego. Jeśli wartość zawierającą rozwijania odwołaniami do zmiennych środowiskowych zostały zapisane jako ciąg (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), a nie jako ciągu rozwijalnego (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> nie jest powiększony. Po pobraniu przez wywołanie metody, można rozwinąć taki ciąg <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Zalecanym sposobem pobierania danych z HKEY_PERFORMANCE_DATA jest użycie <xref:System.Diagnostics.PerformanceCounter> klasy zamiast <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> metody.  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A> i <xref:Microsoft.Win32.Registry.SetValue%2A> metod Otwórz i zamknij klucze każdorazowo, są one używane, więc nie należy wykonywać, a także metody <xref:Microsoft.Win32.RegistryKey> klasy, jeśli masz dostępu do dużej liczby wartości.  
  
 <xref:Microsoft.Win32.RegistryKey> zapewnia także metody, które pozwalają na dodawanie listy kontroli dostępu (ACL) w kluczu rejestru, test typ danych wartości przed ich pobraniem i usuń klucze.  
  
   
  
## Examples  
 Poniższy przykład kodu zapisuje wartości kilku typów danych, w przykładowym kluczem tworzenia klucza, jak robi to tak, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania pary (pustego) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie posiada uprawnień niezbędnych do czytania treści klucza rejestru.</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> Zawierający podaną wartość został oznaczony do usunięcia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> nie zaczyna się od katalogu głównego rejestru prawidłowe.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Odczytywanie zawartości rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">można odczytać klucza rejestru REG_EXPAND_SZ typu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera dane konfiguracyjne dla komputera lokalnego. To pole ma wartość klucza podstawowego rejestru HKEY_LOCAL_MACHINE Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` zawiera pięć kluczy:  
  
 Sprzęt  
 Opisuje sprzęt fizyczny do komputera, sposób sterowniki urządzeń Użyj tego sprzętu i mapowania i powiązanych danych, która łączy sterowników trybu jądra za pomocą kodu w trybie użytkownika. Wszystkie dane w tym kluczu zostaje odtworzone w każdym razem, gdy system jest uruchomiona. Podklucz opis opisuje sprzęt rzeczywisty komputer. Podklucz DeviceMap zawiera różne dane w formatach specyficzne dla poszczególnych klas sterowników. Podklucz ResourceMap opisuje sterowników urządzeń oświadczenia, które zasoby sprzętowe. Program Diagnostyka systemu Windows NT (Winmsdp.exe) można raport na temat jego zawartości w formie łatwych do zrozumienia.  
  
 SAM  
 Usług katalogowych, informacje o zabezpieczeniach dla kont użytkowników i grup i domen w systemie Windows 2000 Server (Menedżera kont zabezpieczeń znany jako baza danych usług katalogowych jest SAM).  
  
 Zabezpieczenia  
 Zawiera zasady zabezpieczeń lokalnych, takich jak prawo określonego użytkownika. Ten klucz jest używany tylko przez podsystem zabezpieczeń Windows 2000.  
  
 Oprogramowanie  
 Baza danych oprogramowania na komputerze. Ten klucz zawiera dane o oprogramowanie zainstalowane na komputerze lokalnym, oraz różne elementy danych o różnych konfiguracji.  
  
 System  
 Uruchamianie systemu kontroli, ładowanie sterownika urządzenia, usługi Windows 2000 i zachowania systemu operacyjnego.  
  
 Zgodnie z Konwencją, jeśli istnieje podobne dane, w ramach <xref:Microsoft.Win32.Registry.CurrentUser> i w obszarze <xref:Microsoft.Win32.Registry.LocalMachine>, dane w <xref:Microsoft.Win32.Registry.CurrentUser> ma pierwszeństwo. Jednak wartości tego klucza można również rozszerzyć (a nie zastąpić) danych w Registry.LocalMachine. Ta nie ma znaczenia, jeśli występują one poza Registry.LocalMachine są także niektóre elementy (np. Ładowanie wpisów sterownika urządzenia).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać klucze podrzędne tego klucza i wyświetla ich nazwy na ekranie. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę, aby utworzyć wystąpienie określonego podklucza zainteresowania. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do manipulowania tego klucza.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera informacje o wydajności dla składników oprogramowania. To pole ma wartość klucza podstawowego HKEY_PERFORMANCE_DATA rejestru Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy składnik oprogramowania tworzy klucze dla jej obiektów liczników, gdy jest zainstalowany i zapisuje dane liczników, podczas jego wykonywania. Ponieważ dostęp do wszelkich innych danych rejestru za pomocą można dostęp do tych danych <xref:Microsoft.Win32.RegistryKey> funkcji.  
  
 Mimo że używasz rejestru do zbierania danych dotyczących wydajności, dane nie są przechowywane w bazie danych rejestru. Zamiast tego dostępu do rejestru przy użyciu tego klucza sprawia, że system zbierania danych z odpowiednim systemem menedżerów obiektu.  
  
 Aby uzyskać dane dotyczące wydajności z systemu lokalnego, należy użyć <xref:Microsoft.Win32.RegistryKey.GetValue%2A> metody, przy użyciu klucza Registry.PerformanceData. Pierwsze wywołanie zostanie otwarty klawisza (nie trzeba jawnie najpierw otworzyć klucza). Jednakże, należy użyć <xref:Microsoft.Win32.RegistryKey.Close%2A> metodę, aby zamknąć dojście do klucza, po zakończeniu, uzyskiwanie danych dotyczących wydajności. Użytkownik nie może zainstalować lub usunąć składnik oprogramowania, gdy swoje dane o wydajności jest w użyciu.  
  
 Aby uzyskać dane dotyczące wydajności z systemu zdalnego, należy użyć <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> metoda nazwą komputera w systemie zdalnym i klucza Registry.PerformanceData. To wywołanie pobiera klucz reprezentujący dane wydajności systemu zdalnego. Aby pobrać dane, należy wywołać <xref:Microsoft.Win32.RegistryKey.GetValue%2A> przy użyciu tego klucza, a nie klucza Registry.PerformanceData.  
  
> [!NOTE]
>  W systemie Windows Server 2003 użytkownik co najmniej musi należeć do grupy Użytkownicy monitora wydajności Aby uzyskać dostęp do podkluczy klucza podstawowego.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać klucze podrzędne tego klucza i wyświetla ich nazwy na ekranie. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę, aby utworzyć wystąpienie określonego podklucza zainteresowania. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do manipulowania tego klucza. Należy pamiętać, że w tym przykładzie można często nie zwracała żadnych wyników, ponieważ mogą istnieć żadne dane wydajności.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia wartość pary nazwa/wartość w kluczu rejestru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu zapisuje wartości kilku typów danych, w przykładowym kluczem tworzenia klucza, jak robi to tak, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania pary (pustego) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Ścieżka rejestru pełną klucza, począwszy od katalogu głównego rejestru prawidłową, takie jak "HKEY_CURRENT_USER".</param>
        <param name="valueName">Nazwa pary nazwa/wartość.</param>
        <param name="value">Wartość, która ma być przechowywany.</param>
        <summary>Ustawia pary nazwa/wartość określona dla wskazanego klucza rejestru. Jeśli określony klucz nie istnieje, zostanie utworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], `valueName` parametr nie jest już ograniczona do maksymalnie 255 znaków; jednak `keyName` parametru w dalszym ciągu ma ograniczenie 255 znaków.  
  
 Ponieważ wiele wartości mogą być przechowywane w każdym klucz rejestru, należy użyć `valueName` parametru do określenia określoną wartość, której chcesz ustawić.  
  
> [!NOTE]
>  Klucz rejestru może zawierać jedną wartość, która nie jest skojarzona z żadną nazwą. Gdy ta nienazwana wartość jest wyświetlana w Edytorze rejestru, zamiast nazwy pojawia się ciąg „(Domyślna)”. Aby ustawić ta Nienazwana wartość, określ `null` lub pustym ciągiem ("") dla `valueName`.  
  
 Jeśli `valueName` nie istnieje w kluczu jest utworzona i skojarzona wartość jest równa `value`.  
  
 Jeśli `keyName` określa podklucza, który nie istnieje, podklucza który zostanie utworzony w określonym katalogu głównym. Na przykład w języku Visual Basic ciąg "HKEY_CURRENT_USER\MyTestKey" tworzy podklucz "MyTestKey" w katalogu głównym HKEY_CURRENT_USER. Ciąg "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" tworzy zagnieżdżone podklucze "MyTestKey", "MyTestKey\Key2" i "MyTestKey\Key2\Key3".  
  
 Nazwy główne obejmują HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_USER i HKEY_DYN_DATA.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> Metoda otwiera klucz rejestru, ustawia wartość i zamyka klucz każdym razem jest wywoływana. Jeśli trzeba zmodyfikować dużą liczbę wartości, <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> metoda może zapewnić lepszą wydajność. <xref:Microsoft.Win32.RegistryKey> Klasa udostępnia także metody, które umożliwiają dodanie listy kontroli dostępu (ACL) w kluczu rejestru, test typ danych wartości przed ich pobraniem i usuń klucze.  
  
 To przeciążenie <xref:Microsoft.Win32.Registry.SetValue%2A> przechowuje 64-bitowych liczb całkowitych jako ciągi (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Do przechowywania 64-bitowymi liczbami jako <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> wartości, należy użyć <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> przeciążenie metody.  
  
 To przeciążenie <xref:Microsoft.Win32.Registry.SetValue%2A> przechowuje wszystkie ciągi jako <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> obiektów, nawet jeśli zawierają one rozwijania odwołaniami do zmiennych środowiskowych. Można zapisać wartości ciągu rozwijalnego jako ciągi (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), użyj <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> przeciążenie metody.  
  
 To przeciążenie jest równoważne z wywoływaniem <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> przeciążenie metody z <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Windows 98 i Windows Millennium Edition (Windows Me) rejestru nie jest Unicode, a nie wszystkie znaki Unicode są prawidłowe dla wszystkich stron kodowych. Znak Unicode, który jest nieprawidłowy dla bieżącej strony kodowej został zastąpiony najlepsze dopasowanie. Jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu zapisuje wartości kilku typów danych, w przykładowym kluczem tworzenia klucza, jak robi to tak, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania pary (pustego) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> nie zaczyna się od katalogu głównego rejestru prawidłowe.  - lub - <paramref name="keyName" /> przekracza maksymalną dozwoloną długość (255 znaków).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> Jest tylko do odczytu i w związku z tym nie można zapisać do, na przykład jest to węzeł poziomu głównego.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wymaganych uprawnień do tworzenia lub modyfikowania kluczy rejestru.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">do modyfikowania wskazanego klucza rejestru, jeśli istnieje, lub utworzenie klucza rejestru, jeśli jeszcze nie istnieje. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName">Ścieżka rejestru pełną klucza, począwszy od katalogu głównego rejestru prawidłową, takie jak "HKEY_CURRENT_USER".</param>
        <param name="valueName">Nazwa pary nazwa/wartość.</param>
        <param name="value">Wartość, która ma być przechowywany.</param>
        <param name="valueKind">Typ danych rejestru do użycia podczas zapisywania danych.</param>
        <summary>Ustawia pary nazwa/wartość dla określonego klucza rejestru, używając typu danych określonego rejestru. Jeśli określony klucz nie istnieje, zostanie utworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], `valueName` parametr nie jest już ograniczona do maksymalnie 255 znaków; jednak `keyName` parametr nadal ma ograniczenie 255 znaków.  
  
 Ponieważ wiele wartości mogą być przechowywane w każdym klucz rejestru, należy użyć `valueName` parametru do określenia określoną wartość, której chcesz ustawić.  
  
> [!NOTE]
>  Klucz rejestru może zawierać jedną wartość, która nie jest skojarzona z żadną nazwą. Gdy ta nienazwana wartość jest wyświetlana w Edytorze rejestru, zamiast nazwy pojawia się ciąg „(Domyślna)”. Aby ustawić ta Nienazwana wartość, określ `null` lub pustym ciągiem ("") dla `valueName`.  
  
 Jeśli `valueName` nie istnieje w kluczu jest utworzona i skojarzona wartość jest równa `value`.  
  
 Jeśli `keyName` określa podklucza, który nie istnieje, podklucza który zostanie utworzony w określonym katalogu głównym. Na przykład w języku Visual Basic ciąg "HKEY_CURRENT_USER\MyTestKey" tworzy podklucz "MyTestKey" w katalogu głównym HKEY_CURRENT_USER. Ciąg "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" tworzy zagnieżdżone podklucze "MyTestKey", "MyTestKey\Key2" i "MyTestKey\Key2\Key3".  
  
 Nazwy główne obejmują HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_USER i HKEY_DYN_DATA.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> Metoda otwiera klucz rejestru, ustawia wartość i zamyka klucz każdym razem jest wywoływana. Jeśli trzeba zmodyfikować dużą liczbę wartości, <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> metoda może zapewnić lepszą wydajność. <xref:Microsoft.Win32.RegistryKey> Klasa udostępnia także metody, które umożliwiają dodanie listy kontroli dostępu (ACL) w kluczu rejestru, test typ danych wartości przed ich pobraniem i usuń klucze.  
  
 Jeśli typ określonego `value` różnią się od określonej `valueKind`, i danych nie może być przekonwertowany, <xref:System.ArgumentException> zgłaszany. Na przykład można przechowywać <xref:System.Int64?displayProperty=nameWithType> jako <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, ale tylko wtedy, gdy jej wartość jest mniejsza niż wartość maksymalna <xref:System.Int32?displayProperty=nameWithType>. Nie można zapisać wartość jednego ciągu jako <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Jeśli wartości spakowanej są przekazywane w celu <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> lub <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, konwersja odbywa się przy użyciu niezmiennej kultury.  
  
> [!NOTE]
>  Windows 98 i Windows Millennium Edition (Windows Me) rejestru nie jest Unicode, a nie wszystkie znaki Unicode są prawidłowe dla wszystkich stron kodowych. Znak Unicode, który jest nieprawidłowy dla bieżącej strony kodowej został zastąpiony najlepsze dopasowanie. Jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu zapisuje wartości kilku typów danych, w przykładowym kluczem tworzenia klucza, jak robi to tak, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania pary (pustego) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> nie zaczyna się od katalogu głównego rejestru prawidłowe.  - lub - <paramref name="keyName" /> przekracza maksymalną dozwoloną długość (255 znaków).  - lub - typ <paramref name="value" /> nie był zgodny typ danych rejestru, które są określone przez <paramref name="valueKind" />, dlatego danych nie można przekonwertować prawidłowo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> Jest tylko do odczytu i w związku z tym nie można zapisać do, na przykład jest to węzeł katalogu głównego lub klucz nie został otwarty z dostępem do zapisu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wymaganych uprawnień do tworzenia lub modyfikowania kluczy rejestru.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">do modyfikowania wskazanego klucza rejestru, jeśli istnieje, lub utworzenie klucza rejestru, jeśli jeszcze nie istnieje. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera informacje o konfiguracji użytkownika domyślnego. To pole ma wartość klucza podstawowego HKEY_USERS rejestru Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten klucz zawiera gałąź dla każdego użytkownika komputera. Domyślna konfiguracja jest dostarczany dla nowych użytkowników na komputerze lokalnym a domyślny bieżącego użytkownika, jeśli użytkownik nie zmienił Preferencje. Ponieważ Windows 98 / mnie obsługuje również Registry.Users, aplikacje mają dostęp do informacji o użytkowniku taki sam sposób jak w Windows 2000. Każdy użytkownik informacje są przechowywane w oddzielnym pliku, które mogą być przechowywane lokalnie lub na serwerze w sieci. Windows 98 / mnie skopiuj ten plik do systemu bieżącego użytkownika, tak aby ustawienia przenoszą się z jednego komputera na inny z użytkownikiem.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać klucze podrzędne tego klucza i wyświetla ich nazwy na ekranie. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę, aby utworzyć wystąpienie określonego podklucza zainteresowania. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do manipulowania tego klucza.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3285d1e778628339c22d54f5aec6bdd96ffc281" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36725562" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia <see cref="T:Microsoft.Win32.RegistryKey" /> obiektów, które reprezentują kluczy głównych w rejestrze systemu Windows i <see langword="static" /> metodach dostępu pary klucz wartość.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa udostępnia zestaw kluczy głównych standardowe znaleziony w rejestrze na komputerach z systemem Windows. Rejestr jest składowania, informacje o aplikacji, użytkowników i domyślnych ustawień systemowych. Aplikacje można na przykład za pomocą rejestru do przechowywania informacji, który ma zostać zachowane po zamknięciu aplikacji i dostęp do tego samego informacji po załadowaniu aplikacji. Na przykład można przechowywać preferencje kolorów ekranu lokalizacji i rozmiaru okna. Te dane dla każdego użytkownika można kontrolować przy informacje są przechowywane w innej lokalizacji w rejestrze.  
  
 Bazowy lub głównego <xref:Microsoft.Win32.RegistryKey> wystąpień, które są dostępne w `Registry` klasy odróżniać magazynu podstawowego mechanizmu podkluczy i wartości rejestru. Wszystkie klucze są tylko do odczytu, ponieważ rejestr jest zależna od ich istnienia. Klucze udostępnianych przez `Registry` są:  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Przechowuje informacje dotyczące preferencji użytkownika.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Przechowuje informacje o konfiguracji dla komputera lokalnego.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Przechowuje informacje dotyczące typów (i klasy) oraz ich właściwości.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Przechowuje informacje o domyślnej konfiguracji użytkownika.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Przechowuje informacje o wydajności dla składników oprogramowania.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Przechowuje informacje dotyczące sprzętu z systemem innym niż określonego użytkownika.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Przechowuje dane dynamiczne.  
  
 Po zidentyfikowaniu klucza głównego, w której chcesz przechowywania/pobierania informacji z rejestru, można użyć <xref:Microsoft.Win32.RegistryKey> klasy, aby dodać lub usunąć podkluczy i manipulowania wartości dla danego klucza.  
  
 Urządzenia można umieścić informacji w rejestrze automatycznie przy użyciu interfejsu typu Plug and Play. Oprogramowanie instalowanie sterowników urządzeń można umieścić informacji w rejestrze, zapisując standardowych interfejsów API.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Pobieranie i ustawianie wartości statycznej metody  
 W programie .NET Framework w wersji 2.0 <xref:Microsoft.Win32.Registry> klasa zawiera także `static` <xref:Microsoft.Win32.Registry.GetValue%2A> i <xref:Microsoft.Win32.Registry.SetValue%2A> metody do ustawiania i pobierania wartości z kluczy rejestru. Otwórz tych metod i kluczy rejestru Zamknij każdego czasu są używane, dlatego nie należy wykonywać, jak również metody analogiczne w <xref:Microsoft.Win32.RegistryKey> klasy, gdy uzyskujesz dostęp do wielu wartości.  
  
 <xref:Microsoft.Win32.RegistryKey> Klasy udostępnia również metody, które umożliwiają skonfigurowanie Windows kontrolę dostępu dla testu typu danych wartość przed ich pobraniem i usuń klucze rejestru.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. W pierwszym przykładzie pokazano klucze główne, a w drugim przykładzie pokazano `static` <xref:Microsoft.Win32.Registry.GetValue%2A> i <xref:Microsoft.Win32.Registry.SetValue%2A> metody.  
  
 Przykład 1  
  
 W poniższym przykładzie pokazano, jak pobrać podkluczy klucza HKEY_USERS i drukować ich nazwy do ekranu. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę w celu utworzenia wystąpienia określonego podklucza zainteresowań. Następnie można użyć innych operacji w `RegistryKey` do modyfikowania tego klucza.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu przechowuje wartości kilku typów danych w przykładowym kluczem tworzenia klucza, ponieważ nie, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania para (typ) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa typy (lub klasy) dokumenty i właściwości skojarzone z tych typów. To pole ma wartość klucza podstawowego wpisów z HKEY_CLASSES_ROOT rejestru systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno aplikacje z konwencjonalnej, jak i aplikacje OLE korzystają z danych przechowywanych w tym kluczu. Ten klucz także zgodności z poprzednimi wersjami z bazy danych rejestracji systemu Windows 3.1 przechowywane informacje dotyczące obsługi i DDE OLE. Plików i rozszerzenia interfejsu użytkownika są przechowywane ich identyfikatorów klasy OLE w tym kluczu, a serwer przetwarzania jest zarejestrowany w tym kluczu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać podklucze tego klucza i wyświetla ich nazwy do ekranu. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę w celu utworzenia wystąpienia określonego podklucza zainteresowań. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do modyfikowania tego klucza.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera informacje o konfiguracji dotyczące sprzętu, który nie jest specyficzne dla użytkownika. To pole ma wartość klucza podstawowego HKEY_CURRENT_USER rejestru systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski jest zamapowana do podklucza w <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Przykład użycia tego elementu członkowskiego jest aplikacja, która przechowuje z inną nazwą serwera danych w zależności od tego, czy system jest podłączony do sieci.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać podklucze tego klucza i wyświetla ich nazwy do ekranu. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę w celu utworzenia wystąpienia określonego podklucza zainteresowań. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do modyfikowania tego klucza.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera informacje o bieżącym preferencji użytkownika. To pole ma wartość klucza podstawowego HKEY_CURRENT_USER rejestru systemu Windows</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje przechowywane w tym kluczu obejmuje ustawienia zmiennych środowiskowych i dane dotyczące grupy programów, kolorów, drukarki, połączeń sieciowych i preferencje. Ten klucz ułatwia ustalenie ustawień bieżącego użytkownika. W tym kluczu dostawców oprogramowania przechowywać bieżącego preferencje użytkownika do użycia w swoich aplikacjach. Microsoft, na przykład tworzy klucz HKEY_CURRENT_USER\Software\Microsoft jej do użycia przez aplikacje, z poszczególnymi aplikacjami, tworzenie własnych podklucz w kluczu firmy Microsoft.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać podklucze tego klucza i wyświetla ich nazwy do ekranu. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę w celu utworzenia wystąpienia określonego podklucza zainteresowań. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do modyfikowania tego klucza.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera dane rejestru dynamicznych. To pole ma wartość klucza podstawowego HKEY_DYN_DATA rejestru systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W rejestrze systemu Windows 98/Windows Me obsługuje zarówno dane statyczne (który jest przechowywany na dysku w rejestrze) i danych dynamicznych (który zmienia się często, takich jak statystyka wydajności). Ten obszar danych dynamicznych to mechanizm umożliwiający sterowniki urządzeń wirtualnych urządzenia (vxd) w czasie rzeczywistym danych do aplikacji Win32, które można uruchomić zdalnie, a także lokalnie. Umożliwia także monitor systemu udostępnić statystyki na Windows 98/Windows Me systemów zdalnych.  
  
 Urządzenia vxd nie są ograniczone do danych dotyczących wydajności. Udostępniają one danych, które chcą, aby przekazać z Ring 0 do 3 pierścień wydajnie bez przejęcie kontroli nad Procesora. Rejestr obsługuje dane dynamiczne, przechowując wskaźnika do funkcji, która zwraca wartość (lub wiele wartości). Jeśli wartości rejestru wywołanie kwerendy skojarzoną z kluczem dynamicznych, czy funkcja jest wywoływana w celu zwrócenia żądaną wartość lub wartości.  
  
> [!NOTE]
>  Dynamiczne klucze zostały wprowadzone w systemie Microsoft Windows 95 do obsługi danych dynamicznych rejestru. Są obsługiwane tylko w systemie Windows 98/Windows Me  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać podklucze tego klucza i wyświetla ich nazwy do ekranu. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę w celu utworzenia wystąpienia określonego podklucza zainteresowań. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do modyfikowania tego klucza. Należy pamiętać, że w tym przykładzie można nie zwracała żadnych wyników, ponieważ mogą być danymi dynamicznymi niedostępne lub nie może działać system Windows 98 / ME. Przy użyciu tego klucza może spowodować błąd w innych systemach.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">System operacyjny nie obsługuje dane dynamiczne; oznacza to, że nie jest Windows 98, Windows 98 Wydanie drugie lub Windows Millennium Edition (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Ścieżka rejestru pełnego klucza, począwszy od katalogu głównego rejestru prawidłową, takie jak "HKEY_CURRENT_USER".</param>
        <param name="valueName">Nazwa pary nazwa/wartość.</param>
        <param name="defaultValue">Wartość zwracana, gdy <c>valueName</c> nie istnieje.</param>
        <summary>Pobiera wartość skojarzoną z określoną nazwą, w określonym kluczu rejestru. Jeśli nazwa nie zostanie znaleziony w określonym kluczu, zwraca wartość domyślną, które zapewniają, lub <see langword="null" /> Jeśli określony klucz nie istnieje.</summary>
        <returns>
          <see langword="null" /> Jeśli podklucz określony przez <paramref name="keyName" /> nie istnieje; w przeciwnym razie wartość skojarzonych z <paramref name="valueName" />, lub <paramref name="defaultValue" /> Jeśli <paramref name="valueName" /> nie znaleziono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg `valueName` nie jest rozróżniana wielkość liter.  
  
> [!NOTE]
>  Klucz rejestru może zawierać jedną wartość, która nie jest skojarzona z żadną nazwą. Gdy ta nienazwana wartość jest wyświetlana w Edytorze rejestru, zamiast nazwy pojawia się ciąg „(Domyślna)”. Aby pobrać to nienazwane wartość, określ `null` lub ciąg pusty ("") dla `valuName`.  
  
 Nazwy prawidłowy główny są HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE wpisów z HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_USER i HKEY_DYN_DATA. Na przykład w języku Visual Basic ciąg "HKEY_CURRENT_USER\MyTestKey" uzyskuje dostęp do pary klucz wartość podklucza "MyTestKey" w katalogu głównym HKEY_CURRENT_USER.  
  
 Gdy <xref:Microsoft.Win32.RegistryKey.GetValue%2A> metoda pobiera wartości ciągu rozwijania (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), rozszerza ciągów środowiska przy użyciu danych z lokalnego środowiska. Jeśli wartość zawierającą rozwijania odwołań do zmiennych środowiskowych przechowywanych jako ciąg (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), a nie jako ciąg rozwijania (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> nie zwiększa. Można rozwinąć taki ciąg po pobraniu przez wywołanie metody <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Zalecanym sposobem pobrania danych z HKEY_PERFORMANCE_DATA jest użycie <xref:System.Diagnostics.PerformanceCounter> klasy, a nie <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> metody.  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A> i <xref:Microsoft.Win32.Registry.SetValue%2A> Otwórz metod i kluczy rejestru Zamknij zawsze są używane, dlatego nie należy wykonywać, a także metody <xref:Microsoft.Win32.RegistryKey> klasy, jeśli dostęp do wielu wartości.  
  
 <xref:Microsoft.Win32.RegistryKey> udostępnia metody, które umożliwiają dodawanie listy kontroli dostępu (ACL) do klucza rejestru, test typu danych wartość przed ich pobraniem i usuwania kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu przechowuje wartości kilku typów danych w przykładowym kluczem tworzenia klucza, ponieważ nie, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania para (typ) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie posiada uprawnień niezbędnych do czytania treści klucza rejestru.</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> Zawierający określona wartość został oznaczony do usunięcia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> nie zaczyna się od katalogu głównego rejestru prawidłową.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Odczytywanie zawartości rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">można odczytać klucza rejestru typu REG_EXPAND_SZ. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera dane konfiguracyjne dla komputera lokalnego. To pole ma wartość klucza podstawowego HKEY_LOCAL_MACHINE rejestru systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` zawiera pięć kluczy:  
  
 Sprzęt  
 Opisuje sposób sterowniki urządzeń, użyj tego sprzętu i mapowania i powiązane dane, który łącza sterowniki trybu jądra z kodu w trybie użytkownika sprzętu fizycznego na komputerze. Wszystkie dane w tym kluczu zostaje odtworzone w każdym uruchomieniu systemu. Opis podklucz opisuje sprzęt komputera. Podklucz DeviceMap zawiera różne dane w formatach specyficzne dla poszczególnych klas sterowników. Podklucz ResourceMap opisuje zasoby sprzętowe oświadczeń sterowników urządzeń. Program Diagnostyka systemu Windows NT (Winmsdp.exe) może raportować na jego zawartość w formie łatwe do odczytania.  
  
 SAM  
 Usług katalogowych informacji zabezpieczeń dla kont użytkowników i grup oraz domen w systemie Windows 2000 Server (Menedżera kont zabezpieczeń znany jako baza danych usług katalogowych jest SAM).  
  
 Zabezpieczenia  
 Zawiera zasady zabezpieczeń lokalnych, takich jak uprawnienia określonego użytkownika. Ten klucz jest używany tylko przez podsystem zabezpieczeń systemu Windows 2000.  
  
 Oprogramowanie  
 Bazy danych dla poszczególnych komputerów. Ten klucz zawiera dane dotyczące oprogramowania zainstalowanego na komputerze lokalnym, oraz różne elementy danych o różnych konfiguracji.  
  
 System  
 Uruchamianie systemu kontroli, ładowanie sterownika urządzenia, usług systemu Windows 2000 i zachowania systemu operacyjnego.  
  
 Konwencja, jeśli istnieje podobne dane w ramach <xref:Microsoft.Win32.Registry.CurrentUser> i w obszarze <xref:Microsoft.Win32.Registry.LocalMachine>, dane w <xref:Microsoft.Win32.Registry.CurrentUser> pierwszeństwo. Jednak wartości w tym kluczu można również rozszerzyć (zamiast Zastąp) danych w Registry.LocalMachine. Ponadto niektóre elementy (takie jak sterownik urządzenia podczas ładowania wpisy) są bez znaczenia, jeśli występują one poza Registry.LocalMachine.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać podklucze tego klucza i wyświetla ich nazwy do ekranu. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę w celu utworzenia wystąpienia określonego podklucza zainteresowań. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do modyfikowania tego klucza.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera informacje o wydajności dla składników oprogramowania. To pole ma wartość klucza podstawowego HKEY_PERFORMANCE_DATA rejestru systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy składnik oprogramowania tworzy klucze dla swoich obiektów liczników podczas instalacji i zapisuje dane liczników, podczas jej wykonywania. Użytkownik uzyskuje dostęp te dane, co spowoduje dostęp innych danych rejestru, przy użyciu <xref:Microsoft.Win32.RegistryKey> funkcji.  
  
 Mimo że używasz rejestru do zbierania danych dotyczących wydajności, dane nie są przechowywane w bazie danych rejestru. Zamiast tego podczas uzyskiwania dostępu do rejestru przy użyciu tego klucza powoduje, że system do zbierania danych z odpowiednim systemem menedżerowie obiektów.  
  
 Aby uzyskać dane wydajności z systemu lokalnego, należy użyć <xref:Microsoft.Win32.RegistryKey.GetValue%2A> metody, przy użyciu klucza Registry.PerformanceData. Pierwsze wywołanie otwiera klucza (nie trzeba jawnie najpierw otworzyć klucza). Jednak zaleca się używanie <xref:Microsoft.Win32.RegistryKey.Close%2A> metodę, aby zamknąć dojścia do klucza, po zakończeniu uzyskiwania danych dotyczących wydajności. Użytkownik nie może zainstalować lub usunąć składnika oprogramowania, jego dane dotyczące wydajności w trakcie używania.  
  
 Aby uzyskać dane wydajności z systemu zdalnego, należy użyć <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> metodę o nazwie komputera zdalnego systemu i klucza Registry.PerformanceData. To wywołanie pobiera klucz reprezentujący dane dotyczące wydajności systemu zdalnego. Aby pobrać dane, należy wywołać <xref:Microsoft.Win32.RegistryKey.GetValue%2A> przy użyciu tego klucza, a nie kluczem Registry.PerformanceData.  
  
> [!NOTE]
>  W systemie Windows Server 2003 użytkownik co najmniej musi należeć do grupy Użytkownicy monitora wydajności Aby uzyskać dostęp do podkluczy klucza podstawowego.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać podklucze tego klucza i wyświetla ich nazwy do ekranu. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę w celu utworzenia wystąpienia określonego podklucza zainteresowań. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do modyfikowania tego klucza. Należy pamiętać, że w tym przykładzie można często nie zwracała żadnych wyników, ponieważ nie mogą istnieć żadne dane wydajności.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia wartość pary nazwa/wartość w kluczu rejestru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu przechowuje wartości kilku typów danych w przykładowym kluczem tworzenia klucza, ponieważ nie, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania para (typ) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Ścieżka rejestru pełnego klucza, począwszy od katalogu głównego rejestru prawidłową, takie jak "HKEY_CURRENT_USER".</param>
        <param name="valueName">Nazwa pary nazwa/wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Ustawia pary nazwa/wartość określona dla określonego klucza rejestru. Jeśli określony klucz nie istnieje, jest tworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], `valueName` parametr nie jest już ograniczone do maksymalnie 255 znaków; jednak `keyName` parametru w dalszym ciągu ma ograniczenie 255 znaków.  
  
 Ponieważ wiele wartości mogą być przechowywane w każdym klucz rejestru, należy użyć `valueName` parametr, aby określić określonej wartości, które chcesz ustawić.  
  
> [!NOTE]
>  Klucz rejestru może zawierać jedną wartość, która nie jest skojarzona z żadną nazwą. Gdy ta nienazwana wartość jest wyświetlana w Edytorze rejestru, zamiast nazwy pojawia się ciąg „(Domyślna)”. Ustawienie wartości nienazwanych, określ `null` lub ciąg pusty ("") dla `valueName`.  
  
 Jeśli `valueName` nie istnieje w kluczu jest utworzona i skojarzona wartość jest równa `value`.  
  
 Jeśli `keyName` określa podklucz, który nie istnieje, podklucz jest tworzony w określonym katalogu głównym. Na przykład w języku Visual Basic ciąg "HKEY_CURRENT_USER\MyTestKey" tworzy podklucz "MyTestKey" w katalogu głównym HKEY_CURRENT_USER. Ciąg "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" tworzy zagnieżdżone podklucze "MyTestKey", "MyTestKey\Key2" i "MyTestKey\Key2\Key3".  
  
 Nazwy głównych prawidłowy obejmują HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, wpisów z HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_USER i HKEY_DYN_DATA.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> — Metoda otwiera klucz rejestru, ustawia wartość i zamyka zawsze jest to klucz. Jeśli trzeba zmodyfikować dużą liczbę wartości, <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> metody może zapewnić lepszą wydajność. <xref:Microsoft.Win32.RegistryKey> Klasa udostępnia również metody, które umożliwiają dodawanie listy kontroli dostępu (ACL) do klucza rejestru, test typu danych wartość przed ich pobraniem i usuwania kluczy.  
  
 To przeciążenie metody <xref:Microsoft.Win32.Registry.SetValue%2A> przechowuje 64-bitowych liczb całkowitych jako ciągi (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Do przechowywania 64-bitowych liczb jako <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> wartości, użyj <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> przeciążenie metody.  
  
 To przeciążenie metody <xref:Microsoft.Win32.Registry.SetValue%2A> przechowuje wszystkie wartości ciągu jako <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> obiekty, nawet jeśli zawierają one rozwijania odwołań do zmiennych środowiskowych. Można zapisać wartości ciągu jako rozwijania ciągów (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), użyj <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> przeciążenie metody.  
  
 To przeciążenie jest odpowiednikiem wywołania <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> przeciążenie metody z <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Windows 98 i Windows Millennium Edition (Windows Me) rejestr nie jest Unicode, a nie wszystkie znaki Unicode są prawidłowe dla wszystkich stron kodowych. Znak Unicode, który jest nieprawidłowy dla bieżącej strony kodowej zastępuje najlepsze dopasowanie. Nie wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu przechowuje wartości kilku typów danych w przykładowym kluczem tworzenia klucza, ponieważ nie, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania para (typ) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> nie zaczyna się od katalogu głównego rejestru prawidłową.  - lub - <paramref name="keyName" /> przekracza maksymalną dozwoloną długość (255 znaków).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> Jest tylko do odczytu i dlatego nie można zapisać do, na przykład jest węzła głównego poziomu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wymaganych uprawnień do tworzenia lub modyfikowania kluczy rejestru.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Aby zmodyfikować określony klucz rejestru, jeśli istnieje, lub można utworzyć klucza rejestru, jeśli jeszcze nie istnieje. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName">Ścieżka rejestru pełnego klucza, począwszy od katalogu głównego rejestru prawidłową, takie jak "HKEY_CURRENT_USER".</param>
        <param name="valueName">Nazwa pary nazwa/wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <param name="valueKind">Typ danych rejestru do użycia podczas zapisywania danych.</param>
        <summary>Ustawia określony klucz rejestru, przy użyciu typu danych określonego rejestru pary nazwa/wartość. Jeśli określony klucz nie istnieje, jest tworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], `valueName` parametr nie jest już ograniczone do maksymalnie 255 znaków; jednak `keyName` parametru nadal mieć ograniczenia 255 znaków.  
  
 Ponieważ wiele wartości mogą być przechowywane w każdym klucz rejestru, należy użyć `valueName` parametr, aby określić określonej wartości, które chcesz ustawić.  
  
> [!NOTE]
>  Klucz rejestru może zawierać jedną wartość, która nie jest skojarzona z żadną nazwą. Gdy ta nienazwana wartość jest wyświetlana w Edytorze rejestru, zamiast nazwy pojawia się ciąg „(Domyślna)”. Ustawienie wartości nienazwanych, określ `null` lub ciąg pusty ("") dla `valueName`.  
  
 Jeśli `valueName` nie istnieje w kluczu jest utworzona i skojarzona wartość jest równa `value`.  
  
 Jeśli `keyName` określa podklucz, który nie istnieje, podklucz jest tworzony w określonym katalogu głównym. Na przykład w języku Visual Basic ciąg "HKEY_CURRENT_USER\MyTestKey" tworzy podklucz "MyTestKey" w katalogu głównym HKEY_CURRENT_USER. Ciąg "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" tworzy zagnieżdżone podklucze "MyTestKey", "MyTestKey\Key2" i "MyTestKey\Key2\Key3".  
  
 Nazwy głównych prawidłowy obejmują HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, wpisów z HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_USER i HKEY_DYN_DATA.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> — Metoda otwiera klucz rejestru, ustawia wartość i zamyka zawsze jest to klucz. Jeśli trzeba zmodyfikować dużą liczbę wartości, <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> metody może zapewnić lepszą wydajność. <xref:Microsoft.Win32.RegistryKey> Klasa udostępnia również metody, które umożliwiają dodawanie listy kontroli dostępu (ACL) do klucza rejestru, test typu danych wartość przed ich pobraniem i usuwania kluczy.  
  
 Jeśli typ określony `value` nie odpowiada określonym `valueKind`, i danych nie może być przekonwertowany, <xref:System.ArgumentException> jest generowany. Na przykład można przechowywać <xref:System.Int64?displayProperty=nameWithType> jako <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, ale tylko wtedy, gdy jego wartość jest mniejsza niż maksymalna wartość <xref:System.Int32?displayProperty=nameWithType>. Nie można zapisać wartość jednego ciągu jako <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Jeśli opakowanego wartości są przekazywane <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> lub <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, konwersja odbywa się przy użyciu Niezmienna kultura.  
  
> [!NOTE]
>  Windows 98 i Windows Millennium Edition (Windows Me) rejestr nie jest Unicode, a nie wszystkie znaki Unicode są prawidłowe dla wszystkich stron kodowych. Znak Unicode, który jest nieprawidłowy dla bieżącej strony kodowej zastępuje najlepsze dopasowanie. Nie wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu przechowuje wartości kilku typów danych w przykładowym kluczem tworzenia klucza, ponieważ nie, a następnie pobiera i wyświetla wartości. W przykładzie pokazano, przechowywania i pobierania para (typ) nazwa/wartość domyślną, a także korzystanie z `defaultValue` Jeśli pary nazwa/wartość nie istnieje.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> nie zaczyna się od katalogu głównego rejestru prawidłową.  - lub - <paramref name="keyName" /> przekracza maksymalną dozwoloną długość (255 znaków).  - lub - typ <paramref name="value" /> niezgodny typ danych rejestru określony przez <paramref name="valueKind" />, w związku z tym danych nie można przekonwertować poprawnie.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> Jest tylko do odczytu i dlatego nie można zapisać do, na przykład jest węzłem głównym poziomie lub klucz nie został otwarty z prawem do zapisu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wymaganych uprawnień do tworzenia lub modyfikowania kluczy rejestru.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Aby zmodyfikować określony klucz rejestru, jeśli istnieje, lub można utworzyć klucza rejestru, jeśli jeszcze nie istnieje. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera informacje o domyślnej konfiguracji użytkownika. To pole ma wartość klucza podstawowego HKEY_USERS rejestru systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten klucz zawiera gałęzi dla każdego użytkownika komputera. Domyślnej konfiguracji są dostarczane dla nowych użytkowników na komputerze lokalnym i domyślne bieżącego użytkownika, jeśli użytkownik nie uległ zmianie preferencji. Ponieważ Windows 98 / ME obsługuje również Registry.Users, aplikacje mają dostęp do informacji o użytkowniku tak samo jak w systemie Windows 2000. Każdy użytkownik informacje są przechowywane w osobnym pliku, które mogą być przechowywane lokalnie lub na serwerze sieciowym. Windows 98 / mnie skopiuj ten plik do systemu bieżącego użytkownika, dzięki czemu ustawienia można przenieść z jednego komputera na inny użytkownik.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać podklucze tego klucza i wyświetla ich nazwy do ekranu. Użyj <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> metodę w celu utworzenia wystąpienia określonego podklucza zainteresowań. Następnie można użyć innych operacji w <xref:Microsoft.Win32.RegistryKey> do modyfikowania tego klucza.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d99d25be1d24abd932081d3e03fd39286f0da69" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037644" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia dostęp do powiadomień o zdarzeniach systemowych. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.Win32.SystemEvents> Klasa umożliwia odpowiadają na określone typy zdarzeń systemowych.  
  
 Przypadku zdarzenia systemu, wszystkie obiekty delegowane dołączyć do zdarzenia są wywoływane przy użyciu wątku, który monitoruje dla zdarzeń systemowych. W związku z tym należy wszystkie wywołania z Twojej zdarzeń obsługi wątkowo. Jeśli należy wywołać zdarzeń systemu, który nie jest ujawniona jako element członkowski tej klasy, możesz użyć <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> metody.  
  
> [!CAUTION]
>  Nie wykonuj dużo czasu przetwarzania w wątku, który wywołuje program obsługi zdarzeń systemu, ponieważ może uniemożliwić inne aplikacje działanie.  
  
> [!NOTE]
>  Niektórych zdarzeń systemowych nie może zostać wywołane na [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Pamiętaj sprawdzić, czy aplikacja działa zgodnie z oczekiwaniami na [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady. Pierwszym przykładzie przedstawiono użycie zdarzenia systemowe w zwykłych aplikacji, a drugi przykład przedstawia sposób użycia zdarzenia systemowe w usłudze systemu Windows.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu rejestruje zainteresowanie niektórych zdarzeń systemowych, a następnie oczekiwanie dla każdego z tych zdarzenia. Dane wyjściowe pokazano występuje, gdy użytkownik zmienia się rozdzielczość ekranu.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykładowy kod przedstawia bardzo proste usługi systemu Windows, która obsługuje <xref:Microsoft.Win32.SystemEvents.TimeChanged> i <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> zdarzenia. Przykład obejmuje usługi o nazwie `SimpleService`, formularz o nazwie `HiddenForm`, a Instalator. Formularz udostępnia pętli komunikatów, wymagany przez zdarzeń systemowych.  
  
> [!NOTE]
>  Usługi nie ma pętli komunikatów, o ile nie mogą wchodzić w interakcje z pulpitem. Jeśli Pętla wiadomości nie jest zapewniana przez ukrytym, jak w poniższym przykładzie, należy uruchomić usługę na koncie systemu lokalnego, a do włączenia interakcji z pulpitem jest wymagana ręczna interwencja. Oznacza to, administrator musi ręcznie sprawdzać **Zezwalaj usłudze na współdziałanie z pulpitem** pole wyboru na **logowanie** kartę okno dialogowe właściwości tej usługi. W takim przypadku Pętla wiadomości jest teraz udostępniana automatycznie. Ta opcja jest dostępna tylko wtedy, gdy usługa jest uruchamiana na koncie systemu lokalnego. Nie można programowo włączyć współdziałanie z pulpitem.  
  
 Usługi w tym przykładzie uruchamia wątku, który uruchamia wystąpienie `HiddenForm`. Zdarzenia są podłączonymi i obsługiwać w formularzu. Zdarzenia musi być podłączonymi w przypadku ładowania formularza, aby upewnić się, że formularz jest całkowicie załadowany najpierw; w przeciwnym razie zdarzenia nie zostanie wygenerowany.  
  
> [!NOTE]
>  W przykładzie przedstawiono wszystkie niezbędne kodu, w tym kod inicjujący formularza zwykle generowane przez projektantów Visual Studio. Jeśli tworzysz usługi w programie Visual Studio można pominąć drugi klasy częściowe i użyj **właściwości** okno, aby ustawić wysokość i szerokość ukrytym na zero, styl obramowania <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>i stanu okna do <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 Aby uruchomić w przykładzie:  
  
1.  Kompilowanie kodu w wierszu polecenia. Nazwa, której użyjesz dla pliku źródłowego nie jest ważna.  
  
2.  Zainstaluj usługę z wiersza polecenia przy użyciu [Installutil.exe (Narzędzie Instalatora)](~/docs/framework/tools/installutil-exe-installer-tool.md) narzędzia. Na przykład `InstallUtil example.exe` Jeśli nazwa pliku źródłowego ma `example.cs` lub `example.vb`. Musi być administratorem, aby zainstalować usługę.  
  
3.  Użyj konsoli usługi, aby uruchomić usługę.  
  
4.  Zmiany czasu systemowego lub zmiany preferencji użytkownika, takie jak właściwości myszy.  
  
5.  Wyświetlanie komunikatów w **aplikacji** kategorii podglądu zdarzeń.  
  
6.  Aby zatrzymać usługę za pomocą konsoli usług.  
  
7.  Odinstaluj usługę z wiersza polecenia przy użyciu `/u` opcji. Na przykład `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartości: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Określa interwał między czasomierza powiadomień, w milisekundach.</param>
        <summary>Tworzy nowego okna czasomierz skojarzony z oknem zdarzeń systemu.</summary>
        <returns>Identyfikator nowego czasomierza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Interwał jest mniejsza lub równa zero.</exception>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się lub nie powiodła się próba utworzenia czasomierza.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zmieni ustawień wyświetlania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak monitorować <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> zdarzeń. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieniane są ustawienia wyświetlania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed zakończeniem wątku, który nasłuchuje zdarzeń systemowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, ponieważ wątek, który odbiera zdarzenia systemu ma zostać zakończone. Delegaty zdarzeń systemu są wywoływane przy użyciu wątku, który nasłuchuje zdarzeń systemowych.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik dodaje czcionek lub usuwa czcionek z systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegat do wywołania, za pomocą wątku, który nasłuchuje zdarzeń systemowych.</param>
        <summary>Wywołuje delegata określony za pomocą wątku, który nasłuchuje zdarzeń systemowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć w każdej chwili potrzebne do obsługi zdarzeń systemu, który nie jest uwidaczniana, w przeciwnym razie przez <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 Gdy ta metoda jest wywoływana, określonego delegata zostanie wywołany przez wątek, który używa aplikacji do przetwarzania zdarzeń systemowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">Identyfikator czasomierza, aby zakończyć.</param>
        <summary>Kończy określony przez dany identyfikator czasomierza.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się lub nie powiodła się próba zakończenia czasomierza.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy system zaczyna brakować dostępnej pamięci RAM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zawijana wiadomość WM_COMPACTING. Ten komunikat jest wysyłany do wszystkich okien najwyższego poziomy, jeśli system wykryje, że więcej niż 12,5% czasu systemowego przedziałach 30 i 60 sekund był zajęty kompaktowania pamięci. Oznacza to, że ilość pamięci w systemie jest niski.  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <block subset="none" type="usage">
          <para>Ten komunikat jest dostępne tylko dla zgodności z 16-bitowych aplikacji opartych na systemie Windows.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zmienia się na aplikacji, która używa innego palety.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak monitorować <xref:Microsoft.Win32.SystemEvents.PaletteChanged> zdarzeń. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik wstrzymuje lub wznawia działanie systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik jest wylogowania lub zamykanie systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik próbuje wylogowania lub zamknięcia systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to zdarzenie można anulować. Ustawienie <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> właściwości `true` będzie żądać sesji nadal działa. Zapewnia on nie gwarancji, że sesja nie zostanie zakończona.  
  
 Jeśli używasz <xref:Microsoft.Win32.SystemEvents.SessionEnding> w formularzu systemu Windows do wykrywania wylogowaniu lub ponowne uruchomienie komputera nie istnieje sposób deterministyczne zdecydować, czy <xref:System.Windows.Forms.Form.Closing> zdarzenia będą uruchamiane przed tym zdarzeniem.  
  
 Jeśli chcesz wykonać kilka zadań specjalne przed <xref:System.Windows.Forms.Form.Closing> jest uruchamiany, należy upewnić się, że <xref:Microsoft.Win32.SystemEvents.SessionEnding> generowane przed <xref:System.Windows.Forms.Form.Closing>. Aby to zrobić, musisz pułapki `WM_QUERYENDSESSION` w formularzu przez zastąpienie `WndProc` funkcji.  W tym przykładzie pokazano, jak to zrobić.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Nie wywołuj aplikacji konsoli <xref:Microsoft.Win32.SystemEvents.SessionEnding> zdarzeń.  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie aktualnie zalogowanego użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zmienia czas zegara systemowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dla interwału czasomierza systemu windows utraciło ważność.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie preferencji użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy Trwa zmienianie preferencji użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko, jeśli działa przekazywanie komunikatów. W usłudze systemu Windows chyba że formularz ukryty lub przekazywanie komunikatów został uruchomiony ręcznie, to zdarzenie nie będą zgłaszane. Aby uzyskać przykład kodu pokazuje sposób obsługi zdarzeń systemowych za pomocą formularza ukryte w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak monitorować <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> zdarzeń. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Wartość procesy serwera, na przykład może nie obsługiwać powiadomień o zdarzeniach systemowych globalnego.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Podjęto próbę utworzenia wątku okna zdarzeń systemowych nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>
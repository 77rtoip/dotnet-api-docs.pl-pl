<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f5ad823f9e2ab0333d38c1e7e64f3e87d6c6bf88" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69313774" /></Metadata><TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <TypeSignature Language="F#" Value="type SystemEvents = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia dostęp do powiadomień dotyczących zdarzeń systemu. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.Win32.SystemEvents> Klasa umożliwia reagowanie na określone typy zdarzeń systemowych.  
  
 Gdy zdarzenie systemowe zostanie wywołane, wszelkie Delegaty dołączone do zdarzenia są wywoływane przy użyciu wątku, który monitoruje zdarzenia systemowe. W związku z tym należy wykonać wszystkie wywołania z programów obsługi zdarzeń, które są bezpieczne wątkowo. Jeśli musisz wywołać zdarzenie systemowe, które nie jest ujawnione jako element członkowski tej klasy, możesz użyć <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> metody.  
  
> [!CAUTION]
>  Nie Wykonuj czasochłonnego przetwarzania w wątku, który wywołuje program obsługi zdarzeń systemu, ponieważ może uniemożliwiać działanie innych aplikacji.  
  
> [!NOTE]
>  Niektóre zdarzenia systemowe mogą nie zostać zgłoszone [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Upewnij się, że aplikacja działa zgodnie z oczekiwaniami w systemie [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady. Pierwszy przykład pokazuje, jak używać zdarzeń systemowych w zwykłej aplikacji, a drugi przykład pokazuje, jak używać zdarzeń systemowych w usłudze systemu Windows.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu rejestruje interesy w niektórych zdarzeniach systemowych, a następnie czeka na wystąpienie któregokolwiek z tych zdarzeń. Dane wyjściowe są wyświetlane, jeśli użytkownik zmieni rozdzielczość ekranu.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu ilustruje bardzo prostą usługę systemu Windows, która obsługuje <xref:Microsoft.Win32.SystemEvents.TimeChanged> zdarzenia <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> i. Przykład dotyczy usługi o nazwie `SimpleService`, formularza o nazwie `HiddenForm`i Instalatora. Formularz zawiera pętlę komunikatów wymaganą przez zdarzenia systemowe.  
  
> [!NOTE]
>  Usługi nie mają pętli komunikatów, chyba że mogą one współistnieć z pulpitem. Jeśli pętla komunikatów nie jest dostarczana przez ukrytą formę, jak w tym przykładzie, usługa musi być uruchomiona w ramach lokalnego konta systemowego, a interwencja ręczna jest wymagana w celu umożliwienia interakcji z pulpitem. Oznacza to, że administrator musi ręcznie zaznaczyć pole wyboru **Zezwalaj usłudze na współdziałanie z pulpitem** na karcie **Logowanie** okna dialogowego właściwości usługi. W takim przypadku automatycznie zostanie przekazana pętla komunikatów. Ta opcja jest dostępna tylko wtedy, gdy usługa jest uruchamiana przy użyciu konta System lokalny. Nie można programowo włączyć interakcji z pulpitem.  
  
 Usługa w tym przykładzie uruchamia wątek, w którym działa wystąpienie `HiddenForm`. Zdarzenia są podłączane i obsługiwane w formularzu. Zdarzenia muszą być podłączane w zdarzeniu ładowania formularza, aby upewnić się, że formularz jest całkowicie załadowany jako pierwszy. w przeciwnym razie zdarzenia nie zostaną zgłoszone.  
  
> [!NOTE]
>  Przykład zawiera wszystkie niezbędne kody, w tym kod inicjujący formularza zwykle generowany przez projektantów programu Visual Studio. Jeśli tworzysz usługę w programie Visual Studio, możesz pominąć drugą klasę częściową i użyć okna **Właściwości** , aby ustawić wysokość i szerokość ukrytego formularza na zero, styl obramowania do <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>i stan <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>okna.  
  
 Aby uruchomić przykład:  
  
1.  Skompiluj kod z wiersza polecenia. Nazwa użyta dla pliku źródłowego nie jest ważna.  
  
2.  Zainstaluj usługę z wiersza polecenia za pomocą narzędzia [Installutil. exe (Narzędzie instalatora)](~/docs/framework/tools/installutil-exe-installer-tool.md) . Na przykład, `InstallUtil example.exe` Jeśli nazwa pliku źródłowego to `example.cs` lub `example.vb`. Aby zainstalować usługę, musisz być administratorem.  
  
3.  Użyj konsoli usługi, aby uruchomić usługę.  
  
4.  Zmień czas systemowy lub zmień preferencje użytkownika, takie jak właściwości myszy.  
  
5.  Wyświetl komunikaty w kategorii **aplikacji** Podgląd zdarzeń.  
  
6.  Zatrzymaj usługę za pomocą konsoli usługi.  
  
7.  Odinstaluj usługę z wiersza polecenia przy użyciu `/u` opcji. Na przykład `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać pełny dostęp do zasobów systemowych. Wartości popytu: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Stan skojarzony:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberSignature Language="F#" Value="static member CreateTimer : int -&gt; nativeint" Usage="Microsoft.Win32.SystemEvents.CreateTimer interval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Określa interwał między powiadomieniami o czasomierzu (w milisekundach).</param>
        <summary>Tworzy nowy czasomierz okna skojarzony z oknem zdarzenia systemowe.</summary>
        <returns>Identyfikator nowego czasomierza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Interwał jest mniejszy lub równy zero.</exception>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem lub próba utworzenia czasomierza nie powiodła się.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanged : EventHandler " Usage="member this.DisplaySettingsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zmieni ustawienia wyświetlania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób monitorowania <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> zdarzenia. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanging : EventHandler " Usage="member this.DisplaySettingsChanging : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie ustawień wyświetlania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberSignature Language="F#" Value="member this.EventsThreadShutdown : EventHandler " Usage="member this.EventsThreadShutdown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed przerwaniem wątku, który nasłuchuje zdarzeń systemowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane, ponieważ wątek, który nasłuchuje zdarzeń systemowych, zostanie zakończony. Delegaty zdarzeń systemowych są wywoływane przy użyciu wątku, który nasłuchuje zdarzeń systemowych.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberSignature Language="F#" Value="member this.InstalledFontsChanged : EventHandler " Usage="member this.InstalledFontsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik doda czcionki lub usunie czcionki z systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="static member InvokeOnEventsThread : Delegate -&gt; unit" Usage="Microsoft.Win32.SystemEvents.InvokeOnEventsThread method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegat do wywołania przy użyciu wątku, który nasłuchuje zdarzeń systemowych.</param>
        <summary>Wywołuje określonego delegata przy użyciu wątku, który nasłuchuje zdarzeń systemowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć w dowolnym momencie, gdy trzeba obsłużyć zdarzenie systemowe, które nie zostało ujawnione w <xref:Microsoft.Win32.SystemEvents> inny sposób przez klasę.  
  
 Po wywołaniu tej metody określony delegat będzie wywoływany przez wątek używany przez aplikację do przetwarzania zdarzeń systemowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberSignature Language="F#" Value="static member KillTimer : nativeint -&gt; unit" Usage="Microsoft.Win32.SystemEvents.KillTimer timerId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">Identyfikator czasomierza do przerwania.</param>
        <summary>Kończy czasomierz określony przez podany identyfikator.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem lub próba zakończenia czasomierza nie powiodła się.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberSignature Language="F#" Value="member this.LowMemory : EventHandler " Usage="member this.LowMemory : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This event has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This event has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy w systemie brakuje dostępnej pamięci RAM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie otacza komunikat WM_COMPACTING. Ten komunikat jest wysyłany do wszystkich okien najwyższego poziomu, gdy system wykryje więcej niż 12,5% czasu systemowego w okresie od 30 do 60 sekund, poświęcając na kompaktowanie pamięci. Oznacza to, że pamięć systemowa jest niska.  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <block subset="none" type="usage"><para>Ten komunikat jest dostępny tylko w celu zapewnienia zgodności z 16-bitowymi aplikacjami opartymi na systemie Windows.</para></block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberSignature Language="F#" Value="member this.PaletteChanged : EventHandler " Usage="member this.PaletteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przełączy się do aplikacji, która używa innej palety.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób monitorowania <xref:Microsoft.Win32.SystemEvents.PaletteChanged> zdarzenia. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberSignature Language="F#" Value="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " Usage="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik wstrzymuje lub wznawia system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberSignature Language="F#" Value="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " Usage="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik loguje się lub zamyka system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " Usage="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik próbuje się wylogować lub zamknąć system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest zdarzenie z możliwością anulowania. Ustawienie właściwości na `true` będzie żądać, aby sesja nadal działała. <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> Nie ma gwarancji, że sesja nie zostanie zakończona.  
  
 W przypadku korzystania <xref:Microsoft.Win32.SystemEvents.SessionEnding> z programu w formularzu systemu Windows w celu wykrycia wylogowania lub ponownego uruchomienia systemu nie istnieje jednoznaczny sposób decydowania <xref:System.Windows.Forms.Form.Closing> , czy zdarzenie zostanie wyzwolone przed tym zdarzeniem.  
  
 Jeśli chcesz wykonać pewne specjalne zadania przed uruchomieniem <xref:System.Windows.Forms.Form.Closing> , musisz upewnić się, że <xref:Microsoft.Win32.SystemEvents.SessionEnding> generowane wcześniej <xref:System.Windows.Forms.Form.Closing>. `WM_QUERYENDSESSION` W tym celu należy zastosować pułapki w formularzu, `WndProc` zastępując funkcję.  W tym przykładzie pokazano, jak to zrobić.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Aplikacje konsolowe nie zgłaszają <xref:Microsoft.Win32.SystemEvents.SessionEnding> zdarzenia.  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberSignature Language="F#" Value="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " Usage="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie aktualnie zalogowanego użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberSignature Language="F#" Value="member this.TimeChanged : EventHandler " Usage="member this.TimeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zmieni godzinę na zegarze systemowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberSignature Language="F#" Value="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " Usage="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po wygaśnięciu interwału czasomierza systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " Usage="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieni się preferencja użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " Usage="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieni się preferencja użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy jest uruchomiona pompa komunikatów. W usłudze systemu Windows, chyba że jest używany formularz ukryty lub pompa komunikatów została uruchomiona ręcznie, to zdarzenie nie zostanie zgłoszone. Przykładowy kod, który pokazuje, jak obsłużyć zdarzenia systemowe przy użyciu ukrytego formularza w usłudze systemu Windows, zobacz <xref:Microsoft.Win32.SystemEvents> Klasa.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób monitorowania <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> zdarzenia. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemowych nie są obsługiwane w bieżącym kontekście. Na przykład procesy serwera mogą nie obsługiwać globalnych powiadomień o zdarzeniach systemu.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzeń systemowych zakończyła się niepowodzeniem.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cb0e0a30ff4825d98f0e7d5c42f34b95733685f4" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52243124" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <TypeSignature Language="F#" Value="type SystemEvents = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia dostęp do powiadomień o zdarzeniach systemu. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.Win32.SystemEvents> Klasa udostępnia także zdolność do reagowania na określone typy zdarzeń systemu.  
  
 Gdy zostanie wywołane zdarzenie systemowe, wszelkie delegatów dołączona do zdarzenia są wywoływane, przy użyciu wątku, który monitoruje dla zdarzeń systemu. W związku z tym należy ustawić wszelkie wywołania z Twojej zdarzenie obsługi metodą o bezpiecznych wątkach. Jeśli potrzebne do wywoływania zdarzeń systemu, który nie jest uwidaczniana jako członek tej klasy, można użyć <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> metody.  
  
> [!CAUTION]
>  Nie należy wykonywać czasochłonne przetwarzania w wątku, który wywołuje program obsługi zdarzeń systemu, ponieważ może uniemożliwić, inne aplikacje, działanie.  
  
> [!NOTE]
>  Niektóre zdarzenia systemowe nie może zostać wywołane na [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Pamiętaj sprawdzić, czy aplikacja działa zgodnie z oczekiwaniami na [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady. Pierwszy przykład pokazuje, jak używać zdarzenia systemowe w zwykłych aplikacji, a drugi przykład przedstawia sposób użycia zdarzenia systemowe w usłudze Windows.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu rejestruje zainteresowanie niektóre zdarzenia systemowe, a następnie czeka na dowolne z tych zdarzeń, nastąpi. Wyświetlone dane wyjściowe występuje, gdy użytkownik zmieni rozdzielczość ekranu.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Przykład 2**  
  
 W poniższym przykładzie kodu pokazano bardzo prostą usługę Windows, który obsługuje <xref:Microsoft.Win32.SystemEvents.TimeChanged> i <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> zdarzenia. Przykład zawiera usługi o nazwie `SimpleService`, formularz o nazwie `HiddenForm`i Instalatora. Formularz udostępnia pętli komunikatów, wymaganego przez zdarzenia systemowe.  
  
> [!NOTE]
>  Usługi nie mają pętli komunikatów, chyba że mogą one wchodzić w interakcje z pulpitem. Jeśli pętli komunikatów nie zostanie podany przez formularz ukryte, jak w poniższym przykładzie, usługa musi być uruchamiana na koncie systemu lokalnego, a ręcznej interwencji jest wymagany do włączenia interakcji z pulpitem. Oznacza to, administrator musi ręcznie sprawdzać **Zezwalaj usłudze na współdziałanie z pulpitem** pole wyboru na **logowanie** karcie okna dialogowego właściwości usługi. W takim przypadku pętlę komunikatów jest dostarczana automatycznie. Ta opcja jest dostępna tylko wtedy, gdy usługa jest uruchamiane na koncie systemu lokalnego. Nie można programowo włączyć współdziałanie z pulpitem.  
  
 Usługi w tym przykładzie rozpoczyna się wątek, który uruchamia wystąpienie `HiddenForm`. Zdarzenia są podłączyłeś i obsługiwać w formularzu. Zdarzenia musi być podłączyłeś w przypadku ładowania formularza, aby upewnić się, że formularz jest całkowicie załadowany najpierw; w przeciwnym razie zdarzenia nie zostaną wywołane.  
  
> [!NOTE]
>  W przykładzie przedstawiono cały wymagany kod, w tym kod inicjujący formularza, które są zwykle generowane przez projektantów programu Visual Studio. Jeśli opracowujesz usługi, w programie Visual Studio, można pominąć drugi klasy częściowe i użyć **właściwości** okna, aby ustawić wysokość i szerokość ukryte formularza na wartość zero, styl obramowania do <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>i stanu okna do <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 Aby uruchomić przykład:  
  
1.  Skompilować kod w wierszu polecenia. To nazwa używana dla pliku źródłowego przez nie jest ważna.  
  
2.  Zainstaluj usługę z wiersza polecenia przy użyciu [Installutil.exe (Narzędzie Instalatora)](~/docs/framework/tools/installutil-exe-installer-tool.md) narzędzia. Na przykład `InstallUtil example.exe` Jeśli nazwa pliku źródłowego ma `example.cs` lub `example.vb`. Musi być administratorem, aby zainstalować usługę.  
  
3.  Aby uruchomić usługę, użyj konsoli usługi.  
  
4.  Zmiana czasu systemowego lub zmienić preferencje użytkownika, takie jak właściwości myszy.  
  
5.  Wyświetlanie komunikatów w **aplikacji** kategorii podglądu zdarzeń.  
  
6.  Aby zatrzymać usługę, użyj konsoli usługi.  
  
7.  Odinstaluj usługę z wiersza polecenia przy użyciu `/u` opcji. Na przykład `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać pełny dostęp do zasobów systemowych. Zapotrzebowanie wartości: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberSignature Language="F#" Value="static member CreateTimer : int -&gt; nativeint" Usage="Microsoft.Win32.SystemEvents.CreateTimer interval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Określa interwał między powiadomienia czasomierza w milisekundach.</param>
        <summary>Tworzy nowy czasomierz okna skojarzony z oknem zdarzeń systemu.</summary>
        <returns>Identyfikator nowego czasomierza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Interwał jest mniejsza lub równa zero.</exception>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się lub nie powiodła się próba utworzenia czasomierza.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanged : EventHandler " Usage="member this.DisplaySettingsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zmienia ustawienia wyświetlania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak monitorować <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> zdarzeń. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanging : EventHandler " Usage="member this.DisplaySettingsChanging : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieniane są ustawienia wyświetlania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberSignature Language="F#" Value="member this.EventsThreadShutdown : EventHandler " Usage="member this.EventsThreadShutdown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed zakończeniem wątku, który będzie nasłuchiwać pod kątem zdarzeń systemowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane, ponieważ wątek, który będzie nasłuchiwać pod kątem zdarzenia systemowe ma zostać zakończone. Delegatów zdarzeń systemowych są wywoływane za pomocą wątku, który będzie nasłuchiwać pod kątem zdarzeń systemowych.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberSignature Language="F#" Value="member this.InstalledFontsChanged : EventHandler " Usage="member this.InstalledFontsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik dodaje czcionki lub usuwa czcionek z systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="static member InvokeOnEventsThread : Delegate -&gt; unit" Usage="Microsoft.Win32.SystemEvents.InvokeOnEventsThread method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegat do wywołania, za pomocą wątku, który będzie nasłuchiwać pod kątem zdarzeń systemowych.</param>
        <summary>Wywołuje delegata określony za pomocą wątku, który będzie nasłuchiwać pod kątem zdarzeń systemowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć tej metody za każdym razem będzie konieczna Obsługa zdarzeń systemu, który nie jest uwidaczniana, w przeciwnym razie przez <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 Gdy ta metoda jest wywoływana, określonego delegata zostanie wywołany przez wątek, który używa aplikacji do przetwarzania zdarzeń systemowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberSignature Language="F#" Value="static member KillTimer : nativeint -&gt; unit" Usage="Microsoft.Win32.SystemEvents.KillTimer timerId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">Identyfikator czasomierza, aby zakończyć.</param>
        <summary>Kończy się czasomierz, określony przez dany identyfikator.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się lub nie powiodła się próba zakończenia czasomierza.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberSignature Language="F#" Value="member this.LowMemory : EventHandler " Usage="member this.LowMemory : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("This event has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy system zaczyna brakować dostępnej pamięci RAM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zawijany wiadomość WM_COMPACTING. Ta wiadomość jest wysyłana do wszystkich okien najwyższego poziomu, gdy system wykryje, że ponad 12,5 procent czasu systemowego przedziałach 30 i 60 sekund spędzania kompaktowania pamięci. Oznacza to, że system jest za mało pamięci.  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <block subset="none" type="usage">
          <para>Ten komunikat jest dostępna tylko dla zgodności z 16-bitowych aplikacji Windows.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberSignature Language="F#" Value="member this.PaletteChanged : EventHandler " Usage="member this.PaletteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przejdzie do aplikacji, która używa różnych palety.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak monitorować <xref:Microsoft.Win32.SystemEvents.PaletteChanged> zdarzeń. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberSignature Language="F#" Value="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " Usage="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik wstrzymuje lub wznawia działanie systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberSignature Language="F#" Value="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " Usage="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik jest wylogowania lub zamykania systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " Usage="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik próbuje się wylogować lub zamykania systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to zdarzenie można anulować. Ustawienie <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> właściwość `true` zażąda sesji kontynuuje działanie. Daje żadnej gwarancji, która nie powoduje zakończenia sesji.  
  
 Jeśli używasz <xref:Microsoft.Win32.SystemEvents.SessionEnding> w formularzu Windows wylogowaniu lub ponowne uruchomienie komputera, nie istnieje sposób deterministyczny zdecydować, czy <xref:System.Windows.Forms.Form.Closing> zdarzenia będą uruchamiane przed tym zdarzeniem.  
  
 Jeśli chcesz wykonać kilka zadań specjalnych przed <xref:System.Windows.Forms.Form.Closing> jest uruchamiany, należy upewnić się, że <xref:Microsoft.Win32.SystemEvents.SessionEnding> jest uruchamiany przed <xref:System.Windows.Forms.Form.Closing>. Aby to zrobić, musisz pułapki `WM_QUERYENDSESSION` w formularzu przez zastąpienie `WndProc` funkcji.  W tym przykładzie pokazano, jak to zrobić.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Aplikacje konsoli nie wywołuj <xref:Microsoft.Win32.SystemEvents.SessionEnding> zdarzeń.  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberSignature Language="F#" Value="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " Usage="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie aktualnie zalogowanego użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberSignature Language="F#" Value="member this.TimeChanged : EventHandler " Usage="member this.TimeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zmienia czas zegara systemowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberSignature Language="F#" Value="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " Usage="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wygasł interwału czasomierza systemu windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " Usage="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie preferencji użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " Usage="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmienia preferencje użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To zdarzenie jest wywoływane tylko wtedy, gdy działa "pompy komunikatów". W usłudze Windows chyba że używany jest ukryty formularz lub "pompy komunikatów" został uruchomiony ręcznie, to zdarzenie nie zostaną wywołane. Dla przykładu kodu, który pokazuje, jak obsługiwać zdarzenia systemowe za pomocą formularza ukryte w usłudze Windows, zobacz <xref:Microsoft.Win32.SystemEvents> klasy.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak monitorować <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> zdarzeń. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:Microsoft.Win32.SystemEvents> klasy.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiadomienia o zdarzeniach systemu nie są obsługiwane w bieżącym kontekście. Wartość procesów serwera, na przykład, może nie obsługiwać powiadomienia o zdarzeniach w globalnym systemie.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Próba utworzenia wątku okna zdarzenia systemowego nie powiodło się.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a2bacddb80f2006249ed7194edf1d3865804236" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69356867" /></Metadata><TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <TypeSignature Language="F#" Value="type IRecordSequence = interface&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia ogólny interfejs do sekwencji rekordów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.IRecordSequence> Interfejs udostępnia interfejs abstrakcyjny do strumienia zorientowanego na rekordy. <xref:System.IO.Log.IRecordSequence> Wystąpienie może służyć do odczytu i zapisu rekordów dzienników.  
  
 <xref:System.IO.Log.IRecordSequence> Interfejs zapewnia następujące możliwości:  
  
-   Dołącz rekordy dziennika przy użyciu <xref:System.IO.Log.IRecordSequence.Append%2A> metod.  
  
-   Odczytaj dołączone rekordy przy użyciu <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> metody.  
  
-   Napisz specjalny rekord ponownego uruchomienia przy użyciu <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> metody.  
  
-   Odczytaj rekordy ponownego uruchomienia od ostatnio zapisanego rekordu ponownego uruchomienia <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> przy użyciu metody.  
  
-   Opróżniaj rekordy do magazynu trwałego za <xref:System.IO.Log.IRecordSequence.Flush%2A> pomocą metody.  
  
-   Rezerwacja miejsca na dołączanie rekordów.  
  
-   Zwolnij miejsce w dzienniku, przenosząc podstawę dziennika.  
  
-   Odbieraj <xref:System.IO.Log.IRecordSequence.TailPinned> powiadomienia o zdarzeniach, aby przenieść bazę dziennika do wolnego miejsca.  
  
 Rekordy dziennika są dołączane do <xref:System.IO.Log.IRecordSequence> wystąpienia, a każdy rekord dziennika ma unikatowy numer sekwencyjny. Numery sekwencji są ściśle monotonicznie rosnące w obrębie danej sekwencji rekordów. Rekord dziennika składa się z nieprzezroczystych danych dostarczonych <xref:System.IO.Log.IRecordSequence> do wystąpienia <xref:System.Collections.IList> w ArraySegments bajtów.  
  
 <xref:System.IO.Log.IRecordSequence> Interfejs udostępnia również kilka podstawowych właściwości, które zawierają informacje o granicach dzienników.  
  
-   <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> Właściwość zawiera numer sekwencji pierwszego prawidłowego rekordu w sekwencji rekordów.  
  
-   <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> Właściwość zawiera numer sekwencyjny, który gwarantuje, że jest większy niż numer sekwencji ostatniego dołączonego rekordu.  
  
-   <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> Właściwość zawiera numer sekwencji ostatnio zapisywanego obszaru ponownego uruchomienia.  
  
-   <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> Właściwość zawiera rozmiar największego rekordu, do którego można dołączyć, lub odczytać z sekwencji.  
  
-   <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> Właściwość zawiera łączny rozmiar wszystkich rezerwacji wykonanych w tej sekwencji rekordów.  
  
-   Jeśli właściwość jest ustawiona na `true`, a <xref:System.IO.Log.IRecordSequence.Append%2A> operacja nie powiedzie się z powodu braku miejsca w sekwencji, sekwencja rekordów podejmie próbę zwolnienia miejsca, a następnie spróbuj ponownie wykonać operację dołączania. <xref:System.IO.Log.IRecordSequence.RetryAppend%2A>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="iRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Nowy numer sekwencyjnej sekwencji rekordu.</param>
        <summary>Przenosi numer sekwencji podstawowej dziennika do przodu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku użycia <xref:System.IO.Log.LogRecordSequence> wystąpienia i próby naliczania numeru sekwencyjnego w celu zwolnienia miejsca w dzienniku nowy podstawowy numer sekwencyjny musi znajdować się w innym zakresie dziennika dla poprzedniego zakresu, aby można go było oznaczyć jako pusty. Częściowe zwalnianie zakresów nie jest obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSequenceNumber" />nie jest aktywny w dzienniku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas modyfikowania sekwencji.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapisuje rekord dziennika do <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapisuje rekord dziennika do <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dołącza rekord dziennika do <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna być użyta dla tego rekordu.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dołącza rekord dziennika do <see cref="T:System.IO.Log.IRecordSequence" />, przy użyciu miejsca zarezerwowanych wcześniej w sekwencji.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Dołączony rekord będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji określonej przez `reservations` parametr. Jeśli dołączenie powiedzie się, będzie zużywać najmniejszy obszar rezerwacji, który może zawierać dane, i że obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna być użyta dla tego rekordu.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dołącza rekord dziennika do <see cref="T:System.IO.Log.IRecordSequence" />, przy użyciu miejsca zarezerwowanych wcześniej w sekwencji.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Dołączony rekord będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji określonej przez `reservations` parametr. Jeśli dołączenie powiedzie się, będzie zużywać najmniejszy obszar rezerwacji, który może zawierać dane, i że obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, Pobiera numer sekwencyjny pierwszego prawidłowego rekordu w bieżącym <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <value>Najniższy numer sekwencyjny odpowiadający prawidłowemu rekordowi w <see cref="T:System.IO.Log.IRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poprawne numery sekwencji są większe lub równe <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> i mniejsze niż. <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>  
  
 Wartość tej właściwości można zmienić przez wywołanie <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> metody lub. <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna asynchroniczne operacje dołączania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna asynchroniczne operacje dołączania.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje dołączenie asynchroniczne, które nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.IRecordSequence.EndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna asynchroniczne operacje dołączania przy użyciu miejsca, które zostało wcześniej zarezerwowane w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje dołączenie asynchroniczne, które nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.IRecordSequence.EndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna być użyta dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna asynchroniczne operacje dołączania przy użyciu miejsca, które zostało wcześniej zarezerwowane w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje dołączenie asynchroniczne, które nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.IRecordSequence.EndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Dołączony rekord będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji określonej przez `reservations` parametr. Jeśli dołączenie powiedzie się, będzie zużywać najmniejszy obszar rezerwacji, który może zawierać dane, i że obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousUndoRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousUndoRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna być użyta dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna asynchroniczne operacje dołączania przy użyciu miejsca, które zostało wcześniej zarezerwowane w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje dołączenie asynchroniczne, które nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.IRecordSequence.EndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Dołączony rekord będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji określonej przez `reservations` parametr. Jeśli dołączenie powiedzie się, będzie zużywać najmniejszy obszar rezerwacji, który może zawierać dane, i że obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji dla najnowszego rekordu, który musi zostać zapisany. Jeśli jest <see cref="T:System.IO.Log.SequenceNumber" /> to nieprawidłowe, należy napisać wszystkie rekordy.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu opróżniania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to określone asynchroniczne żądanie opróżniania z innych żądań.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna asynchroniczne operacje opróżniania przy użyciu miejsca, które zostało wcześniej zarezerwowane w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje asynchroniczną operację opróżniania, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwróconą przez bieżącą metodę <xref:System.IO.Log.IRecordSequence.EndFlush%2A> do metody, aby upewnić się, że opróżnianie i zasoby zostały odpowiednio zwolnione. Jeśli wystąpi błąd podczas asynchronicznego opróżniania, wyjątek nie zostanie zgłoszony, dopóki <xref:System.IO.Log.IRecordSequence.EndFlush%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z zwracanym przez tę metodę.  
  
 Wywołanie tej metody zapewnia, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.IRecordSequence> trwale są zapisywane.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania opróżniania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków w przypadku <xref:System.IO.Log.IRecordSequence.EndFlush%2A> wywołania metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna rezerwę asynchroniczną i operację dołączania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservationCollection">Kolekcja rezerwacji, w której mają zostać wprowadzone rezerwacje.</param>
        <param name="reservations">Rezerwacje do wprowadzenia w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna rezerwę asynchroniczną i operację dołączania.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje tę operację asynchroniczną, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Określone rezerwacje są dodawane do podanej kolekcji rezerwacji w operacji niepodzielnej przy użyciu operacji dołączania rekordu. Jeśli dołączenie nie powiedzie się, żadne miejsce nie jest zarezerwowane.  
  
 Zwykle ta metoda może zostać zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord lub dokonać rezerwacji.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservationCollection">Kolekcja rezerwacji, w której mają zostać wprowadzone rezerwacje.</param>
        <param name="reservations">Rezerwacje do wprowadzenia w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna rezerwę asynchroniczną i operację dołączania.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje tę operację asynchroniczną, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Określone rezerwacje są dodawane do podanej kolekcji rezerwacji w operacji niepodzielnej przy użyciu operacji dołączania rekordu. Jeśli dołączenie nie powiedzie się, żadne miejsce nie jest zarezerwowane.  
  
 Zwykle ta metoda może zostać zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord lub dokonać rezerwacji.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna operację zapisu w obszarze asynchronicznych ponownych uruchomień.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <param name="reservation">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna zostać użyta dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma zostać wywołane po zakończeniu zapisu w obszarze ponownego uruchomienia.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie zapisu w obszarze ponownego uruchamiania z innych żądań.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna operację zapisu w obszarze asynchronicznych ponownych uruchomień przy użyciu miejsca, które zostało wcześniej zarezerwowane w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje operację zapisu w obszarze asynchronicznych ponownych uruchomień, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> metodę, aby upewnić się, że operacja zapisu w obszarze ponownego uruchomienia została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas operacji zapisu w obszarze asynchronicznych ponownych uruchomień, wyjątek nie zostanie wygenerowany <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> , dopóki metoda nie zostanie <xref:System.IAsyncResult> wywołana z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 <xref:System.IO.Log.ReservationCollection> Jeśli jest określony, zapisany obszar ponownego uruchomienia będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji zawartej w kolekcji. Jeśli metoda zakończy się pomyślnie, użyje najmniejszej rezerwacji, która może przechowywać dane i że rezerwacja zostanie usunięta z kolekcji.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <param name="reservation">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna zostać użyta dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma zostać wywołane po zakończeniu zapisu w obszarze ponownego uruchomienia.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie zapisu w obszarze ponownego uruchamiania z innych żądań.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rozpoczyna operację zapisu w obszarze asynchronicznych ponownych uruchomień przy użyciu miejsca, które zostało wcześniej zarezerwowane w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje operację zapisu w obszarze asynchronicznych ponownych uruchomień, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> metodę, aby upewnić się, że operacja zapisu w obszarze ponownego uruchomienia została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas operacji zapisu w obszarze asynchronicznych ponownych uruchomień, wyjątek nie zostanie wygenerowany <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> , dopóki metoda nie zostanie <xref:System.IAsyncResult> wywołana z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 <xref:System.IO.Log.ReservationCollection> Jeśli jest określony, zapisany obszar ponownego uruchomienia będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji zawartej w kolekcji. Jeśli metoda zakończy się pomyślnie, użyje najmniejszej rezerwacji, która może przechowywać dane i że rezerwacja zostanie usunięta z kolekcji.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas zapisywania obszaru ponownego uruchomienia.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="iRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, tworzy nową <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <returns>Nowo utworzony <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekującego żądania asynchroniczne we/wy.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, Kończenie asynchronicznej operacji dołączania.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy. Błędy występujące podczas asynchronicznego żądania zapisu, takie jak awaria dysku w żądaniu we/wy, stają się widoczne po <xref:System.IO.Log.IRecordSequence.EndAppend%2A> wywołaniu.  
  
 Ta metoda musi być wywoływana dokładnie raz na każdym <xref:System.IAsyncResult> zwracanym <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> przez metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekującego żądania asynchroniczne we/wy.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, Kończenie asynchronicznej operacji opróżniania.</summary>
        <returns>Numer sekwencji ostatniego zapisywanego rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy. Błędy występujące podczas asynchronicznego żądania opróżniania, takie jak awaria dysku w żądaniu we/wy, stają się widoczne po <xref:System.IO.Log.IRecordSequence.EndFlush%2A> wywołaniu.  
  
 Ta metoda musi być wywoływana dokładnie raz na każdym <xref:System.IAsyncResult> zwracanym <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> przez metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekującego żądania asynchroniczne we/wy.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, końcowa rezerwa asynchroniczna i operacja dołączania.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy. Błędy występujące podczas asynchronicznego żądania zapisu, takie jak awaria dysku w żądaniu we/wy, stają się widoczne po <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> wywołaniu.  
  
 Ta metoda musi być wywoływana dokładnie raz na każdym <xref:System.IAsyncResult> zwracanym <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> przez metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekującego żądania asynchroniczne we/wy.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zamyka operację zapisu w obszarze asynchronicznego ponownego uruchomienia.</summary>
        <returns>Numer sekwencyjny zapisywanego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy. Błędy występujące podczas asynchronicznego żądania zapisu, takie jak awaria dysku w żądaniu we/wy, stają się widoczne po <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> wywołaniu.  
  
 Ta metoda musi być wywoływana dokładnie raz na każdym <xref:System.IAsyncResult> zwracanym <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> przez metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, powoduje to zapisanie dołączonych rekordów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapewnia, że zostały zapisane wszystkie dołączone rekordy.</summary>
        <returns>Numer sekwencji ostatniego zapisywanego rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody zapewnia, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.IRecordSequence> trwale zostały zapisane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji dla najnowszego rekordu, który musi zostać zapisany. Jeśli jest <see cref="T:System.IO.Log.SequenceNumber" /> to nieprawidłowe, należy napisać wszystkie rekordy.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapewnia, że wszystkie dołączone rekordy do i włącznie z rekordem o określonym numerze sekwencyjnym zostały trwale zapisane.</summary>
        <returns>Numer sekwencji ostatniego zapisywanego rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody zapewnia, że wszystkie rekordy z numerami sekwencji do i włącznie z określonym numerem sekwencyjnym zostały trwale zapisane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, Pobiera numer sekwencyjny, który jest większy niż ostatni dołączony rekord.</summary>
        <value>Numer sekwencyjny, który jest większy od ostatniego dołączonego rekordu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera numer sekwencyjny, który gwarantuje, że jest większy niż numer sekwencji ostatniego dołączonego rekordu. Poprawne numery sekwencji są większe lub równe <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> i mniejsze niż. <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>  
  
> [!NOTE]
>  <xref:System.IO.Log.LogRecordSequence> W<xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> przypadku użycia wystąpienia wartość może stać się nieaktualna, dopóki rekordy nie zostaną opróżnione do dziennika. Zobacz <xref:System.IO.Log.IRecordSequence.Flush%2A> i <xref:System.IO.Log.RecordAppendOptions> , aby uzyskać więcej informacji dotyczących opróżniania rekordów. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera rozmiar największego rekordu, który może być dołączany lub odczytywany z tej sekwencji, w bajtach.</summary>
        <value>Rozmiar największego rekordu, który może być dołączany lub odczytywany z tej sekwencji, w bajtach.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Numer sekwencyjny pierwszego rekordu, w którym rozpocznie się odczytywanie.</param>
        <param name="logRecordEnum">Prawidłowa <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> wartość określająca sposób (czyli do przodu lub do tyłu), w której rekordy mają być odczytywane <see cref="T:System.IO.Log.LogRecordSequence" />z.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca wyliczalną kolekcję rekordów w sekwencji.</summary>
        <returns>Wyliczalna kolekcja rekordów w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy jest zastępowany w klasie pochodnej, zwraca wyliczalną kolekcję rekordów w sekwencji. Kolejność rekordów wyliczanych zależy od wartości `logRecordEnum` parametru.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> metody.  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas odczytywania rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca wyliczalną kolekcję obszarów ponownego uruchomienia w sekwencji.</summary>
        <returns>Wyliczalna kolekcja obszarów ponownego uruchomienia w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszary ponownego uruchomienia są wyliczane w odwrotnej kolejności numerów sekwencyjnych, czyli od najwyższego numeru sekwencyjnego na najniższy numer sekwencyjny. Należy wyliczyć tylko obszary z numerami sekwencyjnymi między ostatnim numerem sekwencyjnym a numerem sekwencyjnym.  
  
> [!NOTE]
>  Jeśli zakres dziennika zawierający <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> ulegnie uszkodzeniu, ta metoda może <xref:System.IO.IOException> zgłosić komunikat o błędzie "nie można wykonać żądania z powodu nieoczekiwanego wyjątku operacji we/wy. Został zwrócony następujący kod błędu: "80070026" ".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas odczytywania rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, automatycznie dokonuje pojedynczej rezerwacji i dołącza rekord do sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera kolekcję, w której będą wprowadzane rezerwacje.</param>
        <param name="reservations">Rezerwacje do wprowadzenia w bajtach.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, automatycznie dokonuje pojedynczej rezerwacji i dołącza rekord do sekwencji.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Określone rezerwacje są dodawane do podanej kolekcji rezerwacji w operacji niepodzielnej przy użyciu operacji dołączania rekordu. Jeśli dołączenie nie powiedzie się, żadne miejsce nie jest zarezerwowane.  
  
 Zwykle ta metoda może zostać zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord lub dokonać rezerwacji.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservationCollection">Kolekcja rezerwacji, w której mają zostać wprowadzone rezerwacje.</param>
        <param name="reservations">Rezerwacje do wprowadzenia w bajtach.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, automatycznie dokonuje pojedynczej rezerwacji i dołącza rekord do sekwencji.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Określone rezerwacje są dodawane do podanej kolekcji rezerwacji w operacji niepodzielnej przy użyciu operacji dołączania rekordu. Jeśli dołączenie nie powiedzie się, żadne miejsce nie jest zarezerwowane.  
  
 Zwykle ta metoda może zostać zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.IRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy rekord lub dokonać rezerwacji.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera łączną liczbę bajtów, które zostały zarezerwowane.</summary>
        <value>Łączny rozmiar wszystkich rezerwacji wykonanych w tej sekwencji rekordów.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej pobiera numer sekwencji ostatnio zapisywanego obszaru ponownego uruchomienia.</summary>
        <value>Numer sekwencji ostatnio zapisywanego obszaru ponownego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchomienia jest używany do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można przeanalizować obszar ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dołączenia są automatycznie ponawiane, jeśli dziennik jest pełny.</summary>
        <value><see langword="true" />Jeśli dołączenia są automatycznie ponawiane, jeśli dziennik jest pełny; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest `true`, <xref:System.IO.Log.IRecordSequence.Append%2A> a wywołanie nie powiedzie się, ponieważ nie ma wystarczającej ilości miejsca w sekwencji, sekwencja rekordów spróbuje zwolnić miejsce i ponowić próbę dołączenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy sekwencja rekordów określa, że końcówka musi zostać przeniesiona do przodu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie można wywołać, gdy w sekwencji rekordów zabrakło wolnego miejsca. Po uruchomieniu tego zdarzenia ogon sekwencji (czyli numer sekwencyjny) jest przenoszony do przodu w celu zwolnienia miejsca.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, program zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.IRecordSequence" />do.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchomienia jest używany do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można przeanalizować obszar ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania. Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.IRecordSequence" />do.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchomienia jest używany do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Common Log File System (CLFS) utrzymuje dwa obszary ponownego uruchomienia w celu zagwarantowania, że co najmniej jeden prawidłowy obszar jest zawsze dostępny. Gdy wymagane jest odzyskanie, CLFS odczytuje jego obszar ponownego uruchomienia i wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtowej zostaną połączone w tablicę jednobajtową w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas zapisywania obszaru ponownego uruchomienia.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.IRecordSequence" />do.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchomienia jest używany do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można przeanalizować obszar ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania. Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtowej zostaną połączone w tablicę jednobajtową w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas zapisywania obszaru ponownego uruchomienia.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapisuje obszar ponownego uruchomienia do <see cref="T:System.IO.Log.IRecordSequence" /> i aktualizuje numer sekwencyjny.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchomienia jest używany do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można przeanalizować obszar ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania. Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Po zapisaniu obszaru ponownego uruchamiania dane w segmentach tablicy bajtowej są łączone do tablicy jednobajtowej w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 Po pomyślnym zakończeniu tej metody numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas zapisywania obszaru ponownego uruchomienia.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.IRecordSequence" /> do i aktualizuje numer sekwencyjny.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchomienia jest używany do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można przeanalizować obszar ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania. Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Po zapisaniu obszaru ponownego uruchamiania dane w segmentach tablicy bajtowej są łączone do tablicy jednobajtowej w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 Po pomyślnym zakończeniu tej metody numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas zapisywania obszaru ponownego uruchomienia.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <param name="reservation">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna zostać użyta dla tego obszaru ponownego uruchomienia.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapisuje obszar ponownego uruchomienia w <see cref="T:System.IO.Log.IRecordSequence" /> ramach rezerwacji przy użyciu i aktualizuje numer sekwencyjny.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchomienia jest używany do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można przeanalizować obszar ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania. Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Po zapisaniu obszaru ponownego uruchamiania dane w segmentach tablicy bajtowej są łączone do tablicy jednobajtowej w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 W przypadku określenia rezerwacji, zapisany obszar ponownego uruchomienia będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji zawartej w kolekcji. Jeśli metoda zakończy się pomyślnie, użyje najmniejszej rezerwacji, która może zawierać dane, i że rezerwacja zostanie usunięta z kolekcji.  
  
 Po pomyślnym zakończeniu tej metody numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas zapisywania obszaru ponownego uruchomienia.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <param name="reservation">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna zostać użyta dla tego obszaru ponownego uruchomienia.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.IRecordSequence" /> w ramach rezerwacji przy użyciu i aktualizuje numer sekwencyjny.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchomienia jest używany do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można przeanalizować obszar ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania. Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Po zapisaniu obszaru ponownego uruchamiania dane w segmentach tablicy bajtowej są łączone do tablicy jednobajtowej w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 W przypadku określenia rezerwacji, zapisany obszar ponownego uruchomienia będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji zawartej w kolekcji. Jeśli metoda zakończy się pomyślnie, użyje najmniejszej rezerwacji, która może zawierać dane, i że rezerwacja zostanie usunięta z kolekcji.  
  
 Po pomyślnym zakończeniu tej metody numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas zapisywania obszaru ponownego uruchomienia.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie może wykonać wystarczającej ilości wolnego miejsca, aby można było zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6260e0146911a1dbb9e8df4620ffe2a357e6709f" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37654495" /></Metadata><TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <TypeSignature Language="F#" Value="type IRecordSequence = interface&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia ogólny interfejs do sekwencji rekordów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.IRecordSequence> Interfejs zapewnia abstrakcyjny interfejs do strumienia zorientowane. A <xref:System.IO.Log.IRecordSequence> wystąpienia może służyć do odczytywania i zapisywania rekordów dziennika.  
  
 <xref:System.IO.Log.IRecordSequence> Interfejs zapewnia następujące możliwości  
  
-   Dołącz rekordów dziennika przy użyciu <xref:System.IO.Log.IRecordSequence.Append%2A> metody.  
  
-   Przeczytaj dołączane rekordy przy użyciu <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> metody.  
  
-   Ponowne uruchomienie specjalnego rekordu przy użyciu <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> metody.  
  
-   Odczytaj, uruchom ponownie rekordy z niedawno napisanych ponowne uruchomienie rekordu przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
-   Flush rekordy do korzystania z magazynu trwałego <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
-   Zarezerwuj miejsce na potrzeby dołączania rekordów.  
  
-   Miejsca w dzienniku bezpłatne przez przesuwania base dziennika.  
  
-   Odbieranie <xref:System.IO.Log.IRecordSequence.TailPinned> powiadomienia o zdarzeniach można przenieść base dziennika, aby zwolnić miejsce.  
  
 Rekordy dziennika są dołączane do <xref:System.IO.Log.IRecordSequence> wystąpienie, a każdy rekord dziennika otrzymuje unikatowy numer kolejny. Numery sekwencyjne ściśle monotonicznie coraz więcej w ramach sekwencji danego rekordu. Rekord dziennika składa się z nieprzezroczyste dane, do <xref:System.IO.Log.IRecordSequence> wystąpienia w <xref:System.Collections.IList> z ArraySegments bajtów.  
  
 <xref:System.IO.Log.IRecordSequence> Interfejsu udostępnia również kilka właściwości podstawowe którym znajdują się informacje o granicach dziennika.  
  
-   <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> Właściwość zawiera numer sekwencyjny pierwszy rekord Nieprawidłowa sekwencja rekordów.  
  
-   <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> Właściwość zawiera numer sekwencji, która może być większa niż liczba sekwencji ostatniej dołączany rekordu.  
  
-   <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> Właściwość zawiera numer sekwencyjny ostatniego obszaru napisane ponownego uruchomienia.  
  
-   <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> Właściwość zawiera rozmiar największego rekordu, które mogą być dołączane do lub odczytywanie sekwencji.  
  
-   <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> Właściwość zawiera łączny rozmiar wszystkich rezerwacji dokonanych w tej sekwencji rekordów.  
  
-   Jeśli <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> właściwość jest ustawiona na `true`i <xref:System.IO.Log.IRecordSequence.Append%2A> operacja zakończy się niepowodzeniem, ponieważ nie ma już miejsca w sekwencji, sekwencja rekordów podejmie próbę wolnego miejsca, a następnie ponów próbę wykonania operacji dołączania.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="iRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Nowy numer sekwencji podstawowy sekwencja rekordów.</param>
        <summary>Przenosi do przodu numer podstawowy sekwencyjny dziennika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy używasz <xref:System.IO.Log.LogRecordSequence> wystąpienie i spróbuj, aby awansować numer sekwencyjny w celu zwolnienia miejsca w dzienniku nowy numer sekwencji podstawowy musi znajdować się w w zakresie innym dzienniku dla poprzedniej, w jakim można oznaczyć jako pusta. Zwalnianie częściowo zakresów nie jest obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSequenceNumber" /> nie jest aktywny w dzienniku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas modyfikowania sekwencji.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje rekord do <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje rekord do <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, w celu uwzględnienia nowego rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dołącza rekordu dziennika, aby <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, w celu uwzględnienia nowego rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservations">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego rekordu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dołącza rekordu dziennika, aby <see cref="T:System.IO.Log.IRecordSequence" />, przy użyciu wcześniej zastrzeżonej w sekwencji.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Rekord dołączonych zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, będą wymagały najmniejszy obszaru rezerwacji, może przechowywać dane, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, w celu uwzględnienia nowego rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservations">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego rekordu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dołącza rekordu dziennika, aby <see cref="T:System.IO.Log.IRecordSequence" />, przy użyciu wcześniej zastrzeżonej w sekwencji.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Rekord dołączonych zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, będą wymagały najmniejszy obszaru rezerwacji, może przechowywać dane, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, w celu uwzględnienia nowego rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, pobiera numer sekwencyjny pierwszy rekord prawidłowe w bieżącym <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <value>Najniższy numer sekwencji, która odpowiada prawidłowy rekord w <see cref="T:System.IO.Log.IRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowych numerów sekwencji jest większa lub równa <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> i mniej niż <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
 Wartość tej właściwości można zmienić, wywołując <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> lub <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchronicznej operacji dołączania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchronicznej operacji dołączania.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentująca asynchroniczną append, przez co mogą nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, w celu uwzględnienia nowego rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchronicznego Dołącz operację, za pomocą wcześniej zastrzeżonej w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentująca asynchroniczną append, przez co mogą nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, w celu uwzględnienia nowego rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservations">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchronicznego Dołącz operację przy użyciu wcześniej zastrzeżonej w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentująca asynchroniczną append, przez co mogą nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Rekord dołączonych zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, będą wymagały najmniejszy obszaru rezerwacji, może przechowywać dane, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, w celu uwzględnienia nowego rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousUndoRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousUndoRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservations">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchronicznego Dołącz operację, za pomocą wcześniej zastrzeżonej w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentująca asynchroniczną append, przez co mogą nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Rekord dołączonych zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, będą wymagały najmniejszy obszaru rezerwacji, może przechowywać dane, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, w celu uwzględnienia nowego rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji jest najnowszy rekord, który musi być napisany. Jeśli ten <see cref="T:System.IO.Log.SequenceNumber" /> jest nieprawidłowy, a następnie wszystkie rekordy, które muszą być napisane.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu pracy opróżniania.</param>
        <param name="state">Obiekt dostarczony przez użytkownika, który odróżnia to asynchroniczne żądanie opróżnienia od innych żądań.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna operację asynchroniczną opróżniania, przy użyciu wcześniej zastrzeżonej w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Czy reprezentuje asynchroniczną opróżniania operacji, która może nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracany przez metodę bieżącego do <xref:System.IO.Log.IRecordSequence.EndFlush%2A> metody, aby upewnić się, że opróżnienie zakończy i zasoby są zwalniane odpowiednio. Jeśli wystąpi błąd podczas asynchronicznego opróżniania, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndFlush%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.IRecordSequence> trwale są zapisywane.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchronicznego opróżniania, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.IRecordSequence.EndFlush%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchronicznego rezerwy i operację dołączania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservationCollection">Kolekcja rezerwacji się rezerwacje WE.</param>
        <param name="reservations">Rezerwacje, aby upewnić się, w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchronicznego rezerwy i operację dołączania.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentujący operację asynchroniczną, która może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacje są dodawane do podana Rezerwacja operację dołączania kolekcji w operacją niepodzielną przy użyciu rekordu. W przypadku niepowodzenia dołączenia miejsce nie jest zarezerwowana.  
  
 Zazwyczaj ta metoda może wykonać, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, aby zawierała nowy rekord lub aby wprowadzić zastrzeżenie.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservationCollection">Kolekcja rezerwacji się rezerwacje WE.</param>
        <param name="reservations">Rezerwacje, aby upewnić się, w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchronicznego rezerwy i operację dołączania.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentujący operację asynchroniczną, która może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacje są dodawane do podana Rezerwacja operację dołączania kolekcji w operacją niepodzielną przy użyciu rekordu. W przypadku niepowodzenia dołączenia miejsce nie jest zarezerwowana.  
  
 Zazwyczaj ta metoda może wykonać, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, aby zawierała nowy rekord lub aby wprowadzić zastrzeżenie.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się operacja zapisu obszaru asynchronicznego ponownego uruchomienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <param name="reservation">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia.</param>
        <param name="state">Obiekt dostarczony przez użytkownika odróżniająca określonego asynchronicznego ponowne uruchomienie zapisu obszaru z innych żądań.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się operacja zapisu obszaru asynchronicznego ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Czy reprezentuje asynchroniczną ponownie uruchomić operację zapisu obszar, który może nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> metody, aby zapewnić, że operacja zapisu obszaru ponowne uruchomienie zostało ukończone i zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchronicznego ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli <xref:System.IO.Log.ReservationCollection> określono obszaru napisane ponownego uruchamiania zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji znajdujących się w kolekcji. Jeśli metoda się powiedzie, zużyje najmniejszy rezerwacji, który może zawierać dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <param name="reservation">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia.</param>
        <param name="state">Obiekt dostarczony przez użytkownika odróżniająca określonego asynchronicznego ponowne uruchomienie zapisu obszaru z innych żądań.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się operacja zapisu obszaru asynchronicznego ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Czy reprezentuje asynchroniczną ponownie uruchomić operację zapisu obszar, który może nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> metody, aby upewnić się, czy ponowne uruchomienie obszaru zapisu operacji i zasobów, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchronicznego ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli <xref:System.IO.Log.ReservationCollection> określono obszaru napisane ponownego uruchamiania zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji znajdujących się w kolekcji. Jeśli metoda się powiedzie, zużyje najmniejszy rezerwacji, który może zawierać dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, w celu uwzględnienia nowego rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="iRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy nowe <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <returns>Nowo utworzony <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do zaległe asynchroniczne żądanie operacji We/Wy.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, kończy się asynchroniczne Dołącz operacji.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie przed ukończeniem operacji We/Wy. Błędy występujące podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy, stanie się widoczna gdy <xref:System.IO.Log.IRecordSequence.EndAppend%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz na każdym <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do zaległe asynchroniczne żądanie operacji We/Wy.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, kończy się opróżniania operację asynchroniczną.</summary>
        <returns>Numer sekwencyjny ostatniego rekordu, które są zapisywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie przed ukończeniem operacji We/Wy. Błędy występujące podczas opróżniania żądania asynchronicznego, takiej jak awaria dysku podczas wykonywania żądania We/Wy, stanie się widoczna gdy <xref:System.IO.Log.IRecordSequence.EndFlush%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz na każdym <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do zaległe asynchroniczne żądanie operacji We/Wy.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, kończy się asynchroniczne zarezerwować i Dołącz operacji.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie przed ukończeniem operacji We/Wy. Błędy występujące podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy, stanie się widoczna gdy <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz na każdym <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do zaległe asynchroniczne żądanie operacji We/Wy.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, kończy się operacji zapisu obszaru asynchronicznego ponownego uruchamiania.</summary>
        <returns>Numer sekwencji rekordu dziennika napisane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie przed ukończeniem operacji We/Wy. Błędy występujące podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy, stanie się widoczna gdy <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz na każdym <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, powoduje, że dołączana rekordów do zapisania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapewnia zapisanych wszystkich dołączonych rekordów.</summary>
        <returns>Numer sekwencyjny ostatniego rekordu, które są zapisywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.IRecordSequence> został trwale zapisany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji jest najnowszy rekord, który musi być napisany. Jeśli ten <see cref="T:System.IO.Log.SequenceNumber" /> jest nieprawidłowy, a następnie wszystkie rekordy, które muszą być napisane.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, gwarantuje, że wszystkie dołączone, w tym rekord o określony numer sekwencji trwale zapisanych rekordów.</summary>
        <returns>Numer sekwencyjny ostatniego rekordu, które są zapisywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody powoduje do liczby wszystkich rekordów z sekwencji, w tym określony numer sekwencji trwale zapisanych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera numer sekwencyjny która jest większa niż ostatni rekord dołączane.</summary>
        <value>Numer sekwencji, która jest większa niż ostatni rekord dołączane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera numer sekwencji, która może być większa niż liczba sekwencji ostatniej dołączany rekordu. Prawidłowych numerów sekwencji jest większa lub równa <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> i mniej niż <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
> [!NOTE]
>  Korzystając z <xref:System.IO.Log.LogRecordSequence> wypadku <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> wartość może stać się nieaktualna aż rekordy zostały przesłane do dziennika. Zobacz <xref:System.IO.Log.IRecordSequence.Flush%2A> i <xref:System.IO.Log.RecordAppendOptions> więcej informacji na temat opróżnianie rekordów...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera rozmiar największego rekord, który może być dołączane do lub odczytywanie sekwencji, w bajtach.</summary>
        <value>Rozmiar największego rekord, który może być dołączane do lub odczytywanie sekwencji, w bajtach.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Numer sekwencji pierwszego rekordu, w którym rozpoczyna się odczytywanie.</param>
        <param name="logRecordEnum">Nieprawidłowy <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> wartość, która określa sposób (to znaczy, do przodu lub do tyłu) w rekordy, które są odczytywane z <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zwraca wyliczalny zbiór rekordów w sekwencji.</summary>
        <returns>Wyliczalne zbiór rekordów w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku przesłonięcia w klasie pochodnej, zwraca wyliczalny zbiór rekordów w sekwencji. Kolejność rekordów wyliczany zależy od wartości `logRecordEnum` parametru.  
  
   
  
## Examples  
 Ten przykład demonstruje użycie <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> metody.  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas odczytu rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zwraca wyliczalny zbiór obszarów ponowne uruchomienie w sekwencji.</summary>
        <returns>Wyliczalne kolekcja obszarów ponowne uruchomienie w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszary ponownego uruchamiania są wyliczane w kolejności odwrotnej kolejności, oznacza to, z najwyższy numer sekwencyjny najniższy numer sekwencji. Tylko ponownie obszarów numerami sekwencji między ostatni numer sekwencji i numer sekwencyjny podstawowej są wyliczane.  
  
> [!NOTE]
>  Jeśli dziennik zawierający zakres <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> staje się uszkodzony, ta metoda może zgłosić <xref:System.IO.IOException> z komunikatem o błędzie "nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy. Został zwrócony kod błędu: "80070026" ".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas odczytu rekordu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, sprawia, że pojedynczy rezerwacji i automatycznie dołącza rekord do sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> , która zawiera kolekcję się rezerwacje WE.</param>
        <param name="reservations">Rezerwacje, aby upewnić się, w bajtach.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, sprawia, że pojedynczy rezerwacji i automatycznie dołącza rekord do sekwencji.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacje są dodawane do podana Rezerwacja operację dołączania kolekcji w operacją niepodzielną przy użyciu rekordu. W przypadku niepowodzenia dołączenia miejsce nie jest zarezerwowana.  
  
 Zazwyczaj ta metoda może wykonać, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, aby zawierała nowy rekord lub aby wprowadzić zastrzeżenie.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservationCollection">Kolekcja rezerwacji się rezerwacje WE.</param>
        <param name="reservations">Rezerwacje, aby upewnić się, w bajtach.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, sprawia, że pojedynczy rezerwacji i automatycznie dołącza rekord do sekwencji.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacje są dodawane do podana Rezerwacja operację dołączania kolekcji w operacją niepodzielną przy użyciu rekordu. W przypadku niepowodzenia dołączenia miejsce nie jest zarezerwowana.  
  
 Zazwyczaj ta metoda może wykonać, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, aby zawierała nowy rekord lub aby wprowadzić zastrzeżenie.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera całkowita liczba bajtów, które zostały zarezerwowane.</summary>
        <value>Całkowity rozmiar wszystkich rezerwacji dokonanych w tej sekwencji rekordów.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera numer sekwencyjny niedawno napisanych obszaru ponownego uruchomienia.</summary>
        <value>Numer sekwencyjny najbardziej niedawno pisemnego ponownie obszar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Podczas odzyskiwania jest to konieczne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony.</summary>
        <value><see langword="true" /> Jeśli dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest `true`i <xref:System.IO.Log.IRecordSequence.Append%2A> połączenie nie powiedzie się, ponieważ nie jest wystarczająca ilość miejsca w sekwencji, sekwencja rekordów podejmie próbę wolne miejsce i ponowić próbę dołączenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rekord sekwencji Określa, że ogona musi zostać przeniesiona do przodu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można uruchomić tego zdarzenia, kiedy sekwencji rekord ma za mało miejsca. To zdarzenie jest wywoływane, ogona sekwencji (czyli numer sekwencyjny podstawowy) jest przenoszony do przodu w celu zwolnienia miejsca.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Podczas odzyskiwania jest to konieczne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania. Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Typowe Log File System (CLFS) obsługuje dwa obszary, które gwarantuje, że co najmniej jeden prawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest to konieczne, CLFS odczytuje obszaru jego ponowne uruchomienie i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtów zostanie połączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Podczas odzyskiwania jest to konieczne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania. Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtów zostanie połączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje obszaru ponownego uruchomienia, aby <see cref="T:System.IO.Log.IRecordSequence" /> i aktualizuje numer sekwencyjny podstawowy</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Podczas odzyskiwania jest to konieczne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania. Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Przy zapisywaniu obszaru ponownego uruchamiania danych w segmentach tablicy bajtów są łączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 Po pomyślnym ukończeniu tej metody został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje obszaru ponownego uruchomienia, aby <see cref="T:System.IO.Log.IRecordSequence" /> i aktualizuje numer podstawowy sekwencyjny.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Podczas odzyskiwania jest to konieczne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania. Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Przy zapisywaniu obszaru ponownego uruchamiania danych w segmentach tablicy bajtów są łączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 Po pomyślnym ukończeniu tej metody został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <param name="reservation">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje obszaru ponownego uruchomienia, aby <see cref="T:System.IO.Log.IRecordSequence" /> za pomocą rezerwacji, a następnie aktualizuje numer sekwencyjny podstawowy</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Podczas odzyskiwania jest to konieczne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania. Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Przy zapisywaniu obszaru ponownego uruchamiania danych w segmentach tablicy bajtów są łączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 Jeśli rezerwacja jest określony, obszar napisane ponownego uruchamiania zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji znajdujących się w kolekcji. Jeśli metoda się powiedzie, zużyje najmniejszą rezerwacji, który może zawierać dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Po pomyślnym ukończeniu tej metody został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSequenceNumber">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <param name="reservation">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje obszaru ponownego uruchomienia, aby <see cref="T:System.IO.Log.IRecordSequence" /> za pomocą rezerwacji, a następnie aktualizuje numer podstawowy sekwencyjny.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Podczas odzyskiwania jest to konieczne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania. Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> metody.  
  
 Przy zapisywaniu obszaru ponownego uruchamiania danych w segmentach tablicy bajtów są łączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 Jeśli rezerwacja jest określony, obszar napisane ponownego uruchamiania zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji znajdujących się w kolekcji. Jeśli metoda się powiedzie, zużyje najmniejszą rezerwacji, który może zawierać dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Po pomyślnym ukończeniu tej metody został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
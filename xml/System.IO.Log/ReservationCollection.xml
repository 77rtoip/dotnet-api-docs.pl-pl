<Type Name="ReservationCollection" FullName="System.IO.Log.ReservationCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80315a981ff347b7a3a3838866d59fe9768b1d59" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30455316" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ReservationCollection : System.Collections.Generic.ICollection&lt;long&gt;, System.Collections.Generic.IEnumerable&lt;long&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ReservationCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;int64&gt;, class System.Collections.Generic.IEnumerable`1&lt;int64&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.ReservationCollection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ReservationCollection&#xA;Implements ICollection(Of Long), IEnumerable(Of Long)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReservationCollection abstract : System::Collections::Generic::ICollection&lt;long&gt;, System::Collections::Generic::IEnumerable&lt;long&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zarządza kolekcji rezerwacji miejsca w sekwencji rekordu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa reprezentuje zestaw rezerwacji obszarów, które zostały wprowadzone w sekwencji rekordu. Dodawanie elementów do kolekcji przydziela nowej rezerwacji. Usuwanie elementów z kolekcji zwalnia te zastrzeżenia.  
  
 Aplikacja zastrzega miejsca w dzienniku zawiera dane, które mają być zapisywane w dzienniku w przyszłości, ale nie można zapisać go bezpośrednio. Zastrzeżenia Podaj gwarancji, które mogą być zapisywane dane do dziennika, gdy dane są dostępne do zapisania. Przy użyciu dzienników, aplikacje często zarezerwować co najmniej jeden rekord dziennika w obszarze kierowanie. Należy zarezerwować rekordów przed ich dołączanie.  
  
 Zastrzeżenia może służyć do zagwarantowania, że przed zatwierdzeniem; danych można wykonać operacji w przeciwnym razie zmiany zostaną wycofane. Można go również używane do rejestrowania w dzienniku "akcję cofania". Podczas operacji wycofywania transakcyjnego menedżera zasobów (RM) musi mieć możliwość odzyskania stanu, jeśli Menedżer zasobów zostanie przerwane podczas operacji wycofywania. Przy użyciu obszaru rezerwacji, RM może zarezerwować miejsca w dzienniku przed jego użyciem.  
  
 <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> Metody można zarezerwować miejsce lub dołączanie danych i/lub, w zależności od parametrów, które zostały określone podczas wywołania. Pracy realizowany w transakcji, aplikację można dołączyć informacje cofania i zarezerwowanego miejsca dla rekordów kompensacji. Podczas operacji wycofywania kompensacji rekordów, które są tworzone wskazują na to, co została cofnięta na dysku. Rekordy są dodawane przy użyciu miejsca, który został wcześniej zarezerwowany. Gwarantuje to, czy protokołu RM nie zabraknie miejsca w dzienniku, czyli warunek krytyczny podczas wykonywania operacji wycofywania. Jeśli dziennik czasochłonną podczas transakcji aplikacji można bezpiecznie wycofać transakcji bez uszkodzenia danych trwałych.  
  
 CLFS jest standardem ARIES systemu rejestrowania przeznaczone do rejestrowania zapisu z wyprzedzeniem. W kolejnej operacji zapisu rejestrowania aplikacji zapisuje rekord cofania przed przesłaniem operacji rezerwacji ilość miejsca, potrzebny w dzienniku zapisać kompensacyjnych rekordu, która może być używana podczas wycofywania. Później zarezerwowane miejsce jest używany, gdy jest zapisana w rekordzie kompensacji.  
  
 Aplikacje można zarezerwować lub dostęp dużo miejsca w danym momencie (są one wykluczają się wzajemnie operacji). Po commit zapisywania rekordu w dzienniku aplikacji można zwolnić rezerwacji rekordów kompensacji. Ta akcja może odbywać się przez wywołanie albo <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> lub <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> metody. Wywoływanie <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> metoda gwarantuje to atomic podczas wywoływania operacji <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> nie ma metody.  
  
 Po zwolnieniu rekordów należy zwolnić te same rekordy zastrzeżone razem w poprzednie wywołanie <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> metody.  
  
> [!NOTE]
>  Implementacji <xref:System.IO.Log.IRecordSequence> musi implementować <xref:System.IO.Log.ReservationCollection.MakeReservation%2A> i <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> metody do rzeczywistego rezerwacji alokacji i dezalokacji. Ponadto należy także wywołać implementacji <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A> Jeśli rekord jest zapisywany w zarezerwowane miejsce.  
  
   
  
## Examples  
 Zastrzeżenia można przeprowadzić na dwa sposoby, jak pokazano w poniższych przykładach. Można przyjąć praktyki przykłady dotyczące niezawodne przetwarzanie. Zwróć uwagę, że to zadanie można wykonać tylko po za pomocą opartego CLFS <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ReservationCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.ReservationCollection" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Add(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(long size);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar żądanego zastrzeżenia w bajtach.</param>
        <summary>Przydziela zastrzeżenie i dodaje go do kolekcji. Ta metoda nie może być dziedziczona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ręcznie rezerwować. Zwróć uwagę, że to zadanie można wykonać tylko po za pomocą opartego CLFS <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="archiveTail" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="size" /> jest nieprawidłowy lub przekracza rozmiar maksymalny rezerwacji.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie rezerwacje w kolekcji. Ta metoda nie może być dziedziczona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="size" /> jest nieprawidłowy lub przekracza rozmiar maksymalny rezerwacji.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Contains(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (size As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(long size);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar do zlokalizowania w kolekcji.</param>
        <summary>Określa, czy wprowadzono rezerwacji o określonym rozmiarze. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see langword="true" /> Jeśli wprowadzono zastrzeżenia co najmniej jeden określony rozmiar; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (long[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int64[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Long(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;long&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Int64[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica, która jest miejscem docelowym kopii.</param>
        <param name="arrayIndex">Rozpoczyna się od zera indeks w tablicy, od których kopiowanie.</param>
        <summary>Kopiuje całą kolekcję jednowymiarowej tablicy, zaczynając od określonego indeksu tablicy docelowej. Ta metoda nie może być dziedziczona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> lub <paramref name="arrayIndex" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest mniejsza od zera, lub większa niż lub równa długości <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">W określonej tablicy na skopiowanie danych nie ma wystarczającej ilości miejsca.  
  
 —lub—  
  
 <paramref name="array" /> nie jest tablicą jednowymiarową, który jest typu dla żądanej akcji.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę rezerwacji w kolekcji.</summary>
        <value>Liczba rezerwacji w kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReservationCollection ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia <see cref="T:System.IO.Log.ReservationCollection" /> można zwolnić zasobów, zanim zostanie zniszczony przez moduł garbage collector.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeReservation">
      <MemberSignature Language="C#" Value="protected abstract void FreeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FreeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.FreeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FreeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FreeReservation(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji do zwolnienia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zwalnia rezerwacji o określonym rozmiarze.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.IO.Log.ReservationCollection" />, musisz zaimplementować tę metodę, aby rzeczywiście zwolnienia miejsca w sekwencji rekordu. Nie należy wywołać <see cref="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" /> po zakończeniu tej metody; że logika jest już obsługiwane.  
  
 Po zwolnieniu rekordów należy zwolnić te same rekordy zastrzeżone razem w poprzednie wywołanie <see cref="Overload:System.IO.Log.IRecordSequence.ReserveAndAppend" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBestMatchingReservation">
      <MemberSignature Language="C#" Value="protected long GetBestMatchingReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int64 GetBestMatchingReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetBestMatchingReservation (size As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; long GetBestMatchingReservation(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji, który musi zmieścić.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera najlepiej dopasowaną rezerwacji na dany rozmiar.</summary>
        <returns>Rezerwacja z kolekcji, która jest większa niż lub równa określonego rozmiaru lub wartość -1, jeśli takie rezerwacja nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana zazwyczaj, gdy dołączanie rekord na podstawie zarezerwowane miejsce do sekwencji rekordu. Gdy powróci ona rezerwacji o rozmiarze zwrócony został usunięty z kolekcji. Jeśli z jakiegoś powodu zarezerwowane miejsce nie są faktycznie dostępne, <xref:System.IO.Log.ReservationCollection.ReservationMade%2A> metoda powinna być wywoływana w celu zapewnienia, że <xref:System.IO.Log.ReservationCollection> dokładnie reprezentuje ilość zarezerwowane miejsce w sekwencji rekordu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;long&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;int64&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;long&gt; ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który można wykonać iterację <see cref="T:System.IO.Log.ReservationCollection" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Moduł wyliczający, który można wykonać iterację <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Operacja jest nieprawidłowa dla jednego z następujących powodów:  
  
-   Wyliczanie zostało zakończone.  
  
-   Kolekcja została zmodyfikowana.  
  
-   Wyliczanie nie rozpoczęło. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> muszą być wprowadzane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolekcja jest tylko do odczytu.</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.IO.Log.ReservationCollection> nigdy nie jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReservation">
      <MemberSignature Language="C#" Value="protected abstract void MakeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void MakeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.MakeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub MakeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void MakeReservation(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji do przydzielenia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przydziela rezerwacji o określonym rozmiarze.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.IO.Log.ReservationCollection" />, musisz zaimplementować tę metodę, aby rzeczywiście zarezerwowanego miejsca w sekwencji rekordu. Nie należy wywołać <see cref="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" /> po zakończeniu tej metody; że logika jest już obsługiwane.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (long item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(int64 item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Remove(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(long item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="item">Rozmiar rezerwacji do zwolnienia.</param>
        <summary>Zwalnia rezerwacji o określonym rozmiarze ma dokonano. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see langword="true" /> Jeśli znaleziono rezerwacji o określonym rozmiarze i usunięte; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ręcznie rezerwować. Zwróć uwagę, że to zadanie można wykonać tylko po za pomocą opartego CLFS <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Rezerwacja nie jest wystarczająco duży, aby zmieścić udostępnionego rekordu znajdują się w określonej kolekcji rezerwacji.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservationFreed">
      <MemberSignature Language="C#" Value="protected void ReservationFreed (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationFreed(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationFreed (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationFreed(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji, który został zwolniony.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje zastrzeżenie został zwolniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy dziedziczeniu z <xref:System.IO.Log.ReservationCollection>, należy wywołać tę metodę po wydaniu zastrzeżenie z przyczyn innych niż usunięcie go z kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReservationMade">
      <MemberSignature Language="C#" Value="protected void ReservationMade (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationMade(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationMade (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationMade(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji, które zostały wprowadzone.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje, czy przeprowadzono rezerwacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy dziedziczeniu z <xref:System.IO.Log.ReservationCollection>, należy wywołać tę metodę, po przeprowadzeniu rezerwacji poza wywołania <xref:System.IO.Log.ReservationCollection.Add%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który można wykonać iterację <see cref="T:System.IO.Log.ReservationCollection" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Moduł wyliczający, który można wykonać iterację <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Operacja jest nieprawidłowa dla jednego z następujących powodów:  
  
-   Wyliczanie zostało zakończone.  
  
-   Kolekcja została zmodyfikowana.  
  
-   Wyliczanie nie rozpoczęło. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> muszą być wprowadzane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
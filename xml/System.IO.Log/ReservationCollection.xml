<Type Name="ReservationCollection" FullName="System.IO.Log.ReservationCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3af3e1a742555f90bf2bf9a58d5acc17efc5ab90" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51307963" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ReservationCollection : System.Collections.Generic.ICollection&lt;long&gt;, System.Collections.Generic.IEnumerable&lt;long&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ReservationCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;int64&gt;, class System.Collections.Generic.IEnumerable`1&lt;int64&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.ReservationCollection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ReservationCollection&#xA;Implements ICollection(Of Long), IEnumerable(Of Long)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReservationCollection abstract : System::Collections::Generic::ICollection&lt;long&gt;, System::Collections::Generic::IEnumerable&lt;long&gt;" />
  <TypeSignature Language="F#" Value="type ReservationCollection = class&#xA;    interface ICollection&lt;int64&gt;&#xA;    interface seq&lt;int64&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zarządza zbiór rezerwacji miejsca w sekwencji rekordu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa reprezentuje zestaw obszarów rezerwacji, które zostały wprowadzone w sekwencji rekordu. Dodawanie elementów do kolekcji przydziela nowej rezerwacji. Usuwanie elementów z kolekcji zwalnia te zastrzeżenia.  
  
 Aplikacja zastrzega miejsca w dzienniku, gdy zawiera dane, które mają być zapisywane w dzienniku w przyszłości, ale nie można zapisać go bezpośrednio. Rezerwacje gwarantować, że dane mogą być zapisywane w dzienniku, po udostępnieniu do zapisania danych. Korzystając z dzienników, aplikacje często zarezerwować co najmniej jednego rekordu dziennika, w obszarze zarządzany. Należy zarezerwować rekordów przed ich dołączenie.  
  
 Rezerwacji może służyć do zagwarantowania, że można można wykonać operacji, zanim dane są zatwierdzone; w przeciwnym razie zmiany zostaną wycofane. Może również służyć do rejestrowania "action cofania" w dzienniku. Podczas operacji wycofywania transakcyjnego menedżera zasobów (RM) musi być możliwe odzyskanie stanu, jeśli Menedżera zasobów zostanie przerwany podczas operacji wycofywania. Za pomocą obszaru rezerwacji, RM możliwość rezerwowania miejsca w dzienniku, zanim zostaną one użyte.  
  
 <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> Metoda może zarezerwować miejsce lub dołączania danych i / lub, w zależności od parametrów, które zostały określone podczas wywołania. W miarę postępów prac w ramach transakcji aplikacji można dołączyć informacje o cofania i zarezerwować miejsce dla rekordów wynagrodzenia. Podczas operacji wycofywania wynagrodzenia rekordy, które są tworzone wskazują, jakie została cofnięta na dysku. Rekordy są dołączane, przy użyciu miejsca, który został wcześniej zarezerwowany. Gwarantuje to, że nie działa RM mało miejsca na dziennik, który jest stanem krytycznym, podczas wykonywania operacji wycofywania. Jeśli dziennik się zapełni podczas transakcji, aplikację można bezpiecznie wycofać transakcji bez uszkodzenia danych trwałych.  
  
 CLFS jest zgodny z ARIES systemu rejestrowania przeznaczone do rejestrowania zapisu z wyprzedzeniem. Rejestrowanie zapisu z wyprzedzeniem, aplikacja zapisuje rekord cofania, przed wykonaniem operacji rezerwacji, ilość miejsca, jaki zajmuje w dzienniku zapisu wyrównującej rekord, który może być używany podczas wycofywania. Później zarezerwowane miejsce jest używana, gdy rekord wynagrodzenia jest zapisana.  
  
 Aplikacje można zarezerwować lub dostęp do miejsca długie w dowolnym momencie (są one wzajemnie wykluczających się operacje). Po zatwierdzeniu rekordu są zapisywane w dzienniku aplikacji można zwolnić rezerwacji dla rekordów wynagrodzenia. Ta akcja może odbywać się przez wywołanie metody albo <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> lub <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> metody. Wywoływanie <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> metoda gwarantuje, że operacja jest atomic, podczas wywoływania <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> nie obsługuje metody.  
  
 Po zwolnieniu rekordy, należy zwolnić te same rekordy został zarezerwowany razem poprzednie wywołanie <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> metody.  
  
> [!NOTE]
>  Implementacja <xref:System.IO.Log.IRecordSequence> musi implementować <xref:System.IO.Log.ReservationCollection.MakeReservation%2A> i <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> metody umożliwiają przeprowadzanie rzeczywiste rezerwacji alokacji i dezalokacji. Ponadto należy także wywołać implementacji <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A> gdy rekord zostanie zapisane zarezerwowane miejsce.  
  
   
  
## Examples  
 Rezerwacje można przeprowadzić na dwa sposoby, jak pokazano w poniższych przykładach. Można przyjąć praktyki przykłady dla niezawodne przetwarzanie. Należy zauważyć, że to zadanie można wykonać tylko podczas korzystania z CLFS opartą <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ReservationCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.ReservationCollection" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Add(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(long size);" />
      <MemberSignature Language="F#" Value="abstract member Add : int64 -&gt; unit&#xA;override this.Add : int64 -&gt; unit" Usage="reservationCollection.Add size" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar żądanej rezerwacji, w bajtach.</param>
        <summary>Przydziela rezerwacji i dodaje go do kolekcji. Ta metoda nie może być dziedziczona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ręcznie utworzyć zastrzeżenie. Należy zauważyć, że to zadanie można wykonać tylko podczas korzystania z CLFS opartą <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="archiveTail" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="size" /> jest nieprawidłowy lub przekracza rozmiar maksymalny rezerwacji.</exception>
        <exception cref="T:System.IO.IOException">Podczas tworzenia migawki archiwum, wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="reservationCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie rezerwacje w kolekcji. Ta metoda nie może być dziedziczona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="size" /> jest nieprawidłowy lub przekracza rozmiar maksymalny rezerwacji.</exception>
        <exception cref="T:System.IO.IOException">Podczas tworzenia migawki archiwum, wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Contains(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (size As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(long size);" />
      <MemberSignature Language="F#" Value="abstract member Contains : int64 -&gt; bool&#xA;override this.Contains : int64 -&gt; bool" Usage="reservationCollection.Contains size" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar do zlokalizowania w kolekcji.</param>
        <summary>Określa, czy wprowadzono rezerwacji o określonym rozmiarze. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see langword="true" /> Jeśli dokonano co najmniej jedną rezerwację o określonym rozmiarze; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (long[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int64[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Long(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;long&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : int64[] * int -&gt; unit&#xA;override this.CopyTo : int64[] * int -&gt; unit" Usage="reservationCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Int64[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica, która jest miejscem docelowym kopii.</param>
        <param name="arrayIndex">Rozpoczyna się od zera indeks w tablicy, w których kopiowanie.</param>
        <summary>Kopiuje całą kolekcję jednowymiarowej tablicy, zaczynając od określonego indeksu tablicy docelowej. Ta metoda nie może być dziedziczona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> lub <paramref name="arrayIndex" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest większa niż zero, lub większa niż długość <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">W wybranej tablicy do kopiowania danych nie jest wystarczająca ilość miejsca.  
  
—lub— 
 <paramref name="array" /> nie jest tablicą jednowymiarową, który jest jedynym typem obsługiwane dla żądanej akcji.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.IO.Log.ReservationCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę rezerwacji w kolekcji.</summary>
        <value>Liczba rezerwacje w kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReservationCollection ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="reservationCollection.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia <see cref="T:System.IO.Log.ReservationCollection" /> zwolnienia zasobów, zanim zostanie zniszczony przez moduł odśmiecania pamięci.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeReservation">
      <MemberSignature Language="C#" Value="protected abstract void FreeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FreeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.FreeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FreeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FreeReservation(long size);" />
      <MemberSignature Language="F#" Value="abstract member FreeReservation : int64 -&gt; unit" Usage="reservationCollection.FreeReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji do wydania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zwalnia rezerwacji o określonym rozmiarze.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.IO.Log.ReservationCollection" />, musisz zaimplementować tę metodę, aby faktycznie zwolnienia miejsca w sekwencji rekordu. Nie należy wywołać <see cref="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" /> po ukończeniu tej metody; obsługiwania logiki dla Ciebie.  
  
Po zwolnieniu rekordy, należy zwolnić te same rekordy został zarezerwowany razem poprzednie wywołanie <see cref="Overload:System.IO.Log.IRecordSequence.ReserveAndAppend" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBestMatchingReservation">
      <MemberSignature Language="C#" Value="protected long GetBestMatchingReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int64 GetBestMatchingReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetBestMatchingReservation (size As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; long GetBestMatchingReservation(long size);" />
      <MemberSignature Language="F#" Value="member this.GetBestMatchingReservation : int64 -&gt; int64" Usage="reservationCollection.GetBestMatchingReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji, które należy dopasować.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera najlepiej dopasowaną rezerwacji na dany rozmiar.</summary>
        <returns>Zastrzeżenie z kolekcji, która jest mniejsza niż określony rozmiar lub wartość -1, jeśli takie rezerwacja nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana zazwyczaj, gdy dołączenie rekord na podstawie zarezerwowane miejsce do sekwencji rekordu. Gdy zwraca ono rezerwacji, rozmiaru zwróconego został usunięty z kolekcji. Jeśli z jakiegoś powodu zarezerwowane miejsce nie są faktycznie dostępne, <xref:System.IO.Log.ReservationCollection.ReservationMade%2A> metoda powinna być wywoływana w celu zapewnienia, że <xref:System.IO.Log.ReservationCollection> dokładnie reprezentuje ilość zarezerwowane miejsce w sekwencji rekordu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;long&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;int64&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;long&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;int64&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;int64&gt;" Usage="reservationCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który można wykonać iterację <see cref="T:System.IO.Log.ReservationCollection" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Moduł wyliczający, który można wykonać iterację <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Ta operacja jest nieprawidłowa dla jednego z następujących powodów: 
— Wyliczanie zostało zakończone.  
  
Kolekcja została zmodyfikowana.  
  
-Wyliczenia nie został uruchomiony. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> muszą być wykonane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolekcja jest tylko do odczytu.</summary>
        <value>Właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.IO.Log.ReservationCollection> nigdy nie jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReservation">
      <MemberSignature Language="C#" Value="protected abstract void MakeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void MakeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.MakeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub MakeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void MakeReservation(long size);" />
      <MemberSignature Language="F#" Value="abstract member MakeReservation : int64 -&gt; unit" Usage="reservationCollection.MakeReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji do przydzielenia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przydziela rezerwacji o określonym rozmiarze.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Przy dziedziczeniu z <see cref="T:System.IO.Log.ReservationCollection" />, musisz zaimplementować tę metodę, aby faktycznie zarezerwowanego miejsca w sekwencji rekordu. Nie należy wywołać <see cref="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" /> po ukończeniu tej metody; obsługiwania logiki dla Ciebie.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (long item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(int64 item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Remove(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(long item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : int64 -&gt; bool&#xA;override this.Remove : int64 -&gt; bool" Usage="reservationCollection.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="item">Rozmiar rezerwacji do wydania.</param>
        <summary>Zwalnia rezerwacji o określonym rozmiarze, jeśli została wprowadzona. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see langword="true" /> Jeśli rezerwacji o określonym rozmiarze zostało znalezione i usunięte; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ręcznie utworzyć zastrzeżenie. Należy zauważyć, że to zadanie można wykonać tylko podczas korzystania z CLFS opartą <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Rezerwacja nie jest wystarczająco duży, aby dopasować podana rekordu znajdują się w określonej kolekcji rezerwacji.</exception>
        <exception cref="T:System.IO.IOException">Podczas tworzenia migawki archiwum, wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservationFreed">
      <MemberSignature Language="C#" Value="protected void ReservationFreed (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationFreed(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationFreed (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationFreed(long size);" />
      <MemberSignature Language="F#" Value="member this.ReservationFreed : int64 -&gt; unit" Usage="reservationCollection.ReservationFreed size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji, która została zwolniona.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje wydano rezerwacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy dziedziczeniu z <xref:System.IO.Log.ReservationCollection>, należy wywołać tę metodę, po zwolnieniu rezerwacji z przyczyn innych niż usunięcie go z kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReservationMade">
      <MemberSignature Language="C#" Value="protected void ReservationMade (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationMade(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationMade (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationMade(long size);" />
      <MemberSignature Language="F#" Value="member this.ReservationMade : int64 -&gt; unit" Usage="reservationCollection.ReservationMade size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji, które zostały wprowadzone.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wskazuje, czy przeprowadzono rezerwacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy dziedziczeniu z <xref:System.IO.Log.ReservationCollection>, należy wywołać tę metodę, po przeprowadzeniu rezerwacji poza wywołanie w celu <xref:System.IO.Log.ReservationCollection.Add%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który można wykonać iterację <see cref="T:System.IO.Log.ReservationCollection" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Moduł wyliczający, który można wykonać iterację <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Ta operacja jest nieprawidłowa dla jednego z następujących powodów: 
— Wyliczanie zostało zakończone.  
  
Kolekcja została zmodyfikowana.  
  
-Wyliczenia nie został uruchomiony. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> muszą być wykonane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ReservationCollection" FullName="System.IO.Log.ReservationCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0b5f7c5e00b035f2197d50e122641e5237cd5df1" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69245106" /></Metadata><TypeSignature Language="C#" Value="public abstract class ReservationCollection : System.Collections.Generic.ICollection&lt;long&gt;, System.Collections.Generic.IEnumerable&lt;long&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ReservationCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;int64&gt;, class System.Collections.Generic.IEnumerable`1&lt;int64&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.ReservationCollection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ReservationCollection&#xA;Implements ICollection(Of Long), IEnumerable(Of Long)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReservationCollection abstract : System::Collections::Generic::ICollection&lt;long&gt;, System::Collections::Generic::IEnumerable&lt;long&gt;" />
  <TypeSignature Language="F#" Value="type ReservationCollection = class&#xA;    interface ICollection&lt;int64&gt;&#xA;    interface seq&lt;int64&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zarządza kolekcją rezerwacji miejsca w sekwencji rekordów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa reprezentuje zestaw obszarów rezerwacji, które są wykonywane w sekwencji rekordów. Dodawanie elementów do kolekcji przydziela nowe rezerwacje. Usunięcie elementów z kolekcji zwalnia te rezerwacje.  
  
 Aplikacja rezerwuje miejsce w dzienniku, gdy ma dane, które mają zostać zapisane w dzienniku w przyszłości, ale nie mogą go natychmiast zapisać. Rezerwacje zapewniają gwarancję, że dane mogą być zapisywane w dzienniku, gdy dane są dostępne do zapisania. W przypadku korzystania z dzienników aplikacje często rezerwują co najmniej jeden rekord dziennika w obszarze organizowania. Przed dołączeniem rekordów należy zarezerwować rekordy.  
  
 Rezerwacje mogą służyć do zagwarantowania, że operacja może zostać zakończona przed zatwierdzeniem danych; w przeciwnym razie zmiany są wycofywane. Można go również użyć do rejestrowania "akcji cofania" w dzienniku. Podczas operacji wycofywania, transakcyjny Menedżer zasobów (RM) musi mieć możliwość odzyskania stanu, jeśli RM zostanie przerwany podczas operacji wycofywania. Za pomocą obszaru rezerwacja, Menedżer zasobów może zarezerwować miejsce w dzienniku przed jego użyciem.  
  
 <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> Metoda może zarezerwować miejsce lub dołączać dane albo w zależności od parametrów, które są określone podczas tworzenia wywołania. W miarę postępów prac w transakcji aplikacja może dołączyć informacje cofania i rezerwowe miejsce dla rekordów wynagrodzeń. Podczas operacji wycofywania tworzone rekordy wynagrodzeń wskazują, co zostało cofnięte na dysku. Rekordy są dołączane przy użyciu miejsca, które zostało wcześniej zarezerwowane. Gwarantuje to, że Menedżer zasobów nie wypróbuje miejsca w dzienniku, co jest krytycznym warunkiem podczas wykonywania operacji wycofywania. Jeśli dziennik zostanie wystawiony podczas transakcji, aplikacja może bezpiecznie wycofać transakcję bez uszkodzenia danych trwałych.  
  
 CLFS to system rejestrowania zgodny z ARIES, przeznaczony do zapisu z wyprzedzeniem. W przypadku rejestrowania z wyprzedzeniem aplikacja zapisuje rekord cofnięcia przed wykonaniem operacji, zachowując ilość miejsca, jaką zajmuje w dzienniku, aby napisać rekord kompensowania, który może być używany podczas wycofywania. Później zarezerwowane miejsce jest używane, gdy rekord wynagrodzeń zostanie rzeczywiście zapisany.  
  
 Aplikacje mogą zarezerwować lub uzyskać dostęp do wolnego miejsca w dowolnym momencie (są to wzajemnie wykluczające się operacje). Po zapisaniu rekordu zatwierdzania w dzienniku Aplikacja może zwolnić rezerwacje dla rekordów wynagrodzeń. Tę akcję można wykonać przez wywołanie <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> metody lub. <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> Wywołanie metody gwarantuje, że operacja jest niepodzielna, podczas gdy <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> wywołanie metody nie jest. <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>  
  
 W przypadku bezpłatnych rekordów należy zwolnić te same rekordy, które zostały zarezerwowane we wcześniejszej wywołaniu <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> metody.  
  
> [!NOTE]
>  Implementacja programu <xref:System.IO.Log.IRecordSequence> musi <xref:System.IO.Log.ReservationCollection.MakeReservation%2A> implementować metody i <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> do wykonywania rzeczywistej alokacji rezerwacji i cofania alokacji. Ponadto implementacja musi również wywołać <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A> , gdy rekord jest zapisywana w zarezerwowanej przestrzeni.  
  
   
  
## Examples  
 Rezerwacje można wykonać na dwa sposoby, jak pokazano w poniższych przykładach. Możesz zastosować praktyki w przykładach do niezawodnego przetwarzania. Należy zauważyć, że to zadanie można wykonać tylko w przypadku korzystania z klasy <xref:System.IO.Log.LogRecordSequence> opartej na CLFS.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ReservationCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.ReservationCollection" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Add(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(long size);" />
      <MemberSignature Language="F#" Value="abstract member Add : int64 -&gt; unit&#xA;override this.Add : int64 -&gt; unit" Usage="reservationCollection.Add size" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar żądanego zastrzeżenia, w bajtach.</param>
        <summary>Alokuje rezerwację i dodaje ją do kolekcji. Ta metoda nie może być dziedziczona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ręcznie wprowadzić rezerwację. Należy zauważyć, że to zadanie można wykonać tylko w przypadku korzystania z klasy <xref:System.IO.Log.LogRecordSequence> opartej na CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="archiveTail" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="size" />jest nieprawidłowy lub przekracza maksymalny rozmiar rezerwacji.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="reservationCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie rezerwacje w kolekcji. Ta metoda nie może być dziedziczona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="size" />jest nieprawidłowy lub przekracza maksymalny rozmiar rezerwacji.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Contains(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (size As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(long size);" />
      <MemberSignature Language="F#" Value="abstract member Contains : int64 -&gt; bool&#xA;override this.Contains : int64 -&gt; bool" Usage="reservationCollection.Contains size" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar, który ma zostać zlokalizowany w kolekcji.</param>
        <summary>Określa, czy została wprowadzona rezerwacja określonego rozmiaru. Ta metoda nie może być dziedziczona.</summary>
        <returns><see langword="true" />Jeśli została wprowadzona co najmniej jedna rezerwacja o określonym rozmiarze; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (long[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int64[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Long(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;long&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : int64[] * int -&gt; unit&#xA;override this.CopyTo : int64[] * int -&gt; unit" Usage="reservationCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Int64[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica, która jest miejscem docelowym kopii.</param>
        <param name="arrayIndex">Indeks (liczony od zera) w tablicy, w której rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje całą kolekcję do jednowymiarowej tablicy, rozpoczynając od określonego indeksu tablicy docelowej. Ta metoda nie może być dziedziczona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />lub <paramref name="arrayIndex" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />jest mniejsza od zera lub większa lub równa długości <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">W określonej tablicy nie ma wystarczającej ilości miejsca, aby skopiować dane.  
  
—lub— 
 <paramref name="array" />nie jest tablicą jednowymiarową, która jest jedynym typem obsługiwanym przez żądaną akcję.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.IO.Log.ReservationCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę rezerwacji w kolekcji.</summary>
        <value>Liczba rezerwacji w kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReservationCollection ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="reservationCollection.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.Log.ReservationCollection" /> Umożliwia zwolnienie zasobów przed ich zniszczeniem przez moduł wyrzucania elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeReservation">
      <MemberSignature Language="C#" Value="protected abstract void FreeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FreeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.FreeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FreeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FreeReservation(long size);" />
      <MemberSignature Language="F#" Value="abstract member FreeReservation : int64 -&gt; unit" Usage="reservationCollection.FreeReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji do zwolnienia.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwalnia rezerwację określonego rozmiaru.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Gdy dziedziczysz z <see cref="T:System.IO.Log.ReservationCollection" />, musisz zaimplementować tę metodę, aby faktycznie zwolnić miejsce w sekwencji rekordów. Nie należy wywoływać <see cref="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" /> , gdy ta metoda jest kompletna. logika jest obsługiwana przez Ciebie.  
  
W przypadku bezpłatnych rekordów należy zwolnić te same rekordy, które zostały zarezerwowane we wcześniejszej wywołaniu <see cref="Overload:System.IO.Log.IRecordSequence.ReserveAndAppend" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetBestMatchingReservation">
      <MemberSignature Language="C#" Value="protected long GetBestMatchingReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int64 GetBestMatchingReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetBestMatchingReservation (size As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; long GetBestMatchingReservation(long size);" />
      <MemberSignature Language="F#" Value="member this.GetBestMatchingReservation : int64 -&gt; int64" Usage="reservationCollection.GetBestMatchingReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji, która musi być zgodna.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera najlepszą zgodną rezerwację dla danego rozmiaru.</summary>
        <returns>Rezerwacja z kolekcji, która jest większa lub równa określonej wielkości lub-1, jeśli taka rezerwacja nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zazwyczaj wywoływana podczas dołączania rekordu z zarezerwowanego miejsca do sekwencji rekordów. Gdy zwróci wartość, rezerwacja zwracanego rozmiaru została usunięta z kolekcji. Jeśli z jakiegoś powodu zarezerwowane miejsce nie jest faktycznie dostępne, należy wywołać <xref:System.IO.Log.ReservationCollection.ReservationMade%2A> metodę, aby upewnić się, <xref:System.IO.Log.ReservationCollection> że dokładnie reprezentuje ilość zarezerwowanego miejsca w sekwencji rekordów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;long&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;int64&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;long&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;int64&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;int64&gt;" Usage="reservationCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który może przechodzić przez <see cref="T:System.IO.Log.ReservationCollection" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Moduł wyliczający, który może przechodzić przez <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Operacja jest nieprawidłowa z jednego z następujących powodów: 
-Wyliczenie zostało zakończone.  
  
-Kolekcja została zmodyfikowana.  
  
-Wyliczenie nie zostało uruchomione. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> musi być wykonane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolekcja jest tylko do odczytu.</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.IO.Log.ReservationCollection> nigdy nie jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReservation">
      <MemberSignature Language="C#" Value="protected abstract void MakeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void MakeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.MakeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub MakeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void MakeReservation(long size);" />
      <MemberSignature Language="F#" Value="abstract member MakeReservation : int64 -&gt; unit" Usage="reservationCollection.MakeReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji do przydzielenia.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, przydziela rezerwację określonego rozmiaru.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Gdy dziedziczysz z <see cref="T:System.IO.Log.ReservationCollection" />, musisz zaimplementować tę metodę, aby faktycznie zarezerwować miejsce w sekwencji rekordów. Nie należy wywoływać <see cref="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" /> , gdy ta metoda jest kompletna. logika jest obsługiwana przez Ciebie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (long item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(int64 item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Remove(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(long item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : int64 -&gt; bool&#xA;override this.Remove : int64 -&gt; bool" Usage="reservationCollection.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="item">Rozmiar rezerwacji do zwolnienia.</param>
        <summary>Zwalnia zastrzeżenie o określonym rozmiarze, jeśli zostało wykonane. Ta metoda nie może być dziedziczona.</summary>
        <returns><see langword="true" />w przypadku znalezienia i usunięcia rezerwacji o określonym rozmiarze; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ręcznie wprowadzić rezerwację. Należy zauważyć, że to zadanie można wykonać tylko w przypadku korzystania z klasy <xref:System.IO.Log.LogRecordSequence> opartej na CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">W określonej kolekcji rezerwacji nie można znaleźć rezerwacji wystarczającej do dopasowania do podanego rekordu.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservationFreed">
      <MemberSignature Language="C#" Value="protected void ReservationFreed (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationFreed(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationFreed (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationFreed(long size);" />
      <MemberSignature Language="F#" Value="member this.ReservationFreed : int64 -&gt; unit" Usage="reservationCollection.ReservationFreed size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar wydanej rezerwacji.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wskazuje, że rezerwacja została wydana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku dziedziczenia <xref:System.IO.Log.ReservationCollection>z, należy wywołać tę metodę, gdy rezerwacja jest wydana z przyczyn innych niż usunięcie jej z kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReservationMade">
      <MemberSignature Language="C#" Value="protected void ReservationMade (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationMade(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationMade (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationMade(long size);" />
      <MemberSignature Language="F#" Value="member this.ReservationMade : int64 -&gt; unit" Usage="reservationCollection.ReservationMade size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar rezerwacji, która została wprowadzona.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oznacza to, że została wprowadzona rezerwacja.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku dziedziczenia <xref:System.IO.Log.ReservationCollection>z, należy wywołać tę metodę, gdy rezerwacja jest wykonywana poza wywołaniem do. <xref:System.IO.Log.ReservationCollection.Add%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który może przechodzić przez <see cref="T:System.IO.Log.ReservationCollection" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Moduł wyliczający, który może przechodzić przez <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Operacja jest nieprawidłowa z jednego z następujących powodów: 
-Wyliczenie zostało zakończone.  
  
-Kolekcja została zmodyfikowana.  
  
-Wyliczenie nie zostało uruchomione. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> musi być wykonane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

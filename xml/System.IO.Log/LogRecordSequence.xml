<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="330d85d921807042238a6dbb6d100c3f96cc1899" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30456045" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje sekwencję rekordu przechowywane w <see cref="T:System.IO.Log.LogStore" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogRecordSequence> Klasa zawiera implementację interfejsu sekwencja rekordów na górze dziennika wspólnej dziennika File System (CLFS). Oprócz standardowych funkcji zorientowane na rekordy zapewnia model zasad pozwala to uniknąć warunków dziennika pełnej i Multipleksowanie klientów na tym samym pliku fizycznego. W przypadku <xref:System.IO.Log.LogStore> klasy, która zapewnia interfejs bezpośrednio manipulacji i zarządzanie CLFS pliku dziennika. Relacja między <xref:System.IO.Log.LogStore> klasy i <xref:System.IO.Log.LogRecordSequence> klasy jest podobna do relacji między pliku na dysku i <xref:System.IO.FileStream> obiektu. Plik dysku zapewnia konkretnych magazynu i atrybuty, takie jak długość i czas ostatniego dostępu; gdy <xref:System.IO.FileStream> obiektu zawiera widok na pliku, który może służyć do odczytu i zapisu do niego. Podobnie <xref:System.IO.Log.LogStore> klasa ma atrybutów, takich jak zasady i kolekcję zakresów dysków; i <xref:System.IO.Log.LogRecordSequence> klasa udostępnia zorientowane na rekordy mechanizm odczytywania i zapisywania danych.  
  
   
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.IO.Log.LogRecordSequence> klasy:  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <see cref="T:System.IO.Log.LogStore" /> Która powinna być używana przez tę sekwencję rekordu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy ze sklepem określony dziennik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar buforu określa maksymalny rozmiar rekordu, które mogą być dołączane lub odczytu. W tym konstruktorze ustawiono wartość domyślną 64. Odpowiednią liczbę buforów jest ustawiony na 10.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logStore" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości, które określa, jak otworzyć lub utworzyć magazynu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy z określonej ścieżki do magazynu dziennika i tryb dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogRecordSequence> na nowym <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określoną ścieżką i trybu. Otrzymuje dostęp do odczytu/zapisu w magazynie, a Magazyn jest otwarty, udostępnianie dostęp do odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="path" /> zawiera tylko biały znak.  
  
 —lub—  
  
 <paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <see cref="T:System.IO.Log.LogStore" /> Która powinna być używana przez tę sekwencję rekordu.</param>
        <param name="bufferSize">Bufor żądany rozmiar w bajtach. Rozmiar buforu określa maksymalny rozmiar rekordu, które mogą być dołączane lub odczytu.</param>
        <param name="bufferCount">Odpowiednią liczbę buforów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy ze sklepem dziennika określony rozmiar buforu dla każdego rekordu, a numer buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli chcesz określić wartości dla `bufferSize` i `bufferCount` i nie chcesz używać domyślnej wartości 64 dla `bufferSize` i 10 dla `bufferCount`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="logStore" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ma wartość ujemną lub wartość zero.  
  
 —lub—  
  
 <paramref name="bufferCount" /> ma wartość ujemną lub wartość zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości, które określa, jak otworzyć lub utworzyć magazynu.</param>
        <param name="access">Jeden z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy z określonej ścieżki do magazynu dziennika i tryby dostępu i udostępniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogRecordSequence> na nowym <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i dostępu. Magazyn jest otwarty, udostępnianie dostęp do odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="path" /> zawiera tylko biały znak.  
  
 —lub—  
  
 <paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości, które określa, jak otworzyć lub utworzyć magazynu.</param>
        <param name="access">Jeden z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Jeden z <see cref="T:System.IO.FileShare" /> wartości, które określa, jak magazynu dziennika będzie współdzielona przez procesy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy z określonej ścieżki do magazynu dziennika i tryb dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogRecordSequence> na nowym <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i dostępu. Magazyn jest otwarty, udostępnianie określonego dostępu.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak użyć tej funkcji <xref:System.IO.Log.LogRecordSequence> konstruktora:  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="path" /> zawiera tylko biały znak.  
  
 —lub—  
  
 <paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości, które określa, jak otworzyć lub utworzyć magazynu.</param>
        <param name="access">Jeden z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Jeden z <see cref="T:System.IO.FileShare" /> wartości, które określa, jak magazynu dziennika będzie współdzielona przez procesy.</param>
        <param name="bufferSize">Bufor żądany rozmiar w bajtach. Rozmiar buforu określa maksymalny rozmiar rekordu, które mogą być dołączane lub odczytu.</param>
        <param name="bufferCount">Odpowiednią liczbę buforów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy z określonej ścieżki do magazynu dziennika, uprawnień do pliku, trybami dostępu i udostępniania, a rozmiar buforu i liczby rekordów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogRecordSequence> na nowym <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i dostępu. Magazyn jest otwarty, udostępnianie określonego dostępu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="path" /> zawiera tylko biały znak.  
  
 —lub—  
  
 <paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Prawidłowy <see cref="T:System.IO.FileMode" /> wartość określającą, jak otworzyć lub utworzyć magazynu.</param>
        <param name="access">Prawidłowy <see cref="T:System.IO.FileAccess" /> wartość, która określa, jak można uzyskać dostępu do magazynu dziennika.</param>
        <param name="share">Prawidłowy <see cref="T:System.IO.FileShare" /> wartość, która określa, jak magazynu dziennika będzie współdzielona przez procesy.</param>
        <param name="bufferSize">Bufor żądany rozmiar w bajtach. Rozmiar buforu określa maksymalny rozmiar rekordu, które mogą być dołączane lub odczytu.</param>
        <param name="bufferCount">Odpowiednią liczbę buforów.</param>
        <param name="fileSecurity">Prawidłowy <see cref="T:System.Security.AccessControl.FileSecurity" /> wartość, która określa zabezpieczeń można ustawić na nowo utworzony magazyn, jeśli magazyn musi zostać utworzony.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Plik określony przez <paramref name="path" /> jest nieprawidłowy.  
  
 —lub—  
  
 Nazwa pliku magazynu określony dziennik nie jest prawidłowy.  
  
 —lub—  
  
 <paramref name="mode" /> ma wartość <see cref="F:System.IO.FileMode.CreateNew" />i nie można używać bez dostępu do zapisu.  
  
 —lub—  
  
 <paramref name="mode" /> ma wartość <see cref="F:System.IO.FileMode.OpenOrCreate" />i nie można używać bez dostępu do zapisu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony przez <paramref name="path" /> nie można odnaleźć.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Plik określony przez <paramref name="path" /> jest niedostępny, ponieważ jest on używany przez inny proces.  
  
 —lub—  
  
 Plik określony przez <paramref name="path" /> nie można utworzyć, ponieważ plik lub katalog już istnieje.  
  
 —lub—  
  
 Nie można powiązać dojścia dziennika z pulą wątków.  
  
 —lub—  
  
 Format pliku dziennika określonego lub wersji jest nieprawidłowy.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Określa nowe base <see cref="T:System.IO.Log.SequenceNumber" /> dziennika. To musi znajdować się w zakresie od bieżący numer sekwencyjny podstawowej i ostatni numer sekwencyjny dziennika (włącznie).</param>
        <summary>Przenosi do przodu numer sekwencji podstawowej dziennika. Ta metoda nie może być dziedziczona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest często używane z <xref:System.IO.Log.LogRecordSequence.TailPinned> zdarzeń w celu zwolnienia miejsca w rekordzie. <xref:System.IO.Log.LogRecordSequence.TailPinned> Zdarzeń wskazuje tail sekwencji (to znaczy numer sekwencji podstawowej) musi zostać przesunięty w celu zwolnienia miejsca. Zwalnianie miejsca może odbywać się za pomocą albo ponownie uruchom za pomocą <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> metody, lub obcinanie dziennika i przy użyciu <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> metodę podstawową numerem dziennika do jednej, określonej przez `newBaseSequenceNumber` parametru. Przykładowy kod w sekcji przykładzie pokazano drugiej metody.  
  
 Należy pamiętać, że wywołanie tej metody jest taka sama jak ustawienie nowego podstawowego sekwencji numeru przy użyciu <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> metody, z wyjątkiem tego, że żaden rekord ponownego uruchomienia komputera są zapisywane w dzienniku.  
  
   
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> metody z <xref:System.IO.Log.LogRecordSequence.TailPinned> zdarzeń w celu zwolnienia miejsca w sekwencji dziennika.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSequenceNumber" /> jest nieprawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
 —lub—  
  
 <paramref name="newBaseSequenceNumber" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException">Określony dziennik nie zawiera żadnych zakresów. Było użyć sekwencji rekordu, należy utworzyć jeden lub więcej zakresów.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje rekord do <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.IO.Log.LogRecordSequence.Append%2A> elementu członkowskiego  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <summary>Zapisuje rekord do <see cref="T:System.IO.Log.LogRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika dołączany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia tej metody do dołączenia do sekwencji rekordu dziennika.  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <summary>Dołącza do rekordu dziennika <see cref="T:System.IO.Log.IRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika dołączany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> zawierający rezerwacji, które mają być używane dla tego rekordu.</param>
        <summary>Dołącza do rekordu dziennika <see cref="T:System.IO.Log.IRecordSequence" />, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika dołączany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby zmieścić <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> zawierający rezerwacji, które mają być używane dla tego rekordu.</param>
        <summary>Dołącza do rekordu dziennika <see cref="T:System.IO.Log.IRecordSequence" />, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika dołączany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby zmieścić <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer sekwencji pierwszy rekord prawidłowe w bieżącym <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <value>Najniższy numer sekwencji, umożliwiająca prawidłowy rekord w <see cref="T:System.IO.Log.LogRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowych numerów sekwencji są większe niż lub równe <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> i mniejsza niż <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.  
  
 Wartość tej właściwości można zmienić wywołując <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> metody lub <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> metody.  
  
   
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> elementu członkowskiego w pętli.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się asynchroniczną operację dołączania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania.</param>
        <param name="state">Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący append asynchroniczne, które mogą nadal oczekiwać.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane. Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracane przez tę metodę.  
  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania.</param>
        <param name="state">Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący append asynchroniczne, które mogą nadal oczekiwać.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane. Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracane przez tę metodę.  
  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> zawierający rezerwacji, które mają być używane dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania.</param>
        <param name="state">Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący append asynchroniczne, które mogą nadal oczekiwać.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane. Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracane przez tę metodę.  
  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby zmieścić <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> zawierający rezerwacji, które mają być używane dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania.</param>
        <param name="state">Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący append asynchroniczne, które mogą nadal oczekiwać.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane. Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracane przez tę metodę.  
  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby zmieścić <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji najnowsze rekordu, który musi być napisana. Jeśli ta <see cref="T:System.IO.Log.SequenceNumber" /> jest nieprawidłowy, a następnie wszystkie rekordy muszą być zapisane.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu flush.</param>
        <param name="state">Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie opróżniania od innych żądań.</param>
        <summary>Rozpoczyna operację asynchroniczną opróżniania, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Czy reprezentuje asynchroniczną opróżnić operacja, która może nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwróconych przez metodę bieżącego <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> metodę, aby zapewnić, że zakończeniu opróżniania i zasoby są zwalniane odpowiednio. Jeśli wystąpi błąd podczas asynchronicznego opróżniania, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracane przez tę metodę.  
  
 Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.LogRecordSequence> trwałym są zapisywane.  
  
 Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchronicznego opróżniania, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> jest nieprawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException">Określony dziennik nie zawiera żadnych zakresów. Przed użyciem sekwencja rekordów, należy utworzyć jeden lub więcej zakresów.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się rezerwy asynchroniczne i Dołącz operacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="reservationCollection">Kolekcja rezerwacji dokonanie rezerwacji w.</param>
        <param name="reservations">Zastrzeżenia dokonanie w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania.</param>
        <param name="state">Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się rezerwy asynchroniczne i Dołącz operacji. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący operację asynchroniczną, która może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane. Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracane przez tę metodę.  
  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.  
  
 Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby zmieścić <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="reservationCollection">Kolekcja rezerwacji dokonanie rezerwacji w.</param>
        <param name="reservations">Zastrzeżenia dokonanie w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania.</param>
        <param name="state">Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się rezerwy asynchroniczne i Dołącz operacji. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący operację asynchroniczną, która może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane. Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracane przez tę metodę.  
  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.  
  
 Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca na zawierają nowy rekord lub aby wprowadzić zastrzeżenie.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się operacja zapisu obszaru asynchroniczne ponownego uruchomienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Segmentów tablicy bajtów, które będą połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej.</param>
        <param name="reservation">A <see cref="T:System.IO.Log.ReservationCollection" /> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia.</param>
        <param name="state">Obiekt dostarczane przez użytkownika, która odróżnia to żądanie zapisu obszaru określonego asynchroniczne ponownego uruchomienia od innych żądań.</param>
        <summary>Rozpoczyna się operacji zapisu obszaru asynchroniczne ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> o reprezentuje asynchroniczną uruchomienie obszaru operacji zapisu, która może nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metodę, aby zapewnić, że operacja zapisu obszaru ponowne uruchomienie zostało ukończone i zasobów można odpowiednio zwalniane. Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchroniczne ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracane przez tę metodę.  
  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli <xref:System.IO.Log.ReservationCollection> określono obszaru napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji, który przechowywania danych, a rezerwacji zostanie usunięty z kolekcji.  
  
 Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 Numer sekwencji rozpoczęcia rejestracji określony dziennik jest nieprawidłowy.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservation" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z parametrów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
 —lub—  
  
 <paramref name="newBaseSeqNum" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia.</param>
        <param name="state">Obiekt dostarczane przez użytkownika, która odróżnia to żądanie zapisu obszaru określonego asynchroniczne ponownego uruchomienia od innych żądań.</param>
        <summary>Rozpoczyna się operacji zapisu obszaru asynchroniczne ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> o reprezentuje asynchroniczną uruchomienie obszaru operacji zapisu, która może nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metodę, aby zapewnić, że operacja zapisu obszaru ponowne uruchomienie zostało ukończone i zasobów można odpowiednio zwalniane. Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchroniczne ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracane przez tę metodę.  
  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli <xref:System.IO.Log.ReservationCollection> określono obszaru napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji, który przechowywania danych, a rezerwacji zostanie usunięty z kolekcji.  
  
 Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 Numer sekwencji rozpoczęcia rejestracji określony dziennik jest nieprawidłowy.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservationCollection" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z parametrów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
 —lub—  
  
 <paramref name="newBaseSeqNum" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.IO.Log.ReservationCollection" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Nowo utworzony <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Zastrzeżenia można przeprowadzić na dwa sposoby, jak pokazano w poniższych przykładach. Można przyjąć praktyki przykłady dotyczące niezawodne przetwarzanie. Zwróć uwagę, że to zadanie można wykonać tylko po za pomocą opartego CLFS <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez składnik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.IO.Log.LogRecordSequence.Dispose%2A> aby zwolnić zasoby:  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekujących żądania asynchroniczne We/Wy.</param>
        <summary>Kończy się asynchroniczne Dołącz operacji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika dołączany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne podczas <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> została już wywołana dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekujących żądania asynchroniczne We/Wy.</param>
        <summary>Kończy operację asynchroniczną opróżniania. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji ostatni rekord zapisywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas opróżniania żądania asynchronicznego, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne podczas <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> została już wywołana dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekujących żądania asynchroniczne We/Wy.</param>
        <summary>Kończy się asynchroniczne rezerwowa i Dołącz operacji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika dołączany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne podczas <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> została już wywołana dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekujących żądania asynchroniczne We/Wy.</param>
        <summary>Kończy operację zapisu obszaru asynchroniczne ponownego uruchomienia. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika napisane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne podczas <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> nie jest prawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> została już wywołana dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dołączony trwale rekordów</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia zapisano wszystkich dołączonych rekordów. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji ostatni rekord zapisywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.LogRecordSequence> trwale zapisana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.InvalidOperationException">Określony dziennik nie zawiera żadnych zakresów. Przed użyciem sekwencja rekordów, należy utworzyć jeden lub więcej zakresów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji najnowsze rekordu, który musi być napisana. Jeśli ta <see cref="T:System.IO.Log.SequenceNumber" /> jest nieprawidłowy, a następnie wszystkie rekordy muszą być zapisane.</param>
        <summary>Zapewnia, że dołączane rekordy, w tym rekord z określony numer sekwencji został trwale zapisany. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji ostatni rekord zapisywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody powoduje do liczby wszystkich rekordów z sekwencją i określony numer sekwencji, w tym trwale zapisano.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> jest nieprawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException">Określony dziennik nie zawiera żadnych zakresów. Przed użyciem sekwencja rekordów, należy utworzyć jeden lub więcej zakresów.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer sekwencji jest ona większa niż ostatni rekord dołączone</summary>
        <value>Numer sekwencji jest ona większa niż ostatni rekord dołączane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera numer sekwencji, który może być większa niż liczba sekwencji ostatniej dołączany rekordu. Prawidłowych numerów sekwencji są większe niż lub równe <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> i mniejsza niż <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>. Wszystkie inne liczby sekwencji jest nieprawidłowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Log.LogStore" /> zawierający dane dla tej sekwencji rekordu. Ta metoda nie może być dziedziczona.</summary>
        <value>
          <see cref="T:System.IO.Log.LogStore" /> Zawierający dane dla tej sekwencji rekordu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.IO.Log.LogRecordSequence.LogStore%2A> elementu członkowskiego, aby dodać zakresów.  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalny rozmiar rekordu, który można dodać do tej sekwencji rekordu.</summary>
        <value>Maksymalny rozmiar rekordu, który można dodać do tej sekwencji rekordu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Numer sekwencji pierwszy rekord, gdy rozpoczyna się odczyt.</param>
        <param name="logRecordEnum">Prawidłowy <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> wartość, która określa sposób (to znaczy, do przodu lub wstecz), w którym rejestrowane są odczytywane z <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Zwraca wyliczalny kolekcji rekordów w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Ustalony zbiór rekordów w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wyliczalny kolekcji rekordów w sekwencji. Kolejność wyliczany rekordów zależy od wartości `logRecordEnum` parametru.  
  
   
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> w pętli.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="logRecordEnum" /> jest nieprawidłowy.  
  
 —lub—  
  
 Nie znaleziono określonego elementu w kolekcji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.  
  
 - lub  
  
 Rozmiar buforu używany do zapisu rekordu dziennika jest większy niż rozmiar buforu używany do jego odczytu.  
  
 —lub—  
  
 Sekwencja rekordów jest uszkodzona.  
  
 —lub—  
  
 Format pliku dziennika określonego lub wersji jest nieprawidłowy.  
  
 —lub—  
  
 Rekord został zapisany za pomocą niezgodnej wersji sekwencja rekordów.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest nieprawidłowa, ponieważ wyliczanie nie został uruchomiony. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> muszą być wprowadzane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalny kolekcji obszarów ponownego uruchomienia w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Wyliczalny kolekcja obszarów ponownego uruchomienia w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszarów ponownego uruchomienia są wymienione w kolejności odwrotnej kolejności, oznacza to, z najwyższym numerem najniższy numer sekwencyjny. Tylko ponownie obszarów z numerami sekwencji między ostatni numer sekwencji i numer sekwencyjny podstawowej są wyliczone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.  
  
 - lub  
  
 Rozmiar buforu używany do zapisu rekordu dziennika jest większy niż rozmiar buforu używany do jego odczytu.  
  
 —lub—  
  
 Sekwencja rekordów jest uszkodzona.  
  
 —lub—  
  
 Format pliku dziennika określonego lub wersji jest nieprawidłowy.  
  
 —lub—  
  
 Rekord został zapisany za pomocą niezgodnej wersji sekwencja rekordów.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest nieprawidłowa, ponieważ wyliczanie nie został uruchomiony. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> muszą być wprowadzane.  
  
 - lub  
  
 Wyliczanie zostało zakończone.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Automatycznie sprawia, że pojedynczy rezerwacji i dołącza do sekwencji rekordu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> zawierający dokonanie rezerwacji w kolekcji.</param>
        <param name="reservations">Zastrzeżenia dokonanie w bajtach.</param>
        <summary>Automatycznie sprawia, że pojedynczy rezerwacji i dołącza do sekwencji rekordu. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika dołączany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.  
  
 Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć tej metody, aby upewnić rezerwacji. Zwróć uwagę, że to zadanie można wykonać tylko po za pomocą opartego CLFS <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservations" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby zmieścić <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Następnego rekordu w kolejności poprzedni numer sekwencji.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak mają być zapisywane dane.</param>
        <param name="reservationCollection">Kolekcja rezerwacji dokonanie rezerwacji w.</param>
        <param name="reservations">Zastrzeżenia dokonanie w bajtach.</param>
        <summary>Automatycznie sprawia, że pojedynczy rezerwacji i dołącza do sekwencji rekordu. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika dołączany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.  
  
 Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca na zawierają nowy rekord lub aby wprowadzić zastrzeżenie.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> lub <paramref name="previousRecord" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby zmieścić <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę bajtów, które zostały zarezerwowane.</summary>
        <value>Całkowity rozmiar wszystkich rezerwacji dokonanych w tej sekwencji rekordu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera najbardziej zbliżony do końca dziennika numer sekwencyjny obszaru ponownego uruchomienia.</summary>
        <value>Numer sekwencyjny najbardziej zbliżony do końca dziennika obszaru ponownego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.  
  
 Przy użyciu <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> metody, można usunąć najbardziej ostatnio zapisany ponownie uruchomić obszaru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony.</summary>
        <value>
          <see langword="true" /> Jeśli dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest `true`i <xref:System.IO.Log.LogRecordSequence.Append%2A> wywołanie zakończy się niepowodzeniem, ponieważ nie ma wystarczającej ilości miejsca w sekwencji, sekwencja rekordów spróbuje wolnego miejsca, a następnie spróbuj ponownie Dołącz.  
  
   
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A> właściwości.  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Liczba nowych ostatniej sekwencji w <see cref="T:System.IO.Log.LogRecordSequence" />.  
  
 Ten powinien dotyczyć bieżącego rekordu prawidłowy obecnie w dzienniku.</param>
        <summary>Ustawia ostatni rekord w <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określony numer sekwencji musi być większy od numeru sekwencji podstawowej.  
  
 Po zakończeniu wykonywania tej metody wszystkie rekordy, które wcześniej były został dołączony numerów sekwencji jest większy niż określony numer sekwencji są niedostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> jest nieprawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
 —lub—  
  
 <paramref name="sequenceNumber" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Osiągnięto koniec dziennika.  
  
 —lub—  
  
 Format pliku dziennika określonego lub wersji jest nieprawidłowy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sygnalizuje konieczność przeniesienia tail sekwencji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mogą wyzwalać to zdarzenie, gdy sekwencja rekordów zabrakło miejsca. To zdarzenie jest wywoływane, tail sekwencji (to znaczy numer sekwencji podstawowej) jest przenoszony do przodu w celu zwolnienia miejsca.  
  
 Zdarzenie może być uruchamiane w dowolnym momencie, gdy sekwencja rekordów decyduje o tym, że musi on zwolnienia miejsca, jakiegokolwiek powodu. Na przykład aparat zasad CLFS może zdecydować o zdarzenia podczas określania ślady dwóch klientów dziennika udostępnianie tego samego pliku dziennika są zbyt daleko od siebie. Zwalnianie miejsca może odbywać się przez zapisywanie obszarów ponownego uruchomienia lub obcinanie dziennika i przy użyciu <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> metody w celu zwolnienia miejsca. Przykładowy kod w sekcji przykładzie pokazano drugiej metody.  
  
 Możesz także wywołać <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> metody poza <xref:System.IO.Log.LogRecordSequence.TailPinned> zdarzenia do wolnego miejsca. Obszar ponowne uruchomienie jest podobny do punktu kontrolnego w dzienniku, innych systemów przetwarzania. Wywołanie tej metody wskazuje, że aplikacji uwzględnia wszystkie wcześniejsze rekordy przed ponownym uruchomieniu jako w pełni ukończone i dołącza dla przyszłych rekordu. Podobnie jak inne rekordy, rzeczywiste wolne miejsce w dzienniku funkcji wymaga rekordu napisane przez tę metodę.  
  
   
  
## Examples  
 Ten przykład przedstawia sposób użycia <xref:System.IO.Log.LogRecordSequence.TailPinned> zdarzeń.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.  
  
 Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Tablica segmentu, który będzie połączony i dołączone jako rekord.</param>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji zapisany ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.  
  
 Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtów zostaną połączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji zapisany ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.  
  
 Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtów zostaną połączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej.</param>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" /> i aktualizuje numer sekwencyjny podstawowej. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji zapisany ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.  
  
 Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.  
  
 Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej.</param>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" /> i aktualizuje numer sekwencyjny podstawowej. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji zapisany ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.  
  
 Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.  
  
 Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" /> za pomocą rezerwacji i aktualizuje numer sekwencyjny podstawowej. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji zapisany ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.  
  
 Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.  
  
 Jeśli określono zastrzeżenie, obszar napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji zawierające dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" /> za pomocą rezerwacji i aktualizuje numer sekwencyjny podstawowej. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji zapisany ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.  
  
 Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.  
  
 Jeśli określono zastrzeżenie, obszar napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji zawierające dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> jest nieprawidłowy dla tej sekwencji.  
  
 —lub—  
  
 Numer sekwencji rozpoczęcia rejestracji określony dziennik jest nieprawidłowy.  
  
 —lub—  
  
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.  
  
 —lub—  
  
 <paramref name="reservationCollection" /> nie została utworzona przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z parametrów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
 —lub—  
  
 <paramref name="newBaseSeqNum" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
 —lub—  
  
 Nie można wykonać żądania z powodu błędu urządzenia We/Wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
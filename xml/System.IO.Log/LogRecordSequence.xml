<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d1f1c78afc776209e87eb703d91df0fb21999318" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57922253" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type LogRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje sekwencję rekordów przechowywanych w <see cref="T:System.IO.Log.LogStore" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogRecordSequence> Klasa zawiera implementację interfejsu sekwencji rekordów na podstawie dzienników wspólnego Log File System (CLFS). Oprócz standardowych funkcji zorientowane zapewnia model zasad unikanie warunków dziennika pełnej i Multipleksowanie klientów na tym samym pliku fizycznego. Współdziała ona z <xref:System.IO.Log.LogStore> klasy, która udostępnia interfejs dla bezpośrednie manipulowanie i zarządzanie nimi CLFS pliku dziennika. Relacja między <xref:System.IO.Log.LogStore> klasy i <xref:System.IO.Log.LogRecordSequence> klasa jest podobna do relacji między pliku na dysku i <xref:System.IO.FileStream> obiektu. Plik dysku zapewnia konkretny magazyn i atrybuty, takie jak długość i czas ostatniego dostępu; gdy <xref:System.IO.FileStream> obiektu zapewnia wgląd w pliku, który może służyć do jego odczytu i zapisu do niego. Podobnie <xref:System.IO.Log.LogStore> klasa ma atrybutów, takich jak zasady i kolekcji zakresów dysków; i <xref:System.IO.Log.LogRecordSequence> klasa udostępnia zorientowane mechanizm do odczytywania i zapisywania danych.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.IO.Log.LogRecordSequence> klasy:  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence logStore" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore"><see cref="T:System.IO.Log.LogStore" /> Którego powinien używać ta sekwencja rekordów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy z magazynu określonego dziennika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar buforu określa maksymalny rozmiar rekord, który może być dołączone lub odczytu. W tym konstruktorze ustawiono wartość domyślną 64. Odpowiednią liczbę buforów jest ustawiony na 10.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logStore" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości, które określa sposób próbę otwarcia lub utworzenia magazynu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy przy użyciu określonej ścieżki do magazynu dziennika i tryb dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nową <xref:System.IO.Log.LogRecordSequence> na nowym <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki i trybu. Otrzymuje dostęp do odczytu/zapisu w magazynie, a jest otwierany magazyn, udostępnianie dostęp do odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" /> zawiera tylko znak odstępu.  
  
—lub— 
 <paramref name="path" /> zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ nie zainstalowano wymaganego składnika Typowe Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (logStore, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore"><see cref="T:System.IO.Log.LogStore" /> Którego powinien używać ta sekwencja rekordów.</param>
        <param name="bufferSize">Bufor żądany rozmiar w bajtach. Rozmiar buforu określa maksymalny rozmiar rekord, który może być dołączone lub odczytu.</param>
        <param name="bufferCount">Odpowiednią liczbę buforów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy z magazynu określonego dziennika, rozmiar buforu dla każdego rekordu, a numer buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli chcesz określić wartości dla `bufferSize` i `bufferCount` i nie chcesz używać domyślnej wartości 64 dla `bufferSize` i 10 `bufferCount`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="logStore" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ma wartość ujemną lub równy zero.  
  
—lub— 
 <paramref name="bufferCount" /> ma wartość ujemną lub równy zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości, które określa sposób próbę otwarcia lub utworzenia magazynu.</param>
        <param name="access">Jedną z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy przy użyciu określonej ścieżki do magazynu dziennika oraz trybów dostępu i udostępniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nową <xref:System.IO.Log.LogRecordSequence> na nowym <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i access. Magazyn jest otwarty, udostępnianie dostęp do odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" /> zawiera tylko znak odstępu.  
  
—lub— 
 <paramref name="path" /> zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ nie zainstalowano wymaganego składnika Typowe Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości, które określa sposób próbę otwarcia lub utworzenia magazynu.</param>
        <param name="access">Jedną z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Jedną z <see cref="T:System.IO.FileShare" /> wartości, które określa, jak magazynu dziennika będą udostępniane między procesami.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy przy użyciu określonej ścieżki do magazynu dziennika i tryb dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nową <xref:System.IO.Log.LogRecordSequence> na nowym <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i access. Magazyn jest otwarty, udostępnianie określonego dostępu.  
  
   
  
## Examples  
 Ten przykład pokazuje, jak skorzystać z tej <xref:System.IO.Log.LogRecordSequence> Konstruktor:  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" /> zawiera tylko znak odstępu.  
  
—lub— 
 <paramref name="path" /> zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ nie zainstalowano wymaganego składnika Typowe Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości, które określa sposób próbę otwarcia lub utworzenia magazynu.</param>
        <param name="access">Jedną z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Jedną z <see cref="T:System.IO.FileShare" /> wartości, które określa, jak magazynu dziennika będą udostępniane między procesami.</param>
        <param name="bufferSize">Bufor żądany rozmiar w bajtach. Rozmiar buforu określa maksymalny rozmiar rekord, który może być dołączone lub odczytu.</param>
        <param name="bufferCount">Odpowiednią liczbę buforów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy przy użyciu określonej ścieżki do magazynu dziennika, uprawnień do pliku, trybami dostępu i udostępniania, a rozmiar buforu i liczby rekordów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nową <xref:System.IO.Log.LogRecordSequence> na nowym <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i access. Magazyn jest otwarty, udostępnianie określonego dostępu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" /> zawiera tylko znak odstępu.  
  
—lub— 
 <paramref name="path" /> zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ nie zainstalowano wymaganego składnika Typowe Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Nieprawidłowy <see cref="T:System.IO.FileMode" /> wartość określającą, jak próbę otwarcia lub utworzenia magazynu.</param>
        <param name="access">Nieprawidłowy <see cref="T:System.IO.FileAccess" /> wartość, która określa, jak można uzyskać dostępu do magazynu dziennika.</param>
        <param name="share">Nieprawidłowy <see cref="T:System.IO.FileShare" /> wartość, która określa, jak magazynu dziennika będzie współdzielona przez procesy.</param>
        <param name="bufferSize">Bufor żądany rozmiar w bajtach. Rozmiar buforu określa maksymalny rozmiar rekord, który może być dołączone lub odczytu.</param>
        <param name="bufferCount">Odpowiednią liczbę buforów.</param>
        <param name="fileSecurity">Nieprawidłowy <see cref="T:System.Security.AccessControl.FileSecurity" /> wartość, która określa zabezpieczeń można ustawić na nowo utworzony magazyn, jeśli magazyn musi zostać utworzona.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogRecordSequence" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">W pliku określonym przez <paramref name="path" /> jest nieprawidłowy.  
  
—lub— 
Nazwa pliku dziennika określonego magazynu nie jest prawidłowy.  
  
—lub— 
 <paramref name="mode" /> ma wartość <see cref="F:System.IO.FileMode.CreateNew" />i nie można używać bez dostępu do zapisu.  
  
—lub— 
 <paramref name="mode" /> ma wartość <see cref="F:System.IO.FileMode.OpenOrCreate" />i nie można używać bez dostępu do zapisu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów są poza zakresem.</exception>
        <exception cref="T:System.IO.FileNotFoundException">W pliku określonym przez <paramref name="path" /> nie można odnaleźć.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
W pliku określonym przez <paramref name="path" /> nie są dostępne, ponieważ jest on używany przez inny proces.  
  
—lub— 
W pliku określonym przez <paramref name="path" /> nie można utworzyć, ponieważ plik lub katalog już istnieje.  
  
—lub— 
Nie można powiązać dojścia dziennika w puli wątków.  
  
—lub— 
Format pliku dziennika określonego lub wersji jest nieprawidłowy.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogRecordSequence" /> Nie można użyć, ponieważ nie zainstalowano wymaganego składnika Typowe Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Określa nowe base <see cref="T:System.IO.Log.SequenceNumber" /> dziennika. To musi należeć do zakresu między bieżącym numerem sekwencji podstawowej i ostatni numer sekwencyjny dziennika (włącznie).</param>
        <summary>Przenosi do przodu numer podstawowy sekwencyjny dziennika. Ta metoda nie może być dziedziczona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest często używana z <xref:System.IO.Log.LogRecordSequence.TailPinned> zdarzenia w celu zwolnienia miejsca w rekordzie. <xref:System.IO.Log.LogRecordSequence.TailPinned> Zdarzenie oznacza, że ogona sekwencji (czyli numer sekwencyjny podstawowej) musi zostać przesunięty w celu zwolnienia miejsca. Zwalnianie miejsca może odbywać się za pomocą albo ponownie uruchom za pomocą <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> metody obcinanie dziennika lub przy użyciu <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> metodę numer podstawowy sekwencyjny dziennika do jednej, określonej przez `newBaseSequenceNumber` parametru. Przykładowy kod w sekcji z przykładowym pokazuje drugiego podejścia.  
  
 Należy pamiętać, że wywołanie tej metody jest taka sama, jak ustawienie nowego podstawowego sekwencji numeru przy użyciu <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> metody, z tą różnicą, że żaden rekord ponowne uruchomienie jest zapisywane w dzienniku.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> metody z <xref:System.IO.Log.LogRecordSequence.TailPinned> zdarzenia w celu zwolnienia miejsca w sekwencji dziennika.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> nie jest prawidłowa dla tej sekwencji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
—lub— 
 <paramref name="newBaseSequenceNumber" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.InvalidOperationException">Określony dziennik nie zawiera żadnych zakresów. Przed sekwencja rekordów, które mogą być używane, należy utworzyć jeden lub więcej zakresów.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje rekord do <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.IO.Log.LogRecordSequence.Append%2A> elementu członkowskiego  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <summary>Zapisuje rekord do <see cref="T:System.IO.Log.LogRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć tej metody, aby dołączyć rekord dziennika do sekwencji.  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <summary>Dołącza rekordu dziennika, aby <see cref="T:System.IO.Log.IRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservations">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego rekordu.</param>
        <summary>Dołącza rekordu dziennika, aby <see cref="T:System.IO.Log.IRecordSequence" />, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Rekord dołączonych zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, będą wymagały najmniejszy obszaru rezerwacji, może przechowywać dane, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby dopasować <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservations">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego rekordu.</param>
        <summary>Dołącza rekordu dziennika, aby <see cref="T:System.IO.Log.IRecordSequence" />, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Rekord dołączonych zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, będą wymagały najmniejszy obszaru rezerwacji, może przechowywać dane, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby dopasować <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer sekwencyjny pierwszy rekord prawidłowe w bieżącym <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <value>Najniższy numer sekwencji, która odpowiada prawidłowy rekord w <see cref="T:System.IO.Log.LogRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowych numerów sekwencji jest większa lub równa <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> i mniej niż <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.  
  
 Wartość tej właściwości można zmienić, wywołując <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> metody lub <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> metody.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> elementu członkowskiego w pętli.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się asynchronicznej operacji dołączania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się asynchronicznej operacji dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentująca asynchroniczną append, przez co mogą nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="nextUndoRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="nextUndoRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się asynchronicznej operacji dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentująca asynchroniczną append, przez co mogą nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservations">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się asynchronicznej operacji dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentująca asynchroniczną append, przez co mogą nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Rekord dołączonych zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, będą wymagały najmniejszy obszaru rezerwacji, może przechowywać dane, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby dopasować <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservations">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się asynchronicznej operacji dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentująca asynchroniczną append, przez co mogą nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Rekord dołączonych zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, będą wymagały najmniejszy obszaru rezerwacji, może przechowywać dane, a obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Ta metoda kończy się normalnie, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby dopasować <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji jest najnowszy rekord, który musi być napisany. Jeśli ten <see cref="T:System.IO.Log.SequenceNumber" /> jest nieprawidłowy, a następnie wszystkie rekordy, które muszą być napisane.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu pracy opróżniania.</param>
        <param name="state">Obiekt dostarczony przez użytkownika, który odróżnia to asynchroniczne żądanie opróżnienia od innych żądań.</param>
        <summary>Rozpoczyna operację asynchroniczną opróżniania, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Czy reprezentuje asynchroniczną opróżniania operacji, która może nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracany przez metodę bieżącego do <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> metody, aby upewnić się, że opróżnienie zakończy i zasoby są zwalniane odpowiednio. Jeśli wystąpi błąd podczas asynchronicznego opróżniania, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.LogRecordSequence> trwale są zapisywane.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchronicznego opróżniania, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sequenceNumber" /> nie jest prawidłowa dla tej sekwencji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException">Określony dziennik nie zawiera żadnych zakresów. Przed użyciem sekwencji rekordu, należy utworzyć jeden lub więcej zakresów.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się rezerwy asynchroniczne, a następnie dołącz operacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservationCollection">Kolekcja rezerwacji się rezerwacje WE.</param>
        <param name="reservations">Rezerwacje, aby upewnić się, w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się rezerwy asynchroniczne, a następnie dołącz operacji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentujący operację asynchroniczną, która może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacje są dodawane do podana Rezerwacja operację dołączania kolekcji w operacją niepodzielną przy użyciu rekordu. W przypadku niepowodzenia dołączenia miejsce nie jest zarezerwowana.  
  
 Zazwyczaj ta metoda może wykonać, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby dopasować <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservationCollection">Kolekcja rezerwacji się rezerwacje WE.</param>
        <param name="reservations">Rezerwacje, aby upewnić się, w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu dołączenia.</param>
        <param name="state">Obiekt dostarczone przez użytkownika, który odróżnia tej konkretnej asynchronicznego Dołącz żądań z innych żądań.</param>
        <summary>Rozpoczyna się rezerwy asynchroniczne, a następnie dołącz operacji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentujący operację asynchroniczną, która może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metody upewnij się, że operacja dołączania została zakończona zasoby, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas dołączania asynchronicznego, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacje są dodawane do podana Rezerwacja operację dołączania kolekcji w operacją niepodzielną przy użyciu rekordu. W przypadku niepowodzenia dołączenia miejsce nie jest zarezerwowana.  
  
 Zazwyczaj ta metoda może wykonać, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, aby zawierała nowy rekord lub aby wprowadzić zastrzeżenie.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się operacja zapisu obszaru asynchronicznego ponownego uruchomienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Segmenty tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <param name="reservation">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia.</param>
        <param name="state">Obiekt dostarczony przez użytkownika odróżniająca określonego asynchronicznego ponowne uruchomienie zapisu obszaru z innych żądań.</param>
        <summary>Rozpoczyna się operacja zapisu obszaru asynchronicznego ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Czy reprezentuje asynchroniczną ponownie uruchomić operację zapisu obszar, który może nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metody, aby upewnić się, czy ponowne uruchomienie obszaru zapisu operacji i zasobów, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchronicznego ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli <xref:System.IO.Log.ReservationCollection> określono obszaru napisane ponownego uruchamiania zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji znajdujących się w kolekcji. Jeśli metoda się powiedzie, zużyje najmniejszy rezerwacji, który może zawierać dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> nie jest prawidłowa dla tej sekwencji.  
  
—lub— 
Numer sekwencji rozpoczęcia wyliczania określonego dziennika jest nieprawidłowy.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservation" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z parametrów ma <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
—lub— 
 <paramref name="newBaseSeqNum" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservationCollection, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <param name="reservationCollection">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia.</param>
        <param name="state">Obiekt dostarczony przez użytkownika odróżniająca określonego asynchronicznego ponowne uruchomienie zapisu obszaru z innych żądań.</param>
        <summary>Rozpoczyna się operacja zapisu obszaru asynchronicznego ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Czy reprezentuje asynchroniczną ponownie uruchomić operację zapisu obszar, który może nadal być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracane przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metody, aby upewnić się, czy ponowne uruchomienie obszaru zapisu operacji i zasobów, które może być zwolniony odpowiednio. Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchronicznego ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana z <xref:System.IAsyncResult> zwracanego przez tę metodę.  
  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli <xref:System.IO.Log.ReservationCollection> określono obszaru napisane ponownego uruchamiania zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji znajdujących się w kolekcji. Jeśli metoda się powiedzie, zużyje najmniejszy rezerwacji, który może zawierać dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> nie jest prawidłowa dla tej sekwencji.  
  
—lub— 
Numer sekwencji rozpoczęcia wyliczania określonego dziennika jest nieprawidłowy.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservationCollection" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z parametrów ma <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
—lub— 
 <paramref name="newBaseSeqNum" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="logRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.IO.Log.ReservationCollection" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Nowo utworzony <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Rezerwacje można przeprowadzić na dwa sposoby, jak pokazano w poniższych przykładach. Można przyjąć praktyki przykłady dla niezawodne przetwarzanie. Należy zauważyć, że to zadanie można wykonać tylko podczas korzystania z CLFS opartą <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez składnik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.IO.Log.LogRecordSequence.Dispose%2A> aby zwolnić zasoby:  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do zaległe asynchroniczne żądanie operacji We/Wy.</param>
        <summary>Kończy się asynchroniczne Dołącz operacji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie przed ukończeniem operacji We/Wy. Błędy występujące podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy, stanie się widoczna gdy <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz na każdym <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" /> została już wywołana dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do zaległe asynchroniczne żądanie operacji We/Wy.</param>
        <summary>Kończy operację asynchroniczną opróżniania. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny ostatniego rekordu, które są zapisywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie przed ukończeniem operacji We/Wy. Błędy występujące podczas opróżniania żądania asynchronicznego, takiej jak awaria dysku podczas wykonywania żądania We/Wy, stanie się widoczna gdy <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz na każdym <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" /> została już wywołana dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do zaległe asynchroniczne żądanie operacji We/Wy.</param>
        <summary>Kończy się asynchroniczne zarezerwować i Dołącz operacji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie przed ukończeniem operacji We/Wy. Błędy występujące podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy, stanie się widoczna gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz na każdym <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" /> została już wywołana dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do zaległe asynchroniczne żądanie operacji We/Wy.</param>
        <summary>Kończy operację zapisu obszaru asynchronicznego ponownego uruchomienia. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji rekordu dziennika napisane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie przed ukończeniem operacji We/Wy. Błędy występujące podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy, stanie się widoczna gdy <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> jest wywoływana.  
  
 Ta metoda musi zostać wywołana tylko raz na każdym <xref:System.IAsyncResult> zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> nie jest prawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" /> została już wywołana dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisy trwale dołączona rekordów</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia zapisanych wszystkich dołączonych rekordów. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny ostatniego rekordu, które są zapisywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.LogRecordSequence> został trwale zapisany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.InvalidOperationException">Określony dziennik nie zawiera żadnych zakresów. Przed użyciem sekwencji rekordu, należy utworzyć jeden lub więcej zakresów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji jest najnowszy rekord, który musi być napisany. Jeśli ten <see cref="T:System.IO.Log.SequenceNumber" /> jest nieprawidłowy, a następnie wszystkie rekordy, które muszą być napisane.</param>
        <summary>Gwarantuje, że wszystkie dołączone, w tym rekord o określony numer sekwencji trwale zapisanych rekordów. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny ostatniego rekordu, które są zapisywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody powoduje do liczby wszystkich rekordów z sekwencji, w tym określony numer sekwencji trwale zapisanych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sequenceNumber" /> nie jest prawidłowa dla tej sekwencji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.</exception>
        <exception cref="T:System.InvalidOperationException">Określony dziennik nie zawiera żadnych zakresów. Przed użyciem sekwencji rekordu, należy utworzyć jeden lub więcej zakresów.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer sekwencyjny która jest większa niż ostatni rekord dołączany</summary>
        <value>Numer sekwencji, która jest większa niż ostatni rekord dołączane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera numer sekwencji, która może być większa niż liczba sekwencji ostatniej dołączany rekordu. Prawidłowych numerów sekwencji jest większa lub równa <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> i mniej niż <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>. Inne liczby sekwencji są nieprawidłowe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStore : System.IO.Log.LogStore" Usage="System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Log.LogStore" /> zawierający dane dla tej sekwencji rekordów. Ta metoda nie może być dziedziczona.</summary>
        <value><see cref="T:System.IO.Log.LogStore" /> Zawierający dane dla tej sekwencji rekordów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.IO.Log.LogRecordSequence.LogStore%2A> elementu członkowskiego, aby dodać zakresów.  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalny rozmiar rekord, który można dodać do tej sekwencji rekordów.</summary>
        <value>Maksymalny rozmiar rekordu, który można dodać do tej sekwencji rekordów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Numer sekwencji pierwszego rekordu, w którym rozpoczyna się odczytywanie.</param>
        <param name="logRecordEnum">Nieprawidłowy <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> wartość, która określa sposób (to znaczy, do przodu lub do tyłu) w rekordy, które są odczytywane z <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Zwraca wyliczalny zbiór rekordów w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Wyliczalne zbiór rekordów w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wyliczalny zbiór rekordów w sekwencji. Kolejność rekordów wyliczany zależy od wartości `logRecordEnum` parametru.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> w pętli.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="start" /> nie jest prawidłowa dla tej sekwencji.  
  
—lub— 
 <paramref name="logRecordEnum" /> jest nieprawidłowy.  
  
—lub— 
Określony element nie został znaleziony w kolekcji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.  
  
— lub 
Rozmiar buforu używany do zapisu do rekordu dziennika jest większy niż rozmiar buforu używany do jego odczytu.  
  
—lub— 
Sekwencja rekordów jest uszkodzony.  
  
—lub— 
Format pliku dziennika określonego lub wersji jest nieprawidłowy.  
  
—lub— 
Rekord został napisany za pomocą niezgodnej wersji sekwencja rekordów.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest nieprawidłowa, ponieważ wyliczenia nie został uruchomiony. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> muszą być wykonane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalny zbiór obszarów ponowne uruchomienie w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Wyliczalne kolekcja obszarów ponowne uruchomienie w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszary ponownego uruchamiania są wyliczane w kolejności odwrotnej kolejności, oznacza to, z najwyższy numer sekwencyjny najniższy numer sekwencji. Tylko ponownie obszarów numerami sekwencji między ostatni numer sekwencji i numer sekwencyjny podstawowej są wyliczane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.  
  
— lub 
Rozmiar buforu używany do zapisu do rekordu dziennika jest większy niż rozmiar buforu używany do jego odczytu.  
  
—lub— 
Sekwencja rekordów jest uszkodzony.  
  
—lub— 
Format pliku dziennika określonego lub wersji jest nieprawidłowy.  
  
—lub— 
Rekord został napisany za pomocą niezgodnej wersji sekwencja rekordów.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest nieprawidłowa, ponieważ wyliczenia nie został uruchomiony. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> muszą być wykonane.  
  
— lub 
Wyliczanie zostało zakończone.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawia, że pojedynczy rezerwacji i automatycznie dołącza rekord do sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> , która zawiera kolekcję się rezerwacje WE.</param>
        <param name="reservations">Rezerwacje, aby upewnić się, w bajtach.</param>
        <summary>Sprawia, że pojedynczy rezerwacji i automatycznie dołącza rekord do sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacje są dodawane do podana Rezerwacja operację dołączania kolekcji w operacją niepodzielną przy użyciu rekordu. W przypadku niepowodzenia dołączenia miejsce nie jest zarezerwowana.  
  
 Zazwyczaj ta metoda może wykonać, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ta metoda umożliwia dokonanie rezerwacji. Należy zauważyć, że to zadanie można wykonać tylko podczas korzystania z CLFS opartą <xref:System.IO.Log.LogRecordSequence> klasy.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="nextUndoRecord" /> lub <paramref name="previousRecord" /> jest nieprawidłowy dla tej sekwencji.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservations" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="nextUndoRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby dopasować <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="userRecord">Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencyjny następnego rekordu w kolejności wstecz.</param>
        <param name="recordAppendOptions">Nieprawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określający, jak powinny być zapisywane dane.</param>
        <param name="reservationCollection">Kolekcja rezerwacji się rezerwacje WE.</param>
        <param name="reservations">Rezerwacje, aby upewnić się, w bajtach.</param>
        <summary>Sprawia, że pojedynczy rezerwacji i automatycznie dołącza rekord do sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny dziennika dołączonych rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane znajdujące się w `data` parametru, zostanie połączonych z tablicy bajtów jednego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.  
  
 Określony rezerwacje są dodawane do podana Rezerwacja operację dołączania kolekcji w operacją niepodzielną przy użyciu rekordu. W przypadku niepowodzenia dołączenia miejsce nie jest zarezerwowana.  
  
 Zazwyczaj ta metoda może wykonać, zanim rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions.ForceFlush> Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas dołączania rekordu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilością wolnego miejsca, aby zawierała nowy rekord lub aby wprowadzić zastrzeżenie.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="userRecord" /> lub <paramref name="previousRecord" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów został otwarty z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Rezerwacja nie jest wystarczająco duży, aby dopasować <paramref name="data" /> znajdują się w <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę bajtów, które zostały zarezerwowane.</summary>
        <value>Całkowity rozmiar wszystkich rezerwacji dokonanych w tej sekwencji rekordów.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer sekwencyjny obszaru ponowne uruchomienie jest najbardziej zbliżony do końca dziennika.</summary>
        <value>Numer sekwencyjny najbardziej zbliżony do końca dziennika obszaru ponownego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Typowe Log File System (CLFS) obsługuje dwa obszary, które gwarantuje, że co najmniej jeden prawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest to konieczne, CLFS odczytuje obszaru jego ponowne uruchomienie i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 Za pomocą <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> metody, można usunąć najbardziej niedawno napisanych ponowne uruchomienie obszaru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony.</summary>
        <value><see langword="true" /> Jeśli dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest `true`i <xref:System.IO.Log.LogRecordSequence.Append%2A> połączenie nie powiedzie się, ponieważ nie jest wystarczająca ilość miejsca w sekwencji, sekwencja rekordów podejmie próbę wolne miejsce i ponowić próbę dołączenia.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A> właściwości.  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.SetLastRecord : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.SetLastRecord sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Liczba nowych ostatniej sekwencji w <see cref="T:System.IO.Log.LogRecordSequence" />.  
  
Ten powinien dotyczyć bieżącego rekordu prawidłowe zapisane w dzienniku.</param>
        <summary>Ustawia ostatni rekord w <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określony numer sekwencji musi być większa niż liczba sekwencji podstawowej.  
  
 Po zakończeniu tej metody, wszystkie rekordy, które było wcześniej zostały dołączany wraz z sekwencji liczby większe niż określony numer sekwencji są niedostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sequenceNumber" /> nie jest prawidłowa dla tej sekwencji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
—lub— 
 <paramref name="sequenceNumber" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Osiągnięto koniec dziennika.  
  
—lub— 
Format pliku dziennika określonego lub wersji jest nieprawidłowy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sygnalizuje konieczność przenoszenia tail sekwencji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można uruchomić tego zdarzenia, kiedy sekwencji rekord ma za mało miejsca. To zdarzenie jest wywoływane, ogona sekwencji (czyli numer sekwencyjny podstawowy) jest przenoszony do przodu w celu zwolnienia miejsca.  
  
 Zdarzenie może być uruchamiane w dowolnym momencie podczas sekwencji rekordów decyduje, że jej musi zwolnić miejsce, jakiegokolwiek powodu. Na przykład aparatu zasad CLFS może podjąć decyzję, zdarzenia, gdy ustali, że ślady dwóch klientów dziennika udostępnianie tego samego pliku dziennika są zbyt daleko od siebie. Zwalnianie miejsca może odbywać się przez pisanie obszarów ponownego uruchamiania lub obcinanie dziennika i przy użyciu <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> metodę, aby wyczyścić miejsca. Przykładowy kod w sekcji z przykładowym pokazuje drugiego podejścia.  
  
 Można również wywołać <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> metoda poza <xref:System.IO.Log.LogRecordSequence.TailPinned> zdarzeń, aby zwolnić miejsce. Obszar ponowne uruchomienie jest podobny do punktu kontrolnego w innym dzienniku systemów przetwarzania. Wywołanie tej metody oznacza, że aplikacja uwzględnia wszystkie wcześniejsze rekordy przed ponownym uruchomieniu jako w pełni ukończone i dołącza użyteczne dla przyszłych rekordu. Podobnie jak inne rekordy, rzeczywiste wolne miejsce w dzienniku funkcji wymaga rekordu napisane przez tę metodę.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.IO.Log.LogRecordSequence.TailPinned> zdarzeń.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Typowe Log File System (CLFS) obsługuje dwa obszary, które gwarantuje, że co najmniej jeden prawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest to konieczne, CLFS odczytuje obszaru jego ponowne uruchomienie i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Segment macierzy, który zostanie połączonych i dołączane jako rekord.</param>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Typowe Log File System (CLFS) obsługuje dwa obszary, które gwarantuje, że co najmniej jeden prawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest to konieczne, CLFS odczytuje obszaru jego ponowne uruchomienie i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtów zostanie połączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <summary>Zapisuje obszar ponownego uruchomienia <see cref="T:System.IO.Log.LogRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Typowe Log File System (CLFS) obsługuje dwa obszary, które gwarantuje, że co najmniej jeden prawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest to konieczne, CLFS odczytuje obszaru jego ponowne uruchomienie i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtów zostanie połączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <summary>Zapisuje obszaru ponownego uruchomienia, aby <see cref="T:System.IO.Log.LogRecordSequence" /> i aktualizuje numer podstawowy sekwencyjny. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Typowe Log File System (CLFS) obsługuje dwa obszary, które gwarantuje, że co najmniej jeden prawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest to konieczne, CLFS odczytuje obszaru jego ponowne uruchomienie i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Przy zapisywaniu obszaru ponownego uruchamiania danych w segmentach tablicy bajtów są łączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 Po pomyślnym ukończeniu tej metody został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <summary>Zapisuje obszaru ponownego uruchomienia, aby <see cref="T:System.IO.Log.LogRecordSequence" /> i aktualizuje numer podstawowy sekwencyjny. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Typowe Log File System (CLFS) obsługuje dwa obszary, które gwarantuje, że co najmniej jeden prawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest to konieczne, CLFS odczytuje obszaru jego ponowne uruchomienie i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Przy zapisywaniu obszaru ponownego uruchamiania danych w segmentach tablicy bajtów są łączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 Po pomyślnym ukończeniu tej metody został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <param name="reservations">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <summary>Zapisuje obszaru ponownego uruchomienia, aby <see cref="T:System.IO.Log.LogRecordSequence" /> za pomocą rezerwacji, a następnie aktualizuje numer podstawowy sekwencyjny. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Typowe Log File System (CLFS) obsługuje dwa obszary, które gwarantuje, że co najmniej jeden prawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest to konieczne, CLFS odczytuje obszaru jego ponowne uruchomienie i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Przy zapisywaniu obszaru ponownego uruchamiania danych w segmentach tablicy bajtów są łączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 Jeśli rezerwacja jest określony, obszar napisane ponownego uruchamiania zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji znajdujących się w kolekcji. Jeśli metoda się powiedzie, zużyje najmniejszą rezerwacji, który może zawierać dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Po pomyślnym ukończeniu tej metody został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas zapisywania obszaru ponownego uruchamiania.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów nie można utworzyć wystarczającą ilość wolnego miejsca, aby zawierać nowy obszar ponownego uruchomienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservationCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które będą łączone i dołączane jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa z bieżącym numerem sekwencji podstawowej.</param>
        <param name="reservationCollection">Element <see cref="T:System.IO.Log.ReservationCollection" /> zawierający zastrzeżenia, które mają być używane dla tego obszaru ponownego uruchomienia.</param>
        <summary>Zapisuje obszaru ponownego uruchomienia, aby <see cref="T:System.IO.Log.LogRecordSequence" /> za pomocą rezerwacji, a następnie aktualizuje numer podstawowy sekwencyjny. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny pisemnego ponownie obszar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta ostatniej operacji punktu kontrolnego. Typowe Log File System (CLFS) obsługuje dwa obszary, które gwarantuje, że co najmniej jeden prawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest to konieczne, CLFS odczytuje obszaru jego ponowne uruchomienie i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabela transakcji, strony zanieczyszczeniu tabeli i Otwórz plik, tabela, dzięki czemu może być używany w procesie odzyskiwania.  
  
 Obszar ponownego uruchamiania może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> metody.  
  
 Przy zapisywaniu obszaru ponownego uruchamiania danych w segmentach tablicy bajtów są łączone z tablicy bajtów jednego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania obszaru ponownego uruchamiania.  
  
 Jeśli rezerwacja jest określony, obszar napisane ponownego uruchamiania zużyje miejsca, który został wcześniej zarezerwowany, za pomocą rezerwacji znajdujących się w kolekcji. Jeśli metoda się powiedzie, zużyje najmniejszą rezerwacji, który może zawierać dane, a rezerwacji zostanie usunięty z kolekcji.  
  
 Po pomyślnym ukończeniu tej metody został zaktualizowany numer podstawowy sekwencyjny. Rejestrowania wszystkich rekordów z numerami sekwencji mniejsza niż nowy numer sekwencji podstawowej są niedostępne.  
  
 Jeśli został zlikwidowany rekordów sekwencji lub przekazać nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Wyjątki zgłaszane, gdy będą powodować błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> nie jest prawidłowa dla tej sekwencji.  
  
—lub— 
Numer sekwencji rozpoczęcia wyliczania określonego dziennika jest nieprawidłowy.  
  
—lub— 
 <paramref name="data" /> Nie można dołączyć, ponieważ ma on większy niż maksymalny rozmiar rekordu.  
  
—lub— 
 <paramref name="reservationCollection" /> nie został utworzony przez tę sekwencję rekordu.</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z parametrów ma <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nowy lub istniejący archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.  
  
—lub— 
 <paramref name="newBaseSeqNum" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.  
  
—lub— 
Nie można wykonać żądania z powodu błędu operacji We/Wy urządzenia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla określonego dziennika sekwencji przez system operacyjny.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
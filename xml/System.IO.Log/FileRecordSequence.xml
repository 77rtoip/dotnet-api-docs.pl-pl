<Type Name="FileRecordSequence" FullName="System.IO.Log.FileRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="357bcf9d63d200a6b2f6eff82d460c052bdce2ba" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69356893" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.FileRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type FileRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><see cref="T:System.IO.Log.IRecordSequence" /> Implementuje na początku pliku. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.FileRecordSequence> Jest to sekwencja rekordów oparta na pojedynczym pliku dziennika w systemie plików. Jest to prosta implementacja <xref:System.IO.Log.IRecordSequence> interfejsu w oparciu o prosty dziennik oparty na plikach.  
  
 W celu manipulowania dziennikiem opartym na plikach konto, na którym działa aplikacja, musi mieć wystarczające uprawnienia, zgodnie z ustawieniami zabezpieczeń systemu plików w czasie <xref:System.IO.Log.FileRecordSequence> konstruowania. Ponadto zapotrzebowanie na FullTrust jest wykonywane w czasie konstruowania. Wyniki weryfikacji uprawnień są następnie zapisywane w pamięci podręcznej z modelem zabezpieczeń systemu Windows. Należy upewnić się, że nie można przypadkowo uwidocznić zawartości sekwencji rekordów dla nieautoryzowanego użytkownika.  
  
   
  
## Examples  
 Poniższy przykład tworzy sekwencję rekordów, dołącza do niej rekord, a wreszcie odczytuje rekordy.  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.FileRecordSequence" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, <see cref="T:System.IO.Log.FileRecordSequence" /> który będzie hermetyzowany to wystąpienie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Log.FileRecordSequence" /> klasy z określonym plikiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy dostęp do odczytu/zapisu do pliku i otwiera plik z dostępem do odczytu. Oznacza to, że żądania otwarcia pliku do zapisu przez ten lub inny proces kończy się niepowodzeniem <xref:System.IO.Log.FileRecordSequence> , dopóki to wystąpienie nie zostanie usunięte, ale próby odczytu zakończą się powodzeniem. Jeśli `path` nie zostanie znaleziony, zostanie utworzony nowy plik o rozmiarze 0 bajtów.  
  
   
  
## Examples  
 Poniższy przykład tworzy sekwencję rekordów, dołącza do niej rekord, odczytuje rekordy i wreszcie usuwa sekwencję.  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Plik określony przez <paramref name="path" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="path" /> określonego przez.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, <see cref="T:System.IO.Log.FileRecordSequence" /> który będzie hermetyzowany to wystąpienie.</param>
        <param name="access">Prawidłowa <see cref="T:System.IO.FileAccess" /> wartość, która kontroluje rodzaj dostępu użytkowników do pliku dziennika.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Log.FileRecordSequence" /> klasy z określonym plikiem i trybem dostępu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Plik określony przez <paramref name="path" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="path" /> określonego przez.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access, int size);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess * int -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access, size)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, <see cref="T:System.IO.Log.FileRecordSequence" /> który będzie hermetyzowany to wystąpienie.</param>
        <param name="access">Prawidłowa <see cref="T:System.IO.FileAccess" /> wartość, która kontroluje rodzaj dostępu użytkowników do pliku dziennika.</param>
        <param name="size">Rozmiar pliku dziennika do otwarcia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Log.FileRecordSequence" /> klasy z określonym plikiem, trybem dostępu i rozmiarem pliku.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Jeden lub więcej parametrów jest poza prawidłowym zakresem.</exception>
        <exception cref="T:System.ArgumentException">Plik określony przez <paramref name="path" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="path" /> określonego przez.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="fileRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Nowy numer sekwencyjnej sekwencji rekordu.</param>
        <summary>Przenosi numer sekwencji podstawowej dziennika do przodu. Ta metoda nie może być dziedziczona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSequenceNumber" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas modyfikowania sekwencji.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje rekord dziennika do <see cref="T:System.IO.Log.FileRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy sekwencję rekordów, dołącza do niej rekord, a wreszcie odczytuje rekordy.  
  
 [!code-csharp[IRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#0)]
 [!code-vb[IRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <summary>Zapisuje rekord dziennika do <see cref="T:System.IO.Log.FileRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
   
  
## Examples  
 Poniższy przykład tworzy sekwencję rekordów, dołącza do niej rekord, a wreszcie odczytuje rekordy.  
  
 [!code-csharp[FileRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/filerecordsequence/cs/filerecordsequence.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <summary>Zapisuje rekord dziennika do <see cref="T:System.IO.Log.FileRecordSequence" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można utworzyć sekwencję rekordów przy użyciu tej metody.  
  
 [!code-csharp[IRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#3)] 
 [!code-vb[IRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#3)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna być użyta dla tego rekordu.</param>
        <summary>Zapisuje rekord dziennika do <see cref="T:System.IO.Log.FileRecordSequence" />, używając przestrzeni wcześniej zarezerwowanej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Dołączony rekord będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji określonej przez `reservations` parametr. Jeśli dołączenie powiedzie się, będzie zużywać najmniejszy obszar rezerwacji, który może zawierać dane, i że obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna być użyta dla tego rekordu.</param>
        <summary>Zapisuje rekord dziennika do <see cref="T:System.IO.Log.FileRecordSequence" />, używając przestrzeni wcześniej zarezerwowanej w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Dołączony rekord będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji określonej przez `reservations` parametr. Jeśli dołączenie powiedzie się, będzie zużywać najmniejszy obszar rezerwacji, który może zawierać dane, i że obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer sekwencji pierwszego prawidłowego rekordu w bieżącym <see cref="T:System.IO.Log.FileRecordSequence" />.</summary>
        <value>Najniższy numer sekwencyjny odpowiadający prawidłowemu rekordowi w <see cref="T:System.IO.Log.FileRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poprawne numery sekwencji są większe lub równe <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> i mniejsze niż. <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A> Wszystkie inne numery sekwencji są nieprawidłowe.  
  
 Wartość tej właściwości można zmienić przez wywołanie <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> metody lub. <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> w pętli:  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna asynchroniczne operacje dołączania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Rozpoczyna asynchroniczne operacje dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje dołączenie asynchroniczne, które nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Rozpoczyna asynchroniczne operacje dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje dołączenie asynchroniczne, które nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna być użyta dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Rozpoczyna asynchroniczne operacje dołączania przy użyciu miejsca, które zostało wcześniej zarezerwowane w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje dołączenie asynchroniczne, które nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Dołączony rekord będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji określonej przez `reservations` parametr. Jeśli dołączenie powiedzie się, będzie zużywać najmniejszy obszar rezerwacji, który może zawierać dane, i że obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna być użyta dla tego rekordu.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Rozpoczyna asynchroniczne operacje dołączania przy użyciu miejsca, które zostało wcześniej zarezerwowane w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje dołączenie asynchroniczne, które nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Dołączony rekord będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji określonej przez `reservations` parametr. Jeśli dołączenie powiedzie się, będzie zużywać najmniejszy obszar rezerwacji, który może zawierać dane, i że obszar rezerwacji zostanie usunięty z kolekcji.  
  
 Zwykle ta metoda zostaje zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji dla najnowszego rekordu, który musi zostać zapisany. Jeśli <see cref="T:System.IO.Log.SequenceNumber" /> jest nieprawidłowa, należy napisać wszystkie rekordy.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu opróżniania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to określone asynchroniczne żądanie opróżniania z innych żądań.</param>
        <summary>Rozpoczyna asynchroniczne operacje opróżniania przy użyciu miejsca, które zostało wcześniej zarezerwowane w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje asynchroniczną operację opróżniania, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwróconą przez bieżącą metodę <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> do metody, aby upewnić się, że opróżnianie i zasoby zostały odpowiednio zwolnione. Jeśli wystąpi błąd podczas asynchronicznego opróżniania, wyjątek nie zostanie zgłoszony, dopóki <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z zwracanym przez tę metodę.  
  
 Wywołanie tej metody zapewnia, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.FileRecordSequence> trwale są zapisywane.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania opróżniania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków w przypadku <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> wywołania metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.  
  
 <paramref name="sequenceNumber" />nie jest prawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację rezerwy asynchronicznej i dołączenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservationCollection">Kolekcja rezerwacji, w której mają zostać wprowadzone rezerwacje.</param>
        <param name="reservations">Rezerwacje do wprowadzenia w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Rozpoczyna operację rezerwy asynchronicznej i dołączenia. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje tę operację asynchroniczną, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Określone rezerwacje są dodawane do podanej kolekcji rezerwacji w operacji niepodzielnej przy użyciu operacji dołączania rekordu. Jeśli dołączenie nie powiedzie się, żadne miejsce nie jest zarezerwowane.  
  
 Zwykle ta metoda może zostać zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservationCollection">Kolekcja rezerwacji, w której mają zostać wprowadzone rezerwacje.</param>
        <param name="reservations">Rezerwacje do wprowadzenia w bajtach.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu dołączania.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie dodania z innych żądań.</param>
        <summary>Rozpoczyna operację rezerwy asynchronicznej i dołączenia. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje tę operację asynchroniczną, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> metodę, aby upewnić się, że operacja dołączania została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas dołączania asynchronicznego, wyjątek nie zostanie wygenerowany, dopóki <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> Metoda nie zostanie wywołana <xref:System.IAsyncResult> z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Określone rezerwacje są dodawane do podanej kolekcji rezerwacji w operacji niepodzielnej przy użyciu operacji dołączania rekordu. Jeśli dołączenie nie powiedzie się, żadne miejsce nie jest zarezerwowane.  
  
 Zwykle ta metoda może zostać zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację zapisu w obszarze asynchronicznego ponownego uruchamiania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <param name="reservation">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna zostać użyta dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma zostać wywołane po zakończeniu zapisu w obszarze ponownego uruchomienia.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie zapisu w obszarze ponownego uruchamiania z innych żądań.</param>
        <summary>Rozpoczyna operację zapisu w obszarze asynchronicznego ponownego uruchamiania, używając miejsca, które zostało wcześniej zarezerwowane w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje operację zapisu w obszarze asynchronicznych ponownych uruchomień, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> metodę, aby upewnić się, że operacja zapisu w obszarze ponownego uruchomienia została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas operacji zapisu w obszarze asynchronicznych ponownych uruchomień, wyjątek nie zostanie wygenerowany <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> , dopóki metoda nie zostanie <xref:System.IAsyncResult> wywołana z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 <xref:System.IO.Log.ReservationCollection> Jeśli jest określony, zapisany obszar ponownego uruchomienia będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji zawartej w kolekcji. Jeśli metoda zakończy się pomyślnie, użyje najmniejszej rezerwacji, która może przechowywać dane i że rezerwacja zostanie usunięta z kolekcji.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.  
  
—lub— 
Nowy lub istniejący element archiwum lub podstawa aktywnego dziennika jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.  
  
—lub— 
 <paramref name="newBaseSeqNum" />nie jest prawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <param name="reservation">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna zostać użyta dla tego obszaru ponownego uruchomienia.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma zostać wywołane po zakończeniu zapisu w obszarze ponownego uruchomienia.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie zapisu w obszarze ponownego uruchamiania z innych żądań.</param>
        <summary>Rozpoczyna operację zapisu w obszarze asynchronicznego ponownego uruchamiania, używając miejsca, które zostało wcześniej zarezerwowane w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje operację zapisu w obszarze asynchronicznych ponownych uruchomień, która nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przekazać <xref:System.IAsyncResult> zwracaną przez tę metodę <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> metodę, aby upewnić się, że operacja zapisu w obszarze ponownego uruchomienia została ukończona, a zasoby mogą być odpowiednio zwolnione. Jeśli wystąpił błąd podczas operacji zapisu w obszarze asynchronicznych ponownych uruchomień, wyjątek nie zostanie wygenerowany <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> , dopóki metoda nie zostanie <xref:System.IAsyncResult> wywołana z wynikiem zwróconym przez tę metodę.  
  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Po pomyślnym zakończeniu operacji numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 <xref:System.IO.Log.ReservationCollection> Jeśli jest określony, zapisany obszar ponownego uruchomienia będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji zawartej w kolekcji. Jeśli metoda zakończy się pomyślnie, użyje najmniejszej rezerwacji, która może przechowywać dane i że rezerwacja zostanie usunięta z kolekcji.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.  
  
—lub— 
Nowy lub istniejący element archiwum lub podstawa aktywnego dziennika jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.  
  
—lub— 
 <paramref name="newBaseSeqNum" />nie jest prawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="fileRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.IO.Log.ReservationCollection" />. Ta metoda nie może być dziedziczona.</summary>
        <returns>Nowo utworzony <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="fileRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Natychmiast zwalnia niezarządzane zasoby używane przez obiekt.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekującego żądania asynchroniczne we/wy.</param>
        <summary>Kończenie asynchronicznej operacji dołączania. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy. Błędy występujące podczas asynchronicznego żądania zapisu, takie jak awaria dysku w żądaniu we/wy, stają się widoczne po <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> wywołaniu.  
  
 Ta metoda musi być wywoływana dokładnie raz na każdym <xref:System.IAsyncResult> zwracanym <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> przez metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" />zostało już wywołane dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekującego żądania asynchroniczne we/wy.</param>
        <summary>Zamyka asynchroniczną operację opróżniania. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji ostatniego zapisywanego rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy. Błędy występujące podczas asynchronicznego żądania opróżniania, takie jak awaria dysku w żądaniu we/wy, stają się widoczne po <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> wywołaniu.  
  
 Ta metoda musi być wywoływana dokładnie raz na każdym <xref:System.IAsyncResult> zwracanym <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> przez metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" />zostało już wywołane dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekującego żądania asynchroniczne we/wy.</param>
        <summary>Przerywa operację rezerwy asynchronicznej i dołączenia. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy. Błędy występujące podczas asynchronicznego żądania zapisu, takie jak awaria dysku w żądaniu we/wy, stają się widoczne po <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> wywołaniu.  
  
 Ta metoda musi być wywoływana dokładnie raz na każdym <xref:System.IAsyncResult> zwracanym <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> przez metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" />zostało już wywołane dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do oczekującego żądania asynchroniczne we/wy.</param>
        <summary>Powoduje zakończenie operacji zapisu w obszarze asynchronicznego ponownego uruchamiania. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny zapisywanego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy. Błędy występujące podczas asynchronicznego żądania zapisu, takie jak awaria dysku w żądaniu we/wy, stają się widoczne po <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> wywołaniu.  
  
 Ta metoda musi być wywoływana dokładnie raz na każdym <xref:System.IAsyncResult> zwracanym <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> przez metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see langword="End" />zostało już wywołane dla tej operacji asynchronicznej.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że dołączone rekordy mają być trwale zapisane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że zostały zapisane wszystkie dołączone rekordy. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji ostatniego zapisywanego rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody zapewnia, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.FileRecordSequence> trwale zostały zapisane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Numer sekwencji dla najnowszego rekordu, który musi zostać zapisany. Jeśli jest <see cref="T:System.IO.Log.SequenceNumber" /> to nieprawidłowe, należy napisać wszystkie rekordy.</param>
        <summary>Zapewnia, że zostały zapisane wszystkie dołączone rekordy. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji ostatniego zapisywanego rekordu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody zapewnia, że wszystkie rekordy z numerami sekwencji do i włącznie z określonym numerem sekwencyjnym zostały trwale zapisane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sequenceNumber" />nie jest prawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas opróżniania danych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer sekwencyjny, który jest większy niż ostatni dołączony rekord.</summary>
        <value>Numer sekwencyjny, który jest większy od ostatniego dołączonego rekordu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera numer sekwencyjny, który gwarantuje, że jest większy niż numer sekwencji ostatniego dołączonego rekordu. Poprawne numery sekwencji są większe lub równe <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> i mniejsze niż. <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A> Wszystkie inne numery sekwencji są nieprawidłowe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar największego rekordu, który może być dołączany do tej sekwencji lub z niej odczytywany w bajtach.</summary>
        <value>Rozmiar największego rekordu, który może być dołączany lub odczytywany z tej sekwencji, w bajtach.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Numer sekwencyjny pierwszego rekordu, w którym rozpocznie się odczytywanie.</param>
        <param name="logRecordEnum">Prawidłowa <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> wartość określająca sposób (czyli do przodu lub do tyłu), w której rekordy mają być odczytywane <see cref="T:System.IO.Log.LogRecordSequence" />z.</param>
        <summary>Zwraca wyliczalną kolekcję rekordów w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Wyliczalna kolekcja rekordów w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wyliczalną kolekcję rekordów w sekwencji. Kolejność rekordów wyliczanych zależy od wartości `logRecordEnum` parametru.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można użyć tej metody do odczytywania rekordów w sekwencji dzienników.  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do zapisu.</exception>
        <exception cref="T:System.IO.IOException">Sekwencja rekordów jest uszkodzona.  
  
 —lub—  
  
 Rekord został zapisany z niezgodną wersją sekwencji rekordów.</exception>
        <exception cref="T:System.InvalidOperationException">Wyliczenie zostało zakończone.  
  
—lub— 
Wyliczenie nie zostało uruchomione. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> musi być wykonane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalną kolekcję obszarów ponownego uruchomienia w sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Wyliczalna kolekcja obszarów ponownego uruchomienia w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszary ponownego uruchomienia są wyliczane w odwrotnej kolejności numerów sekwencyjnych, czyli od najwyższego numeru sekwencyjnego na najniższy numer sekwencyjny. Należy wyliczyć tylko obszary z numerami sekwencyjnymi między ostatnim numerem sekwencyjnym a numerem sekwencyjnym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do zapisu.</exception>
        <exception cref="T:System.IO.IOException">Sekwencja rekordów jest uszkodzona.  
  
 —lub—  
  
 Rekord został zapisany z niezgodną wersją sekwencji rekordów.</exception>
        <exception cref="T:System.InvalidOperationException">Wyliczenie zostało zakończone.  
  
—lub— 
Wyliczenie nie zostało uruchomione. Wywołanie <see cref="M:System.Collections.IEnumerator.MoveNext" /> musi być wykonane.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Automatycznie dokonuje pojedynczej rezerwacji i dołącza rekord do sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera kolekcję, w której będą wprowadzane rezerwacje.</param>
        <param name="reservations">Rezerwacje do wprowadzenia w bajtach.</param>
        <summary>Automatycznie dokonuje pojedynczej rezerwacji i dołącza rekord do sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Określone rezerwacje są dodawane do podanej kolekcji rezerwacji w operacji niepodzielnej przy użyciu operacji dołączania rekordu. Jeśli dołączenie nie powiedzie się, żadne miejsce nie jest zarezerwowane.  
  
 Zwykle ta metoda może zostać zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="nextUndoRecord">Numer sekwencji następnego rekordu w kolejności określonej przez użytkownika.</param>
        <param name="previousRecord">Numer sekwencji następnego rekordu w poprzedniej kolejności.</param>
        <param name="recordAppendOptions">Prawidłowa wartość <see cref="T:System.IO.Log.RecordAppendOptions" /> określająca sposób zapisywania danych.</param>
        <param name="reservationCollection">Kolekcja rezerwacji, w której mają zostać wprowadzone rezerwacje.</param>
        <param name="reservations">Rezerwacje do wprowadzenia w bajtach.</param>
        <summary>Automatycznie dokonuje pojedynczej rezerwacji i dołącza rekord do sekwencji. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencji dołączonego rekordu dziennika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane zawarte w `data` parametrze zostaną połączone do tablicy jednobajtowej w celu dołączenia jako rekord. Jednak nie ma potrzeby dzielenia danych z powrotem do segmentów tablicy podczas odczytywania rekordu.  
  
 Określone rezerwacje są dodawane do podanej kolekcji rezerwacji w operacji niepodzielnej przy użyciu operacji dołączania rekordu. Jeśli dołączenie nie powiedzie się, żadne miejsce nie jest zarezerwowane.  
  
 Zwykle ta metoda może zostać zakończona przed zapisaniem rekordu. Aby upewnić się, że rekord został zapisany, określ <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flagę `recordAppendOptions` przy użyciu <xref:System.IO.Log.FileRecordSequence.Flush%2A> parametru lub wywołaj metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z argumentów jest poza zakresem.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną liczbę bajtów, które zostały zarezerwowane.</summary>
        <value>Łączny rozmiar wszystkich rezerwacji wykonanych w tej sekwencji rekordów.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer sekwencji ostatnio zapisywanego obszaru ponownego uruchomienia.</summary>
        <value>Numer sekwencji ostatnio zapisywanego obszaru ponownego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar ponownego uruchomienia jest używany do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Common Log File System (CLFS) utrzymuje dwa obszary ponownego uruchomienia w celu zagwarantowania, że co najmniej jeden prawidłowy obszar jest zawsze dostępny. Gdy wymagane jest odzyskanie, CLFS odczytuje jego obszar ponownego uruchomienia i wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dołączania są automatycznie ponawiane, jeśli dziennik jest pełny.</summary>
        <value><see langword="true" />Jeśli dołączenia są automatycznie ponawiane, jeśli dziennik jest pełny; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość tej właściwości jest `true`, <xref:System.IO.Log.FileRecordSequence.Append%2A> a wywołanie nie powiedzie się, ponieważ nie ma wystarczającej ilości miejsca w sekwencji, sekwencja rekordów spróbuje zwolnić miejsce i ponowić próbę dołączenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.FileRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy sekwencja rekordów określa, że końcówka musi zostać przeniesiona do przodu. Ta metoda nie może być dziedziczona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie można wywołać, gdy w sekwencji rekordów zabrakło wolnego miejsca. Po uruchomieniu tego zdarzenia ogon sekwencji (czyli numer sekwencyjny) jest przenoszony do przodu w celu zwolnienia miejsca.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje obszar <see cref="T:System.IO.Log.FileRecordSequence" />ponownego uruchomienia w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszaru ponownego uruchomienia można użyć do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można odczytać obszar ponownego uruchomienia i pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <summary>Zapisuje obszar <see cref="T:System.IO.Log.FileRecordSequence" />ponownego uruchomienia w. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszaru ponownego uruchomienia można użyć do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można odczytać obszar ponownego uruchomienia i pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtowej zostaną połączone w tablicę jednobajtową w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <summary>Zapisuje obszar <see cref="T:System.IO.Log.FileRecordSequence" />ponownego uruchomienia w. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszaru ponownego uruchomienia można użyć do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można odczytać obszar ponownego uruchomienia i pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> metody.  
  
 Dane w segmentach tablicy bajtowej zostaną połączone w tablicę jednobajtową w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <summary>Zapisuje obszar <see cref="T:System.IO.Log.FileRecordSequence" />ponownego uruchomienia w. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszaru ponownego uruchomienia można użyć do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można odczytać obszar ponownego uruchomienia i pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> metody.  
  
 Po zapisaniu obszaru ponownego uruchamiania dane w segmentach tablicy bajtowej są łączone do tablicy jednobajtowej w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 Po pomyślnym zakończeniu tej metody numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.  
  
—lub— 
Nowy lub istniejący element archiwum lub podstawa aktywnego dziennika jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" />nie jest prawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <summary>Zapisuje obszar <see cref="T:System.IO.Log.FileRecordSequence" />ponownego uruchomienia w. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszaru ponownego uruchomienia można użyć do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można odczytać obszar ponownego uruchomienia i pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> metody.  
  
 Po zapisaniu obszaru ponownego uruchamiania dane w segmentach tablicy bajtowej są łączone do tablicy jednobajtowej w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 Po pomyślnym zakończeniu tej metody numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.  
  
—lub— 
Nowy lub istniejący element archiwum lub podstawa aktywnego dziennika jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" />nie jest prawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna zostać użyta dla tego obszaru ponownego uruchomienia.</param>
        <summary>Zapisuje obszar <see cref="T:System.IO.Log.FileRecordSequence" />ponownego uruchomienia w. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszaru ponownego uruchomienia można użyć do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można odczytać obszar ponownego uruchomienia i pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> metody.  
  
 Po zapisaniu obszaru ponownego uruchamiania dane w segmentach tablicy bajtowej są łączone do tablicy jednobajtowej w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 W przypadku określenia rezerwacji, zapisany obszar ponownego uruchomienia będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji zawartej w kolekcji. Jeśli metoda zakończy się pomyślnie, użyje najmniejszej rezerwacji, która może zawierać dane, i że rezerwacja zostanie usunięta z kolekcji.  
  
 Po pomyślnym zakończeniu tej metody numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.  
  
—lub— 
Nowy lub istniejący element archiwum lub podstawa aktywnego dziennika jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.  
  
—lub— 
 <paramref name="newBaseSeqNum" />nie jest prawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord.</param>
        <param name="newBaseSeqNum">Nowy numer sekwencyjny. Określony numer sekwencji musi być większy lub równy bieżącemu numerowi sekwencji podstawowej.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> , który zawiera rezerwację, która powinna zostać użyta dla tego obszaru ponownego uruchomienia.</param>
        <summary>Zapisuje obszar <see cref="T:System.IO.Log.FileRecordSequence" />ponownego uruchomienia w. Ta metoda nie może być dziedziczona.</summary>
        <returns>Numer sekwencyjny w zapisanym obszarze ponownego uruchomienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszaru ponownego uruchomienia można użyć do tymczasowego przechowywania informacji zawierających ostatnią operację punktu kontrolnego klienta. Gdy odzyskiwanie jest konieczne, można odczytać obszar ponownego uruchomienia i pobrać wszystkie dane z ostatniej operacji punktu kontrolnego. Te dane inicjują tabelę transakcji, tabelę zanieczyszczonych stron i Otwórz tabelę plików, dzięki czemu mogą być używane w procesie odzyskiwania.  
  
 Obszar ponownego uruchomienia można odczytać za pomocą <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> metody.  
  
 Po zapisaniu obszaru ponownego uruchamiania dane w segmentach tablicy bajtowej są łączone do tablicy jednobajtowej w celu dołączenia jako rekord. Nie wprowadzono żadnych zasobów do dzielenia danych z powrotem do segmentów tablicy, gdy zostanie odczytany obszar ponownego uruchomienia.  
  
 W przypadku określenia rezerwacji, zapisany obszar ponownego uruchomienia będzie zużywać miejsce, które zostało wcześniej zarezerwowane, przy użyciu rezerwacji zawartej w kolekcji. Jeśli metoda zakończy się pomyślnie, użyje najmniejszej rezerwacji, która może zawierać dane, i że rezerwacja zostanie usunięta z kolekcji.  
  
 Po pomyślnym zakończeniu tej metody numer sekwencyjny został zaktualizowany. Wszystkie rekordy dziennika o numerach sekwencyjnych mniejszych niż nowy podstawowy numer sekwencji są niedostępne.  
  
 W przypadku usunięcia sekwencji rekordów lub przekazania nieprawidłowego argumentu wyjątki są generowane natychmiast w ramach tej operacji. Błędy, które wystąpiły podczas asynchronicznego żądania dołączania, na przykład awaria dysku w żądaniu we/wy, spowodują wyrzucanie wyjątków, <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> gdy wywoływana jest metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z argumentów ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.  
  
—lub— 
Nowy lub istniejący element archiwum lub podstawa aktywnego dziennika jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" />Ta sekwencja rekordów nie została utworzona.  
  
—lub— 
 <paramref name="newBaseSeqNum" />nie jest prawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Nie można wykonać żądania z powodu nieoczekiwanego wyjątku we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Nie można <paramref name="data" /> <paramref name="reservations" />znaleźć rezerwacji wystarczająco dużej do dopasowania.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e11df4d7778681fe8d96add17f0f469338dd4175" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36562057" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje magazynu opartą na strukturze dziennika.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogRecordSequence> Klasa zawiera implementację interfejsu sekwencja rekordów na górze dziennika wspólnej dziennika File System (CLFS). W przypadku <xref:System.IO.Log.LogStore> klasy, która zapewnia interfejs bezpośrednio manipulacji i zarządzanie CLFS pliku dziennika. Magazynu dziennika zawiera tylko Dołącz magazynu zestawu zakresów dysków. <xref:System.IO.Log.LogStore> Klasa reprezentuje tego magazynu i dostarcza metod dodawania i usuwania kontenerów, ustawienia zasad i tworzenia archiwa. Nie ma metody dla odczytywanie z oraz zapisywanie do magazynu; te metody są dostarczane przez <xref:System.IO.Log.LogRecordSequence> klasy.  
  
 Relacja między <xref:System.IO.Log.LogStore> klasy i <xref:System.IO.Log.LogRecordSequence> klasy jest podobna do relacji między pliku na dysku i <xref:System.IO.FileStream> obiektu. Plik dysku miejsce przechowywania i atrybuty, takie jak długość i czas ostatniego dostępu podczas <xref:System.IO.FileStream> obiektu zawiera widok na pliku, który może służyć do odczytu i zapisu do niego. Podobnie <xref:System.IO.Log.LogStore> klasa ma atrybutów, takich jak zasady i kolekcję zakresów dysków i <xref:System.IO.Log.LogRecordSequence> klasa udostępnia zorientowane na rekordy mechanizm odczytywania i zapisywania danych.  
  
 W odróżnieniu od sekwencja rekordów pliku reprezentowany przez <xref:System.IO.Log.FileRecordSequence> klasy <xref:System.IO.Log.LogStore> wystąpienia przechowuje dane w kolekcji zakresów dysków, reprezentowany przez <xref:System.IO.Log.LogExtent> wystąpień. Zakresów w danym <xref:System.IO.Log.LogStore> wystąpienia są wszystkie o różnych wielkościach, a miejsca zostaną dodane do i usunięte z <xref:System.IO.Log.LogStore> wystąpienia w przyrostach zakresu. Aby dodać lub usunąć zakresy dziennika, należy użyć <xref:System.IO.Log.LogExtentCollection.Add%2A> i <xref:System.IO.Log.LogExtentCollection.Remove%2A> metody <xref:System.IO.Log.LogExtentCollection> obiektu, który może być zwracany przez <xref:System.IO.Log.LogStore.Extents%2A> właściwości.  
  
 A <xref:System.IO.Log.LogStore> wystąpienie może mieć zasady skojarzone z nim. Są one reprezentowane przez <xref:System.IO.Log.LogPolicy> wystąpień, które mogą być zwrócone przez <xref:System.IO.Log.LogStore.Policy%2A> właściwości. Zasady wymuszają zasady, które dziennika będzie podejmować kolejnych, takich jak maksymalna liczba zakresów, a minimalny rozmiar i instrukcje związanych z rośnie lub zmniejszanie <xref:System.IO.Log.LogStore> w niektórych warunkach. Ponadto można określić czy <xref:System.IO.Log.LogStore> wystąpienie może być archiwizowane. Zasady są ustawione na dziennika i są nietrwałe, co oznacza, że po zamknięciu co dojścia do dziennika zasady już nie istnieje.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób archiwum <xref:System.IO.Log.LogStore> do dokumentu XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dziennika plik, który bieżącego <see cref="T:System.IO.Log.LogStore" /> hermetyzuje obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy dla określonego dojścia.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Nie można powiązać dojścia dziennika z pulą wątków.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości, które określa, jak otworzyć lub utworzyć magazynu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy z określoną ścieżką i trybu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor umożliwia otwieranie magazynu dziennika z określoną ścieżką i trybu. Magazyn jest otwarta z dostępem do odczytu/zapisu i udostępnia dostęp do odczytu.  
  
 `path` Parametru należy użyć następującej składni:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest identyfikatorem unikatowych klientów. Magazynu dziennika powinien być magazynu fizycznego dziennika lub magazynu wirtualnego dziennika, ale nie oba. Po utworzeniu magazynu dziennika, fizycznie lub praktycznie, pozostaje tak przez jego okres istnienia. Magazynu fizycznego dziennika jest tworzony, określając nazwę dziennika fizycznego. Magazynu wirtualnego dziennika jest tworzony przez określenie zarówno nazwę dziennika fizycznych, jak i nazwę dziennika klienta.  
  
 Klientów, które mają taką samą nazwę dziennika fizycznego korzysta z tej samej kolekcji zakresów i zasad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  - lub - <paramref name="path" /> zawiera tylko biały znak.  - lub - <paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla platformy lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> zamiast klasy.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości, które określa, jak otworzyć lub utworzyć magazynu.</param>
        <param name="access">Jeden z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> z określonej ścieżki, tryb i dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otworzyć nowy magazyn dziennika z określonej ścieżki, tryb i dostępu, należy użyć tego konstruktora. Magazyn jest otwarty, udostępnianie dostęp do odczytu.  
  
 `path` Parametru należy użyć następującej składni:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest identyfikatorem unikatowych klientów. Magazynu dziennika powinien być magazynu fizycznego dziennika lub magazynu wirtualnego dziennika, ale nie oba. Po utworzeniu magazynu dziennika, fizycznie lub praktycznie, pozostaje tak przez jego okres istnienia. Magazynu fizycznego dziennika jest tworzony, określając nazwę dziennika fizycznego. Magazynu wirtualnego dziennika jest tworzony przez określenie zarówno nazwę dziennika fizycznych, jak i nazwę dziennika klienta.  
  
 Klientów, które mają taką samą nazwę dziennika fizycznego korzysta z tej samej kolekcji zakresów i zasad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  - lub - <paramref name="path" /> zawiera tylko biały znak.  - lub - <paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.  - lub <paramref name="access" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla platformy lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> zamiast klasy.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości, które określa, jak otworzyć lub utworzyć magazynu.</param>
        <param name="access">Jeden z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Jeden z <see cref="T:System.IO.FileShare" /> wartości, które określa, jak magazynu dziennika będzie współdzielona przez procesy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i dostępu. Magazyn jest otwarty, udostępnianie określonego dostępu.  
  
 `path` Parametru należy użyć następującej składni:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest identyfikatorem unikatowych klientów. Magazynu dziennika powinien być magazynu fizycznego dziennika lub magazynu wirtualnego dziennika, ale nie oba. Po utworzeniu magazynu dziennika, fizycznie lub praktycznie, pozostaje tak przez jego okres istnienia. Magazynu fizycznego dziennika jest tworzony, określając nazwę dziennika fizycznego. Magazynu wirtualnego dziennika jest tworzony przez określenie zarówno nazwę dziennika fizycznych, jak i nazwę dziennika klienta.  
  
 Klientów, które mają taką samą nazwę dziennika fizycznego korzysta z tej samej kolekcji zakresów i zasad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  - lub - <paramref name="path" /> zawiera tylko biały znak.  - lub - <paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.  - lub <paramref name="access" /> zawiera nieprawidłową wartość.  - lub - <paramref name="share" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla platformy lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> zamiast klasy.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości, które określa, jak otworzyć lub utworzyć magazynu.</param>
        <param name="access">Jeden z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Jeden z <see cref="T:System.IO.FileShare" /> wartości, które określa, jak magazynu dziennika będzie współdzielona przez procesy.</param>
        <param name="fileSecurity">Jeden z <see cref="T:System.Security.AccessControl.FileSecurity" /> wartość, która określa zabezpieczeń można ustawić na nowo utworzony magazyn, jeśli magazyn musi zostać utworzony.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i dostępu. Magazyn jest otwarty, udostępnianie określonego dostępu. `path` Parametr należy wykonać następującą składnię:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest identyfikatorem unikatowych klientów. Magazynu dziennika powinien być magazynu fizycznego dziennika lub magazynu wirtualnego dziennika, ale nie oba. Po utworzeniu magazynu dziennika, fizycznie lub praktycznie, pozostaje tak przez jego okres istnienia. Magazynu fizycznego dziennika jest tworzony, określając nazwę dziennika fizycznego. Magazynu wirtualnego dziennika jest tworzony przez określenie zarówno nazwę dziennika fizycznych, jak i nazwę dziennika klienta.  
  
 Klientów, które mają taką samą nazwę dziennika fizycznego korzysta z tej samej kolekcji zakresów i zasad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa pliku magazynu dziennika określony przez <paramref name="path" /> jest nieprawidłowy.  - lub - <paramref name="Mode" /> jest <see langword="CreateNew" />, której nie można używać bez dostępu do zapisu.  - lub - <paramref name="Mode" /> jest <see langword="OpenOrCreate" />, której nie można używać bez dostępu do zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.  - lub <paramref name="access" /> zawiera nieprawidłową wartość.  - lub - <paramref name="share" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas otwierania magazynu dziennika.  Plik określony przez <paramref name="path" /> jest niedostępny, ponieważ jest on używany przez inny proces.  - lub - plik określony przez <paramref name="path" /> nie można utworzyć, ponieważ plik lub katalog już istnieje.  - lub - nie można powiązać dojścia dziennika z pulą wątków.  - lub - format pliku dziennika określonego lub wersja jest nieprawidłowa.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla platformy lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> zamiast klasy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy to <see cref="T:System.IO.Log.LogStore" /> wystąpienie może być archiwizowane.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.Log.LogStore" /> wystąpienie może być archiwizowane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Log.LogStore> nie można utworzyć archiwum, wywołań <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> i <xref:System.IO.Log.LogStore.SetArchiveTail%2A> wynikiem metody <xref:System.NotSupportedException> został zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera najniższy numer sekwencji, odpowiadający z prawidłowym rekordem w tym <see cref="T:System.IO.Log.LogStore" /> wystąpienia.</summary>
        <value>Najniższy numer sekwencji, umożliwiająca prawidłowy rekord w tym <see cref="T:System.IO.Log.LogStore" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowych numerów sekwencji są większe niż lub równe <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> i mniejsza niż <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera migawkę stanu magazynu dziennika niezbędne do wykonywania kopii zapasowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera migawkę stanu magazynu dziennika do tworzenia kopii zapasowej.</summary>
        <returns>A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> obiekt, który zawiera stan niezbędne do archiwum.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób archiwum <xref:System.IO.Log.LogStore> do dokumentu XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można utworzyć archiwum magazynu dziennika.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowa operacja zostało wykonane.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">Numer początkowej sekwencji w zakresie archiwizacji.</param>
        <param name="last">Końcowy numer sekwencji w zakresie archiwizacji.</param>
        <summary>Pobiera migawkę stanu magazynu dziennika między liczbami określona sekwencja do tworzenia kopii zapasowej.</summary>
        <returns>A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> obiekt, który zawiera stan niezbędne do archiwum.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje z numerem podstawowej lub numer sekwencyjny archiwum obejmuje migawki archiwum zwracane z tej metody, nastąpi małe, ostatni numer sekwencji. Nie jest ostatniego numeru sekwencji, co oznacza, że archiwum tylko znajdują się rekordy do z wyjątkiem ostatnich włącznie. Ponadto przy użyciu tej metody, start SequenceNumber musi być równa BaseSequenceNumber aby archiwum było spójne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="first" /> lub <paramref name="last" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="first" /> jest większe niż <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowa operacja zostało wykonane.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.NotSupportedException">Nie można utworzyć archiwum magazynu dziennika.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do usunięcia.</param>
        <summary>Usuwa magazynu dziennika.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  - lub - <paramref name="path" /> zawiera tylko biały znak.  - lub - <paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.IO.Log.LogStore.Dispose%2A> po ukończeniu przy użyciu <xref:System.IO.Log.LogStore>. <xref:System.IO.Log.LogStore.Dispose%2A> Pozostawia metody <xref:System.IO.Log.LogStore> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.IO.Log.LogStore.Dispose%2A> , konieczne jest zwolnienie wszystkich odwołań do <xref:System.IO.Log.LogStore> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.IO.Log.LogStore> klasy.  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.IO.Log.LogStore.Dispose%2A> przed zwolnieniem ostatniego odwołania do <xref:System.IO.Log.LogStore>. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.IO.Log.LogStore> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zakresów dziennika, które zawierają dane dla tego magazynu dziennika.</summary>
        <value>A <see cref="T:System.IO.Log.LogExtentCollection" /> wystąpienia zawierający kolekcję zakresów dziennika, który hermetyzuje dane dla tego magazynu dziennika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.IO.Log.LogStore> wystąpienia przechowuje dane w kolekcji zakresów dysków, reprezentowany przez <xref:System.IO.Log.LogExtent> wystąpień. Zakresów w danym <xref:System.IO.Log.LogStore> wystąpienia są wszystkie o różnych wielkościach, a miejsca zostaną dodane do i usunięte z <xref:System.IO.Log.LogStore> wystąpienia w przyrostach zakresu. Aby dodać lub usunąć zakresy dziennika, należy użyć <xref:System.IO.Log.LogExtentCollection.Add%2A> i <xref:System.IO.Log.LogExtentCollection.Remove%2A> metody <xref:System.IO.Log.LogExtentCollection> obiektu, który jest zwracany przez tę właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów dostępnych w magazynie dziennika.</summary>
        <value>Liczba bajtów, które są dostępne w magazynie dziennika.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście do pliku systemu operacyjnego dla plików dziennika, który bieżącego <see cref="T:System.IO.Log.LogStore" /> hermetyzuje wystąpienia.</summary>
        <value>Dojście do pliku systemu operacyjnego dla dziennika pliku bieżącego <see cref="T:System.IO.Log.LogStore" /> hermetyzuje wystąpienia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera numer sekwencyjny następnego rekordu mają być dołączane do magazynu dziennika.</summary>
        <value>Numer sekwencyjny następnego rekordu mają być dołączane do magazynu dziennika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowych numerów sekwencji są większe niż lub równe <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> i mniejsza niż <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar magazynu dziennika w bajtach.</summary>
        <value>Rozmiar magazynu dziennika w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar magazynu dziennika jest sumą rozmiary zakresów dziennika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość uzyskano po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zasady skojarzone z tym magazynu dziennika.</summary>
        <value>A <see cref="T:System.IO.Log.LogPolicy" /> wystąpienia reprezentującej zasady skojarzone z tym magazynu dziennika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.IO.Log.LogPolicy> zwracane przez tę właściwość do badania i manipulowania zasad dziennika skojarzonych z tym wystąpieniem <xref:System.IO.Log.LogStore>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">Numer sekwencji uchwyt archiwum.</param>
        <summary>Ustawia numer sekwencji uchwyt archiwum.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mniejsze numer sekwencyjny podstawowej i uchwyt archiwum określa końcowego fragmentu dziennika.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób archiwum <xref:System.IO.Log.LogStore> do dokumentu XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="archiveTail" /> nie jest od podstawowego do ostatniego numeru sekwencji.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="archiveTail" /> jest nieprawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowa operacja zostało wykonane.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.NotSupportedException">Nie można utworzyć archiwum magazynu dziennika.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do magazynu określony dziennik przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę strumieni dziennik w tym magazynie dziennika.</summary>
        <value>Liczba strumieni dziennik w tym magazynie dziennika.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
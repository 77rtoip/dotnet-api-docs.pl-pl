<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3d2973801edb7f38489df79e4b3d97f234628173" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69245167" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje magazyn strukturalny dzienników.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogRecordSequence> Klasa zawiera implementację interfejsu sekwencji rekordów na podstawie dziennika Common Log File System (CLFS). Współpracuje z <xref:System.IO.Log.LogStore> klasą, która zapewnia interfejs do bezpośredniego manipulowania plikiem dziennika CLFS i zarządzania nim. Magazyn dzienników zapewnia magazyn tylko do odczytu w zestawie zakresów dysków. <xref:System.IO.Log.LogStore> Klasa reprezentuje ten magazyn i oferuje metody dodawania i usuwania kontenerów, ustawiania zasad i tworzenia archiwów. Nie zapewnia metod odczytu i zapisu do magazynu; te metody są dostarczane przez <xref:System.IO.Log.LogRecordSequence> klasę.  
  
 Relacja między <xref:System.IO.Log.LogStore> klasą <xref:System.IO.Log.LogRecordSequence> a klasą jest podobna do relacji między plikiem dysku a <xref:System.IO.FileStream> obiektem. Plik dysku zawiera rzeczywisty magazyn i ma atrybuty, takie jak długość i czas ostatniego dostępu, podczas gdy <xref:System.IO.FileStream> obiekt zawiera widok pliku, który może być używany do odczytywania z niego i zapisu. Podobnie Klasa ma atrybuty, takie jak zasady i kolekcja zakresów dysku, <xref:System.IO.Log.LogRecordSequence> a Klasa zapewnia mechanizm zorientowany na rekordy do odczytu i zapisu danych. <xref:System.IO.Log.LogStore>  
  
 W przeciwieństwie do sekwencji rekordów plików reprezentowanej <xref:System.IO.Log.FileRecordSequence> przez klasę <xref:System.IO.Log.LogStore> wystąpienie przechowuje swoje dane w kolekcji zakresów dysku reprezentowanej przez <xref:System.IO.Log.LogExtent> wystąpienia. Zakresy w danym <xref:System.IO.Log.LogStore> wystąpieniu mają jednolity rozmiar, a miejsce jest dodawane do i usuwane <xref:System.IO.Log.LogStore> z wystąpienia w przyrostach. Aby dodać i usunąć zakresy dzienników <xref:System.IO.Log.LogExtentCollection.Add%2A> , użyj metod <xref:System.IO.Log.LogExtentCollection> i <xref:System.IO.Log.LogExtentCollection.Remove%2A> <xref:System.IO.Log.LogStore.Extents%2A> obiektu, które mogą być zwracane przez właściwość.  
  
 Z <xref:System.IO.Log.LogStore> wystąpieniem mogą być skojarzone zasady. Są one reprezentowane przez <xref:System.IO.Log.LogPolicy> wystąpienia, które mogą być zwracane <xref:System.IO.Log.LogStore.Policy%2A> przez właściwość. Zasady wymuszają reguły, które będą podejmować próby wykonania dziennika, takie jak Maksymalna liczba zakresów i minimalny rozmiar oraz instrukcje dotyczące wzrostu lub zmniejszania <xref:System.IO.Log.LogStore> w określonych warunkach. Ponadto można określić, czy <xref:System.IO.Log.LogStore> wystąpienie może być archiwizowane. Zasady są ustawiane na dziennik i są nietrwałe, co oznacza, że po zamknięciu każdego dojścia do dziennika zasady już nie istnieją.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.IO.Log.LogStore> jak zarchiwizować plik w dokumencie XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dziennika, które jest hermetyzowane <see cref="T:System.IO.Log.LogStore" /> przez bieżący obiekt.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Log.LogStore" /> klasy dla określonego dojścia.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Nie można powiązać dojścia dziennika z pulą wątków.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dzienników do otwarcia.</param>
        <param name="mode">Jedna z <see cref="T:System.IO.FileMode" /> wartości, która określa, jak otworzyć lub utworzyć magazyn.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Log.LogStore" /> klasy z określoną ścieżką i trybem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor służy do otwierania magazynu dzienników z określoną ścieżką i trybem. Magazyn jest otwierany z dostępem do odczytu/zapisu i udostępnia dostęp do odczytu.  
  
 `path` Parametr powinien mieć następującą składnię:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest unikatowym identyfikatorem klienta. Magazyn dzienników powinien być magazynem dzienników fizycznych lub wirtualnym magazynem dzienników, ale nie obu. Gdy magazyn dzienników został utworzony fizycznie lub praktycznie, pozostaje on w jego okresie istnienia. Magazyn dzienników fizycznych jest tworzony przez określenie tylko nazwy dziennika fizycznego. Wirtualny magazyn dzienników jest tworzony przez określenie zarówno nazwy dziennika fizycznego, jak i nazwy klienta dziennika.  
  
 Klienci, którzy korzystają z tej samej nazwy dziennika fizycznego, mają tę samą kolekcję zakresów i zasady.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" />zawiera tylko biały znak.  
  
—lub— 
 <paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas otwierania magazynu dzienników.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" />nie można użyć, ponieważ nie zainstalowano wymaganego składnika Common Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest dostępny dla danej platformy, lub Użyj <see cref="T:System.IO.Log.FileRecordSequence" /> zamiast niego klasy.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dzienników do otwarcia.</param>
        <param name="mode">Jedna z <see cref="T:System.IO.FileMode" /> wartości, która określa, jak otworzyć lub utworzyć magazyn.</param>
        <param name="access">Jedna z <see cref="T:System.IO.FileAccess" /> wartości, która określa, w <see cref="T:System.IO.Log.LogStore" />jaki sposób można uzyskać dostęp do pliku przez.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Log.LogStore" /> klasy z określoną ścieżką, trybem i dostępem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor służy do otwierania nowego magazynu dzienników z określoną ścieżką, trybem i dostępem. Magazyn zostanie otwarty i dostęp do odczytu.  
  
 `path` Parametr powinien mieć następującą składnię:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest unikatowym identyfikatorem klienta. Magazyn dzienników powinien być magazynem dzienników fizycznych lub wirtualnym magazynem dzienników, ale nie obu. Gdy magazyn dzienników został utworzony fizycznie lub praktycznie, pozostaje on w jego okresie istnienia. Magazyn dzienników fizycznych jest tworzony przez określenie tylko nazwy dziennika fizycznego. Wirtualny magazyn dzienników jest tworzony przez określenie zarówno nazwy dziennika fizycznego, jak i nazwy klienta dziennika.  
  
 Klienci, którzy korzystają z tej samej nazwy dziennika fizycznego, mają tę samą kolekcję zakresów i zasady.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" />zawiera tylko biały znak.  
  
—lub— 
 <paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />zawiera nieprawidłową wartość.  
  
-lub 
 <paramref name="access" />zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas otwierania magazynu dzienników.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" />nie można użyć, ponieważ nie zainstalowano wymaganego składnika Common Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest dostępny dla danej platformy, lub Użyj <see cref="T:System.IO.Log.FileRecordSequence" /> zamiast niego klasy.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dzienników do otwarcia.</param>
        <param name="mode">Jedna z <see cref="T:System.IO.FileMode" /> wartości, która określa, jak otworzyć lub utworzyć magazyn.</param>
        <param name="access">Jedna z <see cref="T:System.IO.FileAccess" /> wartości, która określa, w <see cref="T:System.IO.Log.LogStore" />jaki sposób można uzyskać dostęp do pliku przez.</param>
        <param name="share">Jedna z <see cref="T:System.IO.FileShare" /> wartości, która określa, w jaki sposób magazyn dzienników będzie współużytkowany między procesami.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogStore> obiekt, który otwiera z określoną ścieżką, trybem i dostępem. Magazyn zostanie otwarty, udostępniając określony dostęp.  
  
 `path` Parametr powinien mieć następującą składnię:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest unikatowym identyfikatorem klienta. Magazyn dzienników powinien być magazynem dzienników fizycznych lub wirtualnym magazynem dzienników, ale nie obu. Gdy magazyn dzienników został utworzony fizycznie lub praktycznie, pozostaje on w jego okresie istnienia. Magazyn dzienników fizycznych jest tworzony przez określenie tylko nazwy dziennika fizycznego. Wirtualny magazyn dzienników jest tworzony przez określenie zarówno nazwy dziennika fizycznego, jak i nazwy klienta dziennika.  
  
 Klienci, którzy korzystają z tej samej nazwy dziennika fizycznego, mają tę samą kolekcję zakresów i zasady.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" />zawiera tylko biały znak.  
  
—lub— 
 <paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />zawiera nieprawidłową wartość.  
  
-lub 
 <paramref name="access" />zawiera nieprawidłową wartość.  
  
—lub— 
 <paramref name="share" />zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas otwierania magazynu dzienników.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" />nie można użyć, ponieważ nie zainstalowano wymaganego składnika Common Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest dostępny dla danej platformy, lub Użyj <see cref="T:System.IO.Log.FileRecordSequence" /> zamiast niego klasy.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dzienników do otwarcia.</param>
        <param name="mode">Jedna z <see cref="T:System.IO.FileMode" /> wartości, która określa, jak otworzyć lub utworzyć magazyn.</param>
        <param name="access">Jedna z <see cref="T:System.IO.FileAccess" /> wartości, która określa, w <see cref="T:System.IO.Log.LogStore" />jaki sposób można uzyskać dostęp do pliku przez.</param>
        <param name="share">Jedna z <see cref="T:System.IO.FileShare" /> wartości, która określa, w jaki sposób magazyn dzienników będzie współużytkowany między procesami.</param>
        <param name="fileSecurity">Jedna z <see cref="T:System.Security.AccessControl.FileSecurity" /> wartości, która określa zabezpieczenia do ustawienia dla nowo utworzonego magazynu, jeśli należy utworzyć magazyn.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogStore> obiekt, który otwiera z określoną ścieżką, trybem i dostępem. Magazyn zostanie otwarty, udostępniając określony dostęp. `path` Parametr powinien mieć następującą składnię:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest unikatowym identyfikatorem klienta. Magazyn dzienników powinien być magazynem dzienników fizycznych lub wirtualnym magazynem dzienników, ale nie obu. Gdy magazyn dzienników został utworzony fizycznie lub praktycznie, pozostaje on w jego okresie istnienia. Magazyn dzienników fizycznych jest tworzony przez określenie tylko nazwy dziennika fizycznego. Wirtualny magazyn dzienników jest tworzony przez określenie zarówno nazwy dziennika fizycznego, jak i nazwy klienta dziennika.  
  
 Klienci, którzy korzystają z tej samej nazwy dziennika fizycznego, mają tę samą kolekcję zakresów i zasady.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa pliku magazynu dzienników określona przez <paramref name="path" /> jest nieprawidłowa.  
  
—lub— 
 <paramref name="Mode" />jest <see langword="CreateNew" />, którego nie można używać bez dostępu do zapisu.  
  
—lub— 
 <paramref name="Mode" />jest <see langword="OpenOrCreate" />, którego nie można używać bez dostępu do zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />zawiera nieprawidłową wartość.  
  
-lub 
 <paramref name="access" />zawiera nieprawidłową wartość.  
  
—lub— 
 <paramref name="share" />zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas otwierania magazynu dzienników.  
  
Nie można uzyskać dostępu <paramref name="path" /> do pliku określonego przez program, ponieważ jest on używany przez inny proces.  
  
—lub— 
Nie można utworzyć pliku <paramref name="path" /> określonego przez, ponieważ plik lub katalog już istnieje.  
  
—lub— 
Nie można powiązać dojścia dziennika z pulą wątków.  
  
—lub— 
Określony format lub wersja pliku dziennika jest nieprawidłowa.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" />nie można użyć, ponieważ nie zainstalowano wymaganego składnika Common Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest dostępny dla danej platformy, lub Użyj <see cref="T:System.IO.Log.FileRecordSequence" /> zamiast niego klasy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.IO.Log.LogStore" /> wystąpienie może być archiwizowane.</summary>
        <value><see langword="true" />Jeśli to <see cref="T:System.IO.Log.LogStore" /> wystąpienie można zarchiwizować; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element <xref:System.IO.Log.LogStore> nie jest archiwizowany, wywołania <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> metod <xref:System.NotSupportedException> i <xref:System.IO.Log.LogStore.SetArchiveTail%2A> są wynikiem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera najniższy numer sekwencyjny odpowiadający prawidłowemu rekordowi w tym <see cref="T:System.IO.Log.LogStore" /> wystąpieniu.</summary>
        <value>Najniższy numer sekwencyjny odpowiadający prawidłowemu rekordowi w tym <see cref="T:System.IO.Log.LogStore" /> wystąpieniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poprawne numery sekwencji są większe lub równe <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> i mniejsze niż. <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy migawkę stanu magazynu dzienników niezbędną do utworzenia kopii zapasowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy migawkę stanu magazynu dzienników tworzenia kopii zapasowej.</summary>
        <returns><see cref="T:System.IO.Log.LogArchiveSnapshot" /> Obiekt, który zawiera stan niezbędny do dokonania archiwum.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.IO.Log.LogStore> jak zarchiwizować plik w dokumencie XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Magazyn dzienników nie jest archiwizowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Wykonano nieprawidłową operację.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">Numer sekwencji początkowej zakresu do archiwizacji.</param>
        <param name="last">Końcowy numer sekwencji w zakresie do archiwizacji.</param>
        <summary>Tworzy migawkę stanu magazynu dzienników między określonymi numerami sekwencji tworzenia kopii zapasowej.</summary>
        <returns><see cref="T:System.IO.Log.LogArchiveSnapshot" /> Obiekt, który zawiera stan niezbędny do dokonania archiwum.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Migawka archiwum zwracana z tej metody obejmuje informacje z bazowego numeru sekwencyjnego lub numeru sekwencyjnego archiwum, w zależności od tego, który jest niższy, do ostatniego numeru sekwencji. Ta wartość nie jest uwzględniana dla ostatniego numeru sekwencji, co oznacza, że archiwum zawiera tylko rekordy, do których nie jest uwzględniana wartość Last. Ponadto w przypadku korzystania z tej metody Start SequenceNumber musi być równa BaseSequenceNumber w celu zapewnienia spójności archiwum.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="first" />lub <paramref name="last" /> nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="first" />jest większy niż <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wykonano nieprawidłową operację.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.NotSupportedException">Magazyn dzienników nie jest archiwizowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełna.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka pliku podstawowego magazynu dzienników do usunięcia.</param>
        <summary>Usuwa magazyn dzienników.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" />zawiera tylko biały znak.  
  
—lub— 
 <paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas otwierania magazynu dzienników.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.IO.Log.LogStore" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.IO.Log.LogStore.Dispose%2A> po zakończeniu korzystania z <xref:System.IO.Log.LogStore>. <xref:System.IO.Log.LogStore.Dispose%2A> Metoda<xref:System.IO.Log.LogStore> pozostawia w stanie niezdatnym do użytku. Po wywołaniu <xref:System.IO.Log.LogStore.Dispose%2A> należy wydać wszystkie odwołania <xref:System.IO.Log.LogStore> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.IO.Log.LogStore> , którą zajmował.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.IO.Log.LogStore.Dispose%2A> przed wydaniem ostatniego odwołania <xref:System.IO.Log.LogStore>do. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.IO.Log.LogStore> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zakresów dzienników zawierających dane dla tego magazynu dzienników.</summary>
        <value><see cref="T:System.IO.Log.LogExtentCollection" /> Wystąpienie zawierające kolekcję zakresów dziennika, które hermetyzują dane dla tego magazynu dzienników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie przechowuje swoje dane w kolekcji zakresów dysku reprezentowanej przez <xref:System.IO.Log.LogExtent> wystąpienia. <xref:System.IO.Log.LogStore> Zakresy w danym <xref:System.IO.Log.LogStore> wystąpieniu mają jednolity rozmiar, a miejsce jest dodawane do i usuwane <xref:System.IO.Log.LogStore> z wystąpienia w przyrostach. Aby dodać i usunąć zakresy dzienników, użyj <xref:System.IO.Log.LogExtentCollection.Add%2A> metod <xref:System.IO.Log.LogExtentCollection> i <xref:System.IO.Log.LogExtentCollection.Remove%2A> obiektu, które są zwracane przez tę właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów dostępnych w magazynie dzienników.</summary>
        <value>Liczba bajtów dostępnych w magazynie dzienników.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście do pliku systemu operacyjnego dla pliku dziennika, który jest <see cref="T:System.IO.Log.LogStore" /> hermetyzowane przez bieżące wystąpienie.</summary>
        <value>Dojście do pliku systemu operacyjnego dla pliku dziennika, który jest <see cref="T:System.IO.Log.LogStore" /> hermetyzowane przez bieżące wystąpienie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, Pobiera numer następnego rekordu do dołączenia do magazynu dzienników.</summary>
        <value>Numer sekwencji następnego rekordu, który ma zostać dołączony do magazynu dzienników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poprawne numery sekwencji są większe lub równe <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> i mniejsze niż. <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar magazynu dzienników w bajtach.</summary>
        <value>Rozmiar magazynu dzienników w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar magazynu dzienników to suma rozmiarów zakresów dzienników...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uzyskano dostęp do właściwości po usunięciu sekwencji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zasady skojarzone z tym magazynem dzienników.</summary>
        <value><see cref="T:System.IO.Log.LogPolicy" /> Wystąpienie reprezentujące zasady skojarzone z tym magazynem dzienników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.IO.Log.LogPolicy> wystąpienia zwróconego przez tę właściwość, aby przeanalizować i manipulować zasadami dziennika skojarzonymi <xref:System.IO.Log.LogStore>z tym elementem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">Numer sekwencji ogona archiwum.</param>
        <summary>Ustawia numer sekwencji ogona archiwum.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mniejszy numer sekwencji podstawowej i ślad archiwum określają ogon dziennika.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.IO.Log.LogStore> jak zarchiwizować plik w dokumencie XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="archiveTail" />nie jest między bazowym i ostatnim numerem sekwencji tej sekwencji.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="archiveTail" />nie jest prawidłowy dla tej sekwencji.</exception>
        <exception cref="T:System.InvalidOperationException">Wykonano nieprawidłową operację.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia migawki archiwum.</exception>
        <exception cref="T:System.NotSupportedException">Magazyn dzienników nie jest archiwizowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po usunięciu sekwencji.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby kontynuować wykonywanie programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">System operacyjny odmówiono dostępu do określonego magazynu dzienników.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę strumieni dzienników w tym magazynie dzienników.</summary>
        <value>Liczba strumieni dzienników w tym magazynie dzienników.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7357fc91060fb82ea1c84227020bd77af9eb422f" /><Meta Name="ms.sourcegitcommit" Value="f1d16425528e237257ca3b58eb49217a514849ea" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="04/24/2019" /><Meta Name="ms.locfileid" Value="64002409" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje strukturze dziennika magazynu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogRecordSequence> Klasa zawiera implementację interfejsu sekwencji rekordów na podstawie dzienników wspólnego Log File System (CLFS). Współdziała ona z <xref:System.IO.Log.LogStore> klasy, która udostępnia interfejs dla bezpośrednie manipulowanie i zarządzanie nimi CLFS pliku dziennika. Magazynu dziennika udostępnia magazyn tylko do dołączania zestawu zakresów dysków. <xref:System.IO.Log.LogStore> Klasa reprezentuje ten magazyn i zapewnia metody dodawania i usuwania kontenerów, ustawienia zasad i tworzenia archiwa. Nie zapewnia metody do odczytywanie z oraz zapisywanie w magazynie; te metody są udostępniane przez <xref:System.IO.Log.LogRecordSequence> klasy.  
  
 Relacja między <xref:System.IO.Log.LogStore> klasy i <xref:System.IO.Log.LogRecordSequence> klasa jest podobna do relacji między pliku na dysku i <xref:System.IO.FileStream> obiektu. Plik dysku zapewnia rzeczywisty magazyn i ma atrybuty, takie jak długość i czas ostatniego dostępu, podczas gdy <xref:System.IO.FileStream> obiektu zapewnia wgląd w pliku, który może służyć do jego odczytu i zapisu do niego. Podobnie <xref:System.IO.Log.LogStore> klasa ma atrybutów, takich jak zasady i kolekcji zakresów dysków i <xref:System.IO.Log.LogRecordSequence> klasa udostępnia zorientowane mechanizm do odczytywania i zapisywania danych.  
  
 W przeciwieństwie do pliku sekwencji rekordu, reprezentowane przez <xref:System.IO.Log.FileRecordSequence> klasy <xref:System.IO.Log.LogStore> wystąpienia przechowuje dane w kolekcji zakresów dysków, reprezentowane przez <xref:System.IO.Log.LogExtent> wystąpień. Zakresy w danym <xref:System.IO.Log.LogStore> wystąpienia są wszystkie o różnych wielkościach, a miejsca zostaną dodane do i usunięty z <xref:System.IO.Log.LogStore> wystąpienia w przyrostach zakresu. Aby dodawać i usuwać zakresów dziennika, należy użyć <xref:System.IO.Log.LogExtentCollection.Add%2A> i <xref:System.IO.Log.LogExtentCollection.Remove%2A> metody <xref:System.IO.Log.LogExtentCollection> obiektu, który może zostać zwrócony przez <xref:System.IO.Log.LogStore.Extents%2A> właściwości.  
  
 A <xref:System.IO.Log.LogStore> wystąpienie może mieć zasady skojarzone z nią. Są one reprezentowane przez <xref:System.IO.Log.LogPolicy> wystąpień, które mogą być zwrócone przez <xref:System.IO.Log.LogStore.Policy%2A> właściwości. Zasady połączenia z opisywanym reguł, które dziennika będzie podejmować próby postępuj zgodnie z, takie jak maksymalna liczba zakresów i minimalny rozmiar, a także instrukcje na rosnącą lub zmniejszając <xref:System.IO.Log.LogStore> pod pewnymi warunkami. Ponadto można określić czy <xref:System.IO.Log.LogStore> wystąpienia można znaleźć w temacie. Zasady są ustawione na dziennik i są nietrwałe, co oznacza, że po zamknięciu każdego dojścia do dziennika zasady już nie istnieje.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak archiwizowanie <xref:System.IO.Log.LogStore> do dokumentu XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dziennika pliku, który bieżącego <see cref="T:System.IO.Log.LogStore" /> hermetyzuje.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasę określone dojście.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Nie można powiązać dojścia dziennika w puli wątków.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości, które określa sposób próbę otwarcia lub utworzenia magazynu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy przy użyciu określonej ścieżki i trybu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otworzyć magazynu dziennika przy użyciu określonej ścieżki i tryb, należy użyć tego konstruktora. Magazyn jest otwierany z dostępem do odczytu/zapisu i udostępnia dostęp do odczytu.  
  
 `path` Parametru należy użyć następującej składni:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest identyfikatorem unikatowych klientów. Magazynu dziennika powinien być magazynu dziennika fizycznego lub magazynu dziennika wirtualnego, ale nie oba. Po utworzeniu magazynu dziennika, fizycznie lub wirtualnie, będzie to przez cały okres ich istnienia. Magazynu fizycznego dziennika jest tworzony, określając nazwę dziennika fizycznego. Magazynu wirtualnego dziennika jest tworzony przez określenie zarówno nazwę dziennika fizycznych, jak i nazwę klienta do dziennika.  
  
 Klienci, którzy mają taką samą nazwę dziennika fizycznego używają tej samej kolekcji zakresów i zasad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" /> zawiera tylko znak odstępu.  
  
—lub— 
 <paramref name="path" /> zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" /> Nie można użyć, ponieważ nie zainstalowano wymaganego składnika Typowe Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest on dostępny dla platform lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy zamiast tego.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości, które określa sposób próbę otwarcia lub utworzenia magazynu.</param>
        <param name="access">Jedną z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy przy użyciu określonej ścieżki, tryb i access.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otworzyć nowy magazyn dzienników przy użyciu określonej ścieżki, tryb i dostępu, należy użyć tego konstruktora. Magazyn jest otwarty, udostępnianie dostęp do odczytu.  
  
 `path` Parametru należy użyć następującej składni:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest identyfikatorem unikatowych klientów. Magazynu dziennika powinien być magazynu dziennika fizycznego lub magazynu dziennika wirtualnego, ale nie oba. Po utworzeniu magazynu dziennika, fizycznie lub wirtualnie, będzie to przez cały okres ich istnienia. Magazynu fizycznego dziennika jest tworzony, określając nazwę dziennika fizycznego. Magazynu wirtualnego dziennika jest tworzony przez określenie zarówno nazwę dziennika fizycznych, jak i nazwę klienta do dziennika.  
  
 Klienci, którzy mają taką samą nazwę dziennika fizycznego używają tej samej kolekcji zakresów i zasad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" /> zawiera tylko znak odstępu.  
  
—lub— 
 <paramref name="path" /> zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.  
  
— lub 
 <paramref name="access" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" /> Nie można użyć, ponieważ nie zainstalowano wymaganego składnika Typowe Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest on dostępny dla platform lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy zamiast tego.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości, które określa sposób próbę otwarcia lub utworzenia magazynu.</param>
        <param name="access">Jedną z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Jedną z <see cref="T:System.IO.FileShare" /> wartości, które określa, jak magazynu dziennika będą udostępniane między procesami.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nową <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i access. Magazyn jest otwarty, udostępnianie określonego dostępu.  
  
 `path` Parametru należy użyć następującej składni:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest identyfikatorem unikatowych klientów. Magazynu dziennika powinien być magazynu dziennika fizycznego lub magazynu dziennika wirtualnego, ale nie oba. Po utworzeniu magazynu dziennika, fizycznie lub wirtualnie, będzie to przez cały okres ich istnienia. Magazynu fizycznego dziennika jest tworzony, określając nazwę dziennika fizycznego. Magazynu wirtualnego dziennika jest tworzony przez określenie zarówno nazwę dziennika fizycznych, jak i nazwę klienta do dziennika.  
  
 Klienci, którzy mają taką samą nazwę dziennika fizycznego używają tej samej kolekcji zakresów i zasad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" /> zawiera tylko znak odstępu.  
  
—lub— 
 <paramref name="path" /> zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.  
  
— lub 
 <paramref name="access" /> zawiera nieprawidłową wartość.  
  
—lub— 
 <paramref name="share" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" /> Nie można użyć, ponieważ nie zainstalowano wymaganego składnika Typowe Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest on dostępny dla platform lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy zamiast tego.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do otwarcia.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości, które określa sposób próbę otwarcia lub utworzenia magazynu.</param>
        <param name="access">Jedną z <see cref="T:System.IO.FileAccess" /> wartości, które określa, jak można uzyskać dostępu do pliku <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">Jedną z <see cref="T:System.IO.FileShare" /> wartości, które określa, jak magazynu dziennika będą udostępniane między procesami.</param>
        <param name="fileSecurity">Jedną z <see cref="T:System.Security.AccessControl.FileSecurity" /> wartość, która określa zabezpieczeń można ustawić na nowo utworzony magazyn, jeśli magazyn musi zostać utworzona.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Log.LogStore" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nową <xref:System.IO.Log.LogStore> obiekt, który zostanie otwarty z określonej ścieżki, tryb i access. Magazyn jest otwarty, udostępnianie określonego dostępu. `path` Parametr należy stosować następującą składnię:  
  
 `log:<physical log name>[::<log client name>]`  
  
 gdzie `<physical log name>` jest prawidłową ścieżką do pliku dziennika i `<log client name>` jest identyfikatorem unikatowych klientów. Magazynu dziennika powinien być magazynu dziennika fizycznego lub magazynu dziennika wirtualnego, ale nie oba. Po utworzeniu magazynu dziennika, fizycznie lub wirtualnie, będzie to przez cały okres ich istnienia. Magazynu fizycznego dziennika jest tworzony, określając nazwę dziennika fizycznego. Magazynu wirtualnego dziennika jest tworzony przez określenie zarówno nazwę dziennika fizycznych, jak i nazwę klienta do dziennika.  
  
 Klienci, którzy mają taką samą nazwę dziennika fizycznego używają tej samej kolekcji zakresów i zasad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa pliku dziennika magazynu określony przez <paramref name="path" /> jest nieprawidłowy.  
  
—lub— 
 <paramref name="Mode" /> jest <see langword="CreateNew" />, której nie można używać bez dostępu do zapisu.  
  
—lub— 
 <paramref name="Mode" /> jest <see langword="OpenOrCreate" />, której nie można używać bez dostępu do zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.  
  
— lub 
 <paramref name="access" /> zawiera nieprawidłową wartość.  
  
—lub— 
 <paramref name="share" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy podczas otwierania magazynu dziennika.  
  
W pliku określonym przez <paramref name="path" /> nie są dostępne, ponieważ jest on używany przez inny proces.  
  
—lub— 
W pliku określonym przez <paramref name="path" /> nie można utworzyć, ponieważ plik lub katalog już istnieje.  
  
—lub— 
Nie można powiązać dojścia dziennika w puli wątków.  
  
—lub— 
Format pliku dziennika określonego lub wersji jest nieprawidłowy.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.IO.Log.LogStore" /> Nie można użyć, ponieważ nie zainstalowano wymaganego składnika Typowe Log File System (CLFS). Zainstaluj składnik CLFS, jeśli jest on dostępny dla platform lub użyj <see cref="T:System.IO.Log.FileRecordSequence" /> klasy zamiast tego.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy to <see cref="T:System.IO.Log.LogStore" /> wystąpienia można znaleźć w temacie.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.IO.Log.LogStore" /> wystąpienie może być archiwizowane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Log.LogStore> nie można utworzyć archiwum, wywołania <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> i <xref:System.IO.Log.LogStore.SetArchiveTail%2A> metody powodują w <xref:System.NotSupportedException> zgłaszane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera najniższy numer sekwencji, który odpowiada z prawidłowym rekordem, w tym <see cref="T:System.IO.Log.LogStore" /> wystąpienia.</summary>
        <value>Najniższy numer sekwencji, która odpowiada prawidłowy rekord w tym <see cref="T:System.IO.Log.LogStore" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowych numerów sekwencji jest większa lub równa <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> i mniej niż <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera migawkę stanu magazynu dziennika należy wykonać kopię zapasową.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera migawkę stanu magazynu dziennika do tworzenia kopii zapasowej.</summary>
        <returns>Element <see cref="T:System.IO.Log.LogArchiveSnapshot" /> obiektu, który zawiera stan to niezbędne do zapewnienia archiwum.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak archiwizowanie <xref:System.IO.Log.LogStore> do dokumentu XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można utworzyć archiwum magazynu dziennika.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.IO.IOException">Podczas tworzenia migawki archiwum, wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowa operacja została wykonana.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">Numer początkowej sekwencji w zakresie do archiwizacji.</param>
        <param name="last">Końcowy numer sekwencyjny w zakresie do archiwizacji.</param>
        <summary>Pobiera migawkę stanu magazynu dziennika między liczbami określonej sekwencji do tworzenia kopii zapasowej.</summary>
        <returns>Element <see cref="T:System.IO.Log.LogArchiveSnapshot" /> obiektu, który zawiera stan to niezbędne do zapewnienia archiwum.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Migawki archiwum zwrócone w wyniku tej metody obejmuje informacje z numer sekwencyjny podstawowej lub numer sekwencyjny archiwum, która kwota jest niższa, ostatni numer sekwencyjny. Nie jest całkowity dla ostatni numer sekwencji, co oznacza, że archiwum zawiera tylko rekordy maksymalnie z wyjątkiem ostatniej. Ponadto przy użyciu tej metody, start SequenceNumber musi być równa BaseSequenceNumber kolejność archiwum były zgodne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="first" /> lub <paramref name="last" /> jest spoza zakresu numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="first" /> jest większe niż <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowa operacja została wykonana.</exception>
        <exception cref="T:System.IO.IOException">Podczas tworzenia migawki archiwum, wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można utworzyć archiwum magazynu dziennika.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">Sekwencja rekordów jest pełny.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku podstawowego magazynu dziennika do usunięcia.</param>
        <summary>Usuwa magazynu dziennika.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="path" /> zawiera tylko znak odstępu.  
  
—lub— 
 <paramref name="path" /> zawiera co najmniej jeden nieprawidłowy znak.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy podczas otwierania magazynu dziennika.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.IO.Log.LogStore.Dispose%2A> po zakończeniu, za pomocą <xref:System.IO.Log.LogStore>. <xref:System.IO.Log.LogStore.Dispose%2A> Pozostawia metoda <xref:System.IO.Log.LogStore> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.IO.Log.LogStore.Dispose%2A> , trzeba zwolnić wszystkie odwołania do <xref:System.IO.Log.LogStore> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.IO.Log.LogStore> zajmowaną przez wystąpienie.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.IO.Log.LogStore.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.IO.Log.LogStore>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.IO.Log.LogStore> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zakresy dziennika, które zawierają dane dla tego magazynu dziennika.</summary>
        <value>A <see cref="T:System.IO.Log.LogExtentCollection" /> wystąpienia zawierający kolekcję zakresów dziennika, który hermetyzuje dane dla tego magazynu dziennika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.IO.Log.LogStore> wystąpienia przechowuje dane w kolekcji zakresów dysków, reprezentowane przez <xref:System.IO.Log.LogExtent> wystąpień. Zakresy w danym <xref:System.IO.Log.LogStore> wystąpienia są wszystkie o różnych wielkościach, a miejsca zostaną dodane do i usunięty z <xref:System.IO.Log.LogStore> wystąpienia w przyrostach zakresu. Aby dodawać i usuwać zakresów dziennika, należy użyć <xref:System.IO.Log.LogExtentCollection.Add%2A> i <xref:System.IO.Log.LogExtentCollection.Remove%2A> metody <xref:System.IO.Log.LogExtentCollection> obiektu, który jest zwracany przez tę właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów dostępnych w sklepie dziennika.</summary>
        <value>Liczba bajtów, które są dostępne w sklepie dziennika.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt pliku systemu operacyjnego dla pliku dziennika, który bieżącego <see cref="T:System.IO.Log.LogStore" /> hermetyzuje wystąpienia.</summary>
        <value>Dojście do pliku systemu operacyjnego dla dziennika pliku, który bieżącego <see cref="T:System.IO.Log.LogStore" /> hermetyzuje wystąpienia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera numer sekwencyjny następnego rekordu, który zostanie dołączony do magazynu dziennika.</summary>
        <value>Numer sekwencyjny następnego rekordu, który zostanie dołączony do magazynu dziennika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowych numerów sekwencji jest większa lub równa <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> i mniej niż <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar magazynu dziennika, w bajtach.</summary>
        <value>Rozmiar magazynu dziennika, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar magazynu dziennika jest sumą ilości zakresów dziennika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Właściwość została otwarta po sekwencji został zlikwidowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zasady skojarzone z tego magazynu dziennika.</summary>
        <value>A <see cref="T:System.IO.Log.LogPolicy" /> wystąpienie reprezentujące zasad skojarzonych z tym magazynu dziennika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.IO.Log.LogPolicy> zwracane przez tę właściwość do badania i manipulowania zasady dziennika skojarzonych z tym wystąpieniem <xref:System.IO.Log.LogStore>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">Numer sekwencji uchwyt archiwum.</param>
        <summary>Ustawia numer sekwencyjny uchwyt archiwum.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mniejsze numer sekwencyjny podstawowej i uchwyt archiwum określa ogona dziennika.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak archiwizowanie <xref:System.IO.Log.LogStore> do dokumentu XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="archiveTail" /> nie jest od numeru podstawowego do ostatniego sekwencji.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="archiveTail" /> nie jest prawidłowa dla tej sekwencji.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowa operacja została wykonana.</exception>
        <exception cref="T:System.IO.IOException">Podczas tworzenia migawki archiwum, wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Nie można utworzyć archiwum magazynu dziennika.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wywołana po sekwencji został zlikwidowany.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci dla kontynuowania wykonywania programu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu dla magazynu dziennika określony przez system operacyjny.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę strumieni dziennika, w tym magazynie dziennika.</summary>
        <value>Liczba strumieni dziennik w tym magazynie dziennika.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
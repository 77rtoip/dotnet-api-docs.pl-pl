<Type Name="SearchResultCollection" FullName="System.DirectoryServices.SearchResultCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="315e28b6eb1894f33ea88a366867ae61e7b9f070" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51912748" /></Metadata><TypeSignature Language="C#" Value="public class SearchResultCollection : MarshalByRefObject, IDisposable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SearchResultCollection extends System.MarshalByRefObject implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.DirectoryServices.SearchResultCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class SearchResultCollection&#xA;Inherits MarshalByRefObject&#xA;Implements ICollection, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SearchResultCollection : MarshalByRefObject, IDisposable, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type SearchResultCollection = class&#xA;    inherit MarshalByRefObject&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.DirectoryServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><see cref="T:System.DirectoryServices.SearchResultCollection" /> Klasa zawiera <see cref="T:System.DirectoryServices.SearchResult" /> wystąpień, które zwróciły hierarchii usługi Active Directory, podczas <see cref="T:System.DirectoryServices.DirectorySearcher" /> zapytania.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ze względu na ograniczenia wdrożenia <xref:System.DirectoryServices.SearchResultCollection> klasy nie można zwolnić wszystkie jej zasoby niezarządzane, gdy będzie bezużyteczne. Aby zapobiec przeciek pamięci, należy wywołać <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A> metody podczas <xref:System.DirectoryServices.SearchResultCollection> obiektu nie jest już potrzebny.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.DirectoryServices.DirectoryServicesPermission"><see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
  </Docs>
  <Members>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.DirectoryServices.SearchResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.DirectoryServices.SearchResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.SearchResultCollection.Contains(System.DirectoryServices.SearchResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (result As SearchResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::DirectoryServices::SearchResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.DirectoryServices.SearchResult -&gt; bool" Usage="searchResultCollection.Contains result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.DirectoryServices.SearchResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.DirectoryServices.SearchResult" /> Obiektu do znalezienia.</param>
        <summary>Określa, czy określony <see cref="T:System.DirectoryServices.SearchResult" /> obiekt jest w tej kolekcji.</summary>
        <returns><see langword="true" /> Jeśli określona właściwość należy do tej kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.DirectoryServices.SearchResult[] results, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.DirectoryServices.SearchResult[] results, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.SearchResultCollection.CopyTo(System.DirectoryServices.SearchResult[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (results As SearchResult(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::DirectoryServices::SearchResult ^&gt; ^ results, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.DirectoryServices.SearchResult[] * int -&gt; unit" Usage="searchResultCollection.CopyTo (results, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="results" Type="System.DirectoryServices.SearchResult[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="results">Tablica <see cref="T:System.DirectoryServices.SearchResult" /> obiektów, które odbiera elementów tej kolekcji.</param>
        <param name="index">Liczony od zera indeks w <paramref name="results" /> której ta metoda rozpoczyna kopiowanie tej kolekcji.</param>
        <summary>Kopiuje wszystkie <see cref="T:System.DirectoryServices.SearchResult" /> obiektów w tej kolekcji do określonej tablicy, zaczynając od określonego indeksu w tablicy docelowej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.SearchResultCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.DirectoryServices.SearchResultCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę <see cref="T:System.DirectoryServices.SearchResult" /> obiektów w tej kolekcji.</summary>
        <value>Liczba <see cref="T:System.DirectoryServices.SearchResult" /> obiektów w tej kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są używane przez <see cref="T:System.DirectoryServices.SearchResultCollection" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.SearchResultCollection.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="searchResultCollection.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są używane przez <see cref="T:System.DirectoryServices.SearchResultCollection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A> Metody umożliwia zasoby, które są używane przez <xref:System.DirectoryServices.SearchResultCollection> zostają przeniesione do innych celów. Aby uzyskać więcej informacji na temat <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A>, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).  
  
 Moduł odśmiecania pamięci nie spowoduje zwolnienia pamięci dla <xref:System.DirectoryServices.SearchResultCollection> obiektu. W związku z tym, aplikacja musi wywołać <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A> metoda jawnie, aby zapobiec przeciek pamięci.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.SearchResultCollection.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="searchResultCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane, które są używane przez <see cref="T:System.DirectoryServices.SearchResultCollection" /> obiektu i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A> metody i <xref:System.Object.Finalize%2A> metody. <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A> wywołuje chronioną metodę <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A> metody z `disposing` parametr `true`. <xref:System.Object.Finalize%2A> wywołuje <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A> z `disposing` parametr `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby, które są przechowywane przez wszelkie obiekty zarządzane że <xref:System.DirectoryServices.SearchResultCollection> odwołania.  
  
 Moduł odśmiecania pamięci nie spowoduje zwolnienia pamięci dla <xref:System.DirectoryServices.SearchResultCollection> obiektu. W związku z tym, należy wywołać <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A> metoda jawnie, aby zapobiec przeciek pamięci.  
  
 Ta metoda wywołuje <xref:System.DirectoryServices.SearchResultCollection.Dispose%2A> metoda każdego obiektu w kolekcji.  
  
 Aby uzyskać więcej informacji na temat <xref:System.DirectoryServices.SearchResultCollection.Dispose> i <xref:System.Object.Finalize%2A>, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.DirectoryServices.SearchResultCollection.Dispose" /> Metoda może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see cref="M:System.DirectoryServices.SearchResultCollection.Dispose(System.Boolean)" /> metody należy uważać, aby nie odwołują się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see cref="M:System.DirectoryServices.SearchResultCollection.Dispose" /> metody. Aby uzyskać więcej informacji o sposobie wdrażania <see cref="M:System.DirectoryServices.SearchResultCollection.Dispose" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SearchResultCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.SearchResultCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SearchResultCollection ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="searchResultCollection.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zastępuje <see cref="M:System.Object.Finalize" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.SearchResultCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="searchResultCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który można użyć do iterowania po tej kolekcji.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Obiekt, który można użyć do iterowania po tej kolekcji.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.SearchResultCollection.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.DirectoryServices.SearchResultCollection.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt, który jest zwracany przez <see href="https://msdn.microsoft.com/library/default.asp?url=/library/adsi/adsi/idirectorysearch_executesearch.asp">IDirectorySearch::ExecuteSearch</see> metodę, która przeprowadza rzeczywiste wyszukiwanie. Aby uzyskać więcej informacji, zobacz <see href="https://msdn.microsoft.com/library/default.asp?url=/library/adsi/adsi/idirectorysearch_executesearch.asp">IDirectorySearch::ExecuteSearch</see> tematu w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library).</summary>
        <value>Wartość ADS_SEARCH_HANDLE, która korzysta z tej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DirectoryServices.DirectorySearcher> Które tworzone w tej kolekcji wywołuje [IDirectorySearch::ExecuteSearch](https://msdn.microsoft.com/library/default.asp?url=/library/adsi/adsi/idirectorysearch_executesearch.asp) metody, która udostępnia obiekt T:System.DirectoryServices.SearchResultCollection wyników zapytania. Aby uzyskać więcej informacji, zobacz [IDirectorySearch::ExecuteSearch](https://msdn.microsoft.com/library/default.asp?url=/library/adsi/adsi/idirectorysearch_executesearch.asp) tematu w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library).  
  
 Za każdym razem, zapytanie jest wykonywane, obsługi do wyników tej kwerendy jest skojarzony z jego <xref:System.DirectoryServices.SearchResultCollection> obiektu. To dojście odnosi się do uchwytu wyszukiwania ADSI. To dojście będzie się powtarzać, dopóki nie zostanie wywołana <xref:System.DirectoryServices.SearchResultCollection.Dispose> metody <xref:System.DirectoryServices.SearchResultCollection> obiektu, dlatego należy wywołać <xref:System.DirectoryServices.SearchResultCollection.Dispose> zapobiegające przeciek pamięci. Moduł odśmiecania pamięci nie spowoduje zwolnienia pamięci dla tego konkretnego obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (System.DirectoryServices.SearchResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(class System.DirectoryServices.SearchResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.SearchResultCollection.IndexOf(System.DirectoryServices.SearchResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (result As SearchResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::DirectoryServices::SearchResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : System.DirectoryServices.SearchResult -&gt; int" Usage="searchResultCollection.IndexOf result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.DirectoryServices.SearchResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.DirectoryServices.SearchResult" /> Obiektu do wyszukania w tej kolekcji.</param>
        <summary>Zwraca indeks pierwszego wystąpienia określonego <see cref="T:System.DirectoryServices.SearchResult" /> obiektu w tej kolekcji.</summary>
        <returns>Liczony od zera indeks pierwszego pasującego obiektu. Zwraca wartość -1, jeśli żaden członek tej kolekcji jest taka sama jak <see cref="T:System.DirectoryServices.SearchResult" /> obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.SearchResult this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.DirectoryServices.SearchResult Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.SearchResultCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As SearchResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::SearchResult ^ default[int] { System::DirectoryServices::SearchResult ^ get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.DirectoryServices.SearchResult" Usage="System.DirectoryServices.SearchResultCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.SearchResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks <see cref="T:System.DirectoryServices.SearchResult" /> obiektu do pobrania.</param>
        <summary>Pobiera <see cref="T:System.DirectoryServices.SearchResult" /> obiekt, który znajduje się w określonym indeksie w tej kolekcji.</summary>
        <value><see cref="T:System.DirectoryServices.SearchResult" /> Obiektu, który jest umieszczony pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W języku C#, ta właściwość jest indeksator <xref:System.DirectoryServices.SearchResultCollection> klasy.  
  
 W języku JScript można używać właściwości domyślnie indeksowanej definicją typu, ale nie można jawnie definiować własnych. Jednak określenie atrybutu expando w klasie automatycznie udostępnia domyślny indeksowana właściwość, której typem jest obiektem i korzystając z indeksu typu <xref:System.String>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertiesLoaded">
      <MemberSignature Language="C#" Value="public string[] PropertiesLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PropertiesLoaded" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.SearchResultCollection.PropertiesLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertiesLoaded As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PropertiesLoaded { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertiesLoaded : string[]" Usage="System.DirectoryServices.SearchResultCollection.PropertiesLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DirectoryServices.DirectorySearcher" /> właściwości, które zostały określone, zanim wykonany wyszukiwania.</summary>
        <value>Tablica typu <see cref="T:System.String" /> zawierający właściwości, które zostały określone w <see cref="P:System.DirectoryServices.DirectorySearcher.PropertiesToLoad" /> kolekcji właściwości przed wyszukiwania został wykonany.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.SearchResultCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> czyli miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <param name="index">Liczony od zera indeks w <paramref name="array" /> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy ze <see cref="T:System.Collections.ICollection" /> do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ma charakter wielowymiarowy.  
  
—lub— 
Liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępna ilość miejsca od <paramref name="index" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Typ źródła <see cref="T:System.Collections.ICollection" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.SearchResultCollection.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo).</summary>
        <value><see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo); w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Collections.ICollection>.  
  
 Klasy kolekcji większość w <xref:System.Collections?displayProperty=nameWithType> przestrzeni nazw także implementować metody Synchronized, co zapewnia zsynchronizowane otokę wokół kolekcji źródłowej.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 [Visual Basic, C#]  
  
 Poniższy przykład kodu pokazuje, jak można zablokować kolekcję przy użyciu <xref:System.Collections.ICollection.SyncRoot%2A> podczas całego procesu wyliczania:  
  
```csharp  
ICollection myCollection = new ICollection();  
  lock(myCollection.SyncRoot) {  
  foreach (Object item in myCollection) {  
  // Insert your code here.  
  }  
 }  
```  
  
```vb  
Dim myCollection As New ICollection()  
 Dim item As Object  
 SyncLock myCollection.SyncRoot  
  For Each item In myCollection  
  ' Insert your code here.  
  Next item  
 End SyncLock  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.SearchResultCollection.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla kolekcji, w której magazyn nie jest publicznie dostępna oczekiwany implementacja jest przywrócenie bieżącego wystąpienia. Należy pamiętać, że wskaźnik do bieżącego wystąpienia może nie być wystarczające dla kolekcji, które umieszczają w otoce innych kolekcji; te powinna zwrócić podstawowej kolekcji `SyncRoot` właściwości.  
  
 Klasy kolekcji większość w <xref:System.Collections?displayProperty=nameWithType> także zaimplementować przestrzeń nazw `Synchronized` metody, która zapewnia zsynchronizowane otokę wokół kolekcji źródłowej. Klasy pochodne może jednak zapewniać swoją własną wersję zsynchronizowane za pomocą kolekcji <xref:System.Collections.ICollection.SyncRoot%2A> właściwości. Synchronizowanie kodu należy wykonywać operacje na <xref:System.Collections.ICollection.SyncRoot%2A> kolekcji, a nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności zachowuje właściwe synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie wystąpienie kolekcji.  
  
 W przypadku braku `Synchronized` metody w kolekcji, oczekiwane użycie dla <xref:System.Collections.ICollection.SyncRoot%2A> wygląda podobnie do następującego:  
  
```csharp  
ICollection MyCollection =...  
 lock(MyCollection.SyncRoot) {  
  // Some operation on the collection, which is now thread safe.  
 }  
```  
  
```vb  
Dim myCollection as New ICollection()  
 SyncLock myCollection.SyncRoot  
  ' Some operation on the collection, which is now thread safe.  
 End SyncLock  
```  
  
 Wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 [Visual Basic, C#]  
  
 Poniższy przykład kodu pokazuje, jak można zablokować kolekcję przy użyciu <xref:System.Collections.ICollection.SyncRoot%2A> podczas całego procesu wyliczania:  
  
```csharp  
ICollection myCollection = new ICollection();  
 lock(myCollection.SyncRoot) {  
  foreach (Object item in myCollection) {  
  // Insert your code here.  
  }  
 }  
```  
  
```vb  
Dim myCollection As New ICollection()  
 Dim item As Object  
 SyncLock myCollection.SyncRoot  
  For Each item In myCollection  
  ' Insert your code here.  
  Next item  
 End SyncLock  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
  </Members>
</Type>
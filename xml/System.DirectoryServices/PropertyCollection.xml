<Type Name="PropertyCollection" FullName="System.DirectoryServices.PropertyCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e12db319adb392a4f525ce335be057bf4d600ce5" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36340608" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyCollection : System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.DirectoryServices.PropertyCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyCollection&#xA;Implements IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyCollection : System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type PropertyCollection = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.DirectoryServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <see cref="T:System.DirectoryServices.PropertyCollection" /> Klasy zawiera właściwości <see cref="T:System.DirectoryServices.DirectoryEntry" />.</summary>
    <remarks>To be added.</remarks>
    <permission cref="T:System.DirectoryServices.DirectoryServicesPermission">
      <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />
    </permission>
  </Docs>
  <Members>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.PropertyCollection.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (propertyName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="propertyCollection.Contains propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa właściwości, aby znaleźć.</param>
        <summary>Określa, czy określona właściwość jest w tej kolekcji.</summary>
        <returns>Wartość zwracana jest <see langword="true" /> Jeśli określona właściwość należy do tej kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.DirectoryServices.PropertyValueCollection[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.DirectoryServices.PropertyValueCollection[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.PropertyCollection.CopyTo(System.DirectoryServices.PropertyValueCollection[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As PropertyValueCollection(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::DirectoryServices::PropertyValueCollection ^&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.DirectoryServices.PropertyValueCollection[] * int -&gt; unit" Usage="propertyCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.DirectoryServices.PropertyValueCollection[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica <see cref="T:System.DirectoryServices.PropertyValueCollection" /> obiektów, które otrzymuje elementów tej kolekcji.</param>
        <param name="index">Liczony od zera indeks w <c>tablicy</c> gdy ta metoda rozpoczyna się kopiowanie tej kolekcji.</param>
        <summary>Kopiuje wszystkie obiekty w tej kolekcji do tablicy, zaczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">Wystąpił błąd podczas wywołania powiązanego interfejsu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.DirectoryServices.PropertyCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę właściwości w tej kolekcji.</summary>
        <value>Liczba właściwości w tej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Internet Information Services (IIS) i dostawców Windows NT, czy nie jest obecnie obsługa <xref:System.DirectoryServices.PropertyCollection.Count%2A>, więc każdy zgłosi <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">Wystąpił błąd podczas wywołania powiązanego interfejsu.</exception>
        <exception cref="T:System.NotSupportedException">Katalog nie może zaraportować liczby właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.PropertyCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="propertyCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który służy do iterowania po tej kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> Używanej do iterowania po tej kolekcji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">Wystąpił błąd podczas wywołania powiązanego interfejsu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.DirectoryServices.PropertyValueCollection this[string propertyName] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.DirectoryServices.PropertyValueCollection Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(propertyName As String) As PropertyValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::DirectoryServices::PropertyValueCollection ^ default[System::String ^] { System::DirectoryServices::PropertyValueCollection ^ get(System::String ^ propertyName); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.DirectoryServices.PropertyValueCollection" Usage="System.DirectoryServices.PropertyCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DirectoryServices.PropertyValueCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa właściwości do pobrania.</param>
        <summary>Pobiera określonej właściwości.</summary>
        <value>Wartość określonej właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W języku C#, ta właściwość jest indeksatora dla <xref:System.DirectoryServices.PropertyCollection> klasy.  
  
 W języku JScript można używać właściwości domyślnie indeksowanej wynika z typem, ale nie można jawnie definiować własnych. Jednak określenie atrybutu expando klasy automatycznie udostępnia domyślny indeksowane właściwości z typem obiektu i typ indeksu z <xref:System.String>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyNames">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection PropertyNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection PropertyNames" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.PropertyNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyNames As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ PropertyNames { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyNames : System.Collections.ICollection" Usage="System.DirectoryServices.PropertyCollection.PropertyNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwy właściwości w tej kolekcji.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Obiekt, który zawiera nazwy właściwości w tej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas uzyskiwania dostępu do elementów członkowskich <xref:System.DirectoryServices.PropertyCollection.PropertyNames%2A> właściwość <xref:System.Runtime.InteropServices.COMException> może zostać zgłoszone z powodu błędu podczas uzyskiwania dostępu do powiązanego interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.PropertyCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> który jest miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> Musi mieć indeksowania liczony od zera.</param>
        <param name="index">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.ICollection" /> do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> jest wielowymiarowy.  - lub - liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępne miejsce od <paramref name="index" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Typ źródła <see cref="T:System.Collections.ICollection" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.DirectoryServices.PropertyCollection.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy uzyskują dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wielowątkowość).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wielowątkowość); w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizujący dostęp do <xref:System.Collections.ICollection>.  
  
 Większość kolekcji klas w <xref:System.Collections?displayProperty=nameWithType> przestrzeń nazw również implementować metodę Synchronized, co zapewnia zsynchronizowane otokę odpowiednia kolekcja.  
  
 Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki, które w wyniku zmiany wprowadzone przez inne wątki.  
  
 [Visual Basic, C#]  
  
 Poniższy przykład pokazuje, jak można zablokować za pomocą kolekcji <xref:System.Collections.ICollection.SyncRoot%2A> podczas wyliczania całego:  
  
```csharp  
ICollection myCollection = new ICollection();  
  lock(myCollection.SyncRoot) {  
  foreach (Object item in myCollection) {  
  // Insert your code here.  
  }  
 }  
```  
  
```vb  
Dim myCollection As New ICollection()  
 Dim item As Object  
 SyncLock myCollection.SyncRoot  
  For Each item In myCollection  
  ' Insert your code here.  
  Next item  
 End SyncLock  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.DirectoryServices.PropertyCollection.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla kolekcji, w których Magazyn nie jest publicznie dostępna oczekiwano implementacja jest aby powrócić do bieżącego wystąpienia. Należy pamiętać, że wskaźnik do bieżącego wystąpienia nie może być wystarczający do kolekcji, które otaczają innych kolekcji; te właściwości SyncRoot odpowiednia Kolekcja powinna zostać zwrócona.  
  
 Większość kolekcji klas w <xref:System.Collections?displayProperty=nameWithType> przestrzeń nazw również implementować metodę Synchronized, co zapewnia zsynchronizowane otokę odpowiednia kolekcja. Jednak klasy pochodne zapewniają własne zsynchronizowanej wersji przy użyciu kolekcji <xref:System.Collections.ICollection.SyncRoot%2A> właściwości. Synchronizowanie kodu musi wykonywać operacje <xref:System.Collections.ICollection.SyncRoot%2A> kolekcji, a nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie wystąpienie kolekcji.  
  
 W przypadku braku metodę Synchronized w kolekcji, oczekiwane wykorzystanie dla <xref:System.Collections.ICollection.SyncRoot%2A> wygląda podobnie do następującej:  
  
```csharp  
ICollection MyCollection =...  
 lock(MyCollection.SyncRoot) {  
  // Some operation on the collection, which is now thread safe.  
 }  
```  
  
```vb  
Dim myCollection as New ICollection()  
 SyncLock myCollection.SyncRoot  
  ' Some operation on the collection, which is now thread safe.  
 End SyncLock  
```  
  
 Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 [Visual Basic, C#]  
  
 W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <xref:System.Collections.ICollection.SyncRoot%2A> podczas wyliczania całego:  
  
```csharp  
ICollection myCollection = new ICollection();  
 lock(myCollection.SyncRoot) {  
  foreach (Object item in myCollection) {  
  // Insert your code here.  
  }  
 }  
```  
  
```vb  
Dim myCollection As New ICollection()  
 Dim item As Object  
 SyncLock myCollection.SyncRoot  
  For Each item In myCollection  
  ' Insert your code here.  
  Next item  
 End SyncLock  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.PropertyCollection.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Object" /> Używany jako klucz elementu do dodania.</param>
        <param name="value">
          <see cref="T:System.Object" /> Do użycia jako wartość elementu do dodania.</param>
        <summary>Dodaje element z podany klucz i wartość do <see cref="T:System.Collections.IDictionary" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwość, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w słowniku (na przykład `myCollection["myNonexistentKey"] = myValue`). Jednak jeśli określony klucz już istnieje w słowniku, ustawienie <xref:System.Collections.IDictionary.Item%2A> stara wartość jest zastąpienie właściwości. Z kolei <xref:System.Collections.IDictionary.Add%2A> — metoda nie modyfikuje istniejące elementy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wykonania <xref:System.Collections.IDictionary.Add%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Collections.IDictionary> klasy.  
  
 [!code-cpp[Dictionary#9](~/samples/snippets/cpp/VS_Snippets_CLR/Dictionary/cpp/Dictionary.cpp#9)]
 [!code-csharp[Dictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Dictionary/CS/Dictionary.cs#9)]
 [!code-vb[Dictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dictionary/VB/Dictionary.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element z tym samym kluczem już istnieje w <see cref="T:System.Collections.IDictionary" /> obiektu.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IDictionary" /> Jest tylko do odczytu.  - lub - <see cref="T:System.Collections.IDictionary" /> ma stały rozmiar.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Clear">
      <MemberSignature Language="C#" Value="void IDictionary.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.PropertyCollection.System#Collections#IDictionary#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IDictionary.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Clear() = System::Collections::IDictionary::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.IDictionary" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób implementacji <xref:System.Collections.IDictionary.Clear%2A> metody. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Collections.IDictionary> klasy.  
  
 [!code-cpp[Dictionary#8](~/samples/snippets/cpp/VS_Snippets_CLR/Dictionary/cpp/Dictionary.cpp#8)]
 [!code-csharp[Dictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Dictionary/CS/Dictionary.cs#8)]
 [!code-vb[Dictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dictionary/VB/Dictionary.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IDictionary" /> Obiekt jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.PropertyCollection.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ value) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Klucz do zlokalizowania w <see cref="T:System.Collections.IDictionary" /> obiektu.</param>
        <summary>Określa, czy <see cref="T:System.Collections.IDictionary" /> zawiera element z określonym kluczem.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.IDictionary" /> zawiera element z kluczem; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób implementacji <xref:System.Collections.IDictionary.Contains%2A> metody. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Collections.IDictionary> klasy.  
  
 [!code-cpp[Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Dictionary/cpp/Dictionary.cpp#5)]
 [!code-csharp[Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Dictionary/CS/Dictionary.cs#5)]
 [!code-vb[Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dictionary/VB/Dictionary.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.DirectoryServices.PropertyCollection.System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.IDictionary" /> obiekt ma stały rozmiar.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.IDictionary" /> obiekt ma ustalony rozmiar; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja o stałym rozmiarze nie zezwala dodawania lub usuwania elementów po kolekcji zostało utworzone, ale zezwalaj na modyfikowanie istniejących elementów.  
  
 Kolekcja o stałym rozmiarze jest po prostu kolekcji z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym zmian w źródłowej kolekcji, włączając Dodawanie lub usuwanie elementów z kolekcji o stałym rozmiarze odzwierciedla te zmiany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób implementacji <xref:System.Collections.IDictionary.IsFixedSize%2A> właściwości. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Collections.IDictionary> klasy.  
  
 [!code-cpp[Dictionary#6](~/samples/snippets/cpp/VS_Snippets_CLR/Dictionary/cpp/Dictionary.cpp#6)]
 [!code-csharp[Dictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Dictionary/CS/Dictionary.cs#6)]
 [!code-vb[Dictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dictionary/VB/Dictionary.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.DirectoryServices.PropertyCollection.System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.IDictionary" /> obiekt jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.IDictionary" /> obiekt jest tylko do odczytu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wykonania <xref:System.Collections.IDictionary.IsReadOnly%2A> właściwości. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Collections.IDictionary> klasy.  
  
 [!code-cpp[Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Dictionary/cpp/Dictionary.cpp#4)]
 [!code-csharp[Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Dictionary/CS/Dictionary.cs#4)]
 [!code-vb[Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dictionary/VB/Dictionary.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IDictionary.Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.DirectoryServices.PropertyCollection.System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do pobrania lub ustawienia.</param>
        <summary>Pobiera lub ustawia element z określonym kluczem.</summary>
        <value>Element z określonym kluczem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]`.  
  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwość, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w słowniku (na przykład `myCollection["myNonexistentKey"] = myValue`). Jednak jeśli określony klucz już istnieje w słowniku, ustawienie <xref:System.Collections.IDictionary.Item%2A> stara wartość jest zastąpienie właściwości. Z kolei <xref:System.Collections.IDictionary.Add%2A> — metoda nie modyfikuje istniejące elementy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wykonania <xref:System.Collections.IDictionary.Item%2A> właściwości. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Collections.IDictionary> klasy.  
  
 [!code-cpp[Dictionary#13](~/samples/snippets/cpp/VS_Snippets_CLR/Dictionary/cpp/Dictionary.cpp#13)]
 [!code-csharp[Dictionary#13](~/samples/snippets/csharp/VS_Snippets_CLR/Dictionary/CS/Dictionary.cs#13)]
 [!code-vb[Dictionary#13](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dictionary/VB/Dictionary.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Właściwość jest ustawiona i <see cref="T:System.Collections.IDictionary" /> obiekt jest tylko do odczytu.  - lub - właściwość jest ustawiona, <paramref name="key" /> nie istnieje w kolekcji i <see cref="T:System.Collections.IDictionary" /> ma stały rozmiar.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.DirectoryServices.PropertyCollection.System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ICollection" /> obiekt zawierający klucze <see cref="T:System.Collections.IDictionary" /> obiektu.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Obiekt zawierający klucze <see cref="T:System.Collections.IDictionary" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność kluczy w zwróconym <xref:System.Collections.ICollection> obiekt nie jest określona, ale może mieć takiej samej kolejności jak odpowiednie wartości w <xref:System.Collections.ICollection> zwrócony przez <xref:System.Collections.IDictionary.Values%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wykonania <xref:System.Collections.IDictionary.Keys%2A> właściwości. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Collections.IDictionary> klasy.  
  
 [!code-cpp[Dictionary#10](~/samples/snippets/cpp/VS_Snippets_CLR/Dictionary/cpp/Dictionary.cpp#10)]
 [!code-csharp[Dictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Dictionary/CS/Dictionary.cs#10)]
 [!code-vb[Dictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dictionary/VB/Dictionary.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.PropertyCollection.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.IDictionary" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób wykonania <xref:System.Collections.IDictionary.Remove%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Collections.IDictionary> klasy.  
  
 [!code-cpp[Dictionary#7](~/samples/snippets/cpp/VS_Snippets_CLR/Dictionary/cpp/Dictionary.cpp#7)]
 [!code-csharp[Dictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Dictionary/CS/Dictionary.cs#7)]
 [!code-vb[Dictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dictionary/VB/Dictionary.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IDictionary" /> Obiekt jest tylko do odczytu.  - lub - <see cref="T:System.Collections.IDictionary" /> ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DirectoryServices.PropertyCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IEnumerable" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerable" />.Object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` zaleca się zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> również wprowadzono moduł wyliczający wróć do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> aby pierwszym elementem kolekcji ponownie, należy wywołać <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.DirectoryServices.PropertyCollection.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.DirectoryServices.PropertyCollection.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.DirectoryServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartości właściwości w tej kolekcji.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Zawierający wartości właściwości w tej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas uzyskiwania dostępu do elementów członkowskich <xref:System.DirectoryServices.PropertyCollection.Values%2A> właściwość <xref:System.Runtime.InteropServices.COMException> wyjątek może zostać zgłoszony z powodu błędu podczas uzyskiwania dostępu do powiązanego interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
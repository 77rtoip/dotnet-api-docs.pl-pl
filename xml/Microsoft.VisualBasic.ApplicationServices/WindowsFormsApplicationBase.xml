<Type Name="WindowsFormsApplicationBase" FullName="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6f3d187b0cc507ef2ad15025f3f7fe94d0979b30" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36662215" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WindowsFormsApplicationBase : Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi WindowsFormsApplicationBase extends Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" />
  <TypeSignature Language="VB.NET" Value="Public Class WindowsFormsApplicationBase&#xA;Inherits ConsoleApplicationBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsFormsApplicationBase : Microsoft::VisualBasic::ApplicationServices::ConsoleApplicationBase" />
  <TypeSignature Language="F#" Value="type WindowsFormsApplicationBase = class&#xA;    inherit ConsoleApplicationBase" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia właściwości, metody i zdarzenia związane z bieżącej aplikacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości udostępniane przez `My.Application` obiektu zwracanego dane, które są skojarzone tylko z bieżącej aplikacji lub DLL. Żadne informacje poziom systemu można zmienić z `My.Application`.  
  
 `My.Application` Obiekt składa się z następujących klas:  
  
-   <xref:Microsoft.VisualBasic.ApplicationServices.ApplicationBase> zawiera elementy członkowskie, które są dostępne we wszystkich projektach.  
  
-   <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase> zawiera elementy członkowskie, które są dostępne w aplikacjach formularzy systemu Windows.  
  
-   <xref:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase> zawiera elementy członkowskie, które są dostępne w aplikacji konsoli.  
  
   
  
## Examples  
 W tym przykładzie używa pętli do iterowania po open formularzy aplikacji, wybiera formularze, które mogą być udostępniane bezpośrednio przez bieżący wątek i wyświetla tytuły ich w <xref:System.Windows.Forms.ListBox> formantu. Aby uzyskać informacje dotyczące dostępu do formularzy otwartych, zobacz <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OpenForms%2A>.  
  
 [!code-vb[VbVbalrMyApplication#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/Form1.vb#10)]  
  
 W tym przykładzie musi mieć aplikacji Windows Forms formularza o nazwie `Form1` zawierający pole listy o nazwie `ListBox1`.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase" />
    <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.ApplicationBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsFormsApplicationBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsFormsApplicationBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsFormsApplicationBase (Microsoft.VisualBasic.ApplicationServices.AuthenticationMode authenticationMode);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(valuetype Microsoft.VisualBasic.ApplicationServices.AuthenticationMode authenticationMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.#ctor(Microsoft.VisualBasic.ApplicationServices.AuthenticationMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsFormsApplicationBase(Microsoft::VisualBasic::ApplicationServices::AuthenticationMode authenticationMode);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase : Microsoft.VisualBasic.ApplicationServices.AuthenticationMode -&gt; Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" Usage="new Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase authenticationMode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="authenticationMode" Type="Microsoft.VisualBasic.ApplicationServices.AuthenticationMode" />
      </Parameters>
      <Docs>
        <param name="authenticationMode">
          <see cref="T:Microsoft.VisualBasic.ApplicationServices.AuthenticationMode" />. Określa tryb uwierzytelniania aplikacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" /> klasy z określony tryb uwierzytelniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `authenticationMode` parametr jest <xref:Microsoft.VisualBasic.ApplicationServices.AuthenticationMode.Windows> wartości wyliczenia, a następnie ten konstruktor próbuje ustawić bieżącego wątku <xref:System.Threading.Thread.CurrentPrincipal%2A> właściwości <xref:System.Security.Principal.WindowsPrincipal> dla bieżącego użytkownika.  
  
 Jeśli `authenticationMode` parametr jest <xref:Microsoft.VisualBasic.ApplicationServices.AuthenticationMode.ApplicationDefined> wartości wyliczenia, a następnie ten konstruktor pozostawia bieżący wątek <xref:System.Threading.Thread.CurrentPrincipal%2A> właściwości bez zmian.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationContext">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ApplicationContext ApplicationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ApplicationContext ApplicationContext" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ApplicationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationContext As ApplicationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ApplicationContext ^ ApplicationContext { System::Windows::Forms::ApplicationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationContext : System.Windows.Forms.ApplicationContext" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ApplicationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ApplicationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.ApplicationContext" /> obiektu dla bieżącego wątku aplikacji formularzy systemu Windows.</summary>
        <value>Ta właściwość zwraca <see cref="T:System.Windows.Forms.ApplicationContext" /> obiektu dla bieżącego wątku. Ten obiekt zawiera informacje kontekstowe o wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to zaawansowane elementu członkowskiego; nie ma w funkcji IntelliSense, chyba że kliknięciu **wszystkie** kartę.  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ApplicationContext" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DoEvents();" />
      <MemberSignature Language="F#" Value="member this.DoEvents : unit -&gt; unit" Usage="windowsFormsApplicationBase.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przetwarza wszystkie komunikaty systemu Windows w kolejce wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `My.Application.DoEvents` Metody umożliwia aplikacji do obsługi innych zdarzeń, które może zostać wywołane, gdy kod działa. `My.Application.DoEvents` Metody zachowanie jest takie samo jak <xref:System.Windows.Forms.Application.DoEvents%2A> metody.  
  
 Po uruchomieniu aplikacji formularzy systemu Windows, tworzy nowy formularz, który następnie czeka na zdarzeń do obsłużenia. Zawsze formularz obsługi zdarzenia, takie jak kliknij przycisk, przetwarza cały kod skojarzony z tym zdarzeniem. Wszystkie inne zdarzenia oczekiwać w kolejce. Gdy swój kod obsługi zdarzenia, aplikacja nie odpowiada. Na przykład jeśli inne okno zostanie przeciągnięty u góry okna odświeżenia nie.  
  
 Jeśli należy wywołać `My.Application.DoEvents` w kodzie, aplikacja może obsługiwać inne zdarzenia. Na przykład, jeśli kod dodaje dane do <xref:System.Windows.Forms.ListBox> w pętli i po każdym kroku pętli wywołuje `My.Application.DoEvents`, odświeża formularza, gdy inne okno zostanie przeciągnięty nad nim. Jeśli usuniesz `My.Application.DoEvents` z poziomu kodu formularza nie będzie odświeżenia dopiero po zakończeniu obsługi zdarzeń kliknięcia przycisku wykonywania.  
  
 Zwykle Użyj tej metody w pętli do przetwarzania komunikatów.  
  
> [!NOTE]
>  `My.Application.DoEvents` — Metoda nie przetwarza zdarzenia w taki sam sposób jak w formularzu. Użycie wielowątkowość formularza bezpośrednio obsługiwać zdarzenia. Aby uzyskać więcej informacji, zobacz [aplikacje wielowątkowe](http://msdn.microsoft.com/library/a06a1a56-dd16-44e8-bc01-2c2255511bc6).  
  
> [!CAUTION]
>  Jeśli metoda, która obsługuje zdarzenia interfejsu użytkownika wywołuje metodę `My.Application.DoEvents` metody, metoda może być ponownie wprowadzić, przed zakończeniem. Może to się zdarzyć `My.Application.DoEvents` metoda przetwarza komunikatów systemu Windows i komunikatów systemu Windows może wywoływać zdarzenia.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Application.DoEvents` metody.  
  
|Do|Zobacz|  
|-|-|  
|Zezwalaj na formularzu odpowiedzieć na dane wejściowe podczas zajęty interfejsu użytkownika|[Przewodnik: obsługa zdarzeń](~/docs/visual-basic/programming-guide/language-features/events/walkthrough-handling-events.md)|  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie użyto `My.Application.DoEvents` metodę umożliwiającą interfejsu użytkownika dla `TextBox1` do aktualizacji.  
  
 [!code-vb[VbVbalrMyApplication#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/Form1.vb#6)]  
  
 Ten kod musi należeć do formularza, który ma `TextBox1` składnik o `Text` właściwości.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="protected bool EnableVisualStyles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableVisualStyles" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Protected Property EnableVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool EnableVisualStyles { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableVisualStyles : bool with get, set" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.EnableVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy tej aplikacji będą używać stylów systemu Windows XP do systemu windows, kontrolki itd.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która wskazuje, czy ta aplikacja będzie używać stylów systemu Windows XP dla systemu windows, kontrolki itd.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnInitialize%2A> — Metoda używa tej właściwości, aby określić, czy wywołać <xref:System.Windows.Forms.Application.EnableVisualStyles%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnInitialize(System.Collections.ObjectModel.ReadOnlyCollection{System.String})" />
        <altmember cref="M:System.Windows.Forms.Application.EnableVisualStyles" />
      </Docs>
    </Member>
    <Member MemberName="HideSplashScreen">
      <MemberSignature Language="C#" Value="protected void HideSplashScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyinstance void HideSplashScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.HideSplashScreen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub HideSplashScreen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void HideSplashScreen();" />
      <MemberSignature Language="F#" Value="member this.HideSplashScreen : unit -&gt; unit" Usage="windowsFormsApplicationBase.HideSplashScreen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ukrywa ekranu powitalnego aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase> Klasy tworzy ekranu powitalnego w oddzielnym wątku. Ta metoda marshals wywołanie zorganizuj poprawny wątek.  
  
 Ta metoda jest wywoływana po zakończeniu formularz główny ładowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MinimumSplashScreenDisplayTime" />
        <altmember cref="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ShowSplashScreen" />
        <altmember cref="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateSplashScreen" />
      </Docs>
    </Member>
    <Member MemberName="IsSingleInstance">
      <MemberSignature Language="C#" Value="protected bool IsSingleInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleInstance" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.IsSingleInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Property IsSingleInstance As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSingleInstance { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleInstance : bool with get, set" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.IsSingleInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy ta aplikacja jest pojedyncze wystąpienie aplikacji.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która wskazuje, czy ta aplikacja jest pojedyncze wystąpienie aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Run%2A> — Metoda używa tej właściwości, aby określić, czy ta aplikacja jest pojedyncze wystąpienie aplikacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Run(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="MainForm">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.Form MainForm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form MainForm" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MainForm" />
      <MemberSignature Language="VB.NET" Value="Protected Property MainForm As Form" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Forms::Form ^ MainForm { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainForm : System.Windows.Forms.Form with get, set" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MainForm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia formularz główny dla tej aplikacji.</summary>
        <value>Pobiera lub ustawia formularz główny dla tej aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `MainForm` właściwości można pobrać lub ustawić <xref:System.Windows.Forms.Form> obiekt używający modelu zamykania uruchamiania aplikacji Visual Basic jako formularz główny aplikacji.  
  
 Ta właściwość obsługuje model zamykania uruchamiania aplikacji Visual Basic. Aby uzyskać więcej informacji, zobacz [omówienie modelu aplikacji Visual Basic](~/docs/visual-basic/developing-apps/development-with-my/overview-of-the-visual-basic-application-model.md).  
  
 Zmiany w tej właściwości nie są zachowywane po zamknięciu aplikacji. Aby zmienić trwale formularza głównego, należy zmienić ustawienie **projektanta projektu**.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="MinimumSplashScreenDisplayTime">
      <MemberSignature Language="C#" Value="public int MinimumSplashScreenDisplayTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumSplashScreenDisplayTime" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MinimumSplashScreenDisplayTime" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumSplashScreenDisplayTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumSplashScreenDisplayTime { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSplashScreenDisplayTime : int with get, set" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MinimumSplashScreenDisplayTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa minimalną długość czasu w milisekundach, dla których jest wyświetlany ekran powitalny.</summary>
        <value>
          <see langword="Integer" />. Minimalna długość czasu w milisekundach, dla których jest wyświetlany ekran powitalny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `My.Application.MinimumSplashScreenDisplayTime` Właściwość umożliwia określenie minimalnej długości czasu ekranu powitalnego aplikacji do wyświetlenia. Jeśli formularz główny zakończeniu inicjowania w krótszym czasie niż co to jest określona przez tę właściwość ekranu powitalnego pozostaje do żądanej ilości upływu czasu, po tym czasie zostanie wyświetlony formularz główny. Jeśli aplikacja dłużej, aby rozpocząć, ekran powitalny jest zamknięty, gdy formularz główny staje się aktywny.  
  
 Po dodaniu ekranu powitalnego aplikacji przy użyciu narzędzia Projektant projektu ustawia `My.Application.MinimumSplashScreenDisplayTime` właściwości do 2000, podając czas wyświetlania minimalna dwie sekundy.  
  
 Ta właściwość obsługuje model aplikacji Visual Basic. Aby uzyskać więcej informacji, zobacz [omówienie modelu aplikacji Visual Basic](~/docs/visual-basic/developing-apps/development-with-my/overview-of-the-visual-basic-application-model.md).  
  
 Należy ustawić `My.Application.MinimumSplashScreenDisplayTime` właściwość w metodę, która zastępuje <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnInitialize%2A> lub <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateSplashScreen%2A> metody. Kod, który zastępuje metody <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase> klasy powinny być wprowadzane w pliku ApplicationEvents.vb, który jest domyślnie ukryty.  
  
| |  
|-|  
|Aby uzyskać dostęp do okna edytora kodu dla zastępowanie elementów członkowskich|  
|1.  Z projektem wybranym **Eksploratora rozwiązań**, kliknij przycisk **właściwości** na **projektu** menu.<br />2.  Kliknij przycisk **aplikacji** kartę.<br />3.  Kliknij przycisk **Wyświetl zdarzenia aplikacji** przycisk, aby otworzyć edytora kodu.<br /><br />Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).|  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak ustawić `My.Application.MinimumSplashScreenDisplayTime` właściwości przez zastąpienie <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnInitialize%2A> właściwości.  
  
 [!code-vb[VbVbalrMyApplication#51](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/FakeMyEvents.vb#51)]  
  
 W tym przykładzie musi mieć projekt ekranu powitalnego.  
  
 Należy wprowadzić ten kod w oknie edytora kodu dla zdarzeń aplikacji. Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.SplashScreen" />
        <altmember cref="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnInitialize(System.Collections.ObjectModel.ReadOnlyCollection{System.String})" />
        <altmember cref="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateSplashScreen" />
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="NetworkAvailabilityChanged">
      <MemberSignature Language="C#" Value="public event Microsoft.VisualBasic.Devices.NetworkAvailableEventHandler NetworkAvailabilityChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.VisualBasic.Devices.NetworkAvailableEventHandler NetworkAvailabilityChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.NetworkAvailabilityChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NetworkAvailabilityChanged As NetworkAvailableEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Microsoft::VisualBasic::Devices::NetworkAvailableEventHandler ^ NetworkAvailabilityChanged;" />
      <MemberSignature Language="F#" Value="member this.NetworkAvailabilityChanged : Microsoft.VisualBasic.Devices.NetworkAvailableEventHandler " Usage="member this.NetworkAvailabilityChanged : Microsoft.VisualBasic.Devices.NetworkAvailableEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.Devices.NetworkAvailableEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dostępność sieci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uruchamia aplikację `NetworkAvailabilityChanged` zdarzeń zawsze zmienia dostępność sieci. Można użyć <xref:Microsoft.VisualBasic.Devices.NetworkAvailableEventArgs.IsNetworkAvailable%2A> właściwość `e` parametr, aby uzyskać nowy stan połączenia sieciowego. Aby uzyskać bieżący stan połączenia sieciowego, należy użyć <xref:Microsoft.VisualBasic.Devices.Network.IsAvailable%2A> właściwości.  
  
 To zdarzenie jest wywoływane w wątku głównego aplikacji z innymi zdarzeniami interfejsu użytkownika. Dzięki temu bezpośredni dostęp interfejsu użytkownika aplikacji do obsługi zdarzeń. Jednak jeśli aplikacja jest zajęta, obsługa inne zdarzenie interfejsu użytkownika, gdy to zdarzenie jest zgłaszane, to zdarzenie nie można przetworzyć obsługi zdarzeń zakończenie lub wywołuje <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.DoEvents%2A> metody.  
  
 <xref:Microsoft.VisualBasic.Devices.Network.NetworkAvailabilityChanged> Zdarzeń zapewnia te same funkcje, ale to zdarzenie jest dostępna dla wszystkich typów aplikacji.  
  
 Kod `NetworkAvailabilityChanged` program obsługi zdarzeń jest przechowywany w pliku ApplicationEvents.vb, który jest domyślnie ukryty.  
  
| |  
|-|  
|Aby uzyskać dostęp do okna edytora kodu dla zdarzeń aplikacji|  
|1.  Projekt wybrany w **Eksploratora rozwiązań.** Kliknij przycisk **właściwości** na **projektu** menu.<br />2.  Kliknij przycisk **aplikacji** kartę.<br />3.  Kliknij przycisk **Wyświetl zdarzenia aplikacji** przycisk, aby otworzyć edytora kodu.<br /><br />Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).|  
  
> [!NOTE]
>  Wiele sieci koncentratorów zapewni połączenie sieciowe, nawet jeśli koncentrator jest odłączony od większej sieci. W rezultacie dla połączeń przewodowych to zdarzenie oznacza zmianę połączenia między komputerem a koncentratora.  
  
> [!NOTE]
>  `NetworkAvailabilityChanged` Zdarzenie nie jest wywoływane przez aplikacji uruchamianych w systemie Windows 95 lub Windows 98 lub gdy są uruchamiane z systemem innym niż administrator w systemie Windows 2000. Jeśli aplikacja może działać w tych systemach operacyjnych, użyj <xref:Microsoft.VisualBasic.Devices.Network.IsAvailable%2A> właściwość do sprawdzenia dostępności sieci.  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie wywołuje `SetConnectionStatus` metody domyślnej `Form1` klasy po zmianie dostępność sieci.  
  
 Należy wprowadzić kod w oknie edytora kodu dla zdarzeń aplikacji. Aby uzyskać dostęp do tego okna, postępuj zgodnie z instrukcjami w sekcji uwag w tym temacie.  
  
 Projekt powinien mieć formularza o nazwie `Form1`. Powinien on metodę o nazwie `SetConnectionStatus` pobierającej `Boolean` parametru.  
  
 [!code-vb[VbVbalrMyApplication#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/FakeMyEvents.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" />
        <altmember cref="N:Microsoft.VisualBasic.ApplicationServices" />
        <altmember cref="T:Microsoft.VisualBasic.Devices.NetworkAvailableEventHandler" />
        <altmember cref="E:Microsoft.VisualBasic.Devices.Network.NetworkAvailabilityChanged" />
        <altmember cref="T:Microsoft.VisualBasic.Devices.NetworkAvailableEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateMainForm">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateMainForm ();" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void OnCreateMainForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateMainForm" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateMainForm ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateMainForm();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateMainForm : unit -&gt; unit&#xA;override this.OnCreateMainForm : unit -&gt; unit" Usage="windowsFormsApplicationBase.OnCreateMainForm " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, umożliwia projektanta na emitowanie kodu, który konfiguruje ekran powitalny i ekran główny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda nie działa. Jednak po wybraniu formularz główny aplikacji w języku Visual Basic **projektanta projektu**, Projektant przesłonięcia tej metody za pomocą metody, która ustawia <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MainForm%2A> właściwości nowe wystąpienie klasy głównym formularza.  
  
 Ta metoda jest wywoływana przez <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnRun%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateSplashScreen">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateSplashScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void OnCreateSplashScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateSplashScreen" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateSplashScreen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateSplashScreen();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateSplashScreen : unit -&gt; unit&#xA;override this.OnCreateSplashScreen : unit -&gt; unit" Usage="windowsFormsApplicationBase.OnCreateSplashScreen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, umożliwia projektanta na emitowanie kodu, który inicjuje ekranu powitalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda nie działa. Wybranie ekranu powitalnego aplikacji w języku Visual Basic **projektanta projektu**, zastępuje projektanta <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateSplashScreen%2A> metodę za pomocą metody, która ustawia <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.SplashScreen%2A> właściwości do nowego wystąpienia formularz ekranu powitalnego .  
  
 Ta metoda jest wywoływana przez <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnInitialize%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialize">
      <MemberSignature Language="C#" Value="protected virtual bool OnInitialize (System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; commandLineArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance bool OnInitialize(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; commandLineArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnInitialize(System.Collections.ObjectModel.ReadOnlyCollection{System.String})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnInitialize (commandLineArgs As ReadOnlyCollection(Of String)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnInitialize(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ commandLineArgs);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialize : System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; -&gt; bool&#xA;override this.OnInitialize : System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; -&gt; bool" Usage="windowsFormsApplicationBase.OnInitialize commandLineArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.STAThread</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandLineArgs" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="commandLineArgs">A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> z <see langword="String" />, zawierający argumenty wiersza polecenia jako ciągi dla bieżącej aplikacji.</param>
        <summary>Ustawia stylów wizualnych, style wyświetlania tekstu i bieżący podmiot zabezpieczeń dla wątku głównego aplikacji (Jeśli aplikacja używa uwierzytelniania systemu Windows) i inicjuje ekran powitalny, jeśli została zdefiniowana.</summary>
        <returns>A <see cref="T:System.Boolean" /> wskazującą, czy powinno być kontynuowane uruchamiania aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda ustawia stylów wizualnych, style wyświetlania tekstu i bieżący podmiot zabezpieczeń dla wątku głównego aplikacji (Jeśli aplikacja używa uwierzytelniania systemu Windows) i wywołania `ShowSplashScreen` Jeśli żadna `/nosplash` ani `-nosplash` jest używany jako argument wiersza polecenia.  
  
 Ta metoda wywołuje następujących metod:  
  
-   <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ShowSplashScreen%2A>.  
  
-   <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateSplashScreen%2A>.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.EnableVisualStyles" />
        <altmember cref="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ShowSplashScreen" />
        <altmember cref="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateSplashScreen" />
      </Docs>
    </Member>
    <Member MemberName="OnRun">
      <MemberSignature Language="C#" Value="protected virtual void OnRun ();" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void OnRun() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnRun" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRun ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRun();" />
      <MemberSignature Language="F#" Value="abstract member OnRun : unit -&gt; unit&#xA;override this.OnRun : unit -&gt; unit" Usage="windowsFormsApplicationBase.OnRun " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia punkt początkowy podczas aplikacji głównej jest gotowy do uruchomienia, uruchomiona po ukończeniu inicjowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie przed uśpieniem pętli komunikatów formularzy systemu Windows, ta metoda wywołuje `OnCreateMainForm` (Aby utworzyć formularz główny aplikacji) i `HideSplashScreen` (aby zamknąć ekran powitalny) metod:  
  
-   <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateMainForm%2A>. Umożliwia projektanta na emitowanie kodu, który inicjuje formularz główny.  
  
     Domyślnie ta metoda nie działa. Jednak po wybraniu formularz główny aplikacji w języku Visual Basic **projektanta projektu**, zastępuje projektanta <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateMainForm%2A> metodę za pomocą metody, która ustawia <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MainForm%2A> właściwości nowe wystąpienie klasy głównym formularza.  
  
-   <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.HideSplashScreen%2A>. Jeśli aplikacja ma ekran powitalny zdefiniowany i jest otwarty, ta metoda powoduje zamknięcie ekranu powitalnego.  
  
     Domyślnie ta metoda powoduje zamknięcie ekranu powitalnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="windowsFormsApplicationBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, umożliwia kod wymagany do uruchomienia podczas zamykania aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie działa, jeśli wystąpi nieobsługiwany wyjątek w aplikacji głównej.  
  
 Domyślnie ta metoda zgłasza <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Shutdown> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual bool OnStartup (Microsoft.VisualBasic.ApplicationServices.StartupEventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance bool OnStartup(class Microsoft.VisualBasic.ApplicationServices.StartupEventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnStartup(Microsoft.VisualBasic.ApplicationServices.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnStartup (eventArgs As StartupEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnStartup(Microsoft::VisualBasic::ApplicationServices::StartupEventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : Microsoft.VisualBasic.ApplicationServices.StartupEventArgs -&gt; bool&#xA;override this.OnStartup : Microsoft.VisualBasic.ApplicationServices.StartupEventArgs -&gt; bool" Usage="windowsFormsApplicationBase.OnStartup eventArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgs" Type="Microsoft.VisualBasic.ApplicationServices.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="eventArgs">
          <see cref="T:Microsoft.VisualBasic.ApplicationServices.StartupEventArgs" />. zawiera argumenty wiersza polecenia aplikacji oraz wskazuje, czy powinno być anulowane uruchamiania aplikacji.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, umożliwia kod wymagany do uruchomienia podczas uruchamiania aplikacji.</summary>
        <returns>A <see cref="T:System.Boolean" /> wskazujące, że jeśli aplikacja powinna nadal uruchamiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Startup> zdarzeń. Można ustawić programu obsługi zdarzeń <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwości argumentu zdarzenia. Jeśli <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> jest `True`, ta metoda zwraca `False` anulować uruchamiania aplikacji. W przeciwnym razie ta metoda zwraca `True`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.StartupEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnStartupNextInstance">
      <MemberSignature Language="C#" Value="protected virtual void OnStartupNextInstance (Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void OnStartupNextInstance(class Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnStartupNextInstance(Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartupNextInstance (eventArgs As StartupNextInstanceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartupNextInstance(Microsoft::VisualBasic::ApplicationServices::StartupNextInstanceEventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="abstract member OnStartupNextInstance : Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs -&gt; unit&#xA;override this.OnStartupNextInstance : Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs -&gt; unit" Usage="windowsFormsApplicationBase.OnStartupNextInstance eventArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgs" Type="Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs" />
      </Parameters>
      <Docs>
        <param name="eventArgs">
          <see cref="T:Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs" />. zawiera argumenty wiersza polecenia wystąpienia kolejnych aplikacji oraz wskazuje, czy pierwsze wystąpienie aplikacji powinny być przesunięte na pierwszy plan podczas zamykania programu obsługi wyjątków.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, umożliwia kodu do uruchomienia, gdy rozpoczyna się kolejne wystąpienie pojedyncze wystąpienie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.StartupNextInstance> zdarzeń. Można ustawić programu obsługi zdarzeń <xref:Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs.BringToForeground%2A> właściwości argumentu zdarzenia. Jeśli <xref:Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs.BringToForeground%2A> jest `True`, metoda aktywuje formularz główny. W przeciwnym razie formularz główny pozostanie w jego bieżącym stanie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.IsSingleInstance" />
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventArgs" />
        <altmember cref="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.StartupNextInstance" />
      </Docs>
    </Member>
    <Member MemberName="OnUnhandledException">
      <MemberSignature Language="C#" Value="protected virtual bool OnUnhandledException (Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance bool OnUnhandledException(class Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnUnhandledException(Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnUnhandledException (e As UnhandledExceptionEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnUnhandledException(Microsoft::VisualBasic::ApplicationServices::UnhandledExceptionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnhandledException : Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs -&gt; bool&#xA;override this.OnUnhandledException : Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs -&gt; bool" Usage="windowsFormsApplicationBase.OnUnhandledException e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, umożliwia kod wymagany do uruchomienia, gdy wystąpi nieobsługiwany wyjątek w aplikacji.</summary>
        <returns>A <see cref="T:System.Boolean" /> wskazujące, czy <see cref="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException" /> wywołano zdarzenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException> tak długo, jak nie jest dołączony debuger, a użytkownik jest obsługa zdarzeń `UnhandledException` zdarzeń. Można ustawić programu obsługi zdarzeń <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> właściwości. Jeśli <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> jest `False`, lub jeśli zdarzenie nie jest obsługiwane, aplikacja kończy działanie po powrocie z obsługi wyjątków. W przeciwnym razie kontroli aplikacji są zwracane do pętli komunikatów formularzy systemu Windows.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs" />
        <altmember cref="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję formularzy otwartych wszystkich aplikacji.</summary>
        <value>A <see cref="T:System.Windows.Forms.FormCollection" /> obiekt, który zawiera wszystkie otwarte formularze aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `My.Application.OpenForms` Właściwość pobiera kolekcja formularzy otwartych wszystkich aplikacji. Zachowanie jest takie same jak <xref:System.Windows.Forms.Application.OpenForms%2A?displayProperty=nameWithType> właściwości.  
  
> [!NOTE]
>  `My.Application.OpenForms` Właściwość zwraca wszystkie otwarte formularze, niezależnie od tego, które wątku ich otwarcia. Należy sprawdzić <xref:System.Windows.Forms.Control.InvokeRequired%2A> właściwości każdego formularza przed uzyskaniem dostępu do; w przeciwnym razie może zgłosić <xref:System.InvalidOperationException> wyjątku.  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie pętli otwartych formularzy aplikacji, wybiera te dostępny bezpośrednio przez bieżący wątek i wyświetla jego tytułu na <xref:System.Windows.Forms.ListBox> formantu. W tym przykładzie musi mieć aplikacji Windows Forms formularza o nazwie `Form1` zawierający pole listy o nazwie `ListBox1`.  
  
 [!code-vb[VbVbalrMyApplication#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/Form1.vb#10)]  
  
 W tym przykładzie pętli otwartych formularzy aplikacji i przedstawia tytuły ich w <xref:System.Windows.Forms.ListBox> formantu.  
  
 [!code-vb[VbVbalrMyApplication#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia, które odnoszą się do Schowka i interfejsy użytkownika. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <altmember cref="T:System.Windows.Forms.FormCollection" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run (string[] commandLine);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Run(string[] commandLine) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Run(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Run (commandLine As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Run(cli::array &lt;System::String ^&gt; ^ commandLine);" />
      <MemberSignature Language="F#" Value="member this.Run : string[] -&gt; unit" Usage="windowsFormsApplicationBase.Run commandLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandLine" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="commandLine">Tablica typu <see langword="String" />. Wiersz polecenia z <see langword="Sub Main" />.</param>
        <summary>Konfiguruje i uruchamia model aplikacji Visual Basic.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `My.Application.Run` Metoda zapewnia obsługę model aplikacji Visual Basic. Tę metodę należy wywoływać tylko z poziomu aplikacji `Sub Main`. Domyślnie `Sub Main` formularzy systemu Windows aplikacji wywołuje tę metodę. Aby uzyskać więcej informacji, zobacz [omówienie modelu aplikacji Visual Basic](~/docs/visual-basic/developing-apps/development-with-my/overview-of-the-visual-basic-application-model.md).  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Kontroluje możliwość dostępu wszystkich systemowych zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steruje możliwością dostęp do zmiennych rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <permission cref="T:System.Net.WebPermission">Formanty prawa dostępu do zasobów Internetu HTTP. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Net.SocketPermission">Formanty prawa lub akceptowania połączeń na adres transportu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Kontroluje dostęp do składnika licznika wydajności systemu Windows NT. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SaveMySettingsOnExit">
      <MemberSignature Language="C#" Value="public bool SaveMySettingsOnExit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SaveMySettingsOnExit" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.SaveMySettingsOnExit" />
      <MemberSignature Language="VB.NET" Value="Public Property SaveMySettingsOnExit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SaveMySettingsOnExit { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SaveMySettingsOnExit : bool with get, set" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.SaveMySettingsOnExit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy aplikacja zapisuje ustawień użytkownika na wyjściu.</summary>
        <value>
          <see langword="Boolean" />. <see langword="True" /> Wskazuje, że aplikacja zapisuje ustawień użytkownika na wyjściu. W przeciwnym razie wartość ustawienia nie są domyślnie zapisywane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `SaveMySettingsOnExit` Właściwość umożliwia użytkownikowi zmianę, jak aplikacja zapisuje ustawienia w czasie wykonywania. Można jawnie zapisać zmiany w ustawieniach przy użyciu <xref:System.Configuration.ApplicationSettingsBase.Save%2A> metody `My.Settings` obiektu. Aby uzyskać więcej informacji na temat zmiany i zapisywania ustawień, zobacz [właściwości aplikacji](http://msdn.microsoft.com/library/0ad4926f-636e-41f8-a5b1-faf9d9b0a254).  
  
 Zmiany w tej właściwości nie są zachowywane po zamknięciu aplikacji. Aby zmienić `SaveMySettingsOnExit` właściwości stałe, należy zmienić ustawienie **projektanta projektu**:  
  
| |  
|-|  
|Aby zmienić ustawienia w Projektancie projektu|  
|1.  Projekt wybrany w **Eksploratora rozwiązań**. Kliknij przycisk **właściwości** na **projektu** menu.<br />2.  Kliknij przycisk **aplikacji** kartę.<br />3.  Wybierz **zapisywania My.Settings podczas zamykania**.|  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie ma dwie części.  
  
-   `InitializeSaveMySettingsOnExit` Procedury, która inicjuje stan zaznaczenia <xref:System.Windows.Forms.CheckBox> kontroli do bieżącej wartości `SaveMySettingsOnExit` właściwości.  
  
-   `SaveMySettingsOnExit_CheckedChanged` Procedury, która obsługuje zmiany <xref:System.Windows.Forms.CheckBox> formantu, aby zaktualizować `My.Application.SaveMySettingsOnExit` właściwości.  
  
 [!code-vb[VbVbalrMyApplication#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/Form1.vb#12)]  
  
 W tym przykładzie działała, aplikacja musi mieć <xref:System.Windows.Forms.CheckBox> formantu o nazwie `SaveMySettingsOnExit`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Save" />
      </Docs>
    </Member>
    <Member MemberName="ShowSplashScreen">
      <MemberSignature Language="C#" Value="protected void ShowSplashScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyinstance void ShowSplashScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ShowSplashScreen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ShowSplashScreen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ShowSplashScreen();" />
      <MemberSignature Language="F#" Value="member this.ShowSplashScreen : unit -&gt; unit" Usage="windowsFormsApplicationBase.ShowSplashScreen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy aplikacja ma zdefiniowany ekran powitalny, a jeśli tak, wyświetla go.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda wywołuje `OnCreateSplashScreen` w sposób zapewniający obsługę wielowątkowości.  
  
 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ShowSplashScreen%2A> Metoda zawiera kod, który wyświetla to pozostawienie ekranu powitalnego ekranu dla wyrażony w milisekundach czas określony przez <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MinimumSplashScreenDisplayTime%2A> właściwości. Aby używać tej funkcji, należy ustawić `My.Application.MinimumSplashScreenDisplayTime` właściwość w metodę, która zastępuje <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ShowSplashScreen%2A> lub <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnCreateSplashScreen%2A> metody, lub Dodaj ekran powitalny do swojej aplikacji za pomocą **projektanta projektu**. Aby uzyskać więcej informacji, zobacz <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MinimumSplashScreenDisplayTime%2A>.  
  
 Ta metoda jest wywoływana przez <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnInitialize%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.OnInitialize(System.Collections.ObjectModel.ReadOnlyCollection{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public event Microsoft.VisualBasic.ApplicationServices.ShutdownEventHandler Shutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.VisualBasic.ApplicationServices.ShutdownEventHandler Shutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Event Shutdown As ShutdownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Microsoft::VisualBasic::ApplicationServices::ShutdownEventHandler ^ Shutdown;" />
      <MemberSignature Language="F#" Value="member this.Shutdown : Microsoft.VisualBasic.ApplicationServices.ShutdownEventHandler " Usage="member this.Shutdown : Microsoft.VisualBasic.ApplicationServices.ShutdownEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.ApplicationServices.ShutdownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zamknięciu aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uruchamia aplikację `Shutdown` zdarzeń, aby zakończyć pracę. Dzięki temu można kontrolować, jak aplikacja zamyka jego zasoby. To zdarzenie jest częścią modelu aplikacji Visual Basic. Aby uzyskać więcej informacji, zobacz [omówienie modelu aplikacji Visual Basic](~/docs/visual-basic/developing-apps/development-with-my/overview-of-the-visual-basic-application-model.md).  
  
 Kod `Shutdown` program obsługi zdarzeń jest przechowywany w pliku ApplicationEvents.vb, który jest domyślnie ukryty.  
  
| |  
|-|  
|Aby uzyskać dostęp do okna edytora kodu dla zdarzeń aplikacji|  
|1.  Z projektem wybranym **Eksploratora rozwiązań**, kliknij przycisk **właściwości** na **projektu** menu.<br />2.  Kliknij przycisk **aplikacji** kartę.<br />3.  Kliknij przycisk **Wyświetl zdarzenia aplikacji** przycisk, aby otworzyć edytora kodu.<br /><br />Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).|  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie rejestruje komunikaty podczas zamykania aplikacji.  
  
 [!code-vb[VbVbalrMyApplication#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/FakeMyEvents.vb#13)]  
  
 Należy wprowadzić kod w oknie edytora kodu dla zdarzeń aplikacji. Aby uzyskać dostęp do tego okna, postępuj zgodnie z instrukcjami w sekcji uwag w tym temacie. Aby uzyskać więcej informacji, zobacz [porady: dziennika wiadomości podczas uruchamiania aplikacji lub kończy w dół](~/docs/visual-basic/developing-apps/programming/log-info/how-to-log-messages-when-the-application-starts-or-shuts-down.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStyle">
      <MemberSignature Language="C#" Value="protected internal Microsoft.VisualBasic.ApplicationServices.ShutdownMode ShutdownStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.ApplicationServices.ShutdownMode ShutdownStyle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ShutdownStyle" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property ShutdownStyle As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property Microsoft::VisualBasic::ApplicationServices::ShutdownMode ShutdownStyle { Microsoft::VisualBasic::ApplicationServices::ShutdownMode get(); void set(Microsoft::VisualBasic::ApplicationServices::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownStyle : Microsoft.VisualBasic.ApplicationServices.ShutdownMode with get, set" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.ShutdownStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.ApplicationServices.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, co się stanie po zamknięciu formularza głównego aplikacji.</summary>
        <value>A <see cref="T:Microsoft.VisualBasic.ApplicationServices.ShutdownMode" /> wartość wyliczenia wskazująca, co aplikacja powinna wykonać po zamknięciu formularza głównego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ApplicationContext.OnMainFormClosed%2A> Metoda sprawdza wartość tej właściwości, aby określić, czy aplikacja powinna zamknięta po zamknięciu formularza głównego, lub jeśli inny Otwórz formularz należy promować jako nowy formularz główny.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.ShutdownMode" />
      </Docs>
    </Member>
    <Member MemberName="SplashScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form SplashScreen { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form SplashScreen" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.SplashScreen" />
      <MemberSignature Language="VB.NET" Value="Public Property SplashScreen As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ SplashScreen { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SplashScreen : System.Windows.Forms.Form with get, set" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.SplashScreen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ekran powitalny dla tej aplikacji.</summary>
        <value>A <see cref="T:System.Windows.Forms.Form" /> obiekt, który aplikacja używa jako ekran powitalny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `My.Application.SplashScreen` Właściwość służy do pobierania lub ustawiania <xref:System.Windows.Forms.Form> obiekt, który aplikacja używa jako ekran powitalny, pierwszy graficzne formularz, który jest wyświetlany, gdy aplikacja jest uruchamiana.  
  
 Ta właściwość obsługuje model aplikacji Visual Basic. Aby uzyskać więcej informacji, zobacz [omówienie modelu aplikacji Visual Basic](~/docs/visual-basic/developing-apps/development-with-my/overview-of-the-visual-basic-application-model.md).  
  
 Zmiany w tej właściwości nie są zachowywane po zamknięciu aplikacji. Aby zmienić trwale ekran powitalny, należy zmienić ustawienie **projektanta projektu**.  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie użyto `My.Application.SplashScreen` właściwości i `My.Application.Startup` zdarzeń, aby zaktualizować ekran powitalny informacje o stanie po uruchomieniu aplikacji.  
  
 [!code-vb[VbVbalrMyApplication#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/FakeMyEvents.vb#14)]  
  
 W tym przykładzie musi mieć projekt o nazwie ekran powitalny `SplashScreen1`. Ekran powitalny musi mieć właściwość o nazwie `Status` który aktualizuje interfejs użytkownika.  
  
 Należy wprowadzić ten kod w oknie edytora kodu dla zdarzeń aplikacji. Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Tej samej wartości jest przypisany do tej właściwości i <see cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MainForm" /> właściwości.</exception>
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.MinimumSplashScreenDisplayTime" />
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event Microsoft.VisualBasic.ApplicationServices.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.VisualBasic.ApplicationServices.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Microsoft::VisualBasic::ApplicationServices::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : Microsoft.VisualBasic.ApplicationServices.StartupEventHandler " Usage="member this.Startup : Microsoft.VisualBasic.ApplicationServices.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.ApplicationServices.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje podczas uruchamiania aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalne aplikacji (z systemem innym niż — jednego wystąpienia) zgłasza `Startup` zdarzeń w każdym uruchomieniu. Pojedyncze wystąpienie aplikacji zgłasza `Startup` zdarzeń podczas jej uruchamiania, tylko jeśli aplikacja nie jest jeszcze aktywne, a w przeciwnym, zgłasza `StartupNextInstance` zdarzeń. Aby uzyskać więcej informacji, zobacz <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.StartupNextInstance>.  
  
 To zdarzenie jest częścią modelu aplikacji Visual Basic. Aby uzyskać więcej informacji, zobacz [omówienie modelu aplikacji Visual Basic](~/docs/visual-basic/developing-apps/development-with-my/overview-of-the-visual-basic-application-model.md).  
  
 Można użyć <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwość `e` parametr, aby kontrolować ładowanie formularz początkowy aplikacji. Gdy <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwość jest ustawiona na `True`, nie uruchamia się formularz startowy. W takim przypadku kodu powinny wywoływać ścieżka kodu uruchamiania alternatywny.  
  
 Można użyć <xref:Microsoft.VisualBasic.ApplicationServices.StartupEventArgs.CommandLine%2A> właściwość `e` parametru lub <xref:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs%2A> właściwości można uzyskać dostępu do argumentów wiersza polecenia aplikacji.  
  
 Kod `Startup` program obsługi zdarzeń jest przechowywany w pliku ApplicationEvents.vb, który jest domyślnie ukryty.  
  
| |  
|-|  
|Aby uzyskać dostęp do okna edytora kodu dla zdarzeń aplikacji|  
|1.  Z projektem wybranym **Eksploratora rozwiązań**, kliknij przycisk **właściwości** na **projektu** menu.<br />2.  Kliknij przycisk **aplikacji** kartę.<br />3.  Kliknij przycisk **Wyświetl zdarzenia aplikacji** przycisk, aby otworzyć edytora kodu.<br /><br /> Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).|  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie użyto `My.Application.SplashScreen` właściwości i `My.Application.Startup` zdarzeń, aby zaktualizować ekran powitalny informacje o stanie po uruchomieniu aplikacji.  
  
 [!code-vb[VbVbalrMyApplication#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/FakeMyEvents.vb#14)]  
  
 W tym przykładzie musi mieć projekt o nazwie ekran powitalny `SplashScreen1`. Ekran powitalny musi mieć właściwość o nazwie `Status` który aktualizuje interfejs użytkownika.  
  
 Należy wprowadzić kod w oknie edytora kodu dla zdarzeń aplikacji. Aby uzyskać dostęp do tego okna, postępuj zgodnie z instrukcjami w sekcji uwag w tym temacie. Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Kontroluje możliwość dodawania obsługi zdarzeń dla tego zdarzenia. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</permission>
        <altmember cref="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.StartupNextInstance" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="StartupNextInstance">
      <MemberSignature Language="C#" Value="public event Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventHandler StartupNextInstance;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventHandler StartupNextInstance" />
      <MemberSignature Language="DocId" Value="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.StartupNextInstance" />
      <MemberSignature Language="VB.NET" Value="Public Event StartupNextInstance As StartupNextInstanceEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Microsoft::VisualBasic::ApplicationServices::StartupNextInstanceEventHandler ^ StartupNextInstance;" />
      <MemberSignature Language="F#" Value="member this.StartupNextInstance : Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventHandler " Usage="member this.StartupNextInstance : Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.ApplicationServices.StartupNextInstanceEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy próba uruchomienia pojedynczego wystąpienia aplikacji oraz aplikacja jest już aktywna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojedyncze wystąpienie aplikacji zgłasza <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.StartupNextInstance> zdarzenie, gdy próba ponownego uruchomienia aplikacji, gdy nie jest już aktywny. Podczas uruchamiania pojedynczego wystąpienia aplikacji po raz pierwszy uruchamia <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Startup> zdarzeń. Aby uzyskać więcej informacji, zobacz <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Startup>.  
  
 To zdarzenie jest częścią modelu aplikacji Visual Basic. Aby uzyskać więcej informacji, zobacz [omówienie modelu aplikacji Visual Basic](~/docs/visual-basic/developing-apps/development-with-my/overview-of-the-visual-basic-application-model.md).  
  
 To zdarzenie jest wywoływane w wątku głównego aplikacji z innymi zdarzeniami interfejsu użytkownika. Dzięki temu bezpośredni dostęp interfejsu użytkownika aplikacji do obsługi zdarzeń. Jednak jeśli aplikacja jest zajęta, obsługa inne zdarzenie interfejsu użytkownika, gdy to zdarzenie jest zgłaszane, to zdarzenie nie można przetworzyć obsługi zdarzeń zakończenie lub wywołuje <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.DoEvents%2A> metody.  
  
> [!NOTE]
>  `StartupNextInstance` Zdarzenie jest wywoływane tylko w jednym wystąpieniu aplikacji. Aby włączyć zachowanie jednego wystąpienia aplikacji, należy sprawdzić **aplikacja pojedynczego wystąpienia** pole wyboru w Projektancie projektu.  
  
| |  
|-|  
|Aby pojedynczego wystąpienia aplikacji|  
|1.  Z projektem wybranym **Eksploratora rozwiązań**, kliknij przycisk **właściwości** na **projektu** menu.<br />2.  Kliknij przycisk **aplikacji** kartę.<br />3.  Wybierz **aplikacja pojedynczego wystąpienia** pole wyboru.|  
  
 Należy użyć <xref:Microsoft.VisualBasic.ApplicationServices.StartupEventArgs.CommandLine%2A> właściwość `e` parametr, aby uzyskać dostępu do argumentów dla kolejnych prób uruchomić pojedyncze wystąpienie aplikacji. <xref:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs%2A> Właściwość zawiera argumenty używane do uruchamiania pierwsze wystąpienie pojedyncze wystąpienie aplikacji.  
  
 Kod <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.StartupNextInstance> program obsługi zdarzeń jest przechowywany w pliku ApplicationEvents.vb, który jest domyślnie ukryty.  
  
| |  
|-|  
|Aby uzyskać dostęp do okna edytora kodu dla zdarzeń aplikacji|  
|1.  Z projektem wybranym **Eksploratora rozwiązań**, kliknij przycisk **właściwości** na **projektu** menu.<br />2.  Kliknij przycisk **aplikacji** kartę.<br />3.  Kliknij przycisk **Wyświetl zdarzenia aplikacji** przycisk, aby otworzyć edytora kodu.<br /><br />Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).|  
  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Application.StartupNextInstance` zdarzeń.  
  
|Do|Zobacz|  
|-|-|  
|Sprawdź, czy argumenty wiersza polecenia, pierwszego wystąpienia aplikacji|<xref:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs%2A>|  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|Tak|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie użyto `e` parametr <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.StartupNextInstance> obsługi zdarzeń do sprawdzenia argumenty wiersza polecenia aplikacji. Jeśli argument zostanie znaleziony, który rozpoczyna się od `/input=`, pozostała część tego argumentu jest wyświetlany.  
  
 [!code-vb[VbVbalrMyApplication#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/FakeMyEvents.vb#15)]  
  
 Należy wprowadzić kod w oknie edytora kodu dla zdarzeń aplikacji. Aby uzyskać dostęp do tego okna, postępuj zgodnie z instrukcjami w sekcji uwag w tym temacie. Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.Startup" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.StartupEventArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.StartupEventArgs.CommandLine" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Microsoft::VisualBasic::ApplicationServices::UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventHandler " Usage="member this.UnhandledException : Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja napotka nieobsługiwany wyjątek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uruchamia aplikację `UnhandledException` zdarzeń po napotkaniu nieobsługiwany wyjątek. To zdarzenie jest częścią modelu aplikacji Visual Basic. Aby uzyskać więcej informacji, zobacz [omówienie modelu aplikacji Visual Basic](~/docs/visual-basic/developing-apps/development-with-my/overview-of-the-visual-basic-application-model.md).  
  
 Można użyć <xref:System.Threading.ThreadExceptionEventArgs.Exception%2A> właściwość `e` parametr, aby uzyskać dostęp nieobsługiwany wyjątek, który spowodował to zdarzenie.  
  
 Można użyć <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> właściwość `e` parametru do kontrolowania, czy kończy działanie aplikacji. Domyślnie <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> jest `True`. W związku z tym aplikacji kończy się po zakończeniu `UnhandledException` obsługi zdarzeń. Wartość można ustawić, `False` w `UnhandledException` obsługi zdarzeń, aby aplikacja była uruchomiona i przywrócić stan oczekiwania.  
  
 Kod `UnhandledException` program obsługi zdarzeń jest przechowywany w pliku ApplicationEvents.vb, który jest domyślnie ukryty.  
  
| |  
|-|  
|Aby uzyskać dostęp do okna edytora kodu dla zdarzeń aplikacji|  
|1.  Z projektem wybranym **Eksploratora rozwiązań**, kliknij przycisk **właściwości** na **projektu** menu.<br />2.  Kliknij przycisk **aplikacji** kartę.<br />3.  Kliknij przycisk **Wyświetl zdarzenia aplikacji** przycisk, aby otworzyć edytora kodu.|  
  
 Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).  
  
> [!NOTE]
>  Kompilator Visual Basic zapobiega aplikacje zaprojektowane do debugowania z wywołaniem tego zdarzenia, aby włączyć debugera do obsługi nieobsługiwanych wyjątków. Oznacza to, że w przypadku testowania aplikacji przez uruchomienie jej w debugerze programu Visual Studio, zintegrowane środowisko programistyczne Twojej `UnhandledException` nie zostanie wywołany program obsługi zdarzeń. Aby uzyskać więcej informacji dotyczących tworzenia aplikacji do debugowania, zobacz [/Debug (Visual Basic)](~/docs/visual-basic/reference/command-line-compiler/debug.md).  
  
## <a name="tasks"></a>Zadania  
 W poniższej tabeli przedstawiono przykłady zadań, obejmujących `My.Application.UnhandledException` zdarzeń.  
  
|Do|Zobacz|  
|-|-|  
|Rejestrowania nieobsługiwanych wyjątków|[Instrukcje: wyjątki dziennika](~/docs/visual-basic/developing-apps/programming/log-info/how-to-log-exceptions.md)|  
  
## <a name="availability-by-project-type"></a>Dostępność według typu projektu  
  
|Typ projektu|Dostępne|  
|-|-|  
|Aplikacja interfejsu Windows Forms|**tak**|  
|Biblioteka klas|Nie|  
|Aplikacja konsoli|Nie|  
|Biblioteka formantów interfejsu Windows Forms|Nie|  
|Biblioteka formantów sieci Web|Nie|  
|Usługa systemu Windows|Nie|  
|Witryna sieci Web|Nie|  
  
   
  
## Examples  
 W tym przykładzie użyto `My.Application.UnhandledException` zdarzeń logowania żadnego nieobsługiwane wyjątki.  
  
 Należy wprowadzić kod w oknie edytora kodu dla zdarzeń aplikacji. Aby uzyskać dostęp do tego okna, wykonaj procedurę w sekcji uwag w tym temacie. Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).  
  
 Ponieważ `UnhandledException` zdarzenie nie jest wywoływane, gdy debuger jest dołączony do aplikacji, należy uruchomić ten przykład poza programem Visual Studio zintegrowane środowisko deweloperskie.  
  
 [!code-vb[VbVbalrMyApplication#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrMyApplication/VB/FakeMyEvents.vb#17)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Kontroluje możliwość dodawania obsługi zdarzeń dla tego zdarzenia. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" />
        <altmember cref="N:Microsoft.VisualBasic.ApplicationServices" />
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventHandler" />
        <altmember cref="T:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UseCompatibleTextRendering">
      <MemberSignature Language="C#" Value="protected static bool UseCompatibleTextRendering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseCompatibleTextRendering" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly Property UseCompatibleTextRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static property bool UseCompatibleTextRendering { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseCompatibleTextRendering : bool" Usage="Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ta właściwość umożliwia projektanta określić domyślny aparat renderowania tekstu dla formularzy aplikacji.</summary>
        <value>
          <see langword="Boolean" />. Wartość <see langword="False" /> wskazuje, że aplikacja powinna korzysta z aparatu renderowania tekst domyślny dla [! INCLUDE[vbprvblong](~/includes/vbprvblong-MD.MD)]. Wartość <see langword="True" /> wskazuje, że aplikacja powinna korzystać aparat renderowania tekstu dla języka Visual Basic .NET 2002 i Visual Basic .NET 2003.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta właściwość zwraca `False` z informacją, że tekst GDI aparatu do renderowania [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] służyć do formularzy aplikacji. Jednak można zastąpić tę właściwość, aby zwrócić `True` i określ, czy formularze aplikacji używa interfejsu GDI + mechanizm renderowania tekstu, który jest używany w języku Visual Basic .NET 2002 i Visual Basic .NET 2003.  
  
 Ta właściwość jest wywoływana przez <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase> konstruktora.  
  
 Kod, który zastępuje metody <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase> klasy powinny być wprowadzane w pliku ApplicationEvents.vb, który jest domyślnie ukryty.  
  
| |  
|-|  
|Aby uzyskać dostęp do okna edytora kodu dla zastępowanie elementów członkowskich|  
|1.  Z projektem wybranym **Eksploratora rozwiązań**, kliknij przycisk **właściwości** na **projektu** menu.<br />2.  Kliknij przycisk **aplikacji** kartę.<br />3.  Kliknij przycisk **Wyświetl zdarzenia aplikacji** przycisk, aby otworzyć edytora kodu.<br /><br />Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).|  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak ustawić aparat renderowania tekstu GDI + jako aplikacji domyślny aparat renderowania przez zastąpienie <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A> właściwości.  
  
```vb  
Protected Overloads Shared ReadOnly Property UseCompatibleTextRendering() As Boolean  
    Get  
        ' Use the GDI+ text rendering engine.  
        Return True  
    End Get  
End Property  
```  
  
 Należy wprowadzić ten kod w oknie edytora kodu dla zdarzeń aplikacji. Aby uzyskać więcej informacji, zobacz [strona aplikacji, Projektant projektu (Visual Basic)](https://docs.microsoft.com/visualstudio/ide/reference/application-page-project-designer-visual-basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
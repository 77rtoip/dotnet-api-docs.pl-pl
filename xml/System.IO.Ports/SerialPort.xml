<Type Name="SerialPort" FullName="System.IO.Ports.SerialPort">
  <Metadata><Meta Name="ms.openlocfilehash" Value="467e93275c0074a373286a44ae5305d7ec358304" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69243961" /></Metadata><TypeSignature Language="C#" Value="public class SerialPort : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SerialPort extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.IO.Ports.SerialPort" />
  <TypeSignature Language="VB.NET" Value="Public Class SerialPort&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class SerialPort : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type SerialPort = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.Ports</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("SerialPortDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje zasób portu szeregowego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa służy do sterowania zasobem pliku portu szeregowego. Ta klasa zapewnia synchroniczną i sterowaną zdarzeniami we/wy, dostęp do numerów PIN i stan przerwań oraz dostęp do właściwości sterownika szeregowego. Ponadto funkcje tej klasy mogą być opakowane w obiekt wewnętrzny <xref:System.IO.Stream> , dostępne <xref:System.IO.Ports.SerialPort.BaseStream%2A> za pomocą właściwości i przekazywać do klas, które zawijają lub używają strumieni.  
  
 <xref:System.Text.ASCIIEncoding> <xref:System.Text.UTF8Encoding> <xref:System.Text.UnicodeEncoding>Klasa obsługuje następujące kodowania:, ,<xref:System.Text.UTF32Encoding>, i wszelkie kodowanie zdefiniowane w bibliotece Mscorlib. dll, gdzie strona kodowa jest mniejsza niż 50000 lub strona kodowa to 54936. <xref:System.IO.Ports.SerialPort>  Można użyć alternatywnych kodowań, ale należy użyć <xref:System.IO.Ports.SerialPort.ReadByte%2A> metody lub <xref:System.IO.Ports.SerialPort.Write%2A> i samodzielnie wykonać kodowanie.  
  
 <xref:System.IO.Ports.SerialPort.GetPortNames%2A> Używasz metody do pobierania prawidłowych portów dla bieżącego komputera.  
  
 <xref:System.IO.Ports.SerialPort> Jeśli obiekt zostanie zablokowany podczas operacji odczytu, nie przerywaj wątku. Zamiast tego należy zamknąć podstawowy strumień lub usunąć <xref:System.IO.Ports.SerialPort> obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Oba komputery muszą wykonywać program, aby osiągnąć pełną funkcjonalność tego przykładu.  
  
 [!code-cpp[System.IO.Ports.SerialPort#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#10)]
 [!code-csharp[System.IO.Ports.SerialPort#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#10)]
 [!code-vb[System.IO.Ports.SerialPort#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Ports.SerialPort" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Ports.SerialPort" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor używa domyślnych wartości właściwości, jeśli nie określono żadnych. Na przykład <xref:System.IO.Ports.SerialPort.DataBits%2A> Właściwość domyślnie przyjmuje wartość 8 <xref:System.IO.Ports.SerialPort.Parity%2A> , `None` Domyślnie właściwość jest równa wartości wyliczenia, <xref:System.IO.Ports.SerialPort.StopBits%2A> Domyślnie właściwość jest równa 1 i domyślna nazwa portu COM1.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : System.ComponentModel.IContainer -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Interfejs do kontenera.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Ports.SerialPort" /> klasy przy użyciu określonego <see cref="T:System.ComponentModel.IContainer" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor używa domyślnych wartości właściwości, jeśli nie określono żadnych. Na przykład <xref:System.IO.Ports.SerialPort.DataBits%2A> Właściwość domyślnie przyjmuje wartość 8 <xref:System.IO.Ports.SerialPort.Parity%2A> , `None` Domyślnie właściwość jest równa wartości wyliczenia, <xref:System.IO.Ports.SerialPort.StopBits%2A> Domyślnie właściwość jest równa 1 i domyślna nazwa portu COM1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można znaleźć lub otworzyć podanego portu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort portName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="portName">Port do wykorzystania (na przykład COM1).</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Ports.SerialPort" /> klasy przy użyciu określonej nazwy portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, aby utworzyć nowe wystąpienie <xref:System.IO.Ports.SerialPort> klasy, gdy chcesz określić nazwę portu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można znaleźć lub otworzyć podanego portu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Port do wykorzystania (na przykład COM1).</param>
        <param name="baudRate">Szybkość transmisji.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Ports.SerialPort" /> klasy przy użyciu określonej nazwy portu i szybkości transmisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, aby utworzyć nowe wystąpienie <xref:System.IO.Ports.SerialPort> klasy, gdy chcesz określić nazwę portu i szybkość transmisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można znaleźć lub otworzyć podanego portu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
      </Parameters>
      <Docs>
        <param name="portName">Port do wykorzystania (na przykład COM1).</param>
        <param name="baudRate">Szybkość transmisji.</param>
        <param name="parity">Jedna z <see cref="P:System.IO.Ports.SerialPort.Parity" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Ports.SerialPort" /> klasy przy użyciu określonej nazwy portu, szybkości transmisji i bitu parzystości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, aby utworzyć nowe wystąpienie <xref:System.IO.Ports.SerialPort> klasy, gdy chcesz określić nazwę portu, szybkość transmisji i bit parzystości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można znaleźć lub otworzyć podanego portu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Port do wykorzystania (na przykład COM1).</param>
        <param name="baudRate">Szybkość transmisji.</param>
        <param name="parity">Jedna z <see cref="P:System.IO.Ports.SerialPort.Parity" /> wartości.</param>
        <param name="dataBits">Wartość bitów danych.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Ports.SerialPort" /> klasy przy użyciu określonej nazwy portu, szybkości transmisji, bitu parzystości i bitów danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, aby utworzyć nowe wystąpienie <xref:System.IO.Ports.SerialPort> klasy, gdy chcesz określić nazwę portu, szybkość transmisji, bit parzystości i bity danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można znaleźć lub otworzyć podanego portu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits, valuetype System.IO.Ports.StopBits stopBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32,System.IO.Ports.StopBits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits, System::IO::Ports::StopBits stopBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int * System.IO.Ports.StopBits -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits, stopBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
        <Parameter Name="stopBits" Type="System.IO.Ports.StopBits" />
      </Parameters>
      <Docs>
        <param name="portName">Port do wykorzystania (na przykład COM1).</param>
        <param name="baudRate">Szybkość transmisji.</param>
        <param name="parity">Jedna z <see cref="P:System.IO.Ports.SerialPort.Parity" /> wartości.</param>
        <param name="dataBits">Wartość bitów danych.</param>
        <param name="stopBits">Jedna z <see cref="P:System.IO.Ports.SerialPort.StopBits" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Ports.SerialPort" /> klasy przy użyciu określonej nazwy portu, szybkości transmisji, bitu parzystości, bitów danych i bitu stopu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, aby utworzyć nowe wystąpienie <xref:System.IO.Ports.SerialPort> klasy, gdy chcesz określić nazwę portu, szybkość transmisji, bit parzystości, bity danych i bit zatrzymania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można znaleźć lub otworzyć podanego portu.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.Ports.SerialPort.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt źródłowy <see cref="T:System.IO.Stream" /> <see cref="T:System.IO.Ports.SerialPort" /> dla obiektu.</summary>
        <value>Element <see cref="T:System.IO.Stream" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej właściwości dla jawnych asynchronicznych operacji we/wy lub Przekaż <xref:System.IO.Ports.SerialPort> obiekt <xref:System.IO.Stream> do klasy otoki, takiej <xref:System.IO.StreamWriter>jak.  
  
 Wszystkie otwarte <xref:System.IO.Ports.SerialPort.BaseStream%2A> właściwości portu szeregowego zwracają obiekt, który pochodzi z klasy abstrakcyjnej <xref:System.IO.Stream> , i implementuje metody odczytu i zapisu przy użyciu <xref:System.IO.Stream> prototypów dziedziczonych z klasy: <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.BeginWrite%2A>, <xref:System.IO.Stream.Read%2A> , <xref:System.IO.Stream.ReadByte%2A>, <xref:System.IO.Stream.Write%2A>i .<xref:System.IO.Stream.WriteByte%2A> Metody te mogą być przydatne podczas przekazywania opakowanego zasobu szeregowego do <xref:System.IO.Stream> klasy otoki.  
  
 Ze względu na <xref:System.IO.Stream.Length%2A> niedostępność opakowanego pliku, właściwości i <xref:System.IO.Stream.Position%2A> <xref:System.IO.Stream.Seek%2A> nie są obsługiwane, a metody i <xref:System.IO.Stream.SetLength%2A> nie są obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strumień jest zamknięty. Może się tak zdarzyć, <see cref="M:System.IO.Ports.SerialPort.Open" /> ponieważ metoda nie została wywołana <see cref="M:System.IO.Ports.SerialPort.Close" /> lub metoda została wywołana.</exception>
        <exception cref="T:System.NotSupportedException">Strumień znajduje się w aplikacji .NET Compact Framework i została wywołana jedna z następujących metod: 
 <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" /><see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />  
  
.NET Compact Framework nie obsługuje modelu asynchronicznego ze strumieniami podstawowymi.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaudRate">
      <MemberSignature Language="C#" Value="public int BaudRate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BaudRate" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaudRate" />
      <MemberSignature Language="VB.NET" Value="Public Property BaudRate As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BaudRate { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BaudRate : int with get, set" Usage="System.IO.Ports.SerialPort.BaudRate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(9600)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("BaudRate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szybkość transmisji szeregowej.</summary>
        <value>Szybkość transmisji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szybkość transmisji musi być obsługiwana przez sterownik szeregowy użytkownika. Wartość domyślna to 9600 bitów na sekundę (b/s).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.IO.Ports.SerialPort.BaudRate%2A> jak ustawić właściwość na. `9600`  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 Poniższy przykład ilustruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom rozmowę z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określona szybkość transmisji jest mniejsza lub równa zero lub większa niż maksymalna dozwolona szybkość transmisji dla urządzenia.</exception>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="BreakState">
      <MemberSignature Language="C#" Value="public bool BreakState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakState" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BreakState" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BreakState : bool with get, set" Usage="System.IO.Ports.SerialPort.BreakState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia stan sygnału przerwania.</summary>
        <value><see langword="true" />Jeśli port jest w stanie przerwania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan sygnału przerwania występuje, gdy transmisja jest zawieszona, a linia jest umieszczana w stanie przerwania (wszystkie niskie, bez bitu zatrzymania) do momentu zwolnienia. Aby wprowadzić stan przerwania, należy ustawić tę właściwość `true`na. Jeśli port jest już w stanie przerwania, ustawienie tej właściwości na `true` nie spowoduje wyjątku. Nie można pisać do obiektu, <xref:System.IO.Ports.SerialPort> chociaż <xref:System.IO.Ports.SerialPort.BreakState%2A> jest `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest zamknięty. Może się tak zdarzyć, <see cref="M:System.IO.Ports.SerialPort.Open" /> ponieważ metoda nie została wywołana <see cref="M:System.IO.Ports.SerialPort.Close" /> lub metoda została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToRead">
      <MemberSignature Language="C#" Value="public int BytesToRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToRead As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToRead { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToRead : int" Usage="System.IO.Ports.SerialPort.BytesToRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów danych w buforze odbierania.</summary>
        <value>Liczba bajtów danych w buforze odbierania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bufor odbioru obejmuje bufor odbioru sterownika szeregowego, a także buforowanie wewnętrzne w <xref:System.IO.Ports.SerialPort> samym obiekcie.  
  
 Ponieważ właściwość reprezentuje <xref:System.IO.Ports.SerialPort> zarówno bufor, jak i bufor utworzony przez system Windows, może zwrócić większą wartość niż <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> właściwość, która reprezentuje tylko bufor utworzony w systemie Windows. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Port nie jest otwarty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToWrite">
      <MemberSignature Language="C#" Value="public int BytesToWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToWrite As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToWrite { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToWrite : int" Usage="System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów danych w buforze wysyłania.</summary>
        <value>Liczba bajtów danych w buforze wysyłania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bufor wysyłania obejmuje bufor wysyłania sterownika szeregowego, a także buforowanie wewnętrzne w <xref:System.IO.Ports.SerialPort> samym obiekcie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest zamknięty. Może się tak zdarzyć, <see cref="M:System.IO.Ports.SerialPort.Open" /> ponieważ metoda nie została wywołana <see cref="M:System.IO.Ports.SerialPort.Close" /> lub metoda została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="CDHolding">
      <MemberSignature Language="C#" Value="public bool CDHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CDHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CDHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CDHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CDHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CDHolding : bool" Usage="System.IO.Ports.SerialPort.CDHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan linii wykrywania nośnej dla portu.</summary>
        <value><see langword="true" />w przypadku wykrycia operatora; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może służyć do monitorowania stanu linii wykrywania nośnej dla portu. Żaden z przewoźników nie wskazuje, że odbiornik zawiesił się, a operator został porzucony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest zamknięty. Może się tak zdarzyć, <see cref="M:System.IO.Ports.SerialPort.Open" /> ponieważ metoda nie została wywołana <see cref="M:System.IO.Ports.SerialPort.Close" /> lub metoda została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="serialPort.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka połączenie z portem, ustawia <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> właściwość na <see langword="false" />i usuwa obiekt wewnętrzny <see cref="T:System.IO.Stream" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody powoduje zamknięcie <xref:System.IO.Ports.SerialPort> obiektu i wyczyszczenie buforów odbierania i przesyłania. Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose?displayProperty=nameWithType> metodę, która wywołuje metodę chronioną <xref:System.IO.Ports.SerialPort.Dispose%28System.Boolean%29?displayProperty=nameWithType> z `disposing` parametrem ustawionym na `true`.  
  
 Najlepszym rozwiązaniem dla każdej aplikacji jest oczekiwanie przez pewien czas po wywołaniu <xref:System.IO.Ports.SerialPort.Close%2A> metody przed podjęciem próby <xref:System.IO.Ports.SerialPort.Open%2A> wywołania metody, ponieważ port może nie być natychmiast zamknięty.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="CtsHolding">
      <MemberSignature Language="C#" Value="public bool CtsHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CtsHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CtsHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CtsHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CtsHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CtsHolding : bool" Usage="System.IO.Ports.SerialPort.CtsHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan wiersza "Clear-to-Send".</summary>
        <value><see langword="true" />Jeśli zostanie wykryty wiersz "Wyczyść do wysłania"; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiersz Clear-to-Send (CTS) jest używany w żądaniu do wysyłania/czyszczenia do uzgadniania sprzętowego (RTS/CTS). Wiersz CTS jest wysyłany przez port przed wysłaniem danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest zamknięty. Może się tak zdarzyć, <see cref="M:System.IO.Ports.SerialPort.Open" /> ponieważ metoda nie została wywołana <see cref="M:System.IO.Ports.SerialPort.Close" /> lub metoda została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataBits">
      <MemberSignature Language="C#" Value="public int DataBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DataBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DataBits" />
      <MemberSignature Language="VB.NET" Value="Public Property DataBits As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DataBits { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DataBits : int with get, set" Usage="System.IO.Ports.SerialPort.DataBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DataBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia standardową długość bitów danych na bajt.</summary>
        <value>Długość bitów danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zakres wartości dla tej właściwości wynosi od 5 do 8. Wartość domyślna to 8.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość bitów danych jest mniejsza niż 5 lub większa niż 8.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialDataReceivedEventHandler DataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialDataReceivedEventHandler DataReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.DataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataReceived As SerialDataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialDataReceivedEventHandler ^ DataReceived;" />
      <MemberSignature Language="F#" Value="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " Usage="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialDataReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialDataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że dane zostały odebrane za pomocą portu reprezentowanego <see cref="T:System.IO.Ports.SerialPort" /> przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia danych mogą być spowodowane przez dowolne elementy w <xref:System.IO.Ports.SerialData> wyliczeniu. Ponieważ system operacyjny decyduje o tym, czy zgłosić to zdarzenie, czy nie wszystkie błędy parzystości mogą zostać zgłoszone.  
  
 Zdarzenie jest również zgłaszane w przypadku otrzymania znaku EOF, niezależnie od liczby bajtów w wewnętrznym buforze wejściowym i wartości <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> właściwości. <xref:System.IO.Ports.SerialPort.DataReceived>  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, i <xref:System.IO.Ports.SerialPort.ErrorReceived> zdarzenia mogą być wywoływane poza kolejnością i może istnieć niewielkie opóźnienie między raportem źródłowym a błędem i po wykonaniu programu obsługi zdarzeń. Tylko jeden program obsługi zdarzeń może być wykonywany jednocześnie.  
  
 <xref:System.IO.Ports.SerialPort.DataReceived> Zdarzenie nie jest gwarantowane dla każdego odebranego bajtu. Użyj właściwości <xref:System.IO.Ports.SerialPort.BytesToRead%2A> , aby określić, ile danych pozostało do odczytu w buforze.  
  
 Zdarzenie jest zgłaszane w wątku pomocniczym, gdy dane są odbierane <xref:System.IO.Ports.SerialPort> z obiektu. <xref:System.IO.Ports.SerialPort.DataReceived> Ponieważ to zdarzenie jest zgłaszane w wątku pomocniczym, a nie w wątku głównym, próba zmodyfikowania niektórych elementów w wątku głównym, takich jak elementy interfejsu użytkownika, może wywołać wyjątek wątku. Jeśli konieczne jest zmodyfikowanie elementów w głównym <xref:System.Windows.Forms.Form> lub <xref:System.Windows.Forms.Control>, Opublikuj żądania zmiany ponownie przy użyciu <xref:System.Windows.Forms.Control.Invoke%2A>, co spowoduje wykonanie pracy we właściwym wątku.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Ten przykład dodaje <xref:System.IO.Ports.SerialDataReceivedEventHandler> do <xref:System.IO.Ports.SerialPort.DataReceived> , aby odczytać wszystkie dostępne dane odebrane na porcie COM1. Należy pamiętać, że w celu przetestowania tego kodu należy dysponować sprzętem podłączonym do portu COM1, który wyśle dane.  
  
 [!code-cpp[System.IO.Ports.SerialPort#06](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#06)]
 [!code-csharp[System.IO.Ports.SerialPort#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#06)]
 [!code-vb[System.IO.Ports.SerialPort#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#06)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardInBuffer">
      <MemberSignature Language="C#" Value="public void DiscardInBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardInBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardInBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardInBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardInBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardInBuffer : unit -&gt; unit" Usage="serialPort.DiscardInBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odrzuca dane z buforu odbioru sterownika szeregowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważna następującym Visual Basic kodzie: `MSComm1.InBufferCount = 0`. Czyści bufor odbierania, ale nie wpływa na bufor transmisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest zamknięty. Może się tak zdarzyć, <see cref="M:System.IO.Ports.SerialPort.Open" /> ponieważ metoda nie została wywołana <see cref="M:System.IO.Ports.SerialPort.Close" /> lub metoda została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardNull">
      <MemberSignature Language="C#" Value="public bool DiscardNull { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DiscardNull" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DiscardNull" />
      <MemberSignature Language="VB.NET" Value="Public Property DiscardNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DiscardNull { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DiscardNull : bool with get, set" Usage="System.IO.Ports.SerialPort.DiscardNull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DiscardNull")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy bajty zerowe są ignorowane podczas przekazywania między portem a buforem odbioru.</summary>
        <value><see langword="true" />Jeśli bajty null są ignorowane; w <see langword="false" />przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość powinna być zwykle ustawiona na `false`, szczególnie w przypadku przekazów binarnych.  Ustawienie tej właściwości w `true` taki sposób, aby powodowało nieoczekiwane wyniki dla bajtów zakodowanych w UTF32 i UTF16.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest zamknięty. Może się tak zdarzyć, <see cref="M:System.IO.Ports.SerialPort.Open" /> ponieważ metoda nie została wywołana <see cref="M:System.IO.Ports.SerialPort.Close" /> lub metoda została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardOutBuffer">
      <MemberSignature Language="C#" Value="public void DiscardOutBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardOutBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardOutBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardOutBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardOutBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardOutBuffer : unit -&gt; unit" Usage="serialPort.DiscardOutBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odrzuca dane z bufora przesyłania sterownika szeregowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważna następującym Visual Basic kodzie: `MSComm1.OutBufferCount = 0`. Czyści bufor przesyłania, ale nie wpływa na bufor odbierania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest zamknięty. Może się tak zdarzyć, <see cref="M:System.IO.Ports.SerialPort.Open" /> ponieważ metoda nie została wywołana <see cref="M:System.IO.Ports.SerialPort.Close" /> lub metoda została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serialPort.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.IO.Ports.SerialPort" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A> i metodę. <xref:System.ComponentModel.Component.Dispose%2A>wywołuje metodę chronioną <xref:System.IO.Ports.SerialPort.Dispose%2A> `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje <xref:System.IO.Ports.SerialPort.Dispose%2A> `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.IO.Ports.SerialPort> których odwołują się te odwołania. `disposing` Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose%2A> metodę każdego przywoływanego obiektu.  
  
 Ta metoda opróżnia i zamyka obiekt Stream we <xref:System.IO.Ports.SerialPort.BaseStream%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" />może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej usunięte <see cref="M:System.ComponentModel.Component.Dispose" />w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see cref="M:System.ComponentModel.Component.Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DsrHolding">
      <MemberSignature Language="C#" Value="public bool DsrHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DsrHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DsrHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DsrHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DsrHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DsrHolding : bool" Usage="System.IO.Ports.SerialPort.DsrHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan sygnału gotowości zestawu danych (DSR).</summary>
        <value><see langword="true" />Jeśli sygnał gotowości zestawu danych został wysłany do portu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana w przygotowanym zestawie danych/gotowości (DSR/DTR). Sygnał gotowości zestawu danych (DSR) jest zazwyczaj wysyłany przez modem do portu w celu wskazania, że jest on gotowy do transmisji danych lub odbierania danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest zamknięty. Może się tak zdarzyć, <see cref="M:System.IO.Ports.SerialPort.Open" /> ponieważ metoda nie została wywołana <see cref="M:System.IO.Ports.SerialPort.Close" /> lub metoda została wywołana.</exception>
      </Docs>
    </Member>
    <Member MemberName="DtrEnable">
      <MemberSignature Language="C#" Value="public bool DtrEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtrEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DtrEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property DtrEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtrEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtrEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.DtrEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DtrEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która włącza sygnał gotowości terminalu danych podczas komunikacji szeregowej.</summary>
        <value><see langword="true" />Aby włączyć gotowość terminalu danych (DTR); w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Data Terminal Ready (DTR) jest zazwyczaj włączana podczas uzgadniania oprogramowania XON/XOFF i żądania wysłania/wyczyszczenia w celu wysłania/niejasnego wysyłania sprzętu (RTS/CTS) i komunikacji z modemem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding with get, set" Usage="System.IO.Ports.SerialPort.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Encoding")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kodowanie bajtów dla konwersji typu Text przed i po transmisji.</summary>
        <value><see cref="T:System.Text.Encoding" /> Obiekt. Wartość domyślna to <see cref="T:System.Text.ASCIIEncoding" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Właściwość została ustawiona na <see langword="null" />wartość. <see cref="P:System.IO.Ports.SerialPort.Encoding" /></exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Text.UTF8Encoding" /> <see cref="T:System.Text.ASCIIEncoding" /> <see cref="T:System.Text.UnicodeEncoding" /> <see cref="T:System.Text.UTF32Encoding" />Właściwość została ustawiona na kodowanie, które nie jest,,,, jedno z kodowania jednobajtowego systemu Windows lub jedno z kodowania dwubajtowego systemu Windows. <see cref="P:System.IO.Ports.SerialPort.Encoding" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ErrorReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.ErrorReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorReceived As SerialErrorReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialErrorReceivedEventHandler ^ ErrorReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " Usage="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialErrorReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialErrorReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że wystąpił błąd przy użyciu portu reprezentowanego przez <see cref="T:System.IO.Ports.SerialPort" /> obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia błędów mogą być spowodowane przez którykolwiek z elementów w <xref:System.IO.Ports.SerialError> wyliczeniu. Ponieważ system operacyjny decyduje o tym, czy zgłosić to zdarzenie, czy nie wszystkie błędy parzystości mogą zostać zgłoszone.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, i <xref:System.IO.Ports.SerialPort.ErrorReceived> zdarzenia mogą być wywoływane poza kolejnością i może istnieć niewielkie opóźnienie między raportem źródłowym a błędem, a gdy kod może być wykonywany po wykonaniu procedury obsługi zdarzeń. Tylko jeden program obsługi zdarzeń może być wykonywany jednocześnie.  
  
 Jeśli na końcowym bajcie strumienia wystąpi błąd parzystości, dodatkowy bajt zostanie dodany do buforu wejściowego o wartości 126.  
  
 Zdarzenie jest zgłaszane w wątku pomocniczym po odebraniu błędu <xref:System.IO.Ports.SerialPort> z obiektu. <xref:System.IO.Ports.SerialPort.ErrorReceived> Ponieważ to zdarzenie jest zgłaszane w wątku pomocniczym, a nie w wątku głównym, próba zmodyfikowania niektórych elementów w wątku głównym, takich jak elementy interfejsu użytkownika, może wywołać wyjątek wątku. Jeśli konieczne jest zmodyfikowanie elementów w głównym <xref:System.Windows.Forms.Form> lub <xref:System.Windows.Forms.Control>, Opublikuj żądania zmiany ponownie przy użyciu <xref:System.Windows.Forms.Control.Invoke%2A>, co spowoduje wykonanie pracy we właściwym wątku.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPortNames">
      <MemberSignature Language="C#" Value="public static string[] GetPortNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetPortNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.GetPortNames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPortNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetPortNames();" />
      <MemberSignature Language="F#" Value="static member GetPortNames : unit -&gt; string[]" Usage="System.IO.Ports.SerialPort.GetPortNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tablicę nazw portów szeregowych dla bieżącego komputera.</summary>
        <returns>Tablica nazw portów szeregowych dla bieżącego komputera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie określono kolejności nazw portów zwróconych <xref:System.IO.Ports.SerialPort.GetPortNames%2A> z.  
  
 <xref:System.IO.Ports.SerialPort.GetPortNames%2A> Użyj metody, aby wysłać zapytanie do bieżącego komputera o listę prawidłowych nazw portów szeregowych. Na przykład można użyć tej metody, aby określić, czy COM1 i COM2 są prawidłowymi portami szeregowymi dla bieżącego komputera.  
  
 Nazwy portów są uzyskiwane z rejestru systemowego (na przykład HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM). Jeśli Rejestr zawiera nieodświeżone lub w inny sposób nieprawidłowe <xref:System.IO.Ports.SerialPort.GetPortNames%2A> dane, metoda zwróci nieprawidłowe dane.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metody do wyświetlania nazw portów szeregowych w konsoli programu.  
  
 [!code-cpp[IO.Ports.GetPortNames#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Ports.GetPortNames/cpp/example.cpp#1)]
 [!code-csharp[IO.Ports.GetPortNames#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Ports.GetPortNames/CS/example.cs#1)]
 [!code-vb[IO.Ports.GetPortNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Ports.GetPortNames/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można zbadać nazw portów szeregowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handshake">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Handshake Handshake { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Handshake Handshake" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Handshake" />
      <MemberSignature Language="VB.NET" Value="Public Property Handshake As Handshake" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Handshake Handshake { System::IO::Ports::Handshake get(); void set(System::IO::Ports::Handshake value); };" />
      <MemberSignature Language="F#" Value="member this.Handshake : System.IO.Ports.Handshake with get, set" Usage="System.IO.Ports.SerialPort.Handshake" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handshake")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Handshake</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia protokół uzgadniania transmisji danych portu szeregowego przy użyciu wartości z <see cref="T:System.IO.Ports.Handshake" />.</summary>
        <value>Jedna z <see cref="T:System.IO.Ports.Handshake" /> wartości. Wartość domyślna to <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy jest używane uzgadnianie, urządzenie połączone z <xref:System.IO.Ports.SerialPort> obiektem jest przyliczane do zatrzymania wysyłania danych, gdy w buforze występuje co najmniej (<xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-1024) bajtów. Na urządzeniu zostanie nadana ponowna próba ponownego wysłania danych, gdy w buforze występuje 1024 lub mniej bajtów. Jeśli urządzenie wysyła dane w blokach o rozmiarze większym niż 1024 bajtów, może to spowodować przepełnienie buforu.  
  
 Jeśli właściwość jest ustawiona na <xref:System.IO.Ports.Handshake.RequestToSendXOnXOff> i <xref:System.IO.Ports.SerialPort.CtsHolding%2A> jest ustawiona na `false`, znak XOFF nie zostanie wysłany. <xref:System.IO.Ports.SerialPort.Handshake%2A> Jeśli <xref:System.IO.Ports.SerialPort.CtsHolding%2A> wartość jest ustawiona na `true`, przed wysłaniem znaku XOFF należy wysłać więcej danych.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Przeniesiona wartość nie jest prawidłową wartością w <see cref="T:System.IO.Ports.Handshake" /> wyliczeniu.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public const int InfiniteTimeout = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InfiniteTimeout = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const InfiniteTimeout As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int InfiniteTimeout = -1;" />
      <MemberSignature Language="F#" Value="val mutable InfiniteTimeout : int" Usage="System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Wskazuje, że limit czasu nie powinien występować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest używana z <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> właściwościami i. <xref:System.IO.Ports.SerialPort.WriteTimeout%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="public bool IsOpen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.IsOpen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOpen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOpen : bool" Usage="System.IO.Ports.SerialPort.IsOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą stan <see cref="T:System.IO.Ports.SerialPort" /> otwarty lub zamknięty obiektu.</summary>
        <value><see langword="true" />Jeśli port szeregowy jest otwarty; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Ports.SerialPort.IsOpen%2A> Właściwość śledzi, czy port jest otwarty do użytku przez obiekt wywołujący, a nie niezależnie od tego, czy port jest otwarty przez żadną aplikację na komputerze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see langword="null" />Przeniesiona <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> wartość to.</exception>
        <exception cref="T:System.ArgumentException">Przenoszona <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> wartość jest pustym ciągiem ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public string NewLine { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NewLine { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string with get, set" Usage="System.IO.Ports.SerialPort.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("\n")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("NewLine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość używaną do interpretowania końca wywołania <see cref="M:System.IO.Ports.SerialPort.ReadLine" /> metod i. <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" /></summary>
        <value>Wartość, która reprezentuje koniec wiersza. Wartość domyślna to znak wysuwu wiersza ("\n" w C# lub <see cref="F:Microsoft.VisualBasic.Constants.vbLf" /> w Visual Basic).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa, jaka wartość (Byte) definiuje koniec wiersza dla <xref:System.IO.Ports.SerialPort.ReadLine%2A> metod i. <xref:System.IO.Ports.SerialPort.WriteLine%2A> Domyślnie wartość końca wiersza jest znakiem wysuwu wiersza (`\n` w C#, <xref:Microsoft.VisualBasic.Constants.vbLf?displayProperty=nameWithType> w Visual Basic). Można zmienić tę wartość na inną, jeśli określone urządzenie szeregowe, z którym pracujesz, używa innej wartości w tym samym celu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość właściwości jest pusta.</exception>
        <exception cref="T:System.ArgumentNullException">Wartość właściwości to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Open();" />
      <MemberSignature Language="F#" Value="member this.Open : unit -&gt; unit" Usage="serialPort.Open " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Otwiera nowe połączenie portu szeregowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla każdego <xref:System.IO.Ports.SerialPort> obiektu może istnieć tylko jedno otwarte połączenie.  
  
 Najlepszym rozwiązaniem dla każdej aplikacji jest oczekiwanie przez pewien czas po wywołaniu <xref:System.IO.Ports.SerialPort.Close%2A> metody przed podjęciem próby <xref:System.IO.Ports.SerialPort.Open%2A> wywołania metody, ponieważ port może nie być natychmiast zamknięty.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu do portu.  
  
—lub— 
Bieżący proces lub inny proces w systemie ma już otwarty określony port com przez <see cref="T:System.IO.Ports.SerialPort" /> wystąpienie lub w kodzie niezarządzanym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jedna z właściwości tego wystąpienia jest nieprawidłowa. Na <see cref="P:System.IO.Ports.SerialPort.Parity" />przykład <see cref="P:System.IO.Ports.SerialPort.Handshake" /> <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> <see cref="P:System.IO.Ports.SerialPort.ReadTimeout" /> <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" /> <see cref="P:System.IO.Ports.SerialPort.BaudRate" /> ,, lub właściwości nie są prawidłowymi wartościami; wartość jest mniejsza niż lub równa zero, a właściwość or jest mniejsza od zera i nie jest. <see cref="P:System.IO.Ports.SerialPort.DataBits" /></exception>
        <exception cref="T:System.ArgumentException">Nazwa portu nie zaczyna się od "COM".  
  
—lub—
  
 Typ pliku portu nie jest obsługiwany.</exception>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.InvalidOperationException">Określony port w bieżącym wystąpieniu <see cref="T:System.IO.Ports.SerialPort" /> jest już otwarty.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Skojarzone Wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />Akcja zabezpieczeń:<see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Parity">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Parity Parity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Parity Parity" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Parity" />
      <MemberSignature Language="VB.NET" Value="Public Property Parity As Parity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Parity Parity { System::IO::Ports::Parity get(); void set(System::IO::Ports::Parity value); };" />
      <MemberSignature Language="F#" Value="member this.Parity : System.IO.Ports.Parity with get, set" Usage="System.IO.Ports.SerialPort.Parity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Parity")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Parity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia Protokół kontroli parzystości.</summary>
        <value>Jedna z wartości wyliczenia, która reprezentuje protokół sprawdzania parzystości. Wartość domyślna to <see cref="F:System.IO.Ports.Parity.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parzystość to procedura sprawdzania błędów, w której liczba wartości 1 musi być zawsze taka sama — nawet lub nieparzysta — dla każdej grupy bitów, która jest przesyłana bez błędu. W przypadku komunikacji między modemami, parzystość jest często jednym z parametrów, które muszą zostać uzgodnione przez wysyłanie stron i otrzymywanie stron przed przekazaniem.  
  
 Jeśli na końcowym bajcie strumienia wystąpi błąd parzystości, dodatkowy bajt zostanie dodany do buforu wejściowego o wartości 126.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="T:System.IO.Ports.Parity" /> Przeniesiona wartośćniejestprawidłowąwartościąw<see cref="P:System.IO.Ports.SerialPort.Parity" /> wyliczeniu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ParityReplace">
      <MemberSignature Language="C#" Value="public byte ParityReplace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8 ParityReplace" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ParityReplace" />
      <MemberSignature Language="VB.NET" Value="Public Property ParityReplace As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte ParityReplace { System::Byte get(); void set(System::Byte value); };" />
      <MemberSignature Language="F#" Value="member this.ParityReplace : byte with get, set" Usage="System.IO.Ports.SerialPort.ParityReplace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(63)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ParityReplace")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bajt, który zastępuje nieprawidłowe bajty w strumieniu danych w przypadku wystąpienia błędu parzystości.</summary>
        <value>Bajt, który zastępuje nieprawidłowe bajty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość jest ustawiona na znak null, zastąpienie parzystości jest wyłączone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="PinChanged">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialPinChangedEventHandler PinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialPinChangedEventHandler PinChanged" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.PinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PinChanged As SerialPinChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialPinChangedEventHandler ^ PinChanged;" />
      <MemberSignature Language="F#" Value="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " Usage="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialPinChanged")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialPinChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że na porcie reprezentowanego przez <see cref="T:System.IO.Ports.SerialPort" /> obiekt wystąpi zdarzenie niebędące sygnałem danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia zmiany numeru PIN serializacji mogą być spowodowane przez dowolne elementy w <xref:System.IO.Ports.SerialPinChange> wyliczeniu. Ponieważ system operacyjny decyduje o tym, czy zgłosić to zdarzenie, czy nie wszystkie błędy parzystości mogą zostać zgłoszone. W ramach zdarzenia jest ustawiana nowa wartość numeru PIN.  
  
 Zdarzenie jest zgłaszane, <xref:System.IO.Ports.SerialPort> gdy obiekt przejdzie do <xref:System.IO.Ports.SerialPort.BreakState%2A>, <xref:System.IO.Ports.SerialPort.BreakState%2A>ale nie gdy port opuszcza. <xref:System.IO.Ports.SerialPort.PinChanged> To zachowanie nie dotyczy innych wartości w <xref:System.IO.Ports.SerialPinChange> wyliczeniu.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, i <xref:System.IO.Ports.SerialPort.ErrorReceived> zdarzenia mogą być wywoływane poza kolejnością i może istnieć niewielkie opóźnienie między raportem źródłowym a błędem i po wykonaniu programu obsługi zdarzeń. Tylko jeden program obsługi zdarzeń może być wykonywany jednocześnie.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged> Zdarzenie jest zgłaszane w wątku pomocniczym. Ponieważ to zdarzenie jest zgłaszane w wątku pomocniczym, a nie w wątku głównym, próba zmodyfikowania niektórych elementów w wątku głównym, takich jak elementy interfejsu użytkownika, może wywołać wyjątek wątku. Jeśli konieczne jest zmodyfikowanie elementów w głównym <xref:System.Windows.Forms.Form> lub <xref:System.Windows.Forms.Control>, Opublikuj żądania zmiany ponownie przy użyciu <xref:System.Windows.Forms.Control.Invoke%2A>, co spowoduje wykonanie pracy we właściwym wątku.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortName">
      <MemberSignature Language="C#" Value="public string PortName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PortName" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.PortName" />
      <MemberSignature Language="VB.NET" Value="Public Property PortName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PortName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PortName : string with get, set" Usage="System.IO.Ports.SerialPort.PortName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("COM1")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PortName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia port do komunikacji, w tym między innymi dostępne porty COM.</summary>
        <value>Port komunikacyjny. Wartość domyślna to COM1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listę prawidłowych nazw portów można uzyskać za pomocą <xref:System.IO.Ports.SerialPort.GetPortNames%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.Ports.SerialPort.PortName" /> Właściwość została ustawiona na wartość o długości zero.  
  
—lub— 
Właściwość została ustawiona na wartość rozpoczynającą się od znaku "\\\\". <see cref="P:System.IO.Ports.SerialPort.PortName" />  
  
—lub— 
Nazwa portu jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentNullException">Właściwość została ustawiona na <see langword="null" />wartość. <see cref="P:System.IO.Ports.SerialPort.PortName" /></exception>
        <exception cref="T:System.InvalidOperationException">Określony port jest otwarty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje z <see cref="T:System.IO.Ports.SerialPort" /> buforu wejściowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : byte[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów, w której ma zostać zapisane dane wejściowe.</param>
        <param name="offset">Przesunięcie w <paramref name="buffer" /> miejscu, w którym mają zostać zapisane bajty.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania. Mniej bajtów jest odczytywane <paramref name="count" /> , jeśli jest większa niż liczba bajtów w buforze wejściowym.</param>
        <summary>Odczytuje liczbę bajtów z <see cref="T:System.IO.Ports.SerialPort" /> buforu wejściowego i zapisuje te bajty w tablicy bajtów w określonym przesunięciu.</summary>
        <returns>Liczba odczytanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zachodzi potrzeba przełączenia się między czytaniem tekstu i czytanie ze strumienia danych binarnych, należy wybrać protokół, który dokładnie definiuje granicę między tekstem i danymi binarnymi, taki jak ręczne odczytywanie bajtów i dekodowanie danych.  
  
 Ponieważ Klasa buforuje dane, a strumień zawarty <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości nie jest, dwie mogą powodować konflikty, ile bajtów jest dostępnych do odczytu. <xref:System.IO.Ports.SerialPort>  Właściwość może wskazywać, że istnieją bajty do odczytu, ale te bajty mogą nie być dostępne dla strumienia zawartego <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości, ponieważ zostały zbuforowane do <xref:System.IO.Ports.SerialPort> klasy. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 Metoda nie blokuje innych operacji, gdy liczba odczytanych bajtów jest równa `count` , ale wciąż nie można odczytywać bajtów na porcie szeregowym. <xref:System.IO.Ports.SerialPort.Read%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Przeszedł <see langword="null" />bufor.</exception>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametry <paramref name="offset" /> <paramref name="buffer" /> lub <paramref name="count" /> są poza prawidłowym regionem. <paramref name="offset" /> Albo<paramref name="count" /> jest mniejsze od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />znak <paramref name="count" /> Plus jest większy niż długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.TimeoutException">Brak dostępnych bajtów do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Char(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : char[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, do której mają zostać zapisane dane wejściowe.</param>
        <param name="offset">Przesunięcie w <paramref name="buffer" /> miejscu, w którym mają zostać zapisane znaki.</param>
        <param name="count">Maksymalna liczba znaków do odczytania. Nie można odczytać mniej znaków <paramref name="count" /> , jeśli jest większa niż liczba znaków w buforze wejściowym.</param>
        <summary>Odczytuje liczbę znaków z <see cref="T:System.IO.Ports.SerialPort" /> buforu wejściowego i zapisuje je w tablicy znaków w danym przesunięciu.</summary>
        <returns>Liczba znaków odczytanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody do odczytu znaków z portu szeregowego.  
  
 Jeśli zachodzi potrzeba przełączenia się między czytaniem tekstu i czytanie ze strumienia danych binarnych, należy wybrać protokół, który dokładnie definiuje granicę między tekstem i danymi binarnymi, taki jak ręczne odczytywanie bajtów i dekodowanie danych.  
  
 Ponieważ Klasa buforuje dane, a strumień zawarty <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości nie jest, dwie mogą powodować konflikty, ile znaków jest dostępnych do odczytu. <xref:System.IO.Ports.SerialPort>  Właściwość może wskazywać, że istnieją znaki do odczytania, ale te znaki mogą nie być dostępne dla strumienia zawartego <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości, ponieważ zostały zbuforowane do <xref:System.IO.Ports.SerialPort> klasy. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 Metoda nie blokuje innych operacji, gdy liczba odczytanych bajtów jest równa `count` , ale wciąż nie można odczytywać bajtów na porcie szeregowym. <xref:System.IO.Ports.SerialPort.Read%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />znak <paramref name="count" /> Plus jest większy niż długość buforu.  
  
—lub— 
 <paramref name="count" />ma wartość 1, a w buforze znajduje się znak zastępczy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Zakończony .<see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametry <paramref name="offset" /> <paramref name="buffer" /> lub <paramref name="count" /> są poza prawidłowym regionem. <paramref name="offset" /> Albo<paramref name="count" /> jest mniejsze od zera.</exception>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.TimeoutException">Brak dostępnych znaków do odczytania.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBufferSize">
      <MemberSignature Language="C#" Value="public int ReadBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(4096)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar <see cref="T:System.IO.Ports.SerialPort" /> buforu wejściowego.</summary>
        <value>Rozmiar buforu w bajtach. Wartość domyślna to 4096; wartość maksymalna to dodatnia liczba całkowita lub 2147483647.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> Właściwość ignoruje wszelkie wartości mniejsze niż 4096.  
  
 Ponieważ właściwość reprezentuje tylko bufor utworzony przez system Windows, może zwrócić mniejszą wartość <xref:System.IO.Ports.SerialPort.BytesToRead%2A> niż Właściwość <xref:System.IO.Ports.SerialPort> , która reprezentuje zarówno bufor, jak i bufor utworzony przez system Windows. <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Ustawiona <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> wartość jest mniejsza lub równa zero.</exception>
        <exception cref="T:System.InvalidOperationException">Właściwość <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> została ustawiona, gdy strumień był otwarty.</exception>
        <exception cref="T:System.IO.IOException"><see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> Właściwość została ustawiona na nieparzystą wartość całkowitą.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadByte();" />
      <MemberSignature Language="F#" Value="member this.ReadByte : unit -&gt; int" Usage="serialPort.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Synchronicznie odczytuje jeden bajt z <see cref="T:System.IO.Ports.SerialPort" /> buforu wejściowego.</summary>
        <returns>Bajt, Rzutowanie na <see cref="T:System.Int32" />lub-1, jeśli koniec strumienia został odczytany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje jeden bajt.  
  
 Należy zachować ostrożność <xref:System.IO.Ports.SerialPort.ReadByte%2A> podczas <xref:System.IO.Ports.SerialPort.ReadChar%2A> używania i razem. Przełączenie między odczytywaniem bajtów i odczytem znaków może spowodować, że dodatkowe dane mają być odczytywane i/lub inne niezamierzone zachowanie. Jeśli zachodzi potrzeba przełączenia się między czytaniem tekstu i czytanie ze strumienia danych binarnych, należy wybrać protokół, który dokładnie definiuje granicę między tekstem i danymi binarnymi, taki jak ręczne odczytywanie bajtów i dekodowanie danych.  
  
> [!NOTE]
>  Ponieważ Klasa buforuje dane, a strumień zawarty <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości nie jest, dwie mogą powodować konflikty, ile bajtów jest dostępnych do odczytu. <xref:System.IO.Ports.SerialPort>  Właściwość może wskazywać, że istnieją bajty do odczytu, ale te bajty mogą nie być dostępne dla strumienia zawartego <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości, ponieważ zostały zbuforowane do <xref:System.IO.Ports.SerialPort> klasy. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Operacja nie została ukończona przed upłynięciem limitu czasu.  
  
—lub—
  
 Nie odczytano żadnego bajtu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public int ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChar();" />
      <MemberSignature Language="F#" Value="member this.ReadChar : unit -&gt; int" Usage="serialPort.ReadChar " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Synchronicznie odczytuje jeden znak z <see cref="T:System.IO.Ports.SerialPort" /> buforu wejściowego.</summary>
        <returns>Odczytany znak.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje jeden kompletny znak oparty na kodowaniu.  
  
 Należy zachować ostrożność <xref:System.IO.Ports.SerialPort.ReadByte%2A> podczas <xref:System.IO.Ports.SerialPort.ReadChar%2A> używania i razem. Przełączenie między odczytywaniem bajtów i odczytem znaków może spowodować, że dodatkowe dane mają być odczytywane i/lub inne niezamierzone zachowanie. Jeśli zachodzi potrzeba przełączenia się między czytaniem tekstu i czytanie ze strumienia danych binarnych, należy wybrać protokół, który dokładnie definiuje granicę między tekstem i danymi binarnymi, taki jak ręczne odczytywanie bajtów i dekodowanie danych.  
  
> [!NOTE]
>  Ponieważ Klasa buforuje dane, a strumień zawarty <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości nie jest, dwie mogą powodować konflikty, ile bajtów jest dostępnych do odczytu. <xref:System.IO.Ports.SerialPort>  Właściwość może wskazywać, że istnieją bajty do odczytu, ale te bajty mogą nie być dostępne dla strumienia zawartego <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości, ponieważ zostały zbuforowane do <xref:System.IO.Ports.SerialPort> klasy. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Operacja nie została ukończona przed upłynięciem limitu czasu.  
  
—lub—
  
 Brak dostępnego znaku w wyznaczonym limicie czasu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadExisting">
      <MemberSignature Language="C#" Value="public string ReadExisting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadExisting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadExisting" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadExisting () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadExisting();" />
      <MemberSignature Language="F#" Value="member this.ReadExisting : unit -&gt; string" Usage="serialPort.ReadExisting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wszystkie natychmiast dostępne bajty na podstawie kodowania, w strumieniu i buforze <see cref="T:System.IO.Ports.SerialPort" /> wejściowym obiektu.</summary>
        <returns>Zawartość strumienia i bufor <see cref="T:System.IO.Ports.SerialPort" /> wejściowy obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca zawartość strumienia i wewnętrznego buforu <xref:System.IO.Ports.SerialPort> obiektu jako ciąg. Ta metoda nie używa limitu czasu. Należy zauważyć, że ta metoda może pozostawiać końcowy bajty liderów w buforze wewnętrznym <xref:System.IO.Ports.SerialPort.BytesToRead%2A> , co powoduje, że wartość jest większa od zera.  
  
 Jeśli zachodzi potrzeba przełączenia się między czytaniem tekstu i czytanie ze strumienia danych binarnych, należy wybrać protokół, który dokładnie definiuje granicę między tekstem i danymi binarnymi, taki jak ręczne odczytywanie bajtów i dekodowanie danych.  
  
> [!NOTE]
>  Klasa buforuje dane, ale obiekt Stream zawarty <xref:System.IO.Ports.SerialPort.BaseStream%2A?displayProperty=nameWithType> we właściwości nie jest. <xref:System.IO.Ports.SerialPort> W związku z <xref:System.IO.Ports.SerialPort> tym obiekt i obiekt Stream mogą się różnić od liczby bajtów, które są dostępne do odczytu. Gdy bajty są buforowane do <xref:System.IO.Ports.SerialPort> obiektu <xref:System.IO.Ports.SerialPort.BytesToRead%2A> , właściwość zawiera te bajty w wartości, jednak te bajty mogą być niedostępne dla strumienia zawartego we <xref:System.IO.Ports.SerialPort.BaseStream%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="serialPort.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje do <see cref="P:System.IO.Ports.SerialPort.NewLine" /> wartości w buforze wejściowym.</summary>
        <returns>Zawartość buforu wejściowego do pierwszego wystąpienia <see cref="P:System.IO.Ports.SerialPort.NewLine" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że podczas gdy ta metoda nie <xref:System.IO.Ports.SerialPort.NewLine%2A> zwraca wartości <xref:System.IO.Ports.SerialPort.NewLine%2A> , wartość jest usuwana z buforu wejściowego.  
  
 Domyślnie <xref:System.IO.Ports.SerialPort.ReadLine%2A> Metoda zostanie zablokowana do momentu odebrania wiersza. Jeśli to zachowanie jest niepożądane, ustaw <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> właściwość na dowolną wartość różną od zera, aby wymusić, <xref:System.IO.Ports.SerialPort.ReadLine%2A> że metoda <xref:System.TimeoutException> zgłaszania w przypadku, gdy linia nie jest dostępna na porcie.  
  
 Jeśli zachodzi potrzeba przełączenia się między czytaniem tekstu i czytanie ze strumienia danych binarnych, należy wybrać protokół, który dokładnie definiuje granicę między tekstem i danymi binarnymi, taki jak ręczne odczytywanie bajtów i dekodowanie danych.  
  
> [!NOTE]
>  Ponieważ Klasa buforuje dane, a strumień zawarty <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości nie jest, dwie mogą powodować konflikty, ile bajtów jest dostępnych do odczytu. <xref:System.IO.Ports.SerialPort>  Właściwość może wskazywać, że istnieją bajty do odczytu, ale te bajty mogą nie być dostępne dla strumienia zawartego <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości, ponieważ zostały zbuforowane do <xref:System.IO.Ports.SerialPort> klasy. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.TimeoutException">Operacja nie została ukończona przed upłynięciem limitu czasu.  
  
—lub—
  
 Nie odczytano bajtów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę milisekund przed upływem limitu czasu, gdy operacja odczytu nie zostanie zakończona.</summary>
        <value>Liczba milisekund przed limitem czasu występuje, gdy operacja odczytu nie zostanie zakończona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość limitu czasu odczytu została pierwotnie ustawiona o 500 milisekund w interfejsie API komunikacyjnym Win32. Ta właściwość umożliwia ustawienie tej wartości. Limit czasu można ustawić na dowolną wartość większą od zera lub ustawioną na <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, w takim przypadku nie ma limitu czasu. <xref:System.IO.Ports.SerialPort.InfiniteTimeout>jest wartością domyślną.  
  
> [!NOTE]
>  Użytkownicy struktury niezarządzanej `COMMTIMEOUTS` mogą oczekiwać ustawienia wartości limitu czasu na wartość zero, aby pominąć limity czasu. Jednak aby pominąć limity czasu przy użyciu <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> właściwości, należy określić. <xref:System.IO.Ports.SerialPort.InfiniteTimeout>  
  
 Ta właściwość nie ma wpływu <xref:System.IO.Stream.BeginRead%2A> na metodę strumienia zwracanego <xref:System.IO.Ports.SerialPort.BaseStream%2A> przez właściwość.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość limitu czasu odczytu jest mniejsza od zera i nie jest równa <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTo">
      <MemberSignature Language="C#" Value="public string ReadTo (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadTo(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadTo (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadTo(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.ReadTo : string -&gt; string" Usage="serialPort.ReadTo value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Wartość wskazująca, gdzie zatrzymana operacja odczytu.</param>
        <summary>Odczytuje ciąg do określonego <paramref name="value" /> w buforze wejściowym.</summary>
        <returns>Zawartość buforu wejściowego do określonego <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje ciąg do określonego `value`. Gdy zwrócony ciąg nie zawiera `value` `value` , zostaje usunięty z bufora wejściowego.  
  
 Jeśli zachodzi potrzeba przełączenia się między czytaniem tekstu i czytanie ze strumienia danych binarnych, należy wybrać protokół, który dokładnie definiuje granicę między tekstem i danymi binarnymi, taki jak ręczne odczytywanie bajtów i dekodowanie danych.  
  
> [!NOTE]
>  Ponieważ Klasa buforuje dane, a strumień zawarty <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości nie jest, dwie mogą powodować konflikty, ile bajtów jest dostępnych do odczytu. <xref:System.IO.Ports.SerialPort>  Właściwość może wskazywać, że istnieją bajty do odczytu, ale te bajty mogą nie być dostępne dla strumienia zawartego <xref:System.IO.Ports.SerialPort.BaseStream%2A> we właściwości, ponieważ zostały zbuforowane do <xref:System.IO.Ports.SerialPort> klasy. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="value" /> parametru wynosi 0.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="value" /></exception>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.TimeoutException">Operacja nie została ukończona przed upłynięciem limitu czasu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceivedBytesThreshold">
      <MemberSignature Language="C#" Value="public int ReceivedBytesThreshold { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceivedBytesThreshold" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceivedBytesThreshold As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceivedBytesThreshold { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceivedBytesThreshold : int with get, set" Usage="System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReceivedBytesThreshold")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę bajtów w wewnętrznym buforze wejściowym przed <see cref="E:System.IO.Ports.SerialPort.DataReceived" /> wystąpieniem zdarzenia.</summary>
        <value>Liczba bajtów w wewnętrznym buforze wejściowym przed <see cref="E:System.IO.Ports.SerialPort.DataReceived" /> wywołaniem zdarzenia. Domyślnym ustawieniem jest 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest również zgłaszane w <xref:System.IO.Ports.SerialData.Eof> przypadku odebrania znaku, niezależnie od liczby bajtów w wewnętrznym buforze wejściowym <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> i wartości właściwości. <xref:System.IO.Ports.SerialPort.DataReceived>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" /> Wartość jest mniejsza lub równa zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="RtsEnable">
      <MemberSignature Language="C#" Value="public bool RtsEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RtsEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.RtsEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property RtsEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RtsEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RtsEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.RtsEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("RtsEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy sygnał żądania wysłania (RTS) jest włączony podczas komunikacji szeregowej.</summary>
        <value><see langword="true" />Aby włączyć przesyłanie żądania (RTS); w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sygnał żądania wysłania (RTS) jest zazwyczaj używany w żądaniu wysyłania/czyszczenia do uzgadniania sprzętowego (RTS/CTS).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wartość <see cref="P:System.IO.Ports.SerialPort.RtsEnable" /> właściwości została ustawiona lub pobrana, <see cref="P:System.IO.Ports.SerialPort.Handshake" /> gdy <see cref="F:System.IO.Ports.Handshake.RequestToSend" /> właściwość jest ustawiona <see cref="F:System.IO.Ports.Handshake.RequestToSendXOnXOff" /> na wartość lub wartość.</exception>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="StopBits">
      <MemberSignature Language="C#" Value="public System.IO.Ports.StopBits StopBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.StopBits StopBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.StopBits" />
      <MemberSignature Language="VB.NET" Value="Public Property StopBits As StopBits" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::StopBits StopBits { System::IO::Ports::StopBits get(); void set(System::IO::Ports::StopBits value); };" />
      <MemberSignature Language="F#" Value="member this.StopBits : System.IO.Ports.StopBits with get, set" Usage="System.IO.Ports.SerialPort.StopBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("StopBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.StopBits</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia standardową liczbę StopBits na bajt.</summary>
        <value>Jedna z <see cref="T:System.IO.Ports.StopBits" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.IO.Ports.SerialPort.StopBits%2A> domyślna to <xref:System.IO.Ports.StopBits.One>.  
  
 <xref:System.IO.Ports.StopBits.None?displayProperty=nameWithType> Wartość nie jest obsługiwana.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.IO.Ports.SerialPort.StopBits%2A> jak ustawić właściwość na. `One`  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 Poniższy przykład ilustruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom rozmowę z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.Ports.SerialPort> klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.IO.Ports.SerialPort.StopBits" /> Wartość to<see cref="F:System.IO.Ports.StopBits.None" />.</exception>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dane w buforze wyjściowym portu szeregowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public void Write (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg dla danych wyjściowych.</param>
        <param name="str">To be added.</param>
        <summary>Zapisuje określony ciąg do portu szeregowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli chcesz napisać ciąg jako dane wyjściowe do portu szeregowego.  
  
 Jeśli w buforze wyjściowym jest zbyt wiele bajtów i <xref:System.IO.Ports.SerialPort.Handshake%2A> jest on ustawiony <xref:System.IO.Ports.Handshake.XOnXOff> na <xref:System.ServiceProcess.TimeoutException> , <xref:System.IO.Ports.SerialPort> obiekt może wystąpić podczas oczekiwania na gotowość urządzenia do zaakceptowania większej ilości danych.  
  
 Domyślnie program <xref:System.IO.Ports.SerialPort> używa <xref:System.Text.ASCIIEncoding> do kodowania znaków. <xref:System.Text.ASCIIEncoding>koduje wszystkie znaki większe niż 127 jako (Char) 63 lub "?". Aby zapewnić obsługę dodatkowych znaków w tym zakresie, <xref:System.IO.Ports.SerialPort.Encoding%2A> Ustaw <xref:System.Text.UTF8Encoding>wartość <xref:System.Text.UTF32Encoding>, lub <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="text" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Operacja nie została ukończona przed upłynięciem limitu czasu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów, która zawiera dane do zapisu w porcie.</param>
        <param name="offset">Przesunięcie bajtu (liczony od zera) <paramref name="buffer" /> w parametrze, od którego należy rozpocząć kopiowanie bajtów do portu.</param>
        <param name="count">Liczba bajtów do zapisania.</param>
        <summary>Zapisuje określoną liczbę bajtów do portu szeregowego przy użyciu danych z bufora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli chcesz pisać do buforu bajtów w celu utworzenia danych wyjściowych do portu szeregowego.  
  
 Jeśli w buforze wyjściowym jest zbyt wiele bajtów i <xref:System.IO.Ports.SerialPort.Handshake%2A> jest on ustawiony <xref:System.IO.Ports.Handshake.XOnXOff> na <xref:System.ServiceProcess.TimeoutException> , <xref:System.IO.Ports.SerialPort> obiekt może wystąpić podczas oczekiwania na gotowość urządzenia do zaakceptowania większej ilości danych.  
  
 Domyślnie program <xref:System.IO.Ports.SerialPort> używa <xref:System.Text.ASCIIEncoding> do kodowania znaków. <xref:System.Text.ASCIIEncoding>koduje wszystkie znaki większe niż 127 jako (Char) 63 lub "?". Aby zapewnić obsługę dodatkowych znaków w tym zakresie, <xref:System.IO.Ports.SerialPort.Encoding%2A> Ustaw <xref:System.Text.UTF8Encoding>wartość <xref:System.Text.UTF32Encoding>, lub <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Zakończony .<see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametry <paramref name="offset" /> <paramref name="buffer" /> lub <paramref name="count" /> są poza prawidłowym regionem. <paramref name="offset" /> Albo<paramref name="count" /> jest mniejsze od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />znak <paramref name="count" /> Plus jest większy niż długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Operacja nie została ukończona przed upłynięciem limitu czasu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, która zawiera dane do zapisu w porcie.</param>
        <param name="offset">Przesunięcie bajtu (liczony od zera) <paramref name="buffer" /> w parametrze, od którego należy rozpocząć kopiowanie bajtów do portu.</param>
        <param name="count">Liczba znaków, jaka ma zostać zapisana.</param>
        <summary>Zapisuje określoną liczbę znaków w porcie seryjnym przy użyciu danych z bufora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli chcesz zapisywać w buforze znaków, aby utworzyć dane wyjściowe do portu szeregowego.  
  
 Jeśli w buforze wyjściowym jest zbyt wiele bajtów i <xref:System.IO.Ports.SerialPort.Handshake%2A> jest on ustawiony <xref:System.IO.Ports.Handshake.XOnXOff> na <xref:System.ServiceProcess.TimeoutException> , <xref:System.IO.Ports.SerialPort> obiekt może wystąpić podczas oczekiwania na gotowość urządzenia do zaakceptowania większej ilości danych.  
  
 Domyślnie program <xref:System.IO.Ports.SerialPort> używa <xref:System.Text.ASCIIEncoding> do kodowania znaków. <xref:System.Text.ASCIIEncoding>koduje wszystkie znaki większe niż 127 jako (Char) 63 lub "?". Aby zapewnić obsługę dodatkowych znaków w tym zakresie, <xref:System.IO.Ports.SerialPort.Encoding%2A> Ustaw <xref:System.Text.UTF8Encoding>wartość <xref:System.Text.UTF32Encoding>, lub <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Zakończony .<see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametry <paramref name="offset" /> <paramref name="buffer" /> lub <paramref name="count" /> są poza prawidłowym regionem. <paramref name="offset" /> Albo<paramref name="count" /> jest mniejsze od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />znak <paramref name="count" /> Plus jest większy niż długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Operacja nie została ukończona przed upłynięciem limitu czasu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBufferSize">
      <MemberSignature Language="C#" Value="public int WriteBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2048)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar buforu wyjściowego portu szeregowego.</summary>
        <value>Rozmiar buforu wyjściowego. Wartość domyślna to 2048.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Ports.SerialPort.WriteBufferSize%2A> Właściwość ignoruje wszelkie wartości mniejsze niż 2048.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> Wartość jest mniejsza lub równa zero.</exception>
        <exception cref="T:System.InvalidOperationException">Właściwość <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> została ustawiona, gdy strumień był otwarty.</exception>
        <exception cref="T:System.IO.IOException"><see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> Właściwość została ustawiona na nieparzystą wartość całkowitą.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public void WriteLine (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public void WriteLine (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg do zapisu w buforze wyjściowym.</param>
        <param name="str">To be added.</param>
        <summary>Zapisuje określony ciąg i <see cref="P:System.IO.Ports.SerialPort.NewLine" /> wartość w buforze wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli w buforze wejściowym jest zbyt wiele bajtów i <xref:System.IO.Ports.SerialPort.Handshake%2A> jest on ustawiony <xref:System.IO.Ports.Handshake.XOnXOff> na <xref:System.ServiceProcess.TimeoutException> , <xref:System.IO.Ports.SerialPort> obiekt może wystąpić podczas oczekiwania na gotowość urządzenia do zaakceptowania większej ilości danych.  
  
 Zapisywane dane wyjściowe zawierają <xref:System.IO.Ports.SerialPort.NewLine%2A> ciąg.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="text" /></exception>
        <exception cref="T:System.InvalidOperationException">Podany port nie jest otwarty.</exception>
        <exception cref="T:System.TimeoutException"><see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" /> Metoda nie może wykonać zapisu w strumieniu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę milisekund przed upływem limitu czasu, gdy operacja zapisu nie zostanie zakończona.</summary>
        <value>Liczba milisekund przed upływem limitu czasu. Wartość domyślna to <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość limitu czasu zapisu została pierwotnie ustawiona na 500 milisekund w interfejsie API komunikacyjnym Win32. Ta właściwość umożliwia ustawienie tej wartości. Limit czasu można ustawić na dowolną wartość większą od zera lub ustawioną na <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, w takim przypadku nie ma limitu czasu. <xref:System.IO.Ports.SerialPort.InfiniteTimeout>jest wartością domyślną.  
  
> [!NOTE]
>  Użytkownicy struktury niezarządzanej `COMMTIMEOUTS` mogą oczekiwać ustawienia wartości limitu czasu na wartość zero, aby pominąć limity czasu. Jednak aby pominąć limity czasu przy użyciu <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> właściwości, należy określić. <xref:System.IO.Ports.SerialPort.InfiniteTimeout>  
  
 Ta właściwość nie ma wpływu <xref:System.IO.Stream.BeginWrite%2A> na metodę strumienia zwracanego <xref:System.IO.Ports.SerialPort.BaseStream%2A> przez właściwość.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.Ports.SerialPort> klasy, aby umożliwić dwóm użytkownikom Czat z dwóch oddzielnych komputerów podłączonych za pośrednictwem kabla modemu o wartości null. W tym przykładzie użytkownicy są monitowani, aby ustawić port i nazwę użytkownika przed rozpoczęciem rozmowy. Ten przykład kodu jest częścią większego przykładu kodu podanego <xref:System.IO.Ports.SerialPort> dla klasy.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Port w nieprawidłowym stanie.  
  
—lub— 
Nie można ustawić stanu portu bazowego. Na przykład parametry przesłane z tego <see cref="T:System.IO.Ports.SerialPort" /> obiektu były nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza od zera i nie jest <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />równa. <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /></exception>
      </Docs>
    </Member>
  </Members>
</Type>

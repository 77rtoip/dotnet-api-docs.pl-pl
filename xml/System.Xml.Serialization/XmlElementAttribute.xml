<Type Name="XmlElementAttribute" FullName="System.Xml.Serialization.XmlElementAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4b1af331815abd50b9f81c7fd0cf59a395b32169" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36439626" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlElementAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlElementAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Serialization.XmlElementAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlElementAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlElementAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type XmlElementAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Field | System.AttributeTargets.Parameter | System.AttributeTargets.Property | System.AttributeTargets.ReturnValue, AllowMultiple=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wskazuje, że pola publicznego lub właściwości reprezentuje XML element podczas <see cref="T:System.Xml.Serialization.XmlSerializer" /> serializuje i deserializuje obiekt, który go zawiera.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlElementAttribute> Należy do rodziny atrybutów, która kontroluje sposób <xref:System.Xml.Serialization.XmlSerializer> serializuje i deserializuje obiekt. Pełną listę atrybutów podobne, zobacz [atrybuty że formant serializacji XML](~/docs/standard/serialization/attributes-that-control-xml-serialization.md).  
  
 Dokument XML zawiera zwykle elementów XML, z których każda obejmuje trzy części: otwierający tag o atrybuty tagu zamykającego i danych między tagami. Tagi XML można zagnieżdżać — czyli, dane między tagami mogą być również elementów XML. Tej pojemności jeden element, należy ująć innego umożliwia zawierać hierarchie danych. XML element mogą również obejmować atrybuty.  
  
 Zastosuj <xref:System.Xml.Serialization.XmlElementAttribute> do pola publicznego lub właściwości publicznej odczytu/zapisu, aby kontrolować właściwości elementów XML, takich jak nazwy elementu i przestrzeń nazw.  
  
 <xref:System.Xml.Serialization.XmlElementAttribute> Może odnosić się wielokrotnie do pola, które zwraca tablicę obiektów. Celem tego jest określenie (za pośrednictwem <xref:System.Xml.Serialization.XmlElementAttribute.Type%2A> właściwości) różnych typów, które można wstawiać do tablicy. Na przykład tablicy w poniższym kodzie C# akceptuje ciągi i liczb całkowitych.  
  
```  
public class Things{  
   [XmlElement(Type = typeof(string)),  
   XmlElement(Type = typeof(int))]  
   public object[] StringsAndInts;  
}  
```  
  
 Powoduje to XML, który może wyglądać w następujący sposób.  
  
```  
<Things>  
   <string>Hello</string>  
   <int>999</int>  
   <string>World</string>  
</Things>  
```  
  
 Należy pamiętać, że po zastosowaniu <xref:System.Xml.Serialization.XmlElementAttribute> wiele razy bez określania <xref:System.Xml.Serialization.XmlElementAttribute.ElementName%2A> wartość właściwości elementy są nazywane po typie dopuszczalne obiektów.  
  
 W przypadku zastosowania <xref:System.Xml.Serialization.XmlElementAttribute> pola lub właściwości, która zwraca tablicę elementów w tablicy są zakodowane jako sekwencję elementów XML.  
  
 Z kolei jeśli <xref:System.Xml.Serialization.XmlElementAttribute> nie ma zastosowania do takich pola lub właściwości, elementów w tablicy są zakodowane jako sekwencję elementów podrzędnych elementu o nazwie po pola lub właściwości. (Użyj <xref:System.Xml.Serialization.XmlArrayAttribute> i <xref:System.Xml.Serialization.XmlArrayItemAttribute> atrybutów, aby kontrolować sposób tablicy jest serializowany.)  
  
 Można ustawić <xref:System.Xml.Serialization.XmlElementAttribute.Type%2A> właściwości w celu określenia typu, który pochodzi z typu oryginalnego pola lub właściwości — to znaczy, pole lub właściwość do którego zastosowano <xref:System.Xml.Serialization.XmlElementAttribute>.  
  
 Jeśli to pole ani właściwość zwraca <xref:System.Collections.ArrayList>, można zastosować wiele wystąpień <xref:System.Xml.Serialization.XmlElementAttribute> do elementu członkowskiego. Dla każdego wystąpienia, należy ustawić <xref:System.Xml.Serialization.XmlElementAttribute.Type%2A> dla właściwości typu obiektu, który można wstawiać do tablicy.  
  
 Aby uzyskać więcej informacji o korzystaniu z atrybutów, zobacz [atrybutów](~/docs/standard/attributes/index.md).  
  
> [!NOTE]
>  Można użyć słowa `XmlElement` w kodzie zamiast dłuższy <xref:System.Xml.Serialization.XmlElementAttribute>.  
  
   
  
## Examples  
 Poniższy przykład serializuje klasę o nazwie `Group` i stosuje <xref:System.Xml.Serialization.XmlElementAttribute> niektóre z jego elementów członkowskich. Pole o nazwie `Employees` zwraca tablicę `Employee` obiektów. W takim przypadku <xref:System.Xml.Serialization.XmlElementAttribute> Określa, że wynikowy kod XML będzie nie można zagnieździć (która jest zachowaniem domyślnym elementów w tablicy).  
  
 [!code-cpp[Classic XmlElementAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.Serialization.XmlArrayAttribute" />
    <altmember cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
    <altmember cref="T:System.Xml.Serialization.XmlElementAttributes" />
    <altmember cref="P:System.Xml.Serialization.XmlAttributes.XmlElements" />
    <altmember cref="T:System.Xml.Serialization.XmlRootAttribute" />
    <altmember cref="T:System.Xml.Serialization.XmlSerializer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.Serialization.XmlElementAttribute" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlElementAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlElementAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlElementAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.Serialization.XmlElementAttribute" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Następujący przykład dotyczy <xref:System.Xml.Serialization.XmlElementAttribute> do klasy.  
  
 [!code-cpp[Classic XmlElementAttribute.XmlElementAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute.XmlElementAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute.XmlElementAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlElementAttribute (string elementName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string elementName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlElementAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (elementName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlElementAttribute(System::String ^ elementName);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlElementAttribute : string -&gt; System.Xml.Serialization.XmlElementAttribute" Usage="new System.Xml.Serialization.XmlElementAttribute elementName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="elementName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementName">Nazwa elementu XML Członek serializowany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.Serialization.XmlElementAttribute" /> , określa nazwę elementu XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.Serialization.XmlSerializer> używa nazwy elementu członkowskiego jako nazwa elementu XML podczas serializacji wystąpienia klasy. Na przykład pole o nazwie `Vehicle` generuje element XML o nazwie `Vehicle`. Jednak jeśli potrzebujesz różnych elementów, takich jak `Cars`, przekaż go w `elementName` parametru.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono prostą klasę, która zawiera jedno pole o nazwie `Vehicles`. Przykład dotyczy <xref:System.Xml.Serialization.XmlElementAttribute> do pola i zawiera `elementName` parametr, a tym samym poinstruowanie <xref:System.Xml.Serialization.XmlSerializer> do generowania elementów XML o nazwie "Samochodów" zamiast "Pojazdów".  
  
 [!code-cpp[Classic XmlElementAttribute.XmlElementAttribute1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute.XmlElementAttribute1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute1 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute.XmlElementAttribute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlElementAttribute (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlElementAttribute.#ctor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlElementAttribute(Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlElementAttribute : Type -&gt; System.Xml.Serialization.XmlElementAttribute" Usage="new System.Xml.Serialization.XmlElementAttribute type" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Obiektu pochodzącego od typu elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.Serialization.XmlElementAttribute" /> klasy i określa typ elementu członkowskiego, do którego <see cref="T:System.Xml.Serialization.XmlElementAttribute" /> została zastosowana. Ten typ jest używany przez <see cref="T:System.Xml.Serialization.XmlSerializer" /> podczas serializacji lub deserializacji obiektu, który go zawiera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `type` parametr, aby określić typ, który pochodzi od klasy podstawowej. Na przykład, załóżmy, że właściwość o nazwie `MyAnimal` zwraca `Animal` obiektu. Aby zwiększyć obiekt, aby utworzyć nową klasę o nazwie `Mammal` dziedziczący po `Animal` klasy. Nakazać programowi <xref:System.Xml.Serialization.XmlSerializer> do akceptowania `Mammal` klasy po jego serializuje `MyAnimal` właściwości, przebieg <xref:System.Type> z `Mammal` klasy do konstruktora.  
  
   
  
## Examples  
 Poniższy przykład serializuje klasę o nazwie `Orchestra` zawiera jedno pole o nazwie `Instruments`, która zwraca tablicę `Instrument` obiektów. Drugiej klasy o nazwie `Brass` dziedziczy `Instrument` klasy. Przykład dotyczy <xref:System.Xml.Serialization.XmlElementAttribute> do `Instruments` pól i określa `Brass` typ, dzięki czemu `Instruments` pole, aby zaakceptować `Brass` obiektów. Nazwa elementu XML jest również przykładzie przez ustawienie <xref:System.Xml.Serialization.XmlElementAttribute.ElementName%2A> właściwości.  
  
 [!code-cpp[Classic XmlElementAttribute.XmlElementAttribute2 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute.XmlElementAttribute2 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute2 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute.XmlElementAttribute2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlElementAttribute (string elementName, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string elementName, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlElementAttribute.#ctor(System.String,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlElementAttribute(System::String ^ elementName, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlElementAttribute : string * Type -&gt; System.Xml.Serialization.XmlElementAttribute" Usage="new System.Xml.Serialization.XmlElementAttribute (elementName, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="elementName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="elementName">Nazwa elementu XML Członek serializowany.</param>
        <param name="type">
          <see cref="T:System.Type" /> Obiektu pochodzącego od typu elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.Serialization.XmlElementAttribute" /> i określa nazwę elementu XML i typ pochodny dla elementu członkowskiego, do którego <see cref="T:System.Xml.Serialization.XmlElementAttribute" /> została zastosowana. Ten typ elementu członkowskiego jest używany podczas <see cref="T:System.Xml.Serialization.XmlSerializer" /> serializuje obiekt, który go zawiera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.Serialization.XmlSerializer> używa nazwy elementu członkowskiego jako nazwa elementu XML podczas serializacji wystąpienia klasy. Na przykład pole o nazwie `Vehicle` generuje element XML o nazwie `Vehicle`. Jednak jeśli potrzebujesz różnych elementów, takich jak `Cars`, przekaż go w `elementName` parametru.  
  
 Użyj `type` parametr, aby określić typ, który pochodzi od klasy podstawowej. Na przykład, załóżmy, że właściwość o nazwie `MyAnimal` zwraca `Animal` obiektu. Aby zwiększyć obiekt, aby utworzyć nową klasę o nazwie `Mammal` dziedziczący po `Animal` klasy. Nakazać programowi <xref:System.Xml.Serialization.XmlSerializer> do akceptowania `Mammal` klasy po jego serializuje `MyAnimal` właściwości, przebieg <xref:System.Type> z `Mammal` klasy do konstruktora.  
  
   
  
## Examples  
 Poniższy przykład serializuje klasę o nazwie `Orchestra` zawiera jedno pole o nazwie `Instruments`, która zwraca tablicę `Instrument` obiektów. Drugiej klasy o nazwie `Brass` dziedziczy `Instrument` klasy. Przykład dotyczy <xref:System.Xml.Serialization.XmlElementAttribute> do `Instruments` pól i określa `Brass` typ, dzięki czemu `Instruments` pole, aby zaakceptować `Brass` obiektów. Nazwa elementu XML jest również przykładzie przez ustawienie <xref:System.Xml.Serialization.XmlElementAttribute.ElementName%2A> właściwości.  
  
 [!code-cpp[Classic XmlElementAttribute.XmlElementAttribute2 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute.XmlElementAttribute2 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute2 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute.XmlElementAttribute2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute.XmlElementAttribute2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataType">
      <MemberSignature Language="C#" Value="public string DataType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Serialization.XmlElementAttribute.DataType" />
      <MemberSignature Language="VB.NET" Value="Public Property DataType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataType : string with get, set" Usage="System.Xml.Serialization.XmlElementAttribute.DataType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ danych (XSD) definicji schematu XML elementu XML wygenerowanych przez <see cref="T:System.Xml.Serialization.XmlSerializer" />.</summary>
        <value>Typ danych schematu XML, zgodnie z definicją w dokumencie konsorcjum World Wide Web (www.w3.org) o nazwie "XML schematu część 2: typy danych".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższa tabela zawiera typy proste danych schematu XML z their.NET odpowiedniki.  
  
 Schemat XML `base64Binary` i `hexBinary` typy danych, użyj tablicy <xref:System.Byte> struktury i zastosować <xref:System.Xml.Serialization.XmlElementAttribute> z <xref:System.Xml.Serialization.XmlElementAttribute.DataType%2A> ustawiony na "base64Binary" lub "hexBinary", zgodnie z potrzebami. Schemat XML `time` i `date` typy danych, użyj <xref:System.DateTime> wpisz i zastosować <xref:System.Xml.Serialization.XmlElementAttribute> z <xref:System.Xml.Serialization.XmlElementAttribute.DataType%2A> ustawiony na "date" lub "czas".  
  
 Dla każdego typu schematu XML, który jest zamapowany na ciąg, zastosuj <xref:System.Xml.Serialization.XmlElementAttribute> z jego <xref:System.Xml.Serialization.XmlElementAttribute.DataType%2A> właściwość Typ schematu XML. Istnieje możliwość, że to zmianę formatu serializacji, a nie tylko schematu dla elementu członkowskiego.  
  
> [!NOTE]
>  Właściwość uwzględnia wielkość liter, więc należy ją ustawić dokładnie do jednego z typów danych schematu XML.  
  
> [!NOTE]
>  Przekazywanie danych binarnych jako XML elementu jest skuteczniejsza niż przekazywanie go jako atrybut schematu XML.  
  
 Aby uzyskać więcej informacji na temat typów danych XML zobacz dokument konsorcjum World Wide Web (www.w3.org) o nazwie "XML schematu część 2: typy danych".  
  
|Typ danych XSD|Typ danych .NET|  
|-------------------|--------------------|  
|anyURI|<xref:System.String>|  
|base64Binary|Tablica <xref:System.Byte> obiektów|  
|wartość logiczna|<xref:System.Boolean>|  
|byte|<xref:System.SByte>|  
|Data|<xref:System.DateTime>|  
|Data i godzina|<xref:System.DateTime>|  
|decimal|<xref:System.Decimal>|  
|double|<xref:System.Double>|  
|JEDNOSTKI|<xref:System.String>|  
|JEDNOSTKI|<xref:System.String>|  
|float|<xref:System.Single>|  
|gDay|<xref:System.String>|  
|gMonth|<xref:System.String>|  
|gMonthDay|<xref:System.String>|  
|gYear|<xref:System.String>|  
|gYearMonth|<xref:System.String>|  
|hexBinary|Tablica <xref:System.Byte> obiektów|  
|ID|<xref:System.String>|  
|IDREF|<xref:System.String>|  
|IDREFS|<xref:System.String>|  
|int|<xref:System.Int32>|  
|integer|<xref:System.String>|  
|język|<xref:System.String>|  
|long|<xref:System.Int64>|  
|Nazwa|<xref:System.String>|  
|NCName|<xref:System.String>|  
|negativeInteger|<xref:System.String>|  
|NMTOKEN|<xref:System.String>|  
|NMTOKENS|<xref:System.String>|  
|normalizedString|<xref:System.String>|  
|nonNegativeInteger|<xref:System.String>|  
|nonPositiveInteger|<xref:System.String>|  
|NOTACJA|<xref:System.String>|  
|positiveInteger|<xref:System.String>|  
|QName|<xref:System.Xml.XmlQualifiedName>|  
|czas trwania|<xref:System.String>|  
|string|<xref:System.String>|  
|short|<xref:System.Int16>|  
|czas|<xref:System.DateTime>|  
|Token|<xref:System.String>|  
|unsignedByte|<xref:System.Byte>|  
|unsignedInt|<xref:System.UInt32>|  
|unsignedLong|<xref:System.UInt64>|  
|unsignedShort|<xref:System.UInt16>|  
  
   
  
## Examples  
 Poniższy przykład serializuje klasę o nazwie `Group` zawiera pole o nazwie `ExtraInfo`, która zwraca wartość <xref:System.Collections.ArrayList>. Przykład dotyczy dwóch wystąpień <xref:System.Xml.Serialization.XmlElementAttribute> do pola i określa różne <xref:System.Xml.Serialization.XmlElementAttribute.DataType%2A> wartości dla każdego wystąpienia. Każde wystąpienie umożliwia <xref:System.Xml.Serialization.XmlSerializer> do serializacji określonych typów wstawiony do tablicy.  
  
 [!code-cpp[Classic XmlElementAttribute.DataType Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute.DataType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute.DataType Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute.DataType Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute.DataType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute.DataType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Typ danych schematu XML, które określono nie można zamapować na typ danych platformy.NET.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementName">
      <MemberSignature Language="C#" Value="public string ElementName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ElementName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Serialization.XmlElementAttribute.ElementName" />
      <MemberSignature Language="VB.NET" Value="Public Property ElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ElementName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ElementName : string with get, set" Usage="System.Xml.Serialization.XmlElementAttribute.ElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę wygenerowanego elementu XML.</summary>
        <value>Nazwa elementu XML wygenerowany. Wartość domyślna to identyfikator elementu członkowskiego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ <xref:System.Xml.Serialization.XmlArrayItemAttribute.ElementName%2A> Jeśli nazwa elementu XML wygenerowanych różnią się od identyfikatora elementu członkowskiego.  
  
 Możesz ustawić taki sam <xref:System.Xml.Serialization.XmlArrayAttribute.ElementName%2A> do więcej niż jeden element członkowski klasy wartości, jeśli wygenerowany dokument XML używa przestrzeni nazw XML do rozróżniania między elementy członkowskie o identycznej nazwie. Aby uzyskać więcej informacji na temat korzystania z prefiksem nazwy i przestrzenie nazw w dokumencie XML, zobacz <xref:System.Xml.Serialization.XmlSerializerNamespaces> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Xml.Serialization.XmlElementAttribute.ElementName%2A> właściwość <xref:System.Xml.Serialization.XmlElementAttribute> na nową wartość.  
  
 [!code-cpp[Classic XmlElementAttribute.ElementName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute.ElementName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute.ElementName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute.ElementName Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute.ElementName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute.ElementName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Serialization.XmlAttributeAttribute.AttributeName" />
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaForm Form { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.Schema.XmlSchemaForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Serialization.XmlElementAttribute.Form" />
      <MemberSignature Language="VB.NET" Value="Public Property Form As XmlSchemaForm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaForm Form { System::Xml::Schema::XmlSchemaForm get(); void set(System::Xml::Schema::XmlSchemaForm value); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Xml.Schema.XmlSchemaForm with get, set" Usage="System.Xml.Serialization.XmlElementAttribute.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element jest kwalifikowana.</summary>
        <value>Jeden z <see cref="T:System.Xml.Schema.XmlSchemaForm" /> wartości. Wartość domyślna to <see cref="F:System.Xml.Schema.XmlSchemaForm.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlAttributeAttribute.Form%2A> Właściwość określa, czy XML element jest kwalifikowana lub niekwalifikowane. <xref:System.Xml.Serialization.XmlAttributeAttribute.Form%2A> Właściwość zgodny ze specyfikacją 1999 konsorcjum World Wide Web (www.w3.org), "Przestrzeni nazw w XML".  
  
 Jeśli <xref:System.Xml.Serialization.XmlAttributeAttribute.Namespace%2A> wartość właściwości jest równa wartości, ustawiania <xref:System.Xml.Serialization.XmlElementAttribute.Form%2A> właściwości `XmlSchemaForm.Unqualified` zgłasza wyjątek. Ustawieniem domyślnym `XmlSchemaForm.None`, powoduje, że <xref:System.Xml.Serialization.XmlSerializer> do sprawdzenia schematu dla dokumentu XML ustalić, czy jest kwalifikowana przestrzeni nazw. Jeśli schemat nie określono wartości dla pojedynczego elementu lub atrybutu, <xref:System.Xml.Serialization.XmlSerializer> używa `elementFormDefault` i `attributeFormDefault` wartości, aby ustalić, czy element lub atrybut jest kwalifikowana. Następujący kod XML zawiera schemat:  
  
```  
<schema elementFormDefault="qualified"   
attributeFormDefault="unqualified"... >  
 <element name="Name"/>  
 <attribute name="Number"/>  
</schema>  
```  
  
 Gdy <xref:System.Xml.Serialization.XmlSerializer> odczytuje schematu, <xref:System.Xml.Serialization.XmlAttributeAttribute.Form%2A> wartość dla obu `Name` i `Number` jest `XmlSchemaForm.None`, ale `Name` kwalifikuje się element, podczas `Number` element jest niekwalifikowane.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Xml.Serialization.XmlElementAttribute.Form%2A> właściwości `XmlSchemaForm.Unqualified`.  
  
 [!code-cpp[Classic XmlElementAttribute.Form Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute.Form Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute.Form Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute.Form Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Serialization.XmlElementAttribute.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool with get, set" Usage="System.Xml.Serialization.XmlElementAttribute.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Xml.Serialization.XmlSerializer" /> musi serializować elementu członkowskiego, który ma ustawioną wartość <see langword="null" /> jako pusty tagu z <see langword="xsi:nil" /> ustawić atrybutu <see langword="true" />.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xml.Serialization.XmlSerializer" /> generuje <see langword="xsi:nil" /> atrybutu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specyfikacja schematu XML dla struktury umożliwia dokument XML jawnie sygnalizuje, że brakuje elementu zawartości. Ten atrybut zawiera takiego elementu `xsi:nil` ustawioną `true`. Aby uzyskać więcej informacji zobacz specyfikację konsorcjum World Wide Web (www.w3.org), "XML schematu część 1: struktury".  
  
 Jeśli <xref:System.Xml.Serialization.XmlElementAttribute.IsNullable%2A> właściwość jest ustawiona na `true`, `xsi:nil` atrybutu jest generowane dla elementów członkowskich klasy, które zostały ustawione na `null`. Na przykład jeśli ustawisz pole o nazwie `MyStringArray` do `null`, <xref:System.Xml.Serialization.XmlSerializer> generuje następujący kod XML.  
  
```  
<MyStringArray xsi:nil = "true" />  
```  
  
 Jeśli <xref:System.Xml.Serialization.XmlElementAttribute.IsNullable%2A> właściwość jest `false`, Brak elementu XML jest generowane dla elementów członkowskich klasy, które zostały ustawione na `null`.  
  
> [!NOTE]
>  Nie można zastosować <xref:System.Xml.Serialization.XmlElementAttribute.IsNullable%2A> właściwości do elementu członkowskiego typu wartości, ponieważ typ wartości nie może zawierać `null`. Ponadto nie można ustawić tej właściwości `false` dla typów wartości null. Jeśli takie typy są `null`, będą wykonywane szeregowo przez ustawienie `xsi:nil` do `true`.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono pole o <xref:System.Xml.Serialization.XmlElementAttribute> zastosowano i <xref:System.Xml.Serialization.XmlElementAttribute.IsNullable%2A> ustawioną właściwość `false`.  
  
 [!code-cpp[Classic XmlElementAttribute.IsNullable Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute.IsNullable Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute.IsNullable Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute.IsNullable Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute.IsNullable Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute.IsNullable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Serialization.XmlElementAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Xml.Serialization.XmlElementAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw przypisane do elementu XML, który daje po klasie jest serializowany.</summary>
        <value>Przestrzeń nazw elementu XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlArrayItemAttribute.Namespace%2A> Właściwość zgodny ze specyfikacją konsorcjum World Wide Web (www.w3.org), "Przestrzeni nazw w XML".  
  
 Aby utworzyć przestrzeni nazw, które są skojarzone z prefiksem, należy utworzyć <xref:System.Xml.Serialization.XmlSerializerNamespaces> zawiera obszary nazw i prefiksy używane w dokumencie XML. Jak ustawić przestrzeni nazw dla każdego <xref:System.Xml.Serialization.XmlArrayAttribute>, musi on być zgodny jednej z przestrzeni nazw w <xref:System.Xml.Serialization.XmlSerializerNamespaces>. Podczas generowania pliku XML każdej macierzy jest poprawnie prefiksem prefiks skojarzone z określonego obszaru nazw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Order">
      <MemberSignature Language="C#" Value="public int Order { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Order" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Serialization.XmlElementAttribute.Order" />
      <MemberSignature Language="VB.NET" Value="Public Property Order As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Order { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Order : int with get, set" Usage="System.Xml.Serialization.XmlElementAttribute.Order" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolejność jawne, w którym elementy są serializowany lub deserializowany.</summary>
        <value>Kolejność generowania kodu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Xml.Serialization.CodeGenerationOptions.GenerateOrder> wyliczenie nakazać programowi <xref:System.Web.Services.Description.ServiceDescriptionImporter> do generowania kodu, który ustawia <xref:System.Xml.Serialization.XmlElementAttribute.Order%2A> właściwości.  
  
> [!IMPORTANT]
>  Raz <xref:System.Xml.Serialization.XmlElementAttribute.Order%2A> właściwość została już użyta w jednym publiczną właściwość lub pole w typie, należy zastosować do wszystkich właściwości publiczne i pola tego typu oraz wszystkich dziedziczonych typów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Type Type { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Serialization.XmlElementAttribute.Type" />
      <MemberSignature Language="VB.NET" Value="Public Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ Type { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type with get, set" Usage="System.Xml.Serialization.XmlElementAttribute.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ obiektu, używany do reprezentowania elementu XML.</summary>
        <value>
          <see cref="T:System.Type" /> Elementu członkowskiego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Xml.Serialization.XmlElementAttribute.Type%2A> właściwości w celu określenia typu pochodnego dla pola lub właściwości.  
  
 Jeśli to pole ani właściwość zwraca <xref:System.Collections.ArrayList>, można zastosować wiele wystąpień <xref:System.Xml.Serialization.XmlElementAttribute> do elementu członkowskiego. Dla każdego wystąpienia, należy ustawić <xref:System.Xml.Serialization.XmlElementAttribute.Type%2A> dla właściwości typu obiektu, który można wstawiać do tablicy.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.Serialization.XmlElementAttribute.Type%2A> właściwości w celu określenia obiekt pochodnych dla <xref:System.Xml.Serialization.XmlElementAttribute>. Przykład dotyczy również trzy wystąpienia <xref:System.Xml.Serialization.XmlElementAttribute> do pola, które zwraca <xref:System.Collections.ArrayList>. Każde wystąpienie określa typ dozwolone w tym polu.  
  
 [!code-cpp[Classic XmlElementAttribute.Type Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlElementAttribute.Type Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlElementAttribute.Type Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlElementAttribute.Type Example/CS/source.cs#1)]
 [!code-vb[Classic XmlElementAttribute.Type Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlElementAttribute.Type Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1a611d24c5fb21ef987889fe68369933899ab53b" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52733853" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje obiekt pamięci podręcznej i udostępnia właściwości i metod bazowych do uzyskiwania dostępu do pamięci podręcznej obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache> Typ jest typem podstawowym dla pamięci podręcznej obiektu w pamięci. Aby opracować implementacji niestandardowych pamięci podręcznej, możesz dziedziczyć <xref:System.Runtime.Caching.ObjectCache> klasy.  
  
> [!NOTE]
>  <xref:System.Runtime.Caching.ObjectCache> Klasa jest nowa w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Wbudowane <xref:System.Runtime.Caching.MemoryCache> klasa pochodzi od <xref:System.Runtime.Caching.ObjectCache> klasy. <xref:System.Runtime.Caching.MemoryCache> Klasa to implementacja pamięci podręcznej tylko konkretny obiekt w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] który pochodzi od klasy <xref:System.Runtime.Caching.ObjectCache> klasy.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides">
      <para>Ponieważ <see cref="T:System.Runtime.Caching.ObjectCache" /> typu reprezentuje tylko typowe funkcje pamięci podręcznej, nie jest wymagany na temat <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienia musi być uruchomiony i uzyskać. Ponadto nie jest wymagane, konkretne implementacje <see cref="T:System.Runtime.Caching.ObjectCache" /> klasa musi być pojedynczych wystąpień.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> nie jest klasą pojedynczą, ale należy utworzyć tylko jedną kilku lub potencjalnie tylko <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia i kod, który przechowuje elementy należy korzystać z tych wystąpień.  
  
</para></block>  
  
 Przy dziedziczeniu z <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy, konieczne jest przesłonięcie jej metody.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Wywoływana z konstruktorów w klasach pochodnych w celu zainicjowania <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpisu pamięci podręcznej w pamięci podręcznej, bez konieczności, której można zwrócić istniejący wpis pamięci podręcznej przy użyciu zgodnego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia metody spróbuj wstawić wpis pamięci podręcznej w pamięci podręcznej, bez zastępowania lub usuwania istniejącego wpisu pamięci podręcznej, który ma ten sam klucz. Wpis pamięci podręcznej może być wpisane <xref:System.Runtime.Caching.CacheItem> obiekt lub obiekt generyczny.  
  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Przeciążenia metody i <xref:System.Runtime.Caching.ObjectCache.Add%2A> przeciążenia metody ma jedną istotną różnicą. Tych metod wstawiania wpis pamięci podręcznej, jeśli pozycja znajduje się w pamięci podręcznej, <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążeń metody zwracają istniejący wpis pamięci podręcznej, ale <xref:System.Runtime.Caching.ObjectCache.Add%2A> przeciążenia metody nie obsługują. Posiadanie tych przeciążeń innej metody umożliwia obiekty wywołujące do optymalizacji ich kodu, opartego na czy potrzebują istniejący wpis pamięci podręcznej. W rozproszonej pamięci podręcznej, zwracając istniejącej wartości przy użyciu <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> metody mogą być droższe niż zwraca wartość logiczną przy użyciu <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, próbuje Wstaw wpis pamięci podręcznej w pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpieniu oraz dodaje szczegółowe informacje o jak wykluczyć wpis.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawiania zakończyło się pomyślnie, lub <see langword="false" /> Jeśli istnieje już wpis w pamięci podręcznej, która ma taki sam klucz jako <paramref name="item" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia metody są wirtualne (nie jako abstract) na <xref:System.Runtime.Caching.ObjectCache> klasy, ponieważ <xref:System.Runtime.Caching.ObjectCache.Add%2A> wewnętrznie wywołania metod <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Zmniejsza to liczbę przeciążenia metody, które musi dostarczyć implementujący pamięci podręcznej. Jeśli implementacja pamięci podręcznej nie wymaga specjalnego zachowania w przypadku <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody, można po prostu implementuje on <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="absoluteExpiration">Ustalona data i godzina wygaśnięcia wpisu pamięci podręcznej. Ten parametr jest wymagany, gdy <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" /> metoda jest wywoływana.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej, jeśli regiony są implementowane. Ponieważ regiony nie są implementowane w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wartość domyślna to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej bez zastępowania żadnych istniejący wpis pamięci podręcznej.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawiania zakończyło się pomyślnie, lub <see langword="false" /> Jeśli istnieje już wpis w pamięci podręcznej, która ma taki sam klucz jako <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia metody są wirtualne (nie jako abstract) na <xref:System.Runtime.Caching.ObjectCache> klasy, ponieważ <xref:System.Runtime.Caching.ObjectCache.Add%2A> wewnętrznie wywołania metod <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Zmniejsza to liczbę przeciążenia metody, które musi dostarczyć implementujący pamięci podręcznej. Jeśli implementacja pamięci podręcznej nie wymaga specjalnego zachowania w przypadku <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody, można po prostu implementuje on <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej, jeśli regiony są implementowane. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej, określania informacji na temat sposobu wpis zostanie wykluczona.</summary>
        <returns>
          <see langword="true" /> Jeśli spróbuj wstawiania zakończy się pomyślnie, lub <see langword="false" /> Jeśli istnieje już wpis w pamięci podręcznej przy użyciu tego samego klucza <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia metody są wirtualne (nie jako abstract) na <xref:System.Runtime.Caching.ObjectCache> klasy, ponieważ <xref:System.Runtime.Caching.ObjectCache.Add%2A> wewnętrznie wywołania metod <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Zmniejsza to liczbę przeciążenia metody, które musi dostarczyć implementujący pamięci podręcznej. Jeśli implementacja pamięci podręcznej nie wymaga specjalnego zachowania w przypadku <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody, można po prostu implementuje on <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, próbuje Wstaw wpis pamięci podręcznej w pamięci podręcznej i zwraca istniejący wpis pamięci podręcznej przy użyciu zgodnego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Przeciążenia metody Wstaw wpis w pamięci podręcznej. Jeśli wpis pamięci podręcznej za pomocą dopasowany klucz już istnieje, zwracają one istniejący wpis. Wpis pamięci podręcznej może być <xref:System.Runtime.Caching.CacheItem> obiekt lub obiekt generyczny.  
  
 Istnieje jeden różnica między <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia i <xref:System.Runtime.Caching.ObjectCache.Add%2A> przeciążenia. Gdy te przeciążone metody próba wstawienia wpisu pamięci podręcznej, jeśli istniejący wpis zostanie znaleziony, że klucz, który pasuje do istniejącego wstawił wpisu pamięci podręcznej <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia zwraca istniejący wpis pamięci podręcznej. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia nie obsługują.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia określony <see cref="T:System.Runtime.Caching.CacheItem" /> obiektu w pamięci podręcznej, określania informacji na temat sposobu wpis zostanie wykluczona.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, wpis pamięci podręcznej określoną; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="absoluteExpiration">Ustalona data i godzina wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej, jeśli regiony są implementowane. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej, za pomocą klucza, obiekt do wpisu pamięci podręcznej, wartość bezwzględna wygaśnięcia i opcjonalny region do dodania do pamięci podręcznej.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, wpis pamięci podręcznej określonej wartości. w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> przeciążenie metody zwraca wartość typu object, nie <xref:System.Runtime.Caching.CacheItem> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej, jeśli regiony są implementowane. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej, określając klucz i wartość dla wpisu pamięci podręcznej i dowiedzieć się, jak wpis zostanie wykluczona.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, wpis pamięci podręcznej określonej wartości. w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> Metoda zwraca wartość obiektu nie <xref:System.Runtime.Caching.CacheItem> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, w której pamięci podręcznej można znaleźć, jeśli są implementowane w regionach. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, sprawdza, czy istnieje już wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <returns>
          <see langword="true" /> Jeśli pamięć podręczna zawiera wpis pamięci podręcznej z taką samą wartość klucza jak <paramref name="key" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Unikatowe identyfikatory wpisów pamięci podręcznej do monitorowania.</param>
        <param name="regionName">Opcjonalna. O nazwie region, w którym kluczy pamięci podręcznej w pamięci podręcznej <paramref name="keys" /> parametru istnieje, jeśli są implementowane w regionach. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> obiekt, który może wyzwalać zdarzenia w odpowiedzi na zmiany, aby określić wpisy w pamięci podręcznej.</summary>
        <returns>Monitor zmian, który monitoruje wpisy w pamięci podręcznej w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy pochodnej <xref:System.Runtime.Caching.ObjectCache> klasa zastępuje base <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> metody wdrożenia pamięć podręczną należy utworzyć <xref:System.Runtime.Caching.CacheEntryChangeMonitor> obiektu. Ten monitor wyspecjalizowane zmiany powiadamia wywołań w przypadku zmiany wpisy w pamięci podręcznej, które są określone w `keys` parametru. Na przykład, jeśli monitorowania elementów w `keys` parametr zostanie zaktualizowany lub usunięty z pamięci podręcznej, monitor zmiany utworzone przez tę metodę wyzwala zdarzenie.  
  
 Jeśli implementacja pamięci podręcznej obsługuje regionów nazwaną pamięć podręczną, wartość ciągu można określić jako `regionName` parametru. W przeciwnym razie parametr `null`.  
  
> [!NOTE]
>  Nie wszystkie implementacjach pamięci podręcznej obsługuje monitorów Zmień wpis pamięci podręcznej. Aby sprawdzić, czy Twoja implementacja pamięci podręcznej obsługuje <xref:System.Runtime.Caching.CacheEntryChangeMonitor> obiektów, znajdują się w dokumentacji w celu wykonania określonych pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera opis funkcji, które zawiera implementację buforu.</summary>
        <value>Bitowa kombinacja flag, które wskazują możliwości Domyślna implementacja pamięci podręcznej.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej uzyskać.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego został dodany wpisu pamięci podręcznej, jeśli regiony są implementowane. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, pobiera wpis określony w pamięci podręcznej z pamięci podręcznej jako obiekt.</summary>
        <returns>Wpis pamięci podręcznej, która jest identyfikowana przez <paramref name="key" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej uzyskać.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego został dodany pamięci podręcznej, jeśli są implementowane w regionach. Ponieważ regiony nie są implementowane w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wartość domyślna to <see langword="null" />.</param>
        <summary>Po przesłonięciu w klasie pochodnej pobiera wpisu pamięci podręcznej określoną z pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia.</summary>
        <returns>Wpis pamięci podręcznej, która jest identyfikowana przez <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia metody istnieje, ponieważ niektóre implementacje pamięci podręcznej może wydłużyć <xref:System.Runtime.Caching.CacheItem> klasy. W takim przypadku <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> przeciążenie metody nie będzie zawsze zwracać wszystkie informacje dotyczące danych w pamięci podręcznej. Jednak <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> przeciążenia metody umożliwia niestandardowych pamięci podręczne, aby zwrócić więcej niż tylko wartości pamięci podręcznej.  
  
 <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Metoda przypomina <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> metody, chyba że <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> metoda zwraca wartość zwracaną wpisu pamięci podręcznej jako <xref:System.Runtime.Caching.CacheItem> wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, dla którego liczba wpisu pamięci podręcznej powinny być obliczane, jeśli regiony są implementowane. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera łączna liczba wpisów pamięci podręcznej, w pamięci podręcznej.</summary>
        <returns>Liczba wpisów pamięci podręcznej w pamięci podręcznej. Jeśli <paramref name="regionName" /> nie <see langword="null" />, licznik wskazuje liczbę wpisów, które znajdują się w pamięci podręcznej w określonym regionie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy moduł wyliczający, który może służyć do iterowania po kolekcji wpisy w pamięci podręcznej.</summary>
        <returns>Obiekt moduł wyliczający, który zapewnia dostęp do wpisy w pamięci podręcznej w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje pamięci podręcznej można zastąpić i rozszerzyć tę metodę, aby zapewniać środki niestandardowych iteracji w kolekcji wpisów pamięci podręcznej.  
  
> [!NOTE]
>  Zwraca moduł wyliczający jest zazwyczaj operacją bardziej kosztowne niż powrót wpis całą pamięć podręczną.  
  
 Ta metoda jest wywoływana przez jawne implementacje interfejsu, <xref:System.Runtime.Caching.ObjectCache> klasa ma dla <xref:System.Collections.IEnumerable.GetEnumerator%2A> i <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zestaw wpisów pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Kolekcja unikatowych identyfikatorów dla wpisów pamięci podręcznej, aby pobrać.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego wpisu pamięci podręcznej lub wpisy zostały dodane, jeśli są implementowane w regionach. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera zestaw wpisów pamięci podręcznej, które odpowiadają określonej kluczy.</summary>
        <returns>Słownik par klucz wartość, które reprezentują wpisy w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> Jest przeciążenie metody optymalizacji wydajności w przypadku rozproszonej pamięci podręcznych, które obsługują pobieranie wiele wpisów pamięci podręcznej z pamięci podręcznej podczas wywoływania jednej sieci.  
  
 Mimo, że obiekt wywołujący może przekazać co najmniej jeden klucz do metody, nie ma żadnej gwarancji, że wszystkie klucze przedstawiają wpisy w pamięci podręcznej. W związku z tym zwrócone słownika może zawierać mniej elementów niż liczba kluczy, które zostały przekazane do metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego wpisu pamięci podręcznej lub wpisy zostały dodane, jeśli są implementowane w regionach. Ponieważ regiony nie są implementowane w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wartość domyślna to <see langword="null" />.</param>
        <param name="keys">Kolekcja unikatowych identyfikatorów dla wpisów pamięci podręcznej, aby pobrać.</param>
        <summary>Pobiera zestaw wpisów pamięci podręcznej, które odpowiadają określonej kluczy.</summary>
        <returns>Słownik par klucz wartość, które reprezentują wpisy w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> Jest przeciążenie metody takie jak <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> przeciążenia metody, ale pozwala przekazać o nazwie regionu za pomocą składni opcjonalny parametr, który jest obsługiwany przez języków zarządzanych, takich jak C#.  
  
 Ta metoda jest metodą wirtualną, ponieważ <xref:System.Runtime.Caching.ObjectCache> klasa udostępnia domyślną implementację, która przekazuje `params` tablicy do <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustaw odwołanie do zarządzane środowisko hostingu, która jest dostępna dla <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji, które zapewniają usługi specyficzne dla hosta, aby <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji.</summary>
        <value>Odwołanie do pamięci podręcznej obsługujących zarządzane środowisko hostingu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Host%2A> Właściwość jest przeznaczona do użytku przez [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] środowisk, a przez implementacjach pamięci podręcznej, implementujące zachowanie, który jest zależny od programu .NET Framework środowisko.  
  
 W poniższej tabeli wymieniono zestawu usług środowisko hosta, które mogą być udostępniane przez zarządzane środowisko hostingu i które są dostępne dla <xref:System.Runtime.Caching.ObjectCache> implementacje za pośrednictwem <xref:System.Runtime.Caching.ObjectCache.Host%2A> właściwości:  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Umożliwia środowisk hostów, które zapewniają identyfikatorów domeny aplikacji, które mogą być wymagane przez implementację pamięci podręcznej dla funkcji, np. zidentyfikowanie liczników wydajności.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Umożliwia środowisk hostów to system powiadomień niestandardowego zmian plików, zamiast przy użyciu dostarczonego w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Umożliwia zmniejszenie zużycia pamięci pamięci podręcznej raportu implementacjach pamięci podręcznej dla środowiska hosta. Dzięki temu środowiska hosta, aby centralnie Zarządzaj zużycie pamięci w wielu implementacjach pamięci podręcznej.|  
  
> [!NOTE]
>  Obiekty wywołujące tę wartość właściwości wymagane uprawnienia zabezpieczeń dostępu kodu bez ograniczeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość jest przypisywane do właściwości jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić wartość właściwości więcej niż jeden raz.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla wszystkich metod dostępu do tej właściwości. Ta właściwość nie może służyć przez częściowo zaufany kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wpis pamięci podręcznej nie ma żadnych bezwzględnych wygaśnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wpis pamięci podręcznej, który jest wstawiany do pamięci podręcznej przy użyciu <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> pole ma wartość jako wartość dla wygaśnięcia nie powinien nigdy nie wygasa, oparte na bezwzględna punktu w czasie. Wpis pamięci podręcznej, to ustawienie może jednak wykluczony z pamięci podręcznej z innych przyczyn, które są określane przez implementację określonego pamięci podręcznej, takich jak eksmisji zdarzeń monitorowania zmian, spowodowane przez wykorzystanie pamięci.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej w pamięci podręcznej.</param>
        <summary>Pobiera lub ustawia domyślny indeksator <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy.</summary>
        <value>Klucz, który służy jako indeksator do wystąpienia pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie metody dostępu set tej właściwości jest jak <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> metody. Wewnętrznie, implementacja pamięci podręcznej można ustawić bezwzględnych wygaśnięcia podaną wartością w celu <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> metody. Jednak to zachowanie jest ostatecznie do implementacji pamięci podręcznej.  
  
 Zachowanie metody dostępu get przypomina wywoływanie <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> metody i przy użyciu `null` nazwy regionu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę określonego <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienia.</summary>
        <value>Nazwa wystąpienia określonych pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre implementacje pamięci podręcznej może obsługiwać wiele wystąpień w pamięci podręcznej, który jest uruchomiony w jednej aplikacji. Ta właściwość umożliwia implementacje pamięci podręcznej, które zwraca nazwę, która identyfikuje wystąpienie określonych pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że wpis pamięci podręcznej ma nie przewijania czas wygaśnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wygaśnięcie, oparty na czas trwania lub zdefiniowanych przedział czasu jest również określany jako przedłużanie ważności. Zwykle implementację buforu, który wyklucza mogą elementy, które są oparte na przedłużanie ważności spowoduje usunięcie elementu, który nie uzyska dostępu w określonym przedziale czasu.  
  
 Wpis pamięci podręcznej, który jest wstawiany do pamięci podręcznej przy użyciu <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> pola wartość, ponieważ wartość wygaśnięcia nigdy nie powinna zostać wykluczony ze względu na innych działań w przesuwającego się okna czasowego. Jednak element pamięci podręcznej może zostać wykluczony, jeśli ma on bezwzględnych wygaśnięcia lub występuje inne zdarzenie eksmisji, takie zmiany monitora lub pamięci ciśnienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego został dodany wpisu pamięci podręcznej, jeśli regiony są implementowane. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, usuwa wpis pamięci podręcznej z pamięci podręcznej.</summary>
        <returns>Obiekt, który reprezentuje wartość wpis usunięty pamięci podręcznej, który określono za pomocą klucza lub <see langword="null" /> Jeśli nie można odnaleźć określonego wpisu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli przesłonić tę metodę w implementacji niestandardowych pamięci podręcznej, jeśli istnieje wpis pamięci podręcznej w pamięci podręcznej, który odpowiada `key`, powinna zostać zwrócona wartość usuniętego elementu. Jeśli nic nie został usunięty z pamięci podręcznej, metoda powinna zwrócić `null`.  
  
> [!NOTE]
>  Niektóre implementacje rozproszonej pamięci podręcznej mogą nie obsługiwać możliwość zwracają wartość, która została usunięta z pamięci podręcznej. Może to być, ponieważ implementacja pamięci podręcznej nie obsługuje zwracania wartości elementów usuniętych pamięci podręcznej. Być może kierowanie obiektu, ponieważ wartość zwracana jest za drogi. W takich przypadkach implementacjach pamięci podręcznej może zwrócić `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowym zachowaniem <xref:System.Runtime.Caching.ObjectCache.Set%2A> przeciążenia metody jest operacja wstawiania lub aktualizacji. Wpis pamięci podręcznej jest albo wstawiony jako nowy wpis, jeśli określony wpis nie istnieje lub zaktualizować wpisu pamięci podręcznej z nową wartością, jeśli już istnieje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Element pamięci podręcznej do dodania.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpisu pamięci podręcznej w pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienie określający informacji na temat sposobu wpis zostanie wykluczona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz `item` nie istnieje, `item` zostanie wstawiona jako nowy wpis pamięci podręcznej. Jeśli element z kluczem, który odpowiada `item` istnieje wartość `item` służy do aktualizacji lub Zastąp wartość istniejącego wpisu pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="absoluteExpiration">Ustalona data i godzina wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej, jeśli regiony są implementowane. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej, określając szczegóły na podstawie czasu wygaśnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element, który odpowiada `key` nie istnieje w pamięci podręcznej, `value` i `key` są używane do wstawienia jako nowy wpis pamięci podręcznej. Jeśli element z kluczem, który odpowiada `item` istnieje, aktualizacji lub zastąpić, przy użyciu wpisu pamięci podręcznej `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej, jeśli regiony są implementowane. Wartość domyślna dla opcjonalnego parametru to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia metody umożliwia dostarczenia bardziej szczegółowych informacji eksmisji lub data jej wygaśnięcia niż te, które są dostępne w bezwzględnych wygaśnięcia.  
  
 Jeśli element, który odpowiada `key` nie istnieje w pamięci podręcznej, `value` i `key` są używane do wstawienia jako nowy wpis pamięci podręcznej. Jeśli element z kluczem, który odpowiada `item` istnieje, aktualizacji lub zastąpić, przy użyciu wpisu pamięci podręcznej `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obsługuje iteracji przez kolekcję ogólną.</summary>
        <returns>Obiekt moduł wyliczający, który zapewnia dostęp do elementów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można używać tylko wtedy, gdy jest to pochodnej <xref:System.Runtime.Caching.ObjectCache> wystąpienia jest rzutowany na <xref:System.Collections.IEnumerable> interfejsu.  
  
 Deweloperzy ta metoda służy do iteracji przez kolekcję ogólną wpisy w pamięci podręcznej.  
  
 Jest to opcja domyślna <xref:System.Collections.IEnumerable.GetEnumerator%2A> implementację, która wywołuje wewnętrznie <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5857681ac8d5732c6af8a6885bbec57f01693a37" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69066624" /></Metadata><TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje pamięć podręczną obiektów i udostępnia podstawowe metody i właściwości na potrzeby uzyskiwania dostępu do pamięci podręcznej obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache> Typ jest typem podstawowym dla pamięci podręcznej obiektów w pamięci. Aby opracować implementację niestandardowej pamięci podręcznej, pochodzi <xref:System.Runtime.Caching.ObjectCache> od klasy.  
  
> [!NOTE]
>  Klasa jest nowa [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]z. <xref:System.Runtime.Caching.ObjectCache>  
  
 Wbudowana <xref:System.Runtime.Caching.MemoryCache> Klasa pochodzi <xref:System.Runtime.Caching.ObjectCache> od klasy. Klasa jest jedyną implementacją [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] pamięci podręcznej obiektów, która pochodzi od <xref:System.Runtime.Caching.ObjectCache> klasy. <xref:System.Runtime.Caching.MemoryCache>  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides"><para>Ponieważ typ reprezentuje tylko typowe funkcje pamięci podręcznej, nie jest wymagane, aby <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienie było tworzone i pobierane. <see cref="T:System.Runtime.Caching.ObjectCache" /> Ponadto nie istnieje wymóg, że konkretne implementacje <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy muszą być singletonami.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" />nie jest klasą pojedynczą, ale należy utworzyć tylko jedno <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienie i kod, który przechowuje w pamięci podręcznej elementy powinny używać tych wystąpień.  
  
</para></block>  
  
 W przypadku dziedziczenia z <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy należy zastąpić jej metody.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Wywoływana z konstruktorów w klasach pochodnych w celu zainicjowania <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, wstawia do pamięci podręcznej wpis pamięci podręcznej, bez wymagania, aby można było zwrócić istniejący wpis pamięci podręcznej z pasującym kluczem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Runtime.Caching.ObjectCache.Add%2A> metod próbują wstawić do pamięci podręcznej wpis pamięci podręcznej bez zastępowania ani usuwania istniejącego wpisu pamięci podręcznej, który ma ten sam klucz. Wpis pamięci podręcznej może być <xref:System.Runtime.Caching.CacheItem> obiektem typu Type lub obiektem ogólnym.  
  
 Przeciążenia <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> metod <xref:System.Runtime.Caching.ObjectCache.Add%2A> i przeciążenia metod mają jedną znaczącą różnicę. Gdy te metody wstawą wpis pamięci podręcznej, jeśli w pamięci podręcznej zostanie znaleziony <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> pasujący wpis, przeciążenia metody zwracają istniejący wpis pamięci <xref:System.Runtime.Caching.ObjectCache.Add%2A> podręcznej, ale przeciążenia metody nie są. Różne przeciążenia metod umożliwiają wywoływanie kodu w zależności od tego, czy potrzebują istniejącego wpisu pamięci podręcznej. W rozproszonej pamięci podręcznej zwracanie istniejącej wartości przy użyciu <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> metody może być droższe niż zwracanie wartości logicznej przy użyciu <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program próbuje wstawić do pamięci podręcznej wpis <see cref="T:System.Runtime.Caching.CacheItem" /> pamięci podręcznej jako wystąpienie i dodaje szczegółowe informacje o sposobie wykluczenia wpisu.</summary>
        <returns><see langword="true" />Jeśli wstawianie zakończyło się <see langword="false" /> powodzeniem lub istnieje już wpis w pamięci podręcznej, który ma taki sam klucz <paramref name="item" />jak.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia metod są wirtualne (nieabstrakcyjne) <xref:System.Runtime.Caching.ObjectCache> w klasie, ponieważ <xref:System.Runtime.Caching.ObjectCache.Add%2A> metoda wewnętrznie wywołuje <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Zmniejsza to liczbę przeciążeń metody, które musi dostarczyć implementacja pamięci podręcznej. Jeśli implementacja pamięci podręcznej nie wymaga żadnych specjalnych zachowań dla <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody, można tylko <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> zaimplementować przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="absoluteExpiration">Stała Data i godzina wygaśnięcia wpisu pamięci podręcznej. Ten parametr jest wymagany, <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" /> gdy wywoływana jest metoda.</param>
        <param name="regionName">Opcjonalny. Nazwany region w pamięci podręcznej, do którego można dodać wpis pamięci podręcznej, jeśli regiony zostały zaimplementowane. Ponieważ regiony nie są zaimplementowane w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]programie, wartość domyślna to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, Wstawia wpis pamięci podręcznej bez zastępowania istniejącego wpisu pamięci podręcznej.</summary>
        <returns><see langword="true" />Jeśli wstawianie zakończyło się <see langword="false" /> powodzeniem lub istnieje już wpis w pamięci podręcznej, który ma taki sam klucz <paramref name="key" />jak.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia metod są wirtualne (nieabstrakcyjne) <xref:System.Runtime.Caching.ObjectCache> w klasie, ponieważ <xref:System.Runtime.Caching.ObjectCache.Add%2A> metoda wewnętrznie wywołuje <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Zmniejsza to liczbę przeciążeń metody, które musi dostarczyć implementacja pamięci podręcznej. Jeśli implementacja pamięci podręcznej nie wymaga żadnych specjalnych zachowań dla <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody, można tylko <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> zaimplementować przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <param name="regionName">Opcjonalny. Nazwany region w pamięci podręcznej, do którego można dodać wpis pamięci podręcznej, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wstawia do pamięci podręcznej wpis pamięci podręcznej, określając informacje o tym, w jaki sposób wpis zostanie wykluczony.</summary>
        <returns><see langword="true" />Jeśli wstawianie zakończyło się powodzeniem lub <see langword="false" /> istnieje już wpis w pamięci podręcznej z tym samym kluczem co. <paramref name="key" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia metod są wirtualne (nieabstrakcyjne) <xref:System.Runtime.Caching.ObjectCache> w klasie, ponieważ <xref:System.Runtime.Caching.ObjectCache.Add%2A> metoda wewnętrznie wywołuje <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Zmniejsza to liczbę przeciążeń metody, które musi dostarczyć implementacja pamięci podręcznej. Jeśli implementacja pamięci podręcznej nie wymaga żadnych specjalnych zachowań dla <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody, można tylko <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> zaimplementować przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, program próbuje wstawić do pamięci podręcznej wpis pamięci podręcznej i zwraca istniejący wpis pamięci podręcznej z pasującym kluczem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> metody wstawiają wpis do pamięci podręcznej. Jeśli wpis pamięci podręcznej z zgodnym kluczem już istnieje, zwracają istniejący wpis. Wpis pamięci podręcznej może <xref:System.Runtime.Caching.CacheItem> być obiektem lub obiektem ogólnym.  
  
 Istnieje jedna różnica między <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążeniami <xref:System.Runtime.Caching.ObjectCache.Add%2A> a przeciążeniami. Gdy te przeciążone metody próbują wstawić wpis pamięci podręcznej, jeśli zostanie znaleziony istniejący wpis, który ma klucz pasujący do istniejącego wstawionego wpisu <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> pamięci podręcznej, przeciążenia zwracają istniejący wpis pamięci podręcznej. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia nie są obsługiwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, Wstawia określony <see cref="T:System.Runtime.Caching.CacheItem" /> obiekt do pamięci podręcznej, określając informacje o tym, w jaki sposób wpis zostanie wykluczony.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, określony wpis pamięci podręcznej; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="absoluteExpiration">Stała Data i godzina wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalny. Nazwany region w pamięci podręcznej, do którego można dodać wpis pamięci podręcznej, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wstawia do pamięci podręcznej wpis pamięci podręcznej, przy użyciu klucza, obiektu dla wpisu pamięci podręcznej, bezwzględnej wartości wygaśnięcia i opcjonalnego regionu, do którego ma zostać dodana pamięć podręczna.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, wartość określonego wpisu pamięci podręcznej; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> Przeciążenie metody zwraca wartość obiektu, a <xref:System.Runtime.Caching.CacheItem> nie obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <param name="regionName">Opcjonalna. Nazwany region w pamięci podręcznej, do którego można dodać wpis pamięci podręcznej, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wstawia do pamięci podręcznej wpis pamięci podręcznej, określając klucz i wartość wpisu pamięci podręcznej oraz informacje o tym, jak wpis zostanie wykluczony.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, wartość określonego wpisu pamięci podręcznej; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca wartość obiektu, a <xref:System.Runtime.Caching.CacheItem> nie obiekt. <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalny. Nazwany region w pamięci podręcznej, w którym można znaleźć pamięć podręczną, jeśli są zaimplementowane regiony. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, sprawdza, czy wpis pamięci podręcznej już istnieje w pamięci podręcznej.</summary>
        <returns><see langword="true" />Jeśli pamięć podręczna zawiera wpis pamięci podręcznej z taką samą <paramref name="key" />wartością klucza jak <see langword="false" />; w przeciwnym razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Unikatowe identyfikatory dla wpisów pamięci podręcznej do monitorowania.</param>
        <param name="regionName">Opcjonalna. Nazwany region w pamięci podręcznej, w którym znajdują <paramref name="keys" /> się klucze pamięci podręcznej w parametrze, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, tworzy <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> obiekt, który może wyzwalać zdarzenia w odpowiedzi na zmiany określonych wpisów pamięci podręcznej.</summary>
        <returns>Monitor zmian, który monitoruje wpisy pamięci podręcznej w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy Klasa pochodna <xref:System.Runtime.Caching.ObjectCache> przesłania metodę podstawową <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> , implementacja <xref:System.Runtime.Caching.CacheEntryChangeMonitor> pamięci podręcznej musi utworzyć obiekt. Ten wyspecjalizowany monitor będzie powiadamiał wywołujących w przypadku zmiany wpisów w pamięci podręcznej, które są `keys` określone w parametrze. Na przykład jeśli monitorowany element w `keys` parametrze zostanie zaktualizowany lub usunięty z pamięci podręcznej, monitor zmian utworzony przez tę metodę wyzwala zdarzenie.  
  
 Jeśli implementacja pamięci podręcznej obsługuje nazwane regiony pamięci podręcznej, wartość ciągu można `regionName` określić jako parametr. W przeciwnym razie parametr ma `null`wartość domyślną.  
  
> [!NOTE]
>  Nie wszystkie implementacje pamięci podręcznej obsługują monitory zmian wpisów w pamięci podręcznej. Aby ustalić, czy implementacja pamięci podręcznej obsługuje <xref:System.Runtime.Caching.CacheEntryChangeMonitor> obiekty, zapoznaj się z dokumentacją dla określonej implementacji pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, Pobiera opis funkcji zapewnianych przez implementację pamięci podręcznej.</summary>
        <value>Bitowa kombinacja flag wskazujących domyślne możliwości implementacji pamięci podręcznej.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej, który ma zostać pobrany.</param>
        <param name="regionName">Opcjonalny. Nazwany region w pamięci podręcznej, do którego dodano wpis pamięci podręcznej, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera określony wpis pamięci podręcznej z pamięci podręcznej jako obiekt.</summary>
        <returns>Wpis pamięci podręcznej, który <paramref name="key" />jest identyfikowany przez.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej, który ma zostać pobrany.</param>
        <param name="regionName">Opcjonalny. Nazwany region w pamięci podręcznej, do której dodano pamięć podręczną, jeśli regiony zostały zaimplementowane. Ponieważ regiony nie są zaimplementowane w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]programie, wartość domyślna <see langword="null" />to.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera określony wpis pamięci podręcznej z pamięci <see cref="T:System.Runtime.Caching.CacheItem" /> podręcznej jako wystąpienie.</summary>
        <returns>Wpis pamięci podręcznej, który <paramref name="key" />jest identyfikowany przez.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie metody istnieje, ponieważ niektóre implementacje pamięci podręcznej mogą zwiększyć <xref:System.Runtime.Caching.CacheItem> klasę. W takim przypadku <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> Przeciążenie metody niekoniecznie zwróci wszystkie informacje o danych w pamięci podręcznej. Jednak Przeciążenie metody umożliwia niestandardowym pamięciom podręcznym zwracanie więcej niż tylko wartości pamięci podręcznej. <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29>  
  
 Metoda jest taka <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> sama jak <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Metoda, z tą różnicą, że <xref:System.Runtime.Caching.CacheItem> Metoda zwraca jako wystąpienie zwracany wpis pamięci podręcznej. <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Opcjonalna. Nazwany region w pamięci podręcznej, dla którego należy obliczyć liczbę wpisów pamięci podręcznej, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera łączną liczbę wpisów pamięci podręcznej w pamięci podręcznej.</summary>
        <returns>Liczba wpisów pamięci podręcznej w pamięci podręcznej. Jeśli <paramref name="regionName" /> nie<see langword="null" />jest, liczba wskazuje liczbę wpisów, które znajdują się w określonym regionie pamięci podręcznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, tworzy moduł wyliczający, który może być używany do iteracji w kolekcji wpisów pamięci podręcznej.</summary>
        <returns>Obiekt modułu wyliczającego, który zapewnia dostęp do wpisów pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje pamięci podręcznej mogą przesłonić i zwiększyć tę metodę, aby zapewnić niestandardowy sposób iteracji za pośrednictwem kolekcji wpisów pamięci podręcznej.  
  
> [!NOTE]
>  Zwrócenie modułu wyliczającego jest zazwyczaj bardziej kosztowną operacją niż zwrócenie całego wpisu pamięci podręcznej.  
  
 Ta metoda jest wywoływana przez jawne implementacje interfejsu, które <xref:System.Runtime.Caching.ObjectCache> Klasa ma <xref:System.Collections.IEnumerable.GetEnumerator%2A> dla metod i <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zestaw wpisów pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Kolekcja unikatowych identyfikatorów dla wpisów pamięci podręcznej do pobrania.</param>
        <param name="regionName">Opcjonalny. Nazwany region w pamięci podręcznej, do którego dodano wpis lub wpisy pamięci podręcznej, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, Pobiera zestaw wpisów pamięci podręcznej odpowiadających określonym kluczom.</summary>
        <returns>Słownik par klucz/wartość, które reprezentują wpisy pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> metody to Optymalizacja wydajności rozproszonej pamięci podręcznej, która obsługuje pobieranie wielu wpisów pamięci podręcznej z pamięci podręcznej podczas jednego wywołania sieciowego.  
  
 Mimo że obiekt wywołujący może przekazać jeden lub więcej kluczy do metody, nie ma gwarancji, że wszystkie klucze reprezentują wpisy w pamięci podręcznej. W związku z tym zwracany słownik może zawierać mniej elementów niż liczba kluczy przekazana do metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Opcjonalny. Nazwany region w pamięci podręcznej, do którego dodano wpis lub wpisy pamięci podręcznej, jeśli regiony zostały zaimplementowane. Ponieważ regiony nie są zaimplementowane w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]programie, wartość domyślna <see langword="null" />to.</param>
        <param name="keys">Kolekcja unikatowych identyfikatorów dla wpisów pamięci podręcznej do pobrania.</param>
        <summary>Pobiera zestaw wpisów pamięci podręcznej odpowiadających określonym kluczom.</summary>
        <returns>Słownik par klucz/wartość, które reprezentują wpisy pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie metody przypomina Przeciążenie metody, ale umożliwia przekazanie nazwanego regionu przy użyciu opcjonalnej składni parametrów, która jest obsługiwana przez Języki zarządzane, takie jak C# <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType>  
  
 Ta metoda jest metodą wirtualną, ponieważ <xref:System.Runtime.Caching.ObjectCache> Klasa udostępnia implementację domyślną, która `params` przekazuje tablicę do <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie do zarządzanego środowiska hostingu, które jest dostępne dla <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji i który może udostępniać <see cref="T:System.Runtime.Caching.ObjectCache" /> usługi specyficzne dla hosta.</summary>
        <value>Odwołanie do zarządzanego środowiska hostingu z obsługą pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest przeznaczona do użycia przez [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] środowiska hosta i implementacje pamięci podręcznej implementujące zachowanie, które zależy od środowiska hosta .NET Framework. <xref:System.Runtime.Caching.ObjectCache.Host%2A>  
  
 W poniższej tabeli przedstawiono zestaw usług środowiska hosta, które mogą być dostępne w zarządzanym środowisku hostingu i które są dostępne dla <xref:System.Runtime.Caching.ObjectCache> implementacji <xref:System.Runtime.Caching.ObjectCache.Host%2A> za pośrednictwem właściwości:  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Umożliwia środowisku hosta dostarczanie identyfikatorów domen aplikacji, które mogą być konieczne przez implementację pamięci podręcznej dla funkcji, takich jak identyfikowanie liczników wydajności.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Umożliwia środowisko hosta udostępnia niestandardowy system powiadamiania o zmianach plików, zamiast używać go w programie [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Umożliwia obsługę pamięci podręcznej w raportach dotyczących wykorzystania pamięci przez pamięć podręczną w środowisku hosta. Dzięki temu środowiska hosta mogą centralnie zarządzać użyciem pamięci w wielu implementacjach pamięci podręcznej.|  
  
> [!NOTE]
>  Obiekty wywołujące tę wartość właściwości wymagają uprawnień zabezpieczeń dostępu do kodu bez ograniczeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość przypisana do właściwości to <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę ustawienia wartości właściwości więcej niż jeden raz.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">dla pełnego zaufania dla wszystkich metod dostępu tej właściwości. Ta właściwość nie może być używana przez częściowo zaufany kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, że wpis pamięci podręcznej nie ma bezwzględnego wygaśnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wpis pamięci podręcznej, który został wstawiony do pamięci <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> podręcznej z wartością pola ustawioną jako wartość wygaśnięcia, nigdy nie powinien wygasać na podstawie bezwzględnego punktu w czasie. Wpis pamięci podręcznej z tym ustawieniem można jednak wykluczyć z pamięci podręcznej z innych powodów, które są określane przez określoną implementację pamięci podręcznej, taką jak wykluczenie zdarzenia monitorowania zmian spowodowany przez wykorzystanie pamięci.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej w pamięci podręcznej.</param>
        <summary>Pobiera lub ustawia domyślny indeksator dla <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy.</summary>
        <value>Klucz, który służy jako indeksator do wystąpienia pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie akcesora zestawu tej właściwości jest podobne do <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> metody. Wewnętrznie implementacja pamięci podręcznej może ustawić bezwzględne wygaśnięcie określonej wartości dla <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> metody. Jednak to zachowanie jest ostatecznie do implementacji pamięci podręcznej.  
  
 Zachowanie <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> metody Get Metoda dostępu jest podobne do wywołania metod i przy `null` użyciu dla nazwy regionu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę określonego <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienia.</summary>
        <value>Nazwa określonego wystąpienia pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre implementacje pamięci podręcznej mogą obsługiwać wiele wystąpień pamięci podręcznej, która działa w pojedynczej aplikacji. Ta właściwość umożliwia realizatorom pamięci podręcznej Zwracanie nazwy, która identyfikuje określone wystąpienie pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że wpis pamięci podręcznej nie ma czasu wygaśnięcia przewijania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas wygaśnięcia oparty na czasie trwania lub zdefiniowanego okna jest również określany jako wygasające wygaśnięcie. Zwykle implementacja pamięci podręcznej, która wyklucza elementy, które są oparte na przeniesieniu, spowoduje usunięcie elementu, do którego nie uzyskano dostępu w określonym przedziale czasu.  
  
 Wpis pamięci podręcznej, który został wstawiony do pamięci <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> podręcznej z wartością pola ustawioną jako wartość wygaśnięcia, nigdy nie powinien być wykluczony z powodu braku aktywności w przedziale czasu. Jednak element pamięci podręcznej może zostać wykluczony, jeśli ma bezwzględne wygaśnięcie lub jeśli wystąpi inne zdarzenie wykluczenia, taki monitor zmian lub wykorzystanie pamięci.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwany region w pamięci podręcznej, do którego dodano wpis pamięci podręcznej, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, usuwa wpis pamięci podręcznej z pamięci podręcznej.</summary>
        <returns>Obiekt, który reprezentuje wartość usuniętego wpisu pamięci podręcznej, który został określony przez klucz lub <see langword="null" /> Jeśli nie znaleziono określonego wpisu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zastąpisz tę metodę w implementacji niestandardowej pamięci podręcznej, jeśli w pamięci podręcznej znajduje się wpis pamięci `key`podręcznej, który odpowiada, należy zwrócić wartość usuniętego elementu. Jeśli nic nie zostało usunięte z pamięci podręcznej, Metoda `null`powinna zwrócić.  
  
> [!NOTE]
>  Niektóre implementacje rozproszonej pamięci podręcznej mogą nie obsługiwać możliwości zwracania wartości, która została usunięta z pamięci podręcznej. Może to być spowodowane tym, że implementacja pamięci podręcznej nie obsługuje zwracania wartości usuniętego elementu pamięci podręcznej. Może być to spowodowane tym, że kierowanie obiektu jako wartości zwracanej jest zbyt kosztowne. W takich przypadkach można zwrócić `null`implementacje pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, program wstawia wpis pamięci podręcznej do buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowym zachowaniem <xref:System.Runtime.Caching.ObjectCache.Set%2A> metod przeciążenia jest operacja INSERT-lub-Update. Wpis pamięci podręcznej został wstawiony jako nowy wpis, jeśli określony wpis nie istnieje lub wpis pamięci podręcznej zostanie zaktualizowany o nową wartość, jeśli już istnieje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Element pamięci podręcznej, który ma zostać dodany.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, Wstawia wpis pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienie, określając informacje o tym, w jaki sposób wpis zostanie wykluczony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz `item` nie istnieje, `item` zostanie wstawiony jako nowy wpis pamięci podręcznej. Jeśli istnieje element z kluczem, który jest `item` zgodny, wartość z `item` jest używana do aktualizowania lub zastępowania wartości istniejącego wpisu pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="absoluteExpiration">Stała Data i godzina wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwany region w pamięci podręcznej, do którego można dodać wpis pamięci podręcznej, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>W przypadku zastąpienia w klasie pochodnej program wstawia do pamięci podręcznej wpis pamięci podręcznej, określając informacje o wygasaniu opartym na czasie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element, który jest `key` zgodny, `value` nie istnieje w pamięci podręcznej i `key` służy do wstawiania jako nowy wpis pamięci podręcznej. Jeśli element z kluczem zgodnym `item` z istnieje, wpis pamięci podręcznej jest aktualizowany lub zastępowany przy użyciu. `value`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <param name="regionName">Opcjonalny. Nazwany region w pamięci podręcznej, do którego można dodać wpis pamięci podręcznej, jeśli regiony zostały zaimplementowane. Wartość domyślna parametru Optional to <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program wstawia wpis pamięci podręcznej do buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie metody umożliwia dostarczenie większej ilości informacji o wykluczeniu lub wygaśnięciu niż te, które są dostępne w bezwzględnym czasie.  
  
 Jeśli element, który jest `key` zgodny, `value` nie istnieje w pamięci podręcznej i `key` służy do wstawiania jako nowy wpis pamięci podręcznej. Jeśli element z kluczem zgodnym `item` z istnieje, wpis pamięci podręcznej jest aktualizowany lub zastępowany przy użyciu. `value`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obsługuje iterację w kolekcji o jednoznacznie określonym typie.</summary>
        <returns>Obiekt modułu wyliczającego, który zapewnia dostęp do wpisów pamięci podręcznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obsługuje iterację w kolekcji ogólnej.</summary>
        <returns>Obiekt modułu wyliczającego, który zapewnia dostęp do elementów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, gdy wystąpienie <xref:System.Runtime.Caching.ObjectCache> pochodne jest rzutowane <xref:System.Collections.IEnumerable> do interfejsu.  
  
 Deweloperzy mogą używać tej metody do iteracji w ogólnej kolekcji wpisów pamięci podręcznej.  
  
 Jest to domyślna <xref:System.Collections.IEnumerable.GetEnumerator%2A> implementacja, która wewnętrznie <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> wywołuje metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

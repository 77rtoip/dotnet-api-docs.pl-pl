<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="490163b95a1c739f285d903ae3e13cfd6489a285" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36637587" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje obiekt pamięci podręcznej i udostępnia właściwości i metod bazowych do uzyskiwania dostępu do pamięci podręcznej obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache> Typ jest typem podstawowym dla obiektów w pamięci podręcznej. Aby opracować implementacji niestandardowych pamięci podręcznej, pochodzi z <xref:System.Runtime.Caching.ObjectCache> klasy.  
  
> [!NOTE]
>  <xref:System.Runtime.Caching.ObjectCache> Klasa jest nowa w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Wbudowane <xref:System.Runtime.Caching.MemoryCache> pochodną klasy <xref:System.Runtime.Caching.ObjectCache> klasy. <xref:System.Runtime.Caching.MemoryCache> Klasa jest implementacją pamięci podręcznej tylko konkretny obiekt w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] która pochodzi z <xref:System.Runtime.Caching.ObjectCache> klasy.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides">
      <para>Ponieważ <see cref="T:System.Runtime.Caching.ObjectCache" /> typu reprezentuje tylko typowe funkcje pamięci podręcznej, nie jest wymagane dla jak <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienia muszą być tworzone i uzyskany. Ponadto nie jest wymagane który specyficzne implementacje <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy musi być pojedynczych wystąpień.  <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> nie jest klasą pojedynczą, ale należy utworzyć tylko kilka lub potencjalnie tylko <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia i kod, który buforuje elementów należy korzystać z tych wystąpień.  </para></block>  Przy dziedziczeniu z <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy, konieczne jest przesłonięcie metody.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Metoda wywoływana z konstruktorów w klasach pochodnych w celu zainicjowania <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpisu pamięci podręcznej w pamięci podręcznej, bez konieczności, który zwrócony istniejący wpis pamięci podręcznej z odpowiedniego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia metody próba wstawienia wpis pamięci podręcznej w pamięci podręcznej, zastępowanie lub usuwanie istniejący wpis pamięci podręcznej, która ma ten sam klucz. Wpis pamięci podręcznej może być typu <xref:System.Runtime.Caching.CacheItem> obiekt lub obiekt generyczny.  
  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Przeciążenia metody i <xref:System.Runtime.Caching.ObjectCache.Add%2A> przeciążenia metody ma jedną istotną różnicą. Te metody wstawiania wpis pamięci podręcznej, jeśli pozycja znajduje się w pamięci podręcznej, <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody zwrócić istniejący wpis pamięci podręcznej, ale <xref:System.Runtime.Caching.ObjectCache.Add%2A> przeciążenia metody nie. O tych przeciążenia metody różnych umożliwia wywoływania w celu optymalizacji ich kodu opartego na czy potrzebują istniejący wpis pamięci podręcznej. W rozproszonej pamięci podręcznej, zwracając istniejącej wartości przy użyciu <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> metoda może być droższe niż zwraca wartość logiczną przy użyciu <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, próbuje Wstaw wpis pamięci podręcznej w pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia i dodaje szczegółowe informacje dotyczące sposobu wykluczyć wpis.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawiania zakończyło się pomyślnie, lub <see langword="false" /> Jeśli istnieje już wpis w pamięci podręcznej, który ma tego samego klucza <paramref name="item" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia metody są wirtualnych (nie jako abstract) na <xref:System.Runtime.Caching.ObjectCache> klasy, ponieważ <xref:System.Runtime.Caching.ObjectCache.Add%2A> wewnętrznie wywołuje metodę <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Zmniejsza liczbę przeciążenia metody, które musi dostarczyć implementujący pamięci podręcznej. Implementacja pamięci podręcznej nie wymaga specjalnego zachowania w przypadku <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody, można po prostu implementuje ona <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="absoluteExpiration">Stałe datę i godzinę wygaśnięcia wpisu pamięci podręcznej. Ten parametr jest wymagany, gdy <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" /> metoda jest wywoływana.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej, jeśli zostaną zaimplementowane regionów. Ponieważ regiony nie są zaimplementowane w [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)], wartość domyślna to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej bez zastępowania żadnych istniejący wpis pamięci podręcznej.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawiania zakończyło się pomyślnie, lub <see langword="false" /> Jeśli istnieje już wpis w pamięci podręcznej, który ma tego samego klucza <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia metody są wirtualnych (nie jako abstract) na <xref:System.Runtime.Caching.ObjectCache> klasy, ponieważ <xref:System.Runtime.Caching.ObjectCache.Add%2A> wewnętrznie wywołuje metodę <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Zmniejsza liczbę przeciążenia metody, które musi dostarczyć implementujący pamięci podręcznej. Implementacja pamięci podręcznej nie wymaga specjalnego zachowania w przypadku <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody, można po prostu implementuje ona <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej, określania informacji o jak wpis zostanie usunięty.</summary>
        <returns>
          <see langword="true" /> Jeśli spróbuj wstawiania zakończy się pomyślnie, lub <see langword="false" /> Jeśli istnieje już wpis w pamięci podręcznej przy użyciu tego samego klucza <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia metody są wirtualnych (nie jako abstract) na <xref:System.Runtime.Caching.ObjectCache> klasy, ponieważ <xref:System.Runtime.Caching.ObjectCache.Add%2A> wewnętrznie wywołuje metodę <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Zmniejsza liczbę przeciążenia metody, które musi dostarczyć implementujący pamięci podręcznej. Implementacja pamięci podręcznej nie wymaga specjalnego zachowania w przypadku <xref:System.Runtime.Caching.ObjectCache.Add%2A> metody, można po prostu implementuje ona <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, podejmuje próbę wstawienia wpis pamięci podręcznej w pamięci podręcznej i zwraca istniejący wpis pamięci podręcznej z odpowiedniego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Przeciążenia metody insert wpis w pamięci podręcznej. Jeśli wpis pamięci podręcznej z dopasowany klucz już istnieje, że oba operatory zwracają istniejący wpis. Wpis pamięci podręcznej może być <xref:System.Runtime.Caching.CacheItem> obiekt lub obiekt generyczny.  
  
 Istnieje jeden różnica między <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia i <xref:System.Runtime.Caching.ObjectCache.Add%2A> przeciążenia. Jeśli te metody przeciążane próba wstawienia wpisu pamięci podręcznej, jeśli istniejący wpis zostanie znaleziony, że ma klucz pasujący istniejące dodaje wpis pamięci podręcznej <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia zwracać istniejący wpis pamięci podręcznej. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Przeciążenia nie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia określony <see cref="T:System.Runtime.Caching.CacheItem" /> obiektu w pamięci podręcznej, określania informacji o jak wpis zostanie usunięty.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, wpis pamięci podręcznej określony; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="absoluteExpiration">Stałe datę i godzinę wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej, za pomocą klucza, obiekt do wpisu pamięci podręcznej, wartość bezwzględna wygaśnięcia i region opcjonalny do dodania do pamięci podręcznej.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, wpis pamięci podręcznej określonej wartości. w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> przeciążenie metody nie zwraca wartości obiektu <xref:System.Runtime.Caching.CacheItem> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej, określając klucza i wartość dla wpisu pamięci podręcznej i dowiedzieć się, jak wpis zostanie usunięty.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, wpis pamięci podręcznej określonej wartości. w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> Metoda zwraca wartość obiektu nie <xref:System.Runtime.Caching.CacheItem> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, w których pamięci podręcznej można znaleźć, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, sprawdza, czy istnieje już wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <returns>
          <see langword="true" /> Jeśli pamięć podręczna zawiera wpis pamięci podręcznej o tej samej wartości klucza jako <paramref name="key" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Unikatowe identyfikatory wpisów pamięci podręcznej do monitorowania.</param>
        <param name="regionName">Opcjonalna. Nazwane region, w której klucze pamięci podręcznej w pamięci podręcznej <c>klucze</c> parametr istnieje, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> obiektów, które mogą wyzwalać zdarzenia w odpowiedzi na zmiany we określone wpisy w pamięci podręcznej.</summary>
        <returns>Monitor zmian, który monitoruje wpisy w pamięci podręcznej w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy pochodnego <xref:System.Runtime.Caching.ObjectCache> klasa zastępuje podstawowym <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> metody, należy utworzyć implementację buforu <xref:System.Runtime.Caching.CacheEntryChangeMonitor> obiektu. Ten monitor specjalne zmiany powiadamia wywołań w przypadku zmiany wpisy w pamięci podręcznej, które są określone w `keys` parametru. Na przykład, jeśli element monitorowanych w `keys` parametr jest zaktualizowane lub usunięte z pamięci podręcznej, monitor zmiany utworzone przez tę metodę wyzwala zdarzenie.  
  
 Jeśli implementację buforu obsługuje regionów nazwanego pamięci podręcznej, wartość ciągu można określić jako `regionName` parametru. W przeciwnym razie jest domyślnie `null`.  
  
> [!NOTE]
>  Nie wszystkie implementacje pamięci podręcznej obsługuje monitorów zmiana wpisu pamięci podręcznej. Aby sprawdzić, czy obsługuje implementacji pamięci podręcznej <xref:System.Runtime.Caching.CacheEntryChangeMonitor> obiektów, zobacz dokumentację do wykonania określonych pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera opis funkcji, które zawiera implementację buforu.</summary>
        <value>Bitowe połączenie flag, które wskazują możliwości domyślną implementację buforu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej do pobrania.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego został dodany wpisu pamięci podręcznej, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wpisu określony pamięci podręcznej z pamięci podręcznej jako obiekt.</summary>
        <returns>Wpis pamięci podręcznej, który jest identyfikowany przez <paramref name="key" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej do pobrania.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego został dodany pamięci podręcznej, jeśli zostaną zaimplementowane regionów. Ponieważ regiony nie są zaimplementowane w [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)], wartość domyślna to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wpisu określony pamięci podręcznej z pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia.</summary>
        <returns>Wpis pamięci podręcznej, który jest identyfikowany przez <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie tej metody nie istnieje, ponieważ niektóre implementacje pamięci podręcznej może wydłużyć <xref:System.Runtime.Caching.CacheItem> klasy. W takim przypadku <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> przeciążenie metody nie będzie zawsze zwracać wszystkie informacje o danych z pamięci podręcznej. Jednak <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> przeciążenie metody Włącza niestandardowe pamięci podręcznej otrzymać więcej niż wartość pamięci podręcznej.  
  
 <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Metody przypomina <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> metody, z wyjątkiem <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> metoda zwraca zwracanego wpisu pamięci podręcznej jako <xref:System.Runtime.Caching.CacheItem> wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, dla którego liczba wpisu pamięci podręcznej powinien zostać obliczony, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera całkowita liczba wpisów pamięci podręcznej w pamięci podręcznej.</summary>
        <returns>Liczba wpisów w pamięci podręcznej w pamięci podręcznej. Jeśli <paramref name="regionName" /> nie jest <see langword="null" />, licznik wskazuje liczbę wpisów, które znajdują się w pamięci podręcznej określonego regionu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy moduł wyliczający, który może służyć do iterowania po kolekcji wpisów pamięci podręcznej.</summary>
        <returns>Obiekt moduł wyliczający, który zapewnia dostęp do wpisów pamięci podręcznej w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje pamięci podręcznej można zastąpić i rozszerzenie tej metody, aby zapewnić niestandardowych środka iteracji w kolekcji wpisów pamięci podręcznej.  
  
> [!NOTE]
>  Zwraca moduł wyliczający jest zazwyczaj operacją droższe niż powrót całą pamięć podręczną zapisu.  
  
 Ta metoda jest wywoływana przez implementacje interfejsu jawnego który <xref:System.Runtime.Caching.ObjectCache> klasa ma dla <xref:System.Collections.IEnumerable.GetEnumerator%2A> i <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zestaw wpisów pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Kolekcja unikatowych identyfikatorów dla wpisów pamięci podręcznej do pobrania.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego wpisu pamięci podręcznej lub wpisy zostały dodane, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera zbiór wpisy w pamięci podręcznej, które odpowiadają na określone klucze.</summary>
        <returns>Słownik zawierający pary klucz wartość, które reprezentują wpisy w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> Optymalizację wydajności dla rozproszonej pamięci podręcznej, które obsługuje pobierania wiele wpisów pamięci podręcznej z pamięci podręcznej podczas wywoływania jednej sieci jest przeciążenie metody.  
  
 Mimo że obiekt wywołujący może przekazać przynajmniej jednego klucza do metody, brak żadnej gwarancji, że wszystkie klucze reprezentują wpisów w pamięci podręcznej. W związku z tym zwrócony słownika może zawierać mniej niż liczba kluczy, które zostały przekazane do metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego wpisu pamięci podręcznej lub wpisy zostały dodane, jeśli zostaną zaimplementowane regionów. Ponieważ regiony nie są zaimplementowane w [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)], wartość domyślna to <see langword="null" />.</param>
        <param name="keys">Kolekcja unikatowych identyfikatorów dla wpisów pamięci podręcznej do pobrania.</param>
        <summary>Pobiera zestaw wpisy w pamięci podręcznej, które odpowiadają na określone klucze.</summary>
        <returns>Słownik zawierający pary klucz wartość, które reprezentują wpisy w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> Przeciążenie metody przypomina <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> przeciążenie metody, ale pozwala przekazać nazwanego region przy użyciu składni opcjonalny parametr, który jest obsługiwany przez zarządzane języków, takich jak C#.  
  
 Ta metoda jest metodą wirtualną, ponieważ <xref:System.Runtime.Caching.ObjectCache> klasa udostępnia domyślną implementację, która przekazuje `params` tablicy do <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustaw odwołanie do zarządzanego środowiska hostingu, która jest dostępna dla <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji, które zapewniają usługi specyficzne dla hosta, aby <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji.</summary>
        <value>Odwołanie do pamięci podręcznej obsługujący zarządzanego środowiska hostingu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache.Host%2A> Właściwości jest przeznaczony do użytku przez [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] środowiska, a przez implementacje pamięci podręcznej, które implementuje zachowanie, która jest zależna od programu .NET Framework środowisko.  
  
 Poniższa lista zawiera zbiór usług środowiska hosta, co może być dostępny w środowisku macierzystym zarządzane i które są dostępne do <xref:System.Runtime.Caching.ObjectCache> implementacje za pośrednictwem <xref:System.Runtime.Caching.ObjectCache.Host%2A> właściwości:  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Umożliwia Podaj identyfikatory domeny aplikacji, które mogą być wymagane przez implementację buforu, funkcji, takich jak identyfikujący liczniki wydajności środowiska hosta.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Umożliwia zapewniają niestandardowe zmianę pliku system powiadomień, zamiast przy użyciu jednej w środowiskach hosta [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Umożliwia zmniejszenie zużycia pamięci pamięci podręcznej raportu implementacje pamięci podręcznej w środowisku hosta. Umożliwia to centralne zarządzanie użycie pamięci przez wiele implementacji pamięci podręcznej środowiska hosta.|  
  
> [!NOTE]
>  Wywołań wartość tej właściwości wymagane uprawnienia zabezpieczeń dostępu kodu bez ograniczeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość przypisywane do właściwości jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić wartość właściwości więcej niż jeden raz.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie wszystkie metody dostępu tej właściwości. Tej właściwości nie można użyć przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wpis pamięci podręcznej nie ma żadnych wygaśnięcia bezwzględne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wpis pamięci podręcznej, który znajduje się w pamięci podręcznej <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> pole ma wartość jako wartość wygaśnięcia nigdy nie wygaśnie oparte na bezwzględne punktu w czasie. Wpis pamięci podręcznej tego ustawienia może jednak wykluczony z pamięci podręcznej z innych przyczyn, które są określone przez implementację określonego pamięci podręcznej, na przykład monitor zmianach wykluczenia zdarzeń, spowodowane wykorzystania pamięci.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej w pamięci podręcznej.</param>
        <summary>Pobiera lub ustawia indeksatora domyślny dla <see cref="T:System.Runtime.Caching.ObjectCache" /> klasy.</summary>
        <value>Klucz, który służy jako indeksatora do wystąpienia pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przypomina zachowanie metody dostępu set tej właściwości <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> metody. Wewnętrznie implementację buforu można ustawić czas wygaśnięcia bezwzględne określoną wartość na <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> metody. Jednak to zachowanie jest ostatecznie do implementacji pamięci podręcznej.  
  
 Metody dostępu get jest takie jak wywołania <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> — metoda i przy użyciu `null` nazwę regionu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę określonego <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienia.</summary>
        <value>Nazwa wystąpienia określonego pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre implementacje pamięci podręcznej może obsługiwać wiele wystąpień w pamięci podręcznej działającej w pojedynczej aplikacji. Ta właściwość umożliwia zwraca nazwę identyfikującą wystąpienie pamięci podręcznej określonych implementacje pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wpis pamięci podręcznej nie ma żadnych przesuwanego czas wygaśnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wygaśnięcia opartego na czas trwania lub zdefiniowanych przedziale czasu jest również nazywany przedłużanie ważności. Zwykle implementację buforu, który wyklucza mogą elementy, które są oparte na przedłużanie ważności spowoduje usunięcie elementu, który nie była używana w określonym przedziale czasu.  
  
 Wpis pamięci podręcznej, który znajduje się w pamięci podręcznej <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> pola wartość ustawiona jako wartość wygaśnięcia nigdy nie wykluczyć z powodu innej niż działania w metodzie przesuwanego okna czasu. Jednak element pamięci podręcznej może zostać wykluczony, jeśli ma ona wygaśnięcia bezwzględne lub inne zdarzenia wykluczenia występuje takie zmiany monitora lub pamięci wykorzystania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do którego został dodany wpisu pamięci podręcznej, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej usuwa wpis pamięci podręcznej z pamięci podręcznej.</summary>
        <returns>Obiekt reprezentujący wartość wpisu pamięci podręcznej usunięty, która została określona za pomocą klucza lub <see langword="null" /> , jeśli nie można odnaleźć określonego wpisu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli przesłonić tę metodę w implementacji niestandardowych pamięci podręcznej, jeśli istnieje wpis pamięci podręcznej w pamięci podręcznej, która odpowiada `key`, powinna zostać zwrócona wartość z usuniętym elementem. Jeśli nic nie został usunięty z pamięci podręcznej, metoda powinna zwrócić `null`.  
  
> [!NOTE]
>  Niektóre implementacje rozproszonej pamięci podręcznej może nie obsługiwać możliwość zwracania wartości, który został usunięty z pamięci podręcznej. Może to być spowodowane implementację buforu nie obsługuje zwracania wartości elementów usuniętych pamięci podręcznej. Być może przekazywanie obiektu jako zwracana wartość jest zbyt drogie. W takich przypadkach może zwrócić implementacje pamięci podręcznej `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowe zachowanie <xref:System.Runtime.Caching.ObjectCache.Set%2A> przeciążenia metody jest operacją insert lub update. Wpis pamięci podręcznej jest albo wstawiony jako nowy wpis, jeśli określony wpis nie istnieje lub wpisu pamięci podręcznej jest zaktualizowane przy użyciu nowej wartości, jeśli już istnieje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Aby dodać element pamięci podręcznej.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpisu pamięci podręcznej w pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia, określania informacji o jak wpis zostanie usunięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz `item` nie istnieje, `item` są wstawiane jako nowy wpis pamięci podręcznej. Jeśli element z kluczem takim samym `item` istnieje wartość `item` służy do aktualizacji lub zastąpić wartość istniejący wpis pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="absoluteExpiration">Stałe datę i godzinę wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej, określając szczegóły na podstawie czasu wygaśnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element odpowiadający `key` nie istnieje w pamięci podręcznej, `value` i `key` są używane do wstawiania jako nowy wpis pamięci podręcznej. Jeśli element z kluczem takim samym `item` istnieje, aktualizacji lub zastąpić, przy użyciu wpisu pamięci podręcznej `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <param name="regionName">Opcjonalna. Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej, jeśli zostaną zaimplementowane regionów. Wartość domyślna dla parametru opcjonalnego to <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wstawia wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody umożliwia bardziej szczegółowe wykluczenia i wygaśnięcia niż te, które są dostępne w na podstawie czasu wygaśnięcia bezwzględne.  
  
 Jeśli element odpowiadający `key` nie istnieje w pamięci podręcznej, `value` i `key` są używane do wstawiania jako nowy wpis pamięci podręcznej. Jeśli element z kluczem takim samym `item` istnieje, aktualizacji lub zastąpić, przy użyciu wpisu pamięci podręcznej `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obsługuje iteracji przez kolekcję ogólną.</summary>
        <returns>Obiekt moduł wyliczający, który zapewnia dostęp do elementów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można użyć tylko wtedy, gdy pochodnego <xref:System.Runtime.Caching.ObjectCache> wystąpienia jest rzutowane na <xref:System.Collections.IEnumerable> interfejsu.  
  
 Deweloperzy mogą używać tej metody do iteracji ogólnych kolekcji wpisów pamięci podręcznej.  
  
 Jest to domyślny <xref:System.Collections.IEnumerable.GetEnumerator%2A> implementację, która wywołuje wewnętrznie <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
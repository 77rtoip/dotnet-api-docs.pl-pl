<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ef439688d7b98a238cf8640eb07e63804432a3ba" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30564685" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia klasę podstawową dla typu pochodnego niestandardowego, który monitoruje zmiany w stanie danych, która zależy od elementu pamięci podręcznej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Klasa jest używana jako klasa podstawowa dla klasy pochodnej monitor, które są przeznaczone do pamięci podręcznej konkretnej implementacji. A <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia monitoruje zmiany w stanie danych, która zależy od elementu pamięci podręcznej. Na przykład element może być jednostki pliku lub danych, których zawartość są buforowane. Jednostka danych lub plik jest aktualizowany, również należy zmienić wpis pamięci podręcznej skojarzone. Wspólne elementy, które mogą być monitorowane Dołącz jednostek danych (np. pola bazy danych wartości, wierszy i tabele), inny wpis pamięci podręcznej i pliki i atrybutów pliku.  
  
 Zmiany w stanie zależność jest zmiany zależności. W implementacji typowe pamięci podręcznej po <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia powiadamia pamięci podręcznej, która została zmieniona zależność, wymaganych akcji, na przykład unieważnia wpisu pamięci podręcznej wstawionego wykonuje pamięci podręcznej.  
  
 Pochodnych <xref:System.Runtime.Caching.ChangeMonitor> klasy można dostosować, aby monitorować zmiany zależności dla określonych danych do różnych magazynów. Na przykład są implementacje pamięć podręczna systemu plików, w pamięci fizycznej lub bazy danych. <xref:System.Runtime.Caching.ChangeMonitor> Klasa sprawdza zmiany wprowadzone poza pamięci podręcznej, a następnie powiadamia pamięci podręcznej, które nastąpiły zmiany.  
  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Zawiera następujące klasy, które pochodzą z <xref:System.Runtime.Caching.ChangeMonitor> klasy:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Każda z tych klas współpracuje z różnymi typami zależności. Na przykład pochodnej <xref:System.Runtime.Caching.FileChangeMonitor> klasa śledzi zmiany w pamięci podręcznej danych systemu plików (pliki i foldery), która zależy od elementu pamięci podręcznej.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides">
      <para>W przypadku utworzenia niestandardowego implementację buforu lub zmianę pochodnej monitorować typu, należy wykonać pewne wskazówki. Poniższa lista zawiera podsumowanie poniższych wskazówek. Aby uzyskać więcej informacji zobacz dokumentację dla każdej metody lub właściwości.  
  
-   Należy ustawić konstruktora klasy pochodnej <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> właściwości, rozpoczęcie monitorowania i Wywołaj <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metoda przed metoda zwraca. Jeśli konstruktora napotka błąd podczas konstrukcje, musi mieć do usuwania zasobów konstruktora można wywołać tylko <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> przeciążenia po <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metoda jest wywoływana, ponieważ <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> zgłosi przeciążenia <see cref="T:System.InvalidOperationException" /> wyjątek, jeśli inicjowanie nie zostało ukończone.  
  
-   W przypadku wystąpienia zmian w danych, które są monitorowane przed inicjowania ukończenia, należy wywołać konstruktora <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda przed wywołaniem <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metody.  
  
-   Po pochodnego <see cref="T:System.Runtime.Caching.ChangeMonitor" /> tworzenia wystąpienia typu klasy, należy wstawić monitor do niestandardowego <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji. Lub wywołania po zakończeniu pracy monitora zmiany <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody.  
  
-   Po <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia są wstawiane do <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienia wymagają usunięciu monitor zmiany. Nawet jeśli wstawiania jest nieprawidłowy i powoduje zgłoszenie wyjątku <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji należy wywołać <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> przeciążenia.  
  
-   Po wstawieniu do pamięci podręcznej, monitor pochodnej zmiany <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji należy wywołać <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, przekazując <see cref="T:System.Runtime.Caching.OnChangedCallback" /> obiektu. <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Metodę można wywołać tylko raz. Jeśli zmiana zależności już wystąpił, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wystąpienie będzie wywoływana natychmiast po <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> jest wywoływana. W przeciwnym razie <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wystąpienie zostanie wywołana tylko raz. Występuje wywołania jednorazowo, albo po <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana, ponieważ <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia wykryła zmianę, lub gdy <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> wywoływana jest metoda <see cref="T:System.Runtime.Caching.ChangeMonitor" />, cokolwiek nastąpi najpierw.  
  
-   <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Wystąpienie, które są udostępniane przez <see cref="T:System.Runtime.Caching.ObjectCache" /> Usuń wpis pamięci podręcznej skojarzonych i określić powód przy użyciu implementacji <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> wyliczenia.  
  
-   A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> można wywołać wystąpienia <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metody albo przed implementacją pamięci podręcznej została wywołana <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metody lub po. Jeśli <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana przed <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> jest nazywany podstawowym <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implementacji powiadomi pamięci podręcznej, które tego zdarzenia i wyzwoli wywołania zwrotnego do przekazania do <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> natychmiast po <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> jest wywoływana. Wszystkie dane są przekazywane do stanu <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest zapisywane przez monitor zmiany i następnie przekazywane do <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> — metoda podczas <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> wywołania metody.  
  
-   Monitor zmianach musi implementować <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> metody. Aby uzyskać więcej informacji, zobacz <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> dokumentacji metody.  
  
-   <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Przeciążenie metody należy wywołać zlikwidować <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia. Reguły wywoływania metody Dispose są następujące:  
  
    -   Przed wstawieniem elementu do pamięci podręcznej, jest odpowiedzialny za obiekt wywołujący, aby dysponować <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia.  
  
    -   Raz elementu pamięci podręcznej i <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpień, które są skojarzone z nim są przekazywane do pamięci podręcznej, implementujący pamięci podręcznej musi upewnij się, że który <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda jest wywoływana, nawet jeśli insert nie powiedzie się.  
  
    -   Po elementu i jego skojarzony <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia są przekazywane do pamięci podręcznej, obiekt wywołujący nie musi dysponować zależności, ponieważ podczas <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda jest wywoływana, wywołanie jest traktowane jakby zależność została zmieniona. W związku z tym <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana automatycznie.  
  
-   Biorąc pod uwagę, te reguły <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda musi zostać wywołana w jednym z następujących sposobów:  
  
    -   Użytkownicy muszą wywoływać <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> przeciążenie metody, jeśli nie wstawić wystąpienia pochodne monitor zmianach do pamięci podręcznej.  
  
    -   Jeśli implementacja próbuje wstawić wystąpienia monitora zmiany do obiektu pamięci podręcznej, ale wstawiania nie powiedzie się, implementacja pamięci podręcznej jest odpowiedzialny za wywoływanie <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> przeciążenia. Podczas próby wstawienia powoduje zgłoszenie wyjątku, implementację buforu musi dysponować skojarzone zależności.  
  
    -   Jeśli wpis pamięci podręcznej zostanie usunięty, implementację buforu musi również dysponować zależności.  
  
    -   Wewnętrzny wykonania <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> automatycznie wywołuje metodę <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> zarejestrowany przez metodę po wywołuje wywołania zwrotnego <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  
  
 <block subset="none" type="note"><para>  
 To automatyczne wywołanie metody dispose podczas uruchamiania zdarzeń tylko wtedy, gdy inicjowanie <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienie zostało wcześniej zakończone.  
  
</para></block>  
  
 Gdy monitor pochodnej zmiany Konstruktor wywołuje <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metody, jeśli już zmieniła stan monitora zmiany (czyli stan monitorowanego już zmienione podczas konstruktora było nadal aktywne), a następnie <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> zostanie — metoda automatycznie usuwa monitor zmiany.  
  
-   <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> Właściwość jest ustawiona na <see langword="true" /> po <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana przez wystąpienia pochodne monitor zmianach, niezależnie od tego, czy <see cref="T:System.Runtime.Caching.OnChangedCallback" /> obiekt został ustawiony przez wywołanie do <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metody lub nie.</para>
    </block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy. Ten konstruktor jest wywoływana z konstruktorów w klasach pochodnych w celu zainicjowania klasy podstawowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Klasa ma konstruktora domyślnego. Jednak klasy które dziedziczą z podstawowym <xref:System.Runtime.Caching.ChangeMonitor> klasy i Zdefiniuj niestandardowe monitorowanie zmian zachowania, należy wykonać inicjowania w konstruktorze. Aby uzyskać więcej informacji zobacz Uwagi dotyczące obiektów dziedziczących sekcji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy ustawić konstruktora klasy pochodnej <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> właściwości, rozpoczęcie monitorowania i Wywołaj <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> klasy przed zwróceniem. Jeśli zmiany zależności, przed zainicjowaniem zostało zakończone (na przykład, jeśli klucz pamięci podręcznej zależna nie zostanie znaleziony w pamięci podręcznej), należy wywołać konstruktora <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda przed wywołaniem <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metody. W takim przypadku można wywołać konstruktora <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody tylko po <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metoda jest wywoływana, ponieważ <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda zgłasza wyjątek, jeśli inicjowanie nie zostało ukończone.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Metoda jest używana do zwolnienia <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia i powiązanych zasobów. Publicznego <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metoda jest wywoływana w celu koordynowania proces usuwania zdarzenia cyklu życia klucza klas pochodnych monitor zmianach (takich jak inicjowanie) i wersji <xref:System.Runtime.Caching.ChangeMonitor> , aby wystąpienie może być bezużytecznych. <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Metoda jest implementowana przez klasy pochodnej monitor zmianach zlikwidować ich zasoby zarządzane i niezarządzane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są używane przez bieżące wystąpienie klasy <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Wywołuje metodę <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody klas pochodnych tylko jeden raz, jest ona wywoływana po raz pierwszy. Kolejne wywołania <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> — metoda nie mają żadnego skutku. Po wywołaniu metody <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> właściwość jest ustawiona na `true`.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Przeciążenia musi zostać wywołana zlikwidować <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia. Wywołanie metody dispose zasady są następujące:  
  
-   Przed wstawieniem elementu do pamięci podręcznej, jest odpowiedzialny za wywołującego zlikwidować <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia.  
  
-   Raz elementu pamięci podręcznej i <xref:System.Runtime.Caching.ChangeMonitor> wystąpień, które są skojarzone z nim są przekazywane do pamięci podręcznej, implementujący pamięci podręcznej, który należy się upewnić, że <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> jest wywoływana, nawet jeśli insert nie powiedzie się.  
  
-   Po elementu i jego skojarzony <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia są przekazywane do pamięci podręcznej, obiekt wywołujący nie musi dysponować zależności, ponieważ podczas <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metoda jest wywoływana, wywołanie jest traktowane jakby zależność została zmieniona. W związku z tym <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana automatycznie.  
  
-   Biorąc pod uwagę, te reguły <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metoda musi zostać wywołana w jednym z następujących sposobów:  
  
    -   Użytkownicy muszą wywoływać <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> przeciążenie metody, jeśli nie wstawić wystąpienia pochodne monitor zmianach do pamięci podręcznej.  
  
    -   Implementacja pamięci podręcznej jest odpowiedzialny za wywoływanie <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> przeciążenia, jeśli implementacja próbuje wstawić wystąpienia monitora zmiany do obiektu pamięci podręcznej, ale wstawiania nie powiedzie się. Podczas próby wstawienia powoduje zgłoszenie wyjątku, implementację buforu musi dysponować skojarzone zależności.  
  
    -   Jeśli wpis pamięci podręcznej zostanie usunięty, implementację buforu musi również dysponować zależności.  
  
 Wewnętrzny wykonania <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> automatycznie wywołuje metodę <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> zarejestrowany przez metodę po wywołuje wywołania zwrotnego <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metody.  
  
> [!NOTE]
>  Ta automatycznego usuwania podczas uruchamiania zdarzeń tylko wtedy, gdy inicjowanie <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia wcześniej zakończone.  
  
 Gdy monitor pochodnej zmiany Konstruktor wywołuje <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> metody, jeśli już zmieniła stan monitora zmiany (to znaczy, stan, który jest monitorowany już zmieniona po konstruktora było nadal aktywne) następnie <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> zostanie — metoda automatycznie usunąć monitora zmiany.  
  
> [!NOTE]
>  Użytkownicy nie powinny wywoływać <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody. Nie można jednak zapobiec wywołanie metody. W związku z tym, jeśli nie, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> wywołania metody. W takim przypadku wpis pamięci podręcznej jest powiadamiany o tak, jakby zależność została zmieniona.  
  
 Aby uniemożliwić przesłanianie klas pochodnych <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody, metoda nie jest jawnej implementacji interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Inicjowanie nie zostało zakończone w klasie pochodnej monitor zmianach nazywany podstawowym <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane, a wszelkie odwołania do <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane. Gdy <see langword="false" /> jest przekazywany <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> metoda jest wywoływana przez <see langword="finalizer" /> wątku i zewnętrznych odwołań zarządzanych prawdopodobnie nie jest już prawidłowe, ponieważ są one już bezużytecznych.</param>
        <summary>Zwalnia wszystkie zasoby zarządzane i niezarządzane, a wszelkie odwołania do <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia. To przeciążenie musi być implementowana przez klasy pochodnej monitor zmianach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `disposing` wartość jest `true`, wszystkie zasoby zarządzane i niezarządzane są usuwane i wszelkie odwołania do tego obiektu są wydawane, aby umożliwić wystąpienia pochodne monitor zmianach bezużytecznych. Jest on gwarancję, że podstawowym <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metoda wywoła realizowane <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody tylko jeden raz.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Monitor zmianach musi implementować <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> przeciążenia, aby zwolnić wszystkie zarządzane i niezarządzane zasoby po wartości <paramref name="disposing" /> jest <see langword="true" />. <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Przeciążenie metody, która ma <paramref name="disposing" /> wartość <see langword="true" /> jest wywoływana tylko jeden raz, to znaczy, jeśli wystąpienie zostanie usunięty po raz pierwszy. Monitor zmiany nie mogą wywoływać <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> przeciążenia bezpośrednio. Monitor pochodnej zmiany można wywołać publicznej bez parametrów <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody na podstawie <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy.  
  
 Alternatywnie monitor zmiany może implementować metodę finalizatora. W takim przypadku można wywołać finalizatora <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> — metoda i przekaż go <paramref name="disposing" /> wartość <see langword="false" />. Jednak jest to zazwyczaj niepotrzebne. Monitorowanie zmian zależności jest najczęściej wykonywane przez to usługa, która obsługuje odwołania do wystąpienia zmiany monitora. Odwołanie uniemożliwia wystąpienie bezużytecznych i dlatego powoduje, że metoda finalizator niepotrzebne. Aby uniknąć przecieki pamięci po zmianie zależność <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda usuwa wystąpienie Monitora zmiany (o ile nie zakończył inicjowanie).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje, że stan, który jest monitorowany przez <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasa uległa zmianie.</summary>
        <value>
          <see langword="true" /> Jeśli stan, który jest monitorowany przez <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia został zmieniony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz sprawdzić wartość tej właściwości w pochodnym <xref:System.Runtime.Caching.ChangeMonitor> klasy, aby zobaczyć, czy zależność została zmieniona.  
  
 Wartość jest równa `true` gdy nastąpi zmiana zależności (oznacza to, gdy <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana). Po <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana przez klasę pochodną, wartość <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwość będzie `true`, niezależnie od tego, czy <xref:System.Runtime.Caching.OnChangedCallback> wystąpienia została powiadomiona, przez wywołanie do <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metody.  
  
> [!NOTE]
>  Można sprawdzić wywołań <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwości, aby zobaczyć, czy zależność została zmieniona. Jednak w środowisku wielowątkowych prostszy i bardziej łatwy w obsłudze podejście jest do wstawiania danych do implementacji pamięci podręcznej bez sprawdzania <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwości. Implementacje pamięci podręcznej musi sprawdzić <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwości dla Ciebie i nie może wykonywać operacji insert ani operacji zestawu, jeśli zmienione zostały już co najmniej jeden skojarzone zależności.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana z konstruktora klasy pochodne wskazująca, że ten Inicjowanie zostało zakończone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku zależności zmiany przed zakończeniem inicjowania w klasie pochodnej, musi wywoływać konstruktora klasy pochodnej <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metody.  
  
 Gdy <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> wywołaniu metody <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> jest automatycznie ustawiana właściwość `true` przez monitor zmiany. W związku z tym, gdy monitor zmianach Konstruktor wywołuje <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> , klasa podstawowa zostanie automatycznie wywołanie metody <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody. Jeśli Inicjowanie zostało zakończone, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metody automatycznie usuwa wystąpienia pochodne monitor zmianach.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Konstruktor klasy pochodnej należy wywołać podstawowym <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metoda przed zwraca konstruktora. Można wywołać konstruktora klasy pochodnej <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody tylko po <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> zostanie wywołany, ponieważ <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda zgłasza wyjątek, jeśli inicjowanie nie zostało ukończone.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy wystąpienia pochodne <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasa zostanie usunięty.</summary>
        <value>
          <see langword="true" /> Jeśli wystąpienie zostanie usunięty; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest ustawiona na `true` po podstawowym <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> wywołania metody <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody w klasie pochodnej można zlikwidować wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Odwołanie do metody, które jest wywoływane, gdy zmieniono zależność.</param>
        <summary>Wywoływane przez implementacje pamięci podręcznej zarejestrować wywołania zwrotnego i powiadomienie <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienie za pośrednictwem <see cref="T:System.Runtime.Caching.OnChangedCallback" /> delegowanie, gdy zmieniono zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje pamięci podręcznej umożliwia połączenie się monitor zmiany do tej metody. W przypadku skojarzyć jedną lub więcej zmienić monitorów z elementu pamięci podręcznej, należy przekazać <xref:System.Runtime.Caching.CacheItemPolicy> wystąpienia z właściwością monitorów wypełnione zmiany do elementu pamięci podręcznej. Realizator pamięci podręcznej, że obsługuje zmienić monitorów jest odpowiedzialny za Iterowanie po <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> właściwości i rejestrowanie <xref:System.Runtime.Caching.OnChangedCallback> obiektów delegowanych z każdym zmienić monitor znalezione.  
  
 Ponieważ <xref:System.Runtime.Caching.OnChangedCallback> delegata zawiera parametr opcjonalny stanu, implementacja monitor konkretnych zmiany można przekazać informacji o stanie opcjonalne. Realizator pamięci podręcznej określa, czy należy podjąć jawne zależności od typu stanu monitora zmiany przekazywany jako część wywołania zwrotnego.  
  
> [!NOTE]
>  Podstawowy pamięci podręcznej rozszerzeń interfejsu API nie ma wymagań dotyczących jawne zależności od typu stanu.  
  
 Implementacja <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metoda automatycznie określa, czy stan monitora już został zmieniony w czasie <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metoda jest wywoływana. Jeśli <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwość jest `true`, a następnie automatycznie wywołuje metodę <xref:System.Runtime.Caching.OnChangedCallback> program obsługi zdarzeń, który został zarejestrowany za pomocą <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metody. Dzieje się tak, ponieważ jest to możliwe, że od czasu implementację buforu tworzy monitorem zmiany czasu implementację buforu pobiera monitora i wiążący sam maksymalnie, podstawowy stan monitorowanych została zmieniona. Jeśli stan został już zmieniony następnie obiekt, który jest przekazywany do <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> jest metoda `null`.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Metodę można wywołać tylko raz i spowoduje zgłoszenie wyjątku w kolejnych wywołaniach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda wywołania zwrotnego został już wywołany.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="onChangedCallback" /> jest <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>1.  Należy wywołać <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metody, aby otrzymywać powiadomienia o zmianach zależności. Jeśli zmiana zależności już wystąpił, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wystąpienie zostanie wywołana podczas <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> jest wywoływana. W przeciwnym razie <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wystąpienie zostanie wywołana jeden raz, albo gdy <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana lub gdy <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda jest wywoływana cokolwiek nastąpi najpierw. <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Usuń wpis pamięci podręcznej i żądanie wywołującego pamięci podręcznej pozyskiwania konieczne zmiany lub aktualizacji zdarzeń wstecz do oryginalnego obiektu wywołującego pamięci podręcznej wystąpienia dostarczonej przez implementację pamięci podręcznej.  
  
2.  Implementacji obiektu pamięci podręcznej, należy usunąć skojarzony ze zmianą zależności wpisu pamięci podręcznej.</para>
        </block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Dane zdarzenia zmiany. Ta wartość może być <see langword="null" />.</param>
        <summary>Metoda wywoływana przez klasy pochodne, aby zgłosić zdarzenie, gdy zostanie zmieniona zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana w przypadku wystąpienia zmian zależności. <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Metody również jest wywoływane, gdy wystąpienie Monitora zmiany zostanie usunięty, ale usuwania występuje tylko wtedy, gdy nie ma już wywołać metodę wywołania zwrotnego.  
  
 Jeśli <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana przed <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metoda jest wywoływana, dane o stanie z wywołania <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metody są zapisywane przez implementację pamięci podręcznej. Ponadto wywołanie zwrotne do <xref:System.Runtime.Caching.OnChangedCallback> metoda jest wywoływana natychmiast po <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> wywołania metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która reprezentuje <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienie klasy.</summary>
        <value>Identyfikator wystąpienia zmiany monitora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> Wartość właściwości zazwyczaj składa się z danych dotyczących ciągu nazwy łączyć zależności który jednoznacznie identyfikatory danych, który jest monitorowany przez <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia. Wartość <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> właściwość jest ciągiem. Wartość ciągu można przypisywać unikatowy identyfikator <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przez zastąpienie właściwości, można zdefiniować implementacją niestandardową wartość ciągu właściwości, aby można było go przypisać unikatowy identyfikator.</para>
        </block>
        <block subset="none" type="overrides">
          <para>W klasach pochodnych należy ustawić wartość właściwości w konstruktorze.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
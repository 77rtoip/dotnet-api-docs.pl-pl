<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d7f673552db74d3ed1ff4f6fe8dcc10612167e5c" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="36542116" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia klasę bazową, aby uzyskać pochodny typ niestandardowy, który monitoruje zmiany w stanie danych, która zależy od elementu pamięci podręcznej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Klasa jest używana jako klasa bazowa dla klas pochodnych monitor, które są przeznaczone do implementacji określonego pamięci podręcznej. A <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia monitoruje zmiany w stanie danych, która zależy od elementu pamięci podręcznej. Na przykład element może być jednostką danych lub plików, których zawartość jest buforowana. Jednostki danych lub plik zostanie zaktualizowany, również należy zmienić wpis pamięci podręcznej skojarzone. Wspólne elementy, które mogą być monitorowane obejmują jednostek danych (np. bazy danych, pola wartości, wiersze lub tabele), inny wpis pamięci podręcznej, plików i atrybutów pliku.  
  
 Zmiana zależności różni się w stanie zależności. W implementacji typowych pamięci podręcznej po <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia powiadamia pamięci podręcznej, które uległy zmianie w zależności, pamięci podręcznej wykonuje niezbędne czynności, takich jak co unieważniło wpis pamięci podręcznej wstawiono.  
  
 Pochodne <xref:System.Runtime.Caching.ChangeMonitor> klas można dostosować tak, aby monitorować zmiany zależności dla określonych różnych magazynach danych. Na przykład są implementacjach pamięci podręcznej systemu plików, ilości pamięci fizycznej lub bazy danych. <xref:System.Runtime.Caching.ChangeMonitor> Klasy sprawdza zmiany pojawiające się poza pamięci podręcznej, a następnie powiadamia pamięci podręcznej, które nastąpiły zmiany.  
  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Zawiera następujące klasy, które wynikają z <xref:System.Runtime.Caching.ChangeMonitor> klasy:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Każda z tych klas projektów w programach różne rodzaje zależności. Na przykład pochodnej <xref:System.Runtime.Caching.FileChangeMonitor> klasa śledzi zmiany w pamięci podręcznej dla danych systemu plików (pliki i foldery), który zależy od elementu pamięci podręcznej.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides">
      <para>Jeśli tworzysz niestandardową implementację buforu lub zmiana pochodnej monitorowanie typu, należy wykonać pewne wskazówki. Na poniższej liście podsumowano te wytyczne. Aby uzyskać więcej informacji zobacz dokumentację dla poszczególnych metod lub właściwości.  — Należy ustawić Konstruktor klasy pochodnej <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> właściwości rozpocząć monitorowanie, a następnie wywołaj <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metoda przed powrotem z metody. Jeśli Konstruktor napotka błąd podczas konstrukcje i musi mieć do usuwania zasobów, Konstruktor może wywołać tylko <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> przeciążenia po <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metoda jest wywoływana, ponieważ <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> zgłosi przeciążenia <see cref="T:System.InvalidOperationException" /> wyjątek, jeśli inicjowanie zakończy się.  — Jeśli zmianach w ukończenia dane, które jest monitorowana, zanim będzie inicjowania, należy wywołać konstruktora <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda przed wywołaniem <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metody.  -After pochodnej <see cref="T:System.Runtime.Caching.ChangeMonitor" /> tworzenia wystąpienia typu, należy wstawić monitora do niestandardowego <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji. Lub zadzwoń po zakończeniu pracy monitorowanie zmian <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody.  -Po <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia są wstawiane do <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienia wymagają usunięciu monitor zmiany. Nawet jeśli wstawiania jest nieprawidłowy i powoduje wyjątek <see cref="T:System.Runtime.Caching.ObjectCache" /> należy wywołać implementację <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> przeciążenia.  -Po monitor pochodnej zmiany są wstawiane do pamięci podręcznej, <see cref="T:System.Runtime.Caching.ObjectCache" /> należy wywołać implementację <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, przekazując <see cref="T:System.Runtime.Caching.OnChangedCallback" /> obiektu. <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Metodę można wywołać tylko jeden raz. Jeśli już wystąpiła zmiana zależności, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wystąpienie będzie wywoływana natychmiast po <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> jest wywoływana. W przeciwnym razie <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wystąpienia zostanie wywołana tylko raz. Występuje wywołania to jeden raz, albo po <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana, ponieważ <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia Wykryto zmianę, lub gdy <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda jest wywoływana w <see cref="T:System.Runtime.Caching.ChangeMonitor" />, zależnie co nastąpi wcześniej.  <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Wystąpienie, które są dostarczane przez <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacji należy usunąć wpis pamięci podręcznej skojarzonych i określić przyczynę przy użyciu <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> wyliczenia.  -A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia można wywołać <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metody albo zanim została wywołana z implementacją pamięci podręcznej <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metody lub po. Jeśli <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana przed <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> jest wywoływana, base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implementacji powiadomi pamięć podręczna, która przyczynę problemu i spowoduje wyzwolenie wywołania zwrotnego, które zostaną przekazane do <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> natychmiast po <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> zostanie wywołana. Wszelkie dane stanu, które są przekazywane do <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda zostanie zapisany przez monitor zmiany i następnie przekazywane do <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metody podczas <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metoda jest wywoływana.  -Monitor zmiana musi implementować <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> metody. Aby uzyskać więcej informacji, zobacz <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> metoda dokumentacji.  <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Przeciążenie metody musi zostać wywołana w celu usunięcia <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia. Reguły wywoływania usuwania są następujące:-przed element jest wstawiany do pamięci podręcznej, jest odpowiedzialny za obiekt wywołujący, aby usunąć <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia.  — Gdy element pamięci podręcznej i <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpień, które są skojarzone z nim są przekazywane do pamięci podręcznej, implementujący pamięci podręcznej musi upewnij się, że że <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda jest wywoływana, nawet w przypadku awarii insert.  -After elementu i jego skojarzone <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia są przekazywane do pamięci podręcznej, obiekt wywołujący nie musi dysponować zależności, ponieważ gdy <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda jest wywoływana, wywołanie jest traktowane tak, jakby zależność została zmieniona. W rezultacie <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana automatycznie.  -Biorąc pod uwagę, te reguły <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda musi zostać wywołana w jednym z następujących sposobów:-użytkowników należy wywołać <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> przeciążenia metody, jeśli postanowią nie można wstawić wystąpienia pochodne monitor zmiany do pamięci podręcznej.  — Jeśli implementacja próbuje wstawić wystąpienie Monitora zmiany do obiektu pamięci podręcznej, ale wstawiania zakończy się niepowodzeniem, implementacja pamięci podręcznej jest odpowiedzialny za wywołanie <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> przeciążenia. Podczas próby wstawienia, powoduje wyjątek, implementacja pamięci podręcznej muszą dysponować wszelkie skojarzone zależności.  -Wpisu pamięci podręcznej zostanie usunięty, implementacja pamięci podręcznej muszą również metodę dispose zależności.  -Wewnętrzną implementację <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> automatycznie wywołuje metodę <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda po wywołuje metodę wywołania zwrotnego, jest rejestrowane za pomocą <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  <block subset="none" type="note"><para> To automatyczne wywołanie metody dispose podczas inicjowanie zdarzeń tylko wtedy, gdy inicjalizacja <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienie zostało wcześniej zakończone.  </para></block>  Gdy Konstruktor monitor zmiany pochodnej wywołuje <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metody, jeśli już zmienił stan monitora zmiany (oznacza to, stan, który jest monitorowany już zmienione podczas konstruktora było nadal aktywne), a następnie <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> będą — metoda Automatycznie usuń Monitor zmiany.  <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> Właściwość jest ustawiona na <see langword="true" /> po <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana przez wystąpienia pochodne monitorowania zmian, niezależnie od tego, czy <see cref="T:System.Runtime.Caching.OnChangedCallback" /> obiektu została ustawiona przez wywołanie <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metody lub nie.</para>
    </block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy. Ten konstruktor jest wywoływana z konstruktorów w klasach pochodnych w celu inicjowania klasy bazowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Klasa ma domyślnego konstruktora. Jednak klasy, dziedziczy z podstawowego <xref:System.Runtime.Caching.ChangeMonitor> klasy i Zdefiniuj niestandardowe monitorowanie zmian zachowania, należy wykonać inicjalizacji w konstruktorze. Aby uzyskać więcej informacji zobacz Uwagi dotyczące obiektów dziedziczących sekcji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy ustawić w konstruktorze klasy pochodnej <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> właściwości rozpocząć monitorowanie, a następnie wywołaj <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> klasy przed jego zwracaniem. Jeśli zmiany zależności, przed zainicjowaniem zostało zakończone (na przykład, jeśli klucz pamięci podręcznej zależne nie zostanie znaleziony w pamięci podręcznej), należy wywołać konstruktora <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda przed wywołaniem <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metody. W takim przypadku można wywołać konstruktora <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody tylko po <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metoda jest wywoływana, ponieważ <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda zgłasza wyjątek, jeśli inicjowanie zakończy się.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Metoda jest używana do wersji <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia i powiązane zasoby. Publicznie <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> do koordynowania procesu usuwania ze zdarzeniami cykl życia klucza klasy pochodnej monitorowanie zmian (na przykład inicjowanie) i wersji, wywoływana jest metoda <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia, tak aby wystąpienie może być bezużyteczne. <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Metoda jest implementowana przez klasy pochodne monitor zmiany do usuwania zasobów zarządzanych i niezarządzanych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są używane przez bieżące wystąpienie <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Wywołuje metodę <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metoda w klasach pochodnych tylko jeden raz, jest wywoływana po raz pierwszy. Kolejne wywołania <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodę nie mają wpływu. Po wywołaniu metody <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> właściwość jest ustawiona na `true`.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Przeciążenia musi zostać wywołana w celu usunięcia <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia. Dostępne są następujące reguły wywoływania metody dispose:  
  
-   Zanim element jest wstawiany do pamięci podręcznej, odpowiada wywołującego do rozporządzania <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia.  
  
-   Gdy element pamięci podręcznej i <xref:System.Runtime.Caching.ChangeMonitor> wystąpień, które są skojarzone z nim są przekazywane do pamięci podręcznej, implementujący pamięci podręcznej, który musi upewnij się, że <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> jest wywoływana, nawet w przypadku awarii insert.  
  
-   Po elementu i jego skojarzone <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia są przekazywane do pamięci podręcznej, obiekt wywołujący nie musi dysponować zależności, ponieważ gdy <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metoda jest wywoływana, wywołanie jest traktowane tak, jakby zależność została zmieniona. W rezultacie <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana automatycznie.  
  
-   Biorąc pod uwagę, te reguły <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metoda musi zostać wywołana w jednym z następujących sposobów:  
  
    -   Użytkownicy muszą wywoływać <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> przeciążenia metody, jeśli postanowią nie można wstawić wystąpienia pochodne monitor zmiany do pamięci podręcznej.  
  
    -   Implementacja pamięci podręcznej jest odpowiedzialny za wywołanie <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> przeciążenia, jeśli implementacja próbuje wstawić wystąpienie Monitora zmiany do obiektu pamięci podręcznej, ale wstawiania nie powiedzie się. Podczas próby wstawienia, powoduje wyjątek, implementacja pamięci podręcznej musi dysponować wszelkie skojarzone zależności.  
  
    -   Jeśli wpis pamięci podręcznej został usunięty, implementacja pamięci podręcznej również metodę dispose zależności.  
  
 Wewnętrzną implementację <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> automatycznie wywołuje metodę <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metoda po wywołuje metodę wywołania zwrotnego, jest rejestrowane za pomocą <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metody.  
  
> [!NOTE]
>  Ta automatycznego usuwania podczas inicjowanie zdarzeń tylko wtedy, gdy inicjalizacja <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia już ukończona.  
  
 Gdy Konstruktor monitor zmiany pochodnej wywołuje <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> metody, jeśli już zmienił stan monitora zmiany (oznacza to, stan, który jest monitorowany została już zmieniona podczas konstruktora było nadal aktywne) następnie <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> będą — metoda Automatycznie usuń monitor zmiany.  
  
> [!NOTE]
>  Użytkownicy nie powinien wywoływać <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody. Nie można jednak zapobiec wywołanie metody. W związku z tym, jeśli nie, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana. W takim przypadku wpisu pamięci podręcznej zostanie powiadomiony, tak, jakby zależność została zmieniona.  
  
 Aby uniemożliwić przesłanianie klasy pochodne <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody, metoda nie jest jawną implementacją interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Inicjowanie nie zostało zakończone w klasie pochodnej monitor zmiany, która o nazwie base <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zarządzane i niezarządzane zasoby i wszelkie odwołania do <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia klasy <see langword="false" /> aby zwolnić tylko niezarządzane zasoby. Gdy <see langword="false" /> jest przekazywany <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> metoda jest wywoływana przez <see langword="finalizer" /> wątku i wszystkie odwołania zewnętrzne dla zarządzanych prawdopodobnie nie jest już prawidłowy, ponieważ są one już bezużyteczne.</param>
        <summary>Zwalnia wszystkie zasoby zarządzane i niezarządzane i wszelkie odwołania do <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia. To przeciążenie muszą być zaimplementowane przez klasy pochodne monitor zmiany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wartość `disposing` wartość `true`, zarządzane i niezarządzane zasoby są usunięte i wszelkie odwołania do tego obiektu są zwalniane, tak aby wystąpienia pochodne monitorowanie zmian może zostać usunięte. Ma żadnej gwarancji, że podstawowy <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> realizowane będzie wywoływać metoda <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody tylko jeden raz.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Monitorowanie zmian musi implementować <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> przeciążenia, aby zwolnić wszystkie zasoby zarządzane i niezarządzane po wartości <paramref name="disposing" /> jest <see langword="true" />. <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Przeciążenia metody, która ma <paramref name="disposing" /> wartość <see langword="true" /> jest wywoływana tylko raz, to znaczy, jeśli wystąpienie zostanie usunięty po raz pierwszy. Monitorowanie zmian nie mogą wywoływać <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> przeciążenia bezpośrednio. Monitorowanie zmian pochodnej może wywołać publiczny bez parametrów <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody na podstawie <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy.  Alternatywnie monitor zmiany można zaimplementować metodzie finalizacji. W takim przypadku można wywołać finalizatora <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> metody i przekazać go <paramref name="disposing" /> wartość <see langword="false" />. Jednak jest zazwyczaj zbędna. Monitorowanie zależności zmiany zwykle odbywa się przez usługę, która obsługuje odwołania do wystąpienia zmiany monitora. Odwołanie zapobiega wystąpienia jako elementu bezużytecznego zbierane i w związku z tym sprawia, że metoda finalizator niepotrzebne. Aby uniknąć przecieki pamięci, gdy zmieni się zależność, <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda usuwa wystąpienie zmiany monitora (o ile nie zakończył inicjowanie).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje, że stan, który jest monitorowany przez <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy został zmieniony.</summary>
        <value>
          <see langword="true" /> Jeśli stan, który jest monitorowany przez <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia został zmieniony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz sprawdzić wartość tej właściwości w pochodnej <xref:System.Runtime.Caching.ChangeMonitor> klasy, aby zobaczyć, czy zależność uległy zmianie.  
  
 Wartość jest równa `true` gdy wystąpi zmiana zależności (to znaczy, gdy <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> wywoływana jest metoda). Po <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana w klasie pochodnej, wartość <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwość będzie miała `true`, niezależnie od tego, czy <xref:System.Runtime.Caching.OnChangedCallback> wystąpienia została powiadomiona, przez wywołanie <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metody.  
  
> [!NOTE]
>  Obiekty wywołujące można sprawdzić <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwości, aby zobaczyć, czy zależność uległy zmianie. Jednak w środowisku wielowątkowych, prostsze i będzie łatwiejszy w utrzymaniu podejściem jest aby wstawić dane do implementacji pamięci podręcznej bez sprawdzania <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwości. Należy sprawdzić implementacjach pamięci podręcznej <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwości dla Ciebie i nie może wykonać polecenia wstawienia lub operacja ustawienia, jeśli co najmniej jeden skojarzone zależności już zostały zmienione.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana z konstruktora klasy pochodne z informacją, że Inicjowanie zostało zakończone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zależność zmieni się przed zakończeniem inicjowania w klasie pochodnej, należy wywołać konstruktora klasy pochodnej <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metody.  
  
 Gdy <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana, <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> zostaje automatycznie ustalona `true` przez monitor zmiany. W rezultacie, gdy monitor zmiany Konstruktor wywołuje <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> metody klasy bazowej będzie automatycznie wywoływać <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody. Jeśli Inicjowanie zostało zakończone, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda automatycznie usuwa wystąpienie pochodnej monitor zmiany.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Konstruktor klasy pochodnej musi wywołać base <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metoda przed Konstruktor zwraca. Można wywołać konstruktora klasy pochodnej <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody tylko po <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> jest wywoływana, ponieważ <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda zgłasza wyjątek, jeśli inicjowanie zakończy się.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje, że wystąpieniem pochodzącym z <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy jest usunięty.</summary>
        <value>
          <see langword="true" /> Jeśli wystąpienie zostanie usunięty; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest ustawiona na `true` po base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> wywołania metody <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody w klasie pochodnej w celu usunięcia wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Odwołanie do metody, które jest wywoływane, gdy zmieniono zależności.</param>
        <summary>Wywoływane przez implementacje pamięci podręcznej, aby zarejestrować wywołanie zwrotne i powiadom <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienie za pośrednictwem <see cref="T:System.Runtime.Caching.OnChangedCallback" /> delegowanie, gdy zmieniono zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje pamięci podręcznej ta metoda umożliwia połączenie się do monitorowania zmian. Jeśli można skojarzyć jedno lub więcej zmian monitorów za pomocą elementu pamięci podręcznej, należy podać <xref:System.Runtime.Caching.CacheItemPolicy> wystąpień z właściwością monitorów wypełnione zmiany do elementu pamięci podręcznej. Implementujący pamięci podręcznej, obsługuje monitorach zmian jest odpowiedzialny za Iterowanie <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> właściwości i rejestrowanie <xref:System.Runtime.Caching.OnChangedCallback> obiektów delegowanych z każdym Zmień monitor, które znajdzie.  
  
 Ponieważ <xref:System.Runtime.Caching.OnChangedCallback> delegat obejmuje parametr opcjonalny state, implementacja monitor konkretne zmiany można przekazać informacje o stanie opcjonalne. Implementujący pamięci podręcznej określa, czy mogą być podejmowane jawne zależności od typu stanu zmiany monitora jest przekazywany jako część wywołania zwrotnego.  
  
> [!NOTE]
>  Interfejs API rozszerzania podstawowej pamięci podręcznej nie ma wymagań dotyczących jawne zależności od typu stanu.  
  
 Implementacja <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metoda automatycznie określa, czy stan monitora zmienił się już w momencie <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metoda jest wywoływana. Jeśli <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwość jest `true`, a następnie automatycznie wywołuje metodę <xref:System.Runtime.Caching.OnChangedCallback> program obsługi zdarzeń, który został zarejestrowany za pomocą <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metody. Dzieje się tak, ponieważ istnieje możliwość, że od czasu wykonania pamięci podręcznej tworzy monitorem zmiany do czasu wykonania pamięci podręcznej pobiera monitora i przewody się do niego podstawowy stan monitorowanych została zmieniona. Jeśli stan został już zmieniony następnie obiekt, który jest przekazywany do <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodą jest `null`.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Metoda może być wywołana tylko raz i spowoduje zgłoszenie wyjątku w kolejnych wywołaniach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda wywołania zwrotnego zostało już wywołane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="onChangedCallback" /> jest <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>1.  Należy wywołać <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> metodę, aby otrzymywać powiadomienia o wszelkich zmianach zależności. Jeśli już wystąpiła zmiana zależności, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wystąpienia zostaną wywołane podczas <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> jest wywoływana. W przeciwnym razie <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wystąpienie będzie wywoływana jeden raz, gdy <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metoda jest wywoływana lub <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metoda jest wywoływana, zależnie co nastąpi wcześniej. <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Podanego przez implementację pamięci podręcznej wystąpienia, należy usunąć wpis pamięci podręcznej i żądanie pamięci podręcznej obiektu wywołującego, pozyskiwania niezbędne zmiany lub aktualizacji zdarzeń oryginalnego obiektu wywołującego w pamięci podręcznej.  2.  Implementacja obiektu w pamięci podręcznej, należy usunąć wpis pamięci podręcznej, który jest skojarzony z Zmiana zależności.</para>
        </block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Dane dla zdarzenia zmiany. Ta wartość może być <see langword="null" />.</param>
        <summary>Metoda wywoływana przez klasy pochodne, aby zgłosić zdarzenie, gdy ulegnie zmianie zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana, gdy wystąpią zmiany zależności. <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Metoda również jest wywoływane, gdy wystąpienie Monitora zmiany zostanie usunięty, ale usuwania występuje tylko wtedy, gdy wywołanie zwrotne, które nie zostało już wywołane.  
  
 Jeśli <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metoda jest wywoływana przed <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metoda jest wywoływana, dane o stanie z wywołania <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodę jest zapisywany przez implementację pamięci podręcznej. Ponadto wywołanie zwrotne w celu <xref:System.Runtime.Caching.OnChangedCallback> metoda jest wywoływana bezpośrednio po <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która reprezentuje <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia klasy.</summary>
        <value>Identyfikator wystąpienia zmiany monitora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> Wartość właściwości zwykle składa się z dane ciągu nazwy w połączeniu zależności który jednoznacznie identyfikatory danych, który jest monitorowany przez <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia. Wartość <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> właściwość ma postać ciągu. Wartość ciągu jest używana do przypisywania Unikatowy identyfikator <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Przez zastąpienie właściwości, można zdefiniować niestandardową implementację właściwości dla wartości ciągu, aby można było przypisać mu unikatowy identyfikator.</para>
        </block>
        <block subset="none" type="overrides">
          <para>W klasach pochodnych należy ustawić wartość właściwości w konstruktorze.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
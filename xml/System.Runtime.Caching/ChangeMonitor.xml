<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ed10988d07dceeceb8c3790eaec2ec2b9b04d9fa" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69275585" /></Metadata><TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia klasę bazową dla pochodnego typu niestandardowego, która monitoruje zmiany stanu danych, od których zależy element pamięci podręcznej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Klasa jest używana jako klasa bazowa dla pochodnych klas monitora, które są wyspecjalizowane dla konkretnych implementacji pamięci podręcznej. <xref:System.Runtime.Caching.ChangeMonitor> Wystąpienie monitoruje zmiany stanu danych, od których zależy element pamięci podręcznej. Na przykład element może być plikiem lub obiektem danych, którego zawartość jest buforowana. W przypadku zaktualizowania pliku lub jednostki danych należy również zmienić skojarzony wpis pamięci podręcznej. Typowe elementy, które można monitorować, obejmują jednostki danych (takie jak pola bazy danych, wartości, wiersze lub tabele), inne wpisy w pamięci podręcznej oraz pliki i atrybuty plików.  
  
 Zmiana zależności to zmiana stanu zależności. W typowej implementacji pamięci podręcznej <xref:System.Runtime.Caching.ChangeMonitor> po wystąpieniu powiadamia pamięć podręczną o zmianie zależności, pamięć podręczna wykonuje wymagane działanie, na przykład unieważnienie wstawionego wpisu pamięci podręcznej.  
  
 Klasy <xref:System.Runtime.Caching.ChangeMonitor> pochodne można dostosować do monitorowania zmian zależności dla określonych różnych magazynów danych. Na przykład istnieją implementacje pamięci podręcznej dla systemu plików, pamięci fizycznej lub bazy danych. <xref:System.Runtime.Caching.ChangeMonitor> Klasa bada zmiany, które wystąpiły poza pamięcią podręczną, a następnie generuje alert w pamięci podręcznej, że zmiany zostały wprowadzone.  
  
 Zawiera następujące klasy, które pochodzą z <xref:System.Runtime.Caching.ChangeMonitor> klasy: [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Każda z tych klas działa z różnymi typami zależności. Na przykład Klasa pochodna <xref:System.Runtime.Caching.FileChangeMonitor> monitoruje zmiany w pamięci podręcznej dla danych systemu plików (plików i folderów), od których zależy element pamięci podręcznej.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides"><para>W przypadku tworzenia niestandardowej implementacji pamięci podręcznej lub typu monitora zmian pochodnych należy przestrzegać pewnych wytycznych. Poniższa lista zawiera podsumowanie tych wytycznych. Aby uzyskać więcej informacji, zobacz dokumentację dotyczącą poszczególnych metod lub właściwości.  
  
-Konstruktor klasy pochodnej musi mieć ustawioną <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> właściwość, rozpoczęcie monitorowania i metodę wywołania <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> przed zwróceniem metody. Jeśli Konstruktor napotka błąd podczas konstruowania i musi <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> mieć do Dispose zasobów, Konstruktor może wywołać Przeciążenie tylko <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> po wywołaniu <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metody, ponieważ Przeciążenie spowoduje zgłoszenie <see cref="T:System.InvalidOperationException" /> wyjątek, jeśli Inicjalizacja nie została ukończona.  
  
— Jeśli zmiany są wykonywane w monitorowanych danych przed ukończeniem inicjalizacji, Konstruktor musi wywołać <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metodę przed <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> wywołaniem metody.  
  
-Po utworzeniu wystąpienia <see cref="T:System.Runtime.Caching.ChangeMonitor" /> typu pochodnego należy wstawić monitor do implementacji niestandardowej. <see cref="T:System.Runtime.Caching.ObjectCache" /> Lub jeśli skończysz korzystać z monitora zmian, wywołaj <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodę.  
  
-Po <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wstawieniu wystąpienia <see cref="T:System.Runtime.Caching.ObjectCache" /> do implementacji, <see cref="T:System.Runtime.Caching.ObjectCache" /> wystąpienie wymaga usunięcia monitora zmian. Nawet jeśli wstawienie jest nieprawidłowe i powoduje wyjątek, <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacja musi <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> wywoływać przeciążenie.  
  
-Po wstawieniu monitora zmian pochodnych do pamięci podręcznej <see cref="T:System.Runtime.Caching.ObjectCache" /> implementacja musi wywołać metodę <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, przekazując <see cref="T:System.Runtime.Caching.OnChangedCallback" /> obiekt. <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Metodę można wywołać tylko raz. Jeśli zmiana zależności już wystąpi, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wystąpienie zostanie wywołane natychmiast po <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> wywołaniu. W przeciwnym razie wystąpienie zostanie wywołane tylko raz. <see cref="T:System.Runtime.Caching.OnChangedCallback" /> To <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> jednorazowe wywołanie występuje, gdy wywoływana jest metoda, <see cref="T:System.Runtime.Caching.ChangeMonitor" /> ponieważ wystąpienie wykryło <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> zmianę lub gdy metoda jest wywoływana w <see cref="T:System.Runtime.Caching.ChangeMonitor" />, w zależności od tego, co się dzieje.  
  
-Wystąpienie dostarczone <see cref="T:System.Runtime.Caching.ObjectCache" /> przez implementację powinno usunąć skojarzoną pozycję pamięci podręcznej i określić przyczynę przy użyciu <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> wyliczenia. <see cref="T:System.Runtime.Caching.OnChangedCallback" />  
  
-Wystąpienie może <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> wywołać metodę albo przed implementacją pamięci podręcznej o <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> wywołaniu metody lub po. <see cref="T:System.Runtime.Caching.ChangeMonitor" /> <see cref="T:System.Runtime.Caching.ChangeMonitor" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Jeśli metoda jest wywoływana przed <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> wywołaniem, implementacja podstawowa będzie powiadamiać pamięć podręczną o tym, że wystąpiła, i wyzwoli wywołanie zwrotne do natychmiast po wywołaniu. <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Wszystkie dane stanu, które są przesyłane do <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metody są zapisywane przez Monitor zmian, a następnie przekazywać <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> do metody, gdy <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> wywoływana jest metoda.  
  
-Monitor zmian musi implementować <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> metodę. Aby uzyskać więcej informacji, zobacz <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> dokumentację metody.  
  
-Przeciążenie <see cref="T:System.Runtime.Caching.ChangeMonitor" /> metody musi być wywołana do usuwania wystąpienia. <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Reguły wywoływania metody Dispose są następujące: 
-Przed wstawieniem elementu do pamięci podręcznej jest odpowiedzialny obiekt wywołujący do usuwania <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia.  
  
— Gdy element pamięci podręcznej i <see cref="T:System.Runtime.Caching.ChangeMonitor" /> skojarzone z nim wystąpienia są przesyłane do pamięci podręcznej, implementacja pamięci podręcznej musi upewnić się, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> że metoda jest wywoływana, nawet jeśli nie powiedzie się Wstawianie.  
  
-Po przekazaniu elementu i <see cref="T:System.Runtime.Caching.ChangeMonitor" /> skojarzonych z nim wystąpień do pamięci podręcznej obiekt wywołujący nie może usunąć zależności, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> ponieważ gdy metoda jest wywoływana, wywołanie jest traktowane tak, jakby zależność została zmieniona. W efekcie <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Metoda jest wywoływana automatycznie.  
  
Biorąc pod uwagę te reguły, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Metoda musi być wywoływana w jeden z następujących sposobów: 
— Użytkownicy muszą wywoływać <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Przeciążenie metody, jeśli zdecydują się nie wstawić pochodnego wystąpienia zmiany-monitora do pamięci podręcznej.  
  
— Jeśli implementacja próbuje wstawić wystąpienie usługi Change-monitor do pamięci podręcznej obiektów, ale operacja wstawiania nie powiedzie się, implementacja pamięci podręcznej jest odpowiedzialna za wywołanie <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> przeciążenia. Gdy próba wstawienia powoduje wyjątek, implementacja pamięci podręcznej musi dysponować wszystkimi skojarzonymi zależnościami.  
  
— Jeśli wpis pamięci podręcznej zostanie usunięty, implementacja pamięci podręcznej musi również usunąć zależność.  
  
— Wewnętrzna implementacja <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> metody automatycznie <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> wywołuje metodę po wywołaniu wywołania zwrotnego, które jest rejestrowane za pomocą <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  
  
 <block subset="none" type="note"><para>  
 To automatyczne wywołanie metody Dispose w trakcie wyzwalania zdarzenia występuje tylko wtedy, gdy Inicjalizacja <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia została wcześniej ukończona.  
  
</para></block>  
  
 Gdy Konstruktor pochodnego monitora zmian wywołuje <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> metodę, jeśli stan monitora zmian został już zmieniony (oznacza to, że monitorowany stan został już zmieniony, gdy Konstruktor był nadal aktywny), <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> a następnie metoda zostanie Automatycznie usuwaj monitor zmian.  
  
<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> <see cref="T:System.Runtime.Caching.OnChangedCallback" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> -Właściwość jest ustawiona na <see langword="true" /> po wywołaniu metody przez pochodne wystąpienie monitora zmian, niezależnie od tego, czy obiekt został ustawiony przez wywołanie metody, czy nie. <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /></para></block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/ac11c8ea-df5d-4de8-b315-9ccf1048b0ce">Buforowanie ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy. Ten konstruktor jest wywoływany z konstruktorów w klasach pochodnych w celu zainicjowania klasy bazowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> Klasa ma Konstruktor bez parametrów. Jednak klasy dziedziczące z klasy podstawowej <xref:System.Runtime.Caching.ChangeMonitor> i definiują niestandardowe zachowanie monitorowania zmian muszą wykonać inicjalizację w konstruktorze. Aby uzyskać więcej informacji, zapoznaj się z sekcją uwagi dotyczące dziedziczenia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Konstruktor klasy pochodnej musi ustawiać <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> właściwość, rozpoczynać monitorowanie i <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> wywoływać klasę przed zwróceniem. Jeśli zależność zostanie zmieniona przed ukończeniem inicjalizacji (na przykład jeśli w pamięci podręcznej nie znaleziono zależnego klucza pamięci podręcznej), Konstruktor <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> musi wywołać metodę przed <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> wywołaniem metody. W takim przypadku Konstruktor może wywołać <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodę dopiero <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> po wywołaniu metody, ponieważ <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Metoda zgłasza wyjątek, jeśli Inicjalizacja nie została ukończona.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest używana do <xref:System.Runtime.Caching.ChangeMonitor> zwalniania wystąpienia i powiązanych zasobów. <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Metoda publiczna <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> jest wywoływana w celu koordynowania procesu usuwania przy użyciu zdarzeń cykl życia kluczy pochodnych pochodnej klasy monitorowania (na przykład inicjalizacji) i <xref:System.Runtime.Caching.ChangeMonitor> zwolnienia wystąpienia, tak aby wystąpienie może być zbierane jako elementy bezużyteczne. <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Metoda jest implementowana przez pochodne klasy monitora zmian do usuwania zasobów zarządzanych i niezarządzanych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są używane przez bieżące wystąpienie <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Metoda<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> wywołuje metodę klasy pochodnej tylko jeden raz, przy pierwszym wywołaniu. Kolejne wywołania <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody nie mają żadnego efektu. Po wywołaniu <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> metody właściwość jest ustawiana na `true`.  
  
 Przeciążenie <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> należy wywołać, aby usunąć <xref:System.Runtime.Caching.ChangeMonitor> wystąpienie. Poniżej przedstawiono reguły wywoływania metody Dispose:  
  
-   Zanim element zostanie wstawiony do pamięci podręcznej, jest on odpowiedzialny za <xref:System.Runtime.Caching.ChangeMonitor> usuwanie wystąpienia.  
  
-   Gdy element pamięci podręcznej i <xref:System.Runtime.Caching.ChangeMonitor> skojarzone z nim wystąpienia są przesyłane do pamięci podręcznej, implementacja pamięci podręcznej musi upewnić się, że <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> jest wywoływana, nawet jeśli nie powiedzie się Wstawianie.  
  
-   Gdy element i jego skojarzone <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia są przesyłane do pamięci podręcznej, obiekt wywołujący nie może usunąć zależności, ponieważ gdy Metodajestwywoływana,wywołaniejesttraktowanetak,jakbyzależnośćzostałazmieniona.<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> W efekcie <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Metoda jest wywoływana automatycznie.  
  
-   Biorąc pod uwagę te reguły, <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Metoda musi być wywoływana w jeden z następujących sposobów:  
  
    -   Użytkownicy muszą wywoływać <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Przeciążenie metody, jeśli zdecydują, że nie należy wstawiać pochodnego wystąpienia zmian-monitor do pamięci podręcznej.  
  
    -   Implementacja pamięci podręcznej jest odpowiedzialna <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> za wywołanie przeciążenia, jeśli implementacja próbuje wstawić wystąpienie monitorowania zmian do pamięci podręcznej obiektów, ale nie można wykonać operacji wstawiania. Gdy próba wstawienia powoduje wyjątek, implementacja pamięci podręcznej musi usunąć wszystkie skojarzone zależności.  
  
    -   W przypadku usunięcia wpisu pamięci podręcznej, implementacja pamięci podręcznej musi również zlikwidować zależność.  
  
 Wewnętrzna implementacja <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metody automatycznie <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> wywołuje metodę po wywołaniu wywołania zwrotnego <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> , które jest zarejestrowane za pomocą metody.  
  
> [!NOTE]
>  Ta automatyczna metoda Dispose podczas wyzwalania zdarzenia występuje tylko wtedy, gdy Inicjalizacja <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia została wcześniej ukończona.  
  
 Gdy Konstruktor pochodnego monitora zmian wywołuje <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> metodę, jeśli stan monitora zmian został już zmieniony (oznacza to, że monitorowany stan został już zmieniony, gdy Konstruktor był nadal aktywny), a następnie <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> Metoda zostanie automatycznie Usuń monitor zmian.  
  
> [!NOTE]
>  Użytkownicy nie powinni wywoływać <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody. Nie można jednak uniemożliwić użytkownikom wywoływania metody. W związku z <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> tym, metoda jest wywoływana. W takim przypadku wpis pamięci podręcznej zostanie powiadomiony, jakby zmieniono zależność.  
  
 Aby zapobiec klasie pochodnej przed zastępowaniem <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metody, metoda nie jest jawną implementacją interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Inicjalizacja nie została ukończona w pochodnej klasie monitora zmian, która wywołała metodę bazową <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> .</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />zwalnianie zasobów zarządzanych i niezarządzanych oraz dowolnych <see cref="T:System.Runtime.Caching.ChangeMonitor" /> odwołań do wystąpienia; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych. Gdy <see langword="false" /> jest przekazano <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> , <see langword="finalizer" /> Metoda jest wywoływana przez wątek, a wszystkie zewnętrzne odwołania zarządzane prawdopodobnie nie są już prawidłowe, ponieważ zostały już pobrane jako elementy bezużyteczne.</param>
        <summary>Zwalnia wszystkie zasoby zarządzane i niezarządzane oraz wszystkie odwołania do <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienia. To Przeciążenie musi być zaimplementowane przez pochodne klasy monitora zmian.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wartość `disposing` jest `true`równa, wszystkie zarządzane i niezarządzane zasoby są usuwane i wszystkie odwołania do tego obiektu są zwalniane, aby pochodne wystąpienie monitora zmian może być zbierane jako elementy bezużyteczne. Jest gwarantowane, że metoda <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> podstawowa wywoła zaimplementowaną <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodę tylko jeden raz.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Monitor zmian musi zaimplementować Przeciążenie, <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> aby zwolnić wszystkie zarządzane i niezarządzane zasoby, gdy <paramref name="disposing" /> wartość jest <see langword="true" />. Przeciążenie metody, która <paramref name="disposing" /> ma wartość <see langword="true" /> , jest wywoływana tylko raz, a mianowicie, gdy wystąpienie zostanie usunięte po raz pierwszy. <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Monitor zmian nie może wywoływać <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> bezpośredniego przeciążenia. Pochodny monitor zmian może wywoływać publiczną <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodę bez parametrów w klasie bazowej. <see cref="T:System.Runtime.Caching.ChangeMonitor" />  
  
Alternatywnie, monitor zmian może zaimplementować metodę finalizatora. W takim przypadku finalizator może wywołać <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> metodę i przekazać ją do <paramref name="disposing" /> wartości <see langword="false" />. Jest to jednak zwykle zbędne. Monitorowanie zmian zależności jest zwykle wykonywane przez usługę, która utrzymuje odwołanie do wystąpienia zmiany-monitor. Odwołanie uniemożliwia wystąpienie nie jest zbierane jako elementy bezużyteczne i w związku z tym sprawia, że metoda finalizatora nie jest konieczna. Aby uniknąć przecieków pamięci, gdy zmienia się zależność, <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Metoda usuwa wystąpienie z monitorem zmian (chyba że inicjalizacja nie została ukończona).</para></block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje, że stan monitorowany przez <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasę został zmieniony.</summary>
        <value><see langword="true" />Jeśli stan monitorowany przez <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienie został zmieniony; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz sprawdzić wartość tej właściwości w klasie pochodnej <xref:System.Runtime.Caching.ChangeMonitor> , aby sprawdzić, czy zależność została zmieniona.  
  
 Wartość jest ustawiana `true` po wystąpieniu zmiany zależności (to jest, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> gdy wywoływana jest metoda). <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> <xref:System.Runtime.Caching.OnChangedCallback> `true` <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Po wywołaniu metodyprzezklasępochodnąwartośćwłaściwościbędzie,niezależnieodtego,czywystąpieniezostałopowiadomioneprzezwywołaniemetody.<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>  
  
> [!NOTE]
>  Obiekty wywołujące mogą sprawdzić <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwość, aby sprawdzić, czy zależność została zmieniona. Jednak w środowisku wielowątkowym prostsze i bardziej łatwiejsze w obsłudze podejście polega na wstawieniu danych do implementacji pamięci podręcznej bez sprawdzania <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> właściwości. Implementacje pamięci podręcznej muszą sprawdzać <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Właściwość i nie mogą wykonać operacji INSERT ani Set, jeśli co najmniej jedna skojarzona z nią zależność została już zmieniona.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana z konstruktora klas pochodnych, aby wskazać, że inicjalizacja została zakończona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zależność zmian przed inicjalizacją zostanie zakończona w klasie pochodnej, Konstruktor klasy pochodnej musi wywołać <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metodę.  
  
 Gdy metoda jest wywoływana <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> , właściwość jest automatycznie ustawiana na `true` przez Monitor zmian. <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> W związku z tym, gdy Konstruktor zmiany wywoła <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> metodę, Klasa bazowa automatycznie <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> wywoła metodę. Jeśli inicjalizacja zakończyła <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> się, metoda automatycznie usuwa pochodne wystąpienie monitora zmian.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Konstruktor klasy pochodnej musi wywoływać metodę bazową <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> przed zwróceniem konstruktora. Konstruktor klasy pochodnej może wywoływać <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> metodę tylko po <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> wywołaniu metody, ponieważ <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Metoda zgłasza wyjątek, jeśli Inicjalizacja nie została ukończona.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje, że pochodne wystąpienie <see cref="T:System.Runtime.Caching.ChangeMonitor" /> klasy zostało usunięte.</summary>
        <value><see langword="true" />Jeśli wystąpienie zostanie usunięte; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest ustawiona na `true` , gdy metoda bazowa <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> wywoła <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> metodę w klasie pochodnej do usuwania wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Odwołanie do metody, która jest wywoływana, gdy zależność została zmieniona.</param>
        <summary>Wywoływane przez implementacje pamięci podręcznej w celu zarejestrowania <see cref="T:System.Runtime.Caching.ObjectCache" /> wywołania zwrotnego <see cref="T:System.Runtime.Caching.OnChangedCallback" /> i powiadomienia wystąpienia za pomocą delegata, gdy zależność została zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje pamięci podręcznej używają tej metody do połączenia się z monitorem zmian. W przypadku skojarzenia co najmniej jednego monitora zmian z elementem pamięci podręcznej do elementu <xref:System.Runtime.Caching.CacheItemPolicy> pamięci podręcznej zostanie przekazane wystąpienie z wypełnioną właściwością monitorowanych zmian. Realizator pamięci podręcznej obsługujący monitory zmian jest odpowiedzialny za iterację <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> właściwości i <xref:System.Runtime.Caching.OnChangedCallback> rejestrowanie delegatów z każdym znalezionym monitorem zmian.  
  
 <xref:System.Runtime.Caching.OnChangedCallback> Ponieważ delegat zawiera opcjonalny parametr stanu, konkretna implementacja monitora zmian może przekazać opcjonalne informacje o stanie. Implementacja pamięci podręcznej określa, czy w ramach wywołania zwrotnego można wykonać jawną zależność od typu stanu, który jest przekazywany przez niestandardowy monitor zmian.  
  
> [!NOTE]
>  Interfejs API rozszerzalności podstawowej pamięci podręcznej nie jest wymagany dla jawnej zależności od typu stanu.  
  
 Implementacja <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> metody automatycznie określa, czy stan monitora został już zmieniony w momencie <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> wywołania metody. Jeśli właściwość ma `true`wartość, metoda automatycznie wywołuje <xref:System.Runtime.Caching.OnChangedCallback> <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> procedurę obsługi zdarzeń, która została zarejestrowana za pomocą metody. <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Dzieje się tak, ponieważ istnieje możliwość, że od momentu utworzenia przez implementację pamięci podręcznej monitora zmian, w czasie gdy implementacja pamięci podręcznej pobiera monitor i nastąpi do niego okablowanie, zmieniony stan monitorowania uległ zmianie. Jeśli stan został już zmieniony, obiekt, który jest przesyłany do <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> metody to. `null`  
  
 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Metoda może być wywoływana tylko jeden raz i będzie zgłaszać wyjątek przy kolejnych wywołaniach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda wywołania zwrotnego została już wywołana.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="onChangedCallback" />jest <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>1.  Należy wywołać metodę, <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aby otrzymywać powiadomienia o wszelkich zmianach zależności. Jeśli ta <see cref="T:System.Runtime.Caching.OnChangedCallback" /> zmiana zależności już wystąpi, wystąpienie zostanie wywołane, gdy <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> zostanie wywołane. W przeciwnym razie <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> wystąpienie zostanie wywołane jednokrotnie, gdy wywoływana jest metoda lub gdy wywoływana jest metoda, w zależności od tego, która występuje w <see cref="T:System.Runtime.Caching.OnChangedCallback" /> pierwszej kolejności. <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Wystąpienie zapewniane przez implementację pamięci podręcznej powinno usunąć wpis pamięci podręcznej i jeśli jest żądane przez obiekt wywołujący pamięci podręcznej, podwyższyć wymagane zdarzenie zmiany lub aktualizacji z powrotem do oryginalnego obiektu wywołującego pamięci podręcznej.  
  
2.  Implementacja pamięci podręcznej obiektów musi usunąć wpis pamięci podręcznej, który jest skojarzony ze zmianą zależności.</para></block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Dane dla zdarzenia zmiany. Ta wartość może być <see langword="null" />równa.</param>
        <summary>Wywoływane przez klasy pochodne, aby zgłosić zdarzenie w przypadku zmiany zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Metoda jest wywoływana, gdy występuje zmiana zależności. Metoda <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> jest również wywoływana, gdy wystąpienie monitora zmian jest usuwane, ale usuwanie następuje tylko wtedy, gdy wywołanie zwrotne nie zostało już wywołane.  
  
 Jeśli metoda jest wywoływana <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> przed wywołaniem metody, dane stanu <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> z wywołania metody są zapisywane przez implementację pamięci podręcznej. <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Ponadto wywołanie zwrotne do <xref:System.Runtime.Caching.OnChangedCallback> metody jest wywoływana natychmiast <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> po wywołaniu metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość reprezentującą <see cref="T:System.Runtime.Caching.ChangeMonitor" /> wystąpienie klasy.</summary>
        <value>Identyfikator wystąpienia zmiany-monitora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości zwykle składa się z nazw zależności połączonych ciągów, które jednoznacznie identyfikują dane monitorowane <xref:System.Runtime.Caching.ChangeMonitor> przez wystąpienie. <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> Wartość <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> właściwości jest ciągiem. Wartość ciągu służy do przypisywania unikatowego identyfikatora <xref:System.Runtime.Caching.ChangeMonitor> wystąpienia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastępując właściwość, można zdefiniować implementację niestandardową dla wartości ciągu właściwości w celu przypisania jej do unikatowego identyfikatora.</para></block>
        <block subset="none" type="overrides"><para>W klasach pochodnych należy ustawić wartość właściwości w konstruktorze.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c6cf59a4e0d40381714770602c4fb0166959aab6" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55313040" /></Metadata><TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryCache = class&#xA;    inherit ObjectCache&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje typ, który implementuje w pamięci podręcznej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache> Klasa jest konkretną implementację abstrakcyjnej <xref:System.Runtime.Caching.ObjectCache> klasy.  
  
> [!NOTE]
>  <xref:System.Runtime.Caching.MemoryCache> Klasa jest podobna do platformy ASP.NET <xref:System.Web.Caching.Cache> klasy. <xref:System.Runtime.Caching.MemoryCache> Klasy zawiera wiele właściwości i metod dostępu do pamięci podręcznej, który ma być znane, jeśli używasz platformy ASP.NET <xref:System.Web.Caching.Cache> klasy. Główne różnice między <xref:System.Web.Caching.Cache> i <xref:System.Runtime.Caching.MemoryCache> klasy, które są <xref:System.Runtime.Caching.MemoryCache> klasy został zmieniony na wymagane przez [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] aplikacje, które nie są aplikacjami ASP.NET. Na przykład <xref:System.Runtime.Caching.MemoryCache> klasa nie ma zależności `System.Web` zestawu. Inny różnica polega na tym, możesz utworzyć wiele wystąpień <xref:System.Runtime.Caching.MemoryCache> klasy do użycia w tej samej aplikacji w taki sam <xref:System.AppDomain> wystąpienia.  
  
 <xref:System.Runtime.Caching.MemoryCache> Klasy nie zezwala na `null` jako wartość w pamięci podręcznej. Dowolne próba Dodaj lub zmień wpis pamięci podręcznej z wartością `null` zakończy się niepowodzeniem.  
  
 <xref:System.Runtime.Caching.MemoryCache> Typ nie implementuje *regionów w pamięci podręcznej*. W związku z tym, gdy wywołujesz <xref:System.Runtime.Caching.MemoryCache> metody, które implementują metod bazowych, które zawierają parametr dla regionów, nie przekazuj wartości dla parametru. Metody, które używają parametru regionu wszystkie podać domyślny `null` wartość. Na przykład <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> przeciążenia metody ma `regionName` parametr, którego wartość domyślna to `null`.  
  
   
  
## Examples  
 Poniższy przykład deklaruje odwołanie do domyślnego wystąpienia pamięci podręcznej pamięci. Wpis pamięci podręcznej <xref:System.Runtime.Caching.CacheItemPolicy> obiektu, aby podać szczegóły wykluczania i wygaśnięcia wpisu pamięci podręcznej. Korzysta również <xref:System.Runtime.Caching.ChangeMonitor> obiektów do monitorowania stanu źródła danych (jest to plik) w systemie plików.  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/942236f6-0138-4aaf-af71-a5ea451a1e23">Przewodnik: Buforowanie danych aplikacji na platformie ASP.NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/c4b47ee0-4b82-4124-9bce-818088385e34">Buforowanie w aplikacjach .NET Framework</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = null)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia w celu wyszukania informacji o konfiguracji.  
  
 <c>Uwaga</c> nie jest to wymagane informacje dotyczące konfiguracji zapewniającej istnieje dla każdej nazwy.  
  
Jeśli istnieje zgodnego wpisu konfiguracji, informacje o konfiguracji jest używany do konfigurowania <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia. Jeśli nie ma zgodnego wpisu konfiguracji, nazwa jest możliwy za pośrednictwem <see cref="P:System.Runtime.Caching.MemoryCache.Name" /> właściwość, ponieważ podana nazwa jest skojarzona z <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia. Dla informacji na temat konfigurowania pamięci podręcznej pamięci <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />.</param>
        <param name="config">Kolekcja par nazwa/wartość informacji o konfiguracji służące do konfigurowania pamięci podręcznej.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Runtime.Caching.MemoryCache> klasa jest inicjowana, sprawdzane są wpisy konfiguracji, które mogą poprawić przy użyciu opcjonalnego `config` parametr w konstruktorze. Można przekazać następujących parametrów w `config` parametru. Wszystkie wartości mogą być przekazywane jako liczby całkowite.  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 Gdy ten konstruktor jest wywoływany, ustawienia konfiguracji najpierw są pobierane z plików konfiguracji aplikacji. Jeśli istnieje żadnych wpisów konfiguracji w pliku konfiguracyjnym aplikacji, tylko ustawienia podane w `config` są stosowane. Wpisów konfiguracji w konfiguracji aplikacji, a także przekazanych informacji `config`, informacje zawarte w `config` zastępuje informacje, które są odczytywane z pliku konfiguracji.  
  
 Wartość nazwy, która jest przypisana do wystąpienia pamięci podręcznej jest używany na dwa sposoby:  
  
-   Aby ułatwić Ci śledzić wiele wystąpień pamięci podręcznej, jeśli istnieje więcej niż jedno wystąpienie.  
  
-   Aby odwołać się do ustawienia w konfiguracji pliku, kiedy <xref:System.Runtime.Caching.MemoryCache> zainicjowano wystąpienia.  
  
    > [!NOTE]
    >  Nie ma mechanizmu do wymuszania unikatowej nazwy dla wystąpienia pamięci podręcznej. W związku z tym istnieje możliwość mają wiele wystąpień pamięci podręcznej o takiej samej nazwie.  
  
    > [!CAUTION]
    >  Nie należy tworzyć <xref:System.Runtime.Caching.MemoryCache> wystąpień, chyba że jest to wymagane. Jeśli tworzysz wystąpienia pamięci podręcznej klienta i aplikacji sieci Web <xref:System.Runtime.Caching.MemoryCache> wystąpienia należy utworzyć na wczesnym etapie cyklu życia aplikacji. Należy utworzyć tylko liczbę wystąpień pamięci podręcznej, które będą używane w aplikacji i są przechowywane odwołania do wystąpienia pamięci podręcznej w zmiennych, które mogą być udostępniane globalnie. Na przykład w aplikacji ASP.NET, można przechowywać odwołania w stan aplikacji. Jeśli tworzysz instancję jednej pamięci podręcznej w aplikacji przy użyciu pamięci podręcznej domyślne i odwołać się do niej <xref:System.Runtime.Caching.MemoryCache.Default%2A> właściwości, gdy potrzebujesz dostępu do pamięci podręcznej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa lub wartość w <paramref name="config" /> nie można przeanalizować parametru.</exception>
        <exception cref="T:System.Configuration.ConfigurationException">Wartość w <paramref name="config" /> kolekcji jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection * bool -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config, ignoreConfigSection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia w celu wyszukania informacji o konfiguracji.</param>
        <param name="config">Kolekcja par nazwa/wartość informacji o konfiguracji służące do konfigurowania pamięci podręcznej.</param>
        <param name="ignoreConfigSection">Wskazuje, czy mają być ignorowane w sekcji konfiguracji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="memoryCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpieniu oraz dodaje szczegółowe informacje o jak wykluczyć wpis.</summary>
        <returns>wartość true, jeśli wstawienie powiodło się lub false, jeśli istnieje już wpis w pamięci podręcznej, która ma taki sam klucz jako element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> i <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody nie obsługują <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości. W związku z tym aby ustawić <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwość dla wpisu pamięci podręcznej, użyj <xref:System.Runtime.Caching.MemoryCache.Set%2A> zamiast przeciążenia metod.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A> Przeciążenia metody są używane do wstawienia wpis pamięci podręcznej w pamięci podręcznej. Jeśli wpis pamięci podręcznej za pomocą dopasowany klucz nie istnieje, te metody Wstaw nowy wpis. Jeśli wpis pamięci podręcznej za pomocą dopasowany klucz już istnieje, zwracają one istniejący wpis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.AddOrGetExisting (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <summary>Dodaje wpis pamięci podręcznej w pamięci podręcznej przy użyciu określonego <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienie i szczegółowe informacje na temat wykluczenia wpis.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, istniejący wpis pamięci podręcznej; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `item` Parametr dostarcza klucz i wartość, która jest używana przez metodę. Jeśli pamięć podręczna zawiera wpis pamięci podręcznej przy użyciu tego samego klucza jako klucz `item` parametr, metoda zwraca wartość istniejącego wpisu jako <xref:System.Runtime.Caching.CacheItem> wystąpienia. Jeśli brak istniejącego wpisu pamięci podręcznej, ta metoda tworzy nową przy użyciu klucza i wartości dostarczone przez `item` parametru i przy użyciu szczegółów eksmisji, określony przez `policy`.  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> i <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody nie obsługują <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości. W związku z tym aby ustawić <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwość dla wpisu pamięci podręcznej, użyj <xref:System.Runtime.Caching.MemoryCache.Set%2A> zamiast przeciążenia metod.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Runtime.Caching.CacheItem.Value" /> Właściwość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Bezwzględna i przedłużanie ważności wartości <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości innej niż wartości domyślne ze <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pola. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy nie można ustawić zasady wygasania, oparte na kombinacji bezwzględnych wygaśnięcia i wygaśniecie. Tylko jedno ustawienie wygaśnięcia może być jawnie ustawione, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia. Ustawienie wygaśnięcia musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> pola lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pola.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość mniej niż <see cref="F:System.TimeSpan.Zero" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwości ustawiono wartość większa niż jeden rok.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej dodać.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="absoluteExpiration">Ustalona data i godzina wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Dodaje wpis pamięci podręcznej w pamięci podręcznej przy użyciu określonego klucza i wartości i wartości bezwzględne wygasania.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, istniejący wpis pamięci podręcznej; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pamięć podręczna nie ma wpisu pamięci podręcznej którego klucza dopasowania `key` parametru utworzony nowy wpis pamięci podręcznej i <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> przeciążenie metody zwraca `null`. Jeśli istnieje zgodnego wpisu pamięci podręcznej, zwracany jest istniejący wpis.  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> i <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody nie obsługują <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości. W związku z tym aby ustawić <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwość dla wpisu pamięci podręcznej, użyj <xref:System.Runtime.Caching.MemoryCache.Set%2A> zamiast przeciążenia metod.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Bezwzględna i przedłużanie ważności wartości <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości innej niż wartości domyślne ze <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pola. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy nie można ustawić zasady wygasania, oparte na kombinacji bezwzględnych wygaśnięcia i wygaśniecie. Tylko jedno ustawienie wygaśnięcia może być jawnie ustawione, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia. Ustawienie wygaśnięcia musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość mniej niż <see cref="F:System.TimeSpan.Zero" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwości ustawiono wartość większa niż jeden rok.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej dodać lub pobrać.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej. Nie przekazuj wartości tego parametru. Domyślnie ten parametr jest <see langword="null" />, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej przy użyciu określonego klucza i wartości i określonymi szczegółami jak to wykluczenie.</summary>
        <returns>Jeśli wpis pamięci podręcznej pasującego już istnieje, wpis pamięci podręcznej; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> i <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> przeciążenia metody nie obsługują <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości. W związku z tym aby ustawić <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwość dla wpisu pamięci podręcznej, użyj <xref:System.Runtime.Caching.MemoryCache.Set%2A> zamiast przeciążenia metod.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Bezwzględna i przedłużanie ważności wartości <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości innej niż wartości domyślne ze <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy nie można ustawić zasady wygasania, oparte na kombinacji wygaśniecie i bezwzględnej. Tylko jedno ustawienie wygaśnięcia może być jawnie ustawione, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy. Inne ustawienie musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
—lub— 
Wywołanie zwrotne usuwania i wywołania zwrotnego aktualizacji zostały określone dla <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. <see cref="T:System.Runtime.Caching.MemoryCache" /> Obsługuje tylko przy użyciu jednego typu wywołania zwrotnego dla pamięci podręcznej zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość mniej niż <see cref="F:System.TimeSpan.Zero" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Została ustawiona na wartość większą niż rok.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci na komputerze, w bajtach, które mogą być używane przez pamięć podręczną.</summary>
        <value>Ilość pamięci w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżące wystąpienie pamięci podręcznej przekracza limit pamięci ustawione przez <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> właściwości implementację buforu usuwa wpisy w pamięci podręcznej. Każde wystąpienie pamięci podręcznej w aplikacji może używać ilości pamięci, który jest określony przez <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> właściwości.  
  
 Ustawienia dla <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> właściwość może być określona w pliku konfiguracyjnym aplikacji. Alternatywnie mogą być przekazywane w Konstruktorze podczas <xref:System.Runtime.Caching.MemoryCache> klasa jest inicjowana. Aby uzyskać więcej informacji na temat konfigurowania tej właściwości, zobacz [ &lt;namedCaches&gt; — Element (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Aby uzyskać więcej informacji o sposobie Ustaw tę wartość przy <xref:System.Runtime.Caching.MemoryCache> klasy jest inicjowany, zobacz <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> metody.  
  
 <xref:System.Runtime.Caching.MemoryCache> nie wymusza natychmiastowe <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> każdym dodaniu nowego elementu do <xref:System.Runtime.Caching.MemoryCache> wystąpienia. Wewnętrzne algorytmy heurystyczne, który wyklucza mogą dodatkowe elementy z <xref:System.Runtime.Caching.MemoryCache> zrobi to stopniowo i uwzględnia informacje o koncie z modułu odśmiecania pamięci (zobacz [wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/index.md)) oraz innych czynników, takich jak bieżący rozmiar pamięci podręcznej i ogólne wykorzystanie pamięci systemu. W związku z tym nawet jeśli <xref:System.Runtime.Caching.MemoryCache> próbuje zachować rozmiar pamięci podręcznej w ramach skonfigurowanych <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> można tymczasowo przekraczają limit, dodając elementy pamięci podręcznej z bardzo dużą szybkością.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; — Element (ustawienia pamięci podręcznej)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Contains : string * string -&gt; bool" Usage="memoryCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej wyszukać.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Określa, czy wpis pamięci podręcznej istnieje w pamięci podręcznej.</summary>
        <returns><see langword="true" /> Jeśli pamięć podręczna zawiera wpis pamięci podręcznej, w których klucz pasuje <paramref name="key" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="override this.CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="memoryCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Wyliczenie wpisu pamięci podręcznej unikatowe klucze dla <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> obiektu.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Tworzy <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> obiekt, który może wyzwalać zdarzenia w odpowiedzi na zmiany, aby określić wpisy w pamięci podręcznej.</summary>
        <returns>Monitor zmian, który monitoruje wpisów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> Metoda tworzy <xref:System.Runtime.Caching.CacheEntryChangeMonitor> wystąpienia. Ten monitor wyspecjalizowane zmiany służy do monitorowania wpisy w pamięci podręcznej, które są określone w `keys` kolekcji i wyzwalać zdarzenia, gdy zmienią się wpisy.  
  
 Monitorowane wpis jest uważana za uległ zmianie z następujących powodów:  
  
-   Klucz nie istnieje w momencie wywołania, które ma <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> metody. W takim przypadku wynikowy <xref:System.Runtime.Caching.CacheEntryChangeMonitor> wystąpienia natychmiast jest ustawiony do zmiany stanu. Oznacza to, że gdy kod wiąże następnie powiadomienie o zmianie wywołanie zwrotne, wywołanie zwrotne zostanie wywołany bezpośrednio.  
  
-   Wpis pamięci podręcznej skojarzonych został usunięty z pamięci podręcznej. Taka sytuacja może wystąpić, jeśli wpis jest jawnym usunięciu, gdy wygaśnie lub zostanie usunięty w celu odzyskania pamięci  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element <paramref name="keys" /> kolekcja jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Caching.MemoryCache" Usage="System.Runtime.Caching.MemoryCache.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do domyślnego <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia.</summary>
        <value>Domyślne wystąpienie pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca odwołanie do domyślnego wystąpienia pamięci podręcznej. Dla typowych scenariuszy aplikacji, tylko jedno wystąpienie <xref:System.Runtime.Caching.MemoryCache> jest wymagana.  
  
 Ponieważ domyślne wystąpienie pamięci podręcznej nie jest tworzone przez konstruktora, musi być jawnie ustawione pamięci i wartościami sondowania dla domyślnego wystąpienia pamięci podręcznej konfiguracji. Aby uzyskać więcej informacji, zobacz [ &lt;memoryCache&gt; — Element (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/182a622f-f7cf-472d-9d0b-451d2fd94525">&lt;memoryCache&gt; — Element (ustawienia pamięci podręcznej)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opis funkcji, które udostępnia pamięć podręczną.</summary>
        <value>Bitowa kombinacja flag, które wskazują możliwości Domyślna implementacja pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwości implementacja pamięci podręcznej są kombinacją następujących wartości:  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryCache.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są używane przez bieżące wystąpienie <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy <xref:System.Runtime.Caching.MemoryCache> wystąpienia jest powiązana z <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> zdarzeń. Jednak podczas zamykania domeny aplikacji, jeśli nie zostało jawnie usunięte pamięci podręcznej oparte na pamięci, wystąpienie pamięci podręcznej będzie automatycznie wywoływać <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> metody.  
  
 Wystąpienie zlikwidowanego pamięci podręcznej jest wyłączony wykonując następujące czynności:  
  
1.  Stan pamięci podręcznej jest ustawiony do wskazania, że pamięć podręczna zostanie usunięty. Każda próba wywołania publicznego buforowania metod, które zmieniają stan pamięci podręcznej, takie jak metody, które dodaje, usuwa lub pobrać Wpisy w pamięci podręcznej, może spowodować nieoczekiwane zachowanie. Na przykład, jeśli wywołasz <xref:System.Runtime.Caching.MemoryCache.Set%2A> występuje błąd pusta metody po usunięciu pamięci podręcznej. Jeśli użytkownik podejmie próbę pobierania elementów z pamięci podręcznej, <xref:System.Runtime.Caching.MemoryCache.Get%2A> metoda zawsze zwraca `null`.  
  
2.  Informacje o liczniku wydajności jest już wywoływane z bieżącego wystąpienia pamięci podręcznej.  
  
3.  Wszystkie odwołania do pamięci podręcznej obiektów przechowywanych przez bieżące wystąpienie pamięci podręcznej są zwalniane.  
  
4.  Wszelkie <xref:System.Runtime.Caching.CacheEntryChangeMonitor> wystąpień, które są aktualnie monitorowane przez wpisy w pamięci podręcznej są powiadamiani.  
  
5.  Wywołuje się obiektów wywołanie zwrotne, które będą dostarczać powiadomienia o zmianach dla tych monitorów.  
  
6.  Wszelkie <xref:System.Web.Caching.CacheItemRemovedCallback> noszą nazwę wystąpienia, które są zarejestrowane z wpisy w pamięci podręcznej. Powód usunięcia, który jest przekazywany do wywołania zwrotne jest <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Get : string * string -&gt; obj" Usage="memoryCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej uzyskać.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Zwraca wpis z pamięci podręcznej.</summary>
        <returns>Odwołanie do wpisu pamięci podręcznej, która jest identyfikowana przez <paramref name="key" />, jeśli istnieje wpis; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="override this.GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej uzyskać.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Zwraca określony wpis z pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia.</summary>
        <returns>Odwołanie do wpisu pamięci podręcznej identyfikowane przez <paramref name="key" /> Jeśli istnieje wpis; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wpis pamięci podręcznej określony przez `key` istnieje w pamięci podręcznej, <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> metoda zwraca je jako <xref:System.Runtime.Caching.CacheItem> wystąpienia. <xref:System.Runtime.Caching.CacheItem.Key%2A> i <xref:System.Runtime.Caching.CacheItem.Value%2A> właściwości <xref:System.Runtime.Caching.CacheItem> ustawi wystąpienia. Jednak <xref:System.Runtime.Caching.CacheItem.RegionName%2A> właściwość będzie miała `null`, ponieważ regiony nie są implementowane w <xref:System.Runtime.Caching.MemoryCache> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="override this.GetCount : string -&gt; int64" Usage="memoryCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Zwraca łączna liczba wpisów pamięci podręcznej w pamięci podręcznej.</summary>
        <returns>Liczba wpisów w pamięci podręcznej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="memoryCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy moduł wyliczający, który może służyć do iterowania po kolekcji wpisy w pamięci podręcznej.</summary>
        <returns>Obiekt moduł wyliczający, który zapewnia dostęp do elementów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający, który jest zwracany przez <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> metoda może służyć do wykonywania iteracji wpisów w pamięci podręcznej.  
  
> [!IMPORTANT]
>  Trwa pobieranie modułu wyliczającego dla <xref:System.Runtime.Caching.MemoryCache> wystąpienia jest operacją intensywnie korzystających z zasobów i blokowania. W związku z tym moduł wyliczający nie należy używać w aplikacjach produkcyjnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="member this.GetLastSize : string -&gt; int64" Usage="memoryCache.GetLastSize regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="regionName">Nazwa regionu.</param>
        <summary>Pobiera rozmiar obszaru o nazwie.</summary>
        <returns>Rozmiar obszaru o nazwie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="override this.GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="memoryCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Zestaw unikatowych identyfikatorów dla wpisów pamięci podręcznej do zwrócenia.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Zwraca zestaw wpisów pamięci podręcznej, które odpowiadają określonej kluczy.</summary>
        <returns>Zestaw wpisów pamięci podręcznej, które odpowiadają określonej kluczy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wpis pamięci podręcznej, który jest reprezentowany przez `keys` nie istnieje, odpowiadająca wartość dla zwracany obiekt w słowniku jest ustawiony na `null`. W związku z tym, zwrócone słownika zawsze ma taką samą liczbę elementów jako liczbę elementów w `keys`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Poszczególne klucz w kolekcji jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.MemoryCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator do pobierania lub ustawiania wartości pamięci podręcznej.</param>
        <summary>Pobiera lub ustawia wartość w pamięci podręcznej za pomocą właściwości indeksatora domyślny dla wystąpienia <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <value>Wartość wystąpienia pamięci podręcznej dla określonego klucza, jeśli istnieje wpis w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ustawieniu tej właściwości wartości zostaną wstawione do pamięci podręcznej. Zasady wygaśnięcia wpisu pamięci podręcznej są ustawione na <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration>. Jeśli wpis pamięci podręcznej za pomocą dopasowany klucz już istnieje, jego wartość jest aktualizowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.  
  
—lub— 
Wstawiona wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.MemoryCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę pamięci podręcznej.</summary>
        <value>Nazwa pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.Name%2A> Właściwość zwraca nazwę bieżącego wystąpienia <xref:System.Runtime.Caching.MemoryCache> klasy. W aplikacji, która korzysta z wielu wystąpień pamięci podręcznej, można użyć <xref:System.Runtime.Caching.MemoryCache.Name%2A> właściwość ułatwia odróżnienie wystąpień. Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> metody. Domyślny opartego na pamięci pamięci podręcznej zwraca nazwę domyślną.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość procentowa używanego dla pamięci podręcznej pamięci fizycznej.</summary>
        <value>Procent pamięci fizycznej, używanego dla pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> Właściwość zwraca procent pamięci łączna liczba komputerów fizycznych, które mogą być używane przez jedno wystąpienie <xref:System.Runtime.Caching.MemoryCache> klasy. Jeśli wystąpienie pamięci podręcznej przekracza określony limit, wpisy w pamięci podręcznej są usuwane.  
  
 Ustawienia dla <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> właściwość może być określona w pliku konfiguracyjnym aplikacji. Alternatywnie mogą być przekazywane przez obiekt wywołujący podczas <xref:System.Runtime.Caching.MemoryCache> klasa jest inicjowana. Aby uzyskać więcej informacji na temat konfigurowania tej właściwości, zobacz [ &lt;namedCaches&gt; — Element (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Aby uzyskać więcej informacji o sposobie konfigurowania właściwości podczas <xref:System.Runtime.Caching.MemoryCache> klasy jest inicjowany, zobacz <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; — Element (ustawienia pamięci podręcznej)</related>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PollingInterval : TimeSpan" Usage="System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalny czas, po upływie którego pamięć podręczną aktualizuje statystyki jego pamięci.</summary>
        <value>Maksymalny czas, który może występować przed pamięci statystyki są aktualizowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienia dla <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A> właściwość może być określona w pliku konfiguracyjnym aplikacji. Można również one mogą być przekazywane podczas <xref:System.Runtime.Caching.MemoryCache> klasa jest inicjowana. Aby uzyskać więcej informacji na temat konfigurowania tej właściwości, zobacz [ &lt;namedCaches&gt; — Element (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Aby uzyskać więcej informacji o sposobie konfigurowania właściwości podczas <xref:System.Runtime.Caching.MemoryCache> klasy jest inicjowany, zobacz <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; — Element (ustawienia pamięci podręcznej)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa określony element z pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * string -&gt; obj" Usage="memoryCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej do usunięcia.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Usuwa wpis pamięci podręcznej z pamięci podręcznej.</summary>
        <returns>Jeśli wpis zostanie znaleziony w pamięci podręcznej wpisu pamięci podręcznej usunięte; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wpis określony przez `key` istnieje w pamięci podręcznej, usuwanie wyzwalaczy elementu monitorów żadnych skojarzonych zmian. Jeśli usunięty element został skojarzony z <xref:System.Web.Caching.CacheItemUpdateCallback> obiektu lub <xref:System.Web.Caching.CacheItemRemovedCallback> obiekt, przyczyna przekazane do wywołania zwrotnego <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * System.Runtime.Caching.CacheEntryRemovedReason * string -&gt; obj" Usage="memoryCache.Remove (key, reason, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="regionName" Type="System.String" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej do usunięcia.</param>
        <param name="reason">Powodów, dla którego element został usunięty.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Usuwa wpis pamięci podręcznej z pamięci podręcznej, za pomocą przyczynę.</summary>
        <returns>Jeśli wpis zostanie znaleziony w pamięci podręcznej wpisu pamięci podręcznej usunięte; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony wpis nie istnieje, zostanie utworzony. Jeśli określona pozycja istnieje, jest aktualizowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="memoryCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który reprezentuje wpis pamięci podręcznej do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej przy użyciu <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia, aby dostarczyć klucz oraz wartość dla wpisu pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jak inne <xref:System.Runtime.Caching.MemoryCache.Set%2A> przeciążenia metody <xref:System.Runtime.Caching.MemoryCache.Set%2A> metody zawsze umieszcza wartość pamięci podręcznej w pamięci podręcznej, niezależnie od tego, czy wpis już istnieje, która ma taki sam klucz. Jeśli nie istnieje określony wpis w pamięci podręcznej, jest wstawiany nowy wpis pamięci podręcznej. Jeśli określony wpis już istnieje, jego wartość jest aktualizowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> jest <see langword="null" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItem.Key" /> Właściwość <see langword="null" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItem.Value" /> Właściwość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nieprawidłowa kombinacja argumentów dla wpisu pamięci podręcznej został przekazany. Dzieje się tak, jeśli następujące szczegóły wygaśnięcia ustawionych w obiekcie zasad dla wpisu pamięci podręcznej: 
-Jeśli bezwzględne i przedłużanie ważności wartości <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości innej niż wartości domyślne ze <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pola. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy nie można ustawić zasady wygasania, na podstawie bezwzględnych wygaśnięcia i wygaśniecie. Tylko jedno ustawienie wygaśnięcia może być jawnie ustawione, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy. Inne ustawienie musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> właściwości.  
  
— Jeśli określono zarówno wywołania zwrotnego usuwania, jak i wywołanie zwrotne aktualizacji dla <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy obsługuje tylko przy użyciu jednego typu wywołania zwrotnego dla pamięci podręcznej zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość mniej niż <see cref="F:System.TimeSpan.Zero" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwości ustawiono wartość większa niż jeden rok.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> Nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="memoryCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej do wstawienia.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="absoluteExpiration">Ustalona data i godzina wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej przy użyciu klucza i wartości, a następnie określa szczegółowe informacje na podstawie czasu wygaśnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jak inne <xref:System.Runtime.Caching.MemoryCache.Set%2A> przeciążenia metody <xref:System.Runtime.Caching.MemoryCache.Set%2A> metody zawsze umieszcza wartość pamięci podręcznej w pamięci podręcznej, niezależnie od tego, czy istnieje już wpis o takim samym kluczem. Jeśli określony wpis nie istnieje, jest wstawiany nowy wpis pamięci podręcznej. Jeśli określona pozycja istnieje, jest aktualizowana.  
  
 `absoluteExpiration` Parametr wskazuje, kiedy należy usunąć wpis z pamięci podręcznej.  
  
 Usuwanie wpisu wyzwala monitorów żadnych skojarzonych zmian. Jeśli usunięty element został skojarzony z <xref:System.Web.Caching.CacheItemUpdateCallback> obiektu lub <xref:System.Web.Caching.CacheItemRemovedCallback> obiektu przyczynę usunięcia, który jest przekazywany do wywołania zwrotne znajduje się w <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="Value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">— Nieprawidłowa kombinacja argumentów dla wpisu pamięci podręcznej został przekazany. Dzieje się tak, jeśli następujące szczegóły wygaśnięcia ustawionych w obiekcie zasad dla wpisu pamięci podręcznej: 
— Jeśli wygaśnięcia przewijania i bezwzględne wartości na <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości innej niż wartości domyślne ze <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Dzieje się tak dlatego <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie obsługuje wygasające wpisy na podstawie bezwzględnym i wygaśniecie. Tylko jedno ustawienie wygaśnięcia może być jawnie ustawione, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy. Inne ustawienie musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
— Jeśli wywołanie zwrotne usuwania i aktualizacji wywołanie zwrotne, które są określone na <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy obsługuje tylko przy użyciu jednego typu wywołania zwrotnego dla pamięci podręcznej zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość mniej niż <see cref="F:System.TimeSpan.Zero" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwości ustawiono wartość większa niż jeden rok.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="memoryCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej do wstawienia.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji eksmisji niż prosty, bezwzględnych wygaśnięcia.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, w którym można dodać wpisu pamięci podręcznej. Nie przekazuj wartości tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej za pomocą klucza i wartości i wykluczania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jak inne <xref:System.Runtime.Caching.MemoryCache.Set%2A> przeciążenia metody <xref:System.Runtime.Caching.MemoryCache.Set%2A> metody zawsze umieszcza wartość pamięci podręcznej w pamięci podręcznej, niezależnie od tego, czy pozycja już istnieje. Jeśli nie istnieje określony wpis w pamięci podręcznej, jest wstawiany nowy wpis pamięci podręcznej. Jeśli określona pozycja istnieje, jest aktualizowana.  
  
 Usuwanie wpisu wyzwala monitorów żadnych skojarzonych zmian. Jeśli usunięty element został skojarzony z <xref:System.Web.Caching.CacheItemUpdateCallback> obiektu lub <xref:System.Web.Caching.CacheItemRemovedCallback> obiektu przyczynę usunięcia, który jest przekazywany do wywołania zwrotne znajduje się w <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="value" /> jest <see langword="null" />  
  
—lub— 
Odwołanie wywołania zwrotnego, która została przekazana do metody pomocnika w <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" /> właściwość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">— Nieprawidłowa kombinacja argumentów dla wpisu pamięci podręcznej istnieje. Dzieje się tak, jeśli następujące szczegóły wygaśnięcia ustawionych w obiekcie zasad dla wpisu pamięci podręcznej: 
— Jeśli wygaśnięcia przewijania i bezwzględne wartości na <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości innej niż wartości domyślne ze <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Jest to spowodowane <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie obsługuje wygasające wpisy na podstawie bezwzględnym i wygaśniecie. Tylko jedno ustawienie wygaśnięcia może być jawnie ustawione, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy. Inne ustawienie musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
— Jeśli wywołanie zwrotne usuwania i aktualizacji wywołanie zwrotne, które są określone na <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> klasy. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy obsługuje tylko przy użyciu jednego typu wywołania zwrotnego dla pamięci podręcznej zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość mniej niż <see cref="F:System.TimeSpan.Zero" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwości ustawiono wartość większa niż jeden rok.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> nie jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia obsługę iteracji przez kolekcję ogólną.</summary>
        <returns>Obiekt moduł wyliczający, który zapewnia dostęp do wpisów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Runtime.Caching.MemoryCache> wystąpienia jest rzutowany na <xref:System.Collections.IEnumerable> interfejsu.  
  
 Ta metoda służy do iteracji przez kolekcję ogólną wpisy w pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberSignature Language="F#" Value="member this.Trim : int -&gt; int64" Usage="memoryCache.Trim percent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">Procent całkowitej wpisów pamięci podręcznej do usunięcia.</param>
        <summary>Usuwa określoną wartość procentową wpisy w pamięci podręcznej z obiektu pamięci podręcznej.</summary>
        <returns>Liczba wpisów jest usuwane z pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.Trim%2A> Właściwość najpierw usuwa wpisy, które przekroczyły bezwzględną lub przedłużanie ważności. Wszelkie wywołania zwrotne, które są zarejestrowane dla elementów, które zostaną usunięte zostaną przekazane usunięto przyczynę <xref:System.Web.Caching.CacheItemRemovedReason.Expired>.  
  
 Jeśli usuwanie wpisów wygasłe jest za mała, aby osiągnąć określony procent przycinania, dodatkowe wpisy zostaną usunięte z pamięci podręcznej oparte na algorytmu Najdawniej używane (LRU), aż do osiągnięcia żądanego procent przycinania. Wszelkie wywołania zwrotne, które są zarejestrowane dla elementów, które są usuwane w ten sposób zostanie przekazany Usuń przyczynę <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
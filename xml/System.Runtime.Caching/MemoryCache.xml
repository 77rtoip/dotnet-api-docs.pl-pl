<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4ee2cb9a75e5d483ec72c62d8ba6243c69376d44" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69275526" /></Metadata><TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryCache = class&#xA;    inherit ObjectCache&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje typ implementujący pamięć podręczną w pamięci.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa jest konkretną implementacją klasy abstrakcyjnej <xref:System.Runtime.Caching.ObjectCache>. <xref:System.Runtime.Caching.MemoryCache>  
  
> [!NOTE]
>  Klasa jest podobna do klasy ASP.NET <xref:System.Web.Caching.Cache>. <xref:System.Runtime.Caching.MemoryCache> Klasa ma wiele właściwości i metod uzyskiwania dostępu do pamięci podręcznej, która będzie znana dla Ciebie, jeśli użyto klasy <xref:System.Web.Caching.Cache>ASP.NET. <xref:System.Runtime.Caching.MemoryCache> Główne różnice między <xref:System.Web.Caching.Cache> klasami i <xref:System.Runtime.Caching.MemoryCache> polegają na tym <xref:System.Runtime.Caching.MemoryCache> , że klasa została zmieniona w celu wykorzystania jej [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] przez aplikacje, które nie są aplikacjami ASP.NET. Na przykład <xref:System.Runtime.Caching.MemoryCache> Klasa nie ma żadnych zależności `System.Web` względem zestawu. Kolejną różnicą jest to, że można utworzyć wiele wystąpień <xref:System.Runtime.Caching.MemoryCache> klasy do użycia w tej samej aplikacji i w tym samym <xref:System.AppDomain> wystąpieniu.  
  
 Klasa nie zezwala `null` jako wartość w pamięci podręcznej. <xref:System.Runtime.Caching.MemoryCache> Każda próba dodania lub zmiany wpisu pamięci podręcznej o wartości `null` nie powiedzie się.  
  
 Typ nie implementuje *regionów pamięci podręcznej.* <xref:System.Runtime.Caching.MemoryCache> W związku z tym podczas <xref:System.Runtime.Caching.MemoryCache> wywoływania metod implementujących metody podstawowe, które zawierają parametr dla regionów, nie należy przekazywać wartości parametru. Metody, które używają parametru region wszystkie dostarczają wartość domyślną `null` . Na przykład <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> Przeciążenie metody `regionName` ma parametr, którego wartość domyślna to `null`.  
  
   
  
## Examples  
 Poniższy przykład deklaruje odwołanie do domyślnego wystąpienia pamięci podręcznej pamięci. Wpis pamięci podręcznej <xref:System.Runtime.Caching.CacheItemPolicy> używa obiektu do zapewnienia wykluczenia i szczegółów wygaśnięcia dla wpisu pamięci podręcznej. Używa ona również <xref:System.Runtime.Caching.ChangeMonitor> obiektu do monitorowania stanu danych źródłowych (czyli pliku) w systemie plików.  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/942236f6-0138-4aaf-af71-a5ea451a1e23">Przewodnik: Buforowanie danych aplikacji w ASP.NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/c4b47ee0-4b82-4124-9bce-818088385e34">Buforowanie w aplikacjach .NET Framework</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = null)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa, która ma być używana do wyszukiwania informacji o konfiguracji.  
  
 <c>Uwaga</c> Nie jest wymagane, aby informacje o konfiguracji istniały dla każdej nazwy.  
  
Jeśli istnieje odpowiedni wpis konfiguracji, informacje o konfiguracji są używane do konfigurowania <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia. Jeśli pasujący wpis konfiguracji nie istnieje, do nazwy można uzyskać dostęp za pomocą <see cref="P:System.Runtime.Caching.MemoryCache.Name" /> właściwości, ponieważ określona nazwa jest skojarzona <see cref="T:System.Runtime.Caching.MemoryCache" /> z wystąpieniem. Informacje o konfiguracji pamięci podręcznej pamięci <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />znajdują się w temacie.</param>
        <param name="config">Kolekcja par nazwa/wartość informacji konfiguracyjnych, które mają być użyte do skonfigurowania pamięci podręcznej.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zainicjowaniu <xref:System.Runtime.Caching.MemoryCache> klasy sprawdza wpisy konfiguracji, które mogły zostać zastąpione przy użyciu opcjonalnego `config` parametru w konstruktorze. W `config` parametrze można przekazać następujące parametry. Wszystkie wartości mogą być przesyłane jako liczby całkowite.  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 Gdy ten konstruktor jest wywoływany, ustawienia konfiguracji są najpierw pobierane z plików konfiguracji aplikacji. Jeśli w pliku konfiguracji aplikacji nie ma żadnych wpisów konfiguracji, są stosowane tylko ustawienia podane `config` w temacie. Jeśli istnieją wpisy konfiguracyjne w konfiguracji aplikacji i jeśli informacje są również `config`przenoszone, informacje w obszarze `config` zastępują informacje, które są odczytywane z pliku konfiguracyjnego.  
  
 Wartość nazwy, która jest przypisana do wystąpienia pamięci podręcznej, jest używana na dwa sposoby:  
  
-   Aby ułatwić śledzenie wielu wystąpień pamięci podręcznej, gdy istnieje więcej niż jedno wystąpienie.  
  
-   Aby odwoływać się do ustawień w pliku konfiguracji <xref:System.Runtime.Caching.MemoryCache> , gdy wystąpienie zostanie zainicjowane.  
  
    > [!NOTE]
    >  Nie ma mechanizmu wymuszania unikatowych nazw dla wystąpień pamięci podręcznej. W związku z tym można mieć wiele wystąpień pamięci podręcznej o tej samej nazwie.  
  
    > [!CAUTION]
    >  Nie należy tworzyć <xref:System.Runtime.Caching.MemoryCache> wystąpień, chyba że jest to wymagane. Jeśli tworzysz wystąpienia pamięci podręcznej w aplikacjach klienta i sieci <xref:System.Runtime.Caching.MemoryCache> Web, wystąpienia powinny być tworzone wczesnie w cyklu życia aplikacji. Należy utworzyć tylko liczbę wystąpień pamięci podręcznej, które będą używane w aplikacji, i zapisać odwołania do wystąpień pamięci podręcznej w zmiennych, do których można uzyskać dostęp globalnie. Na przykład w aplikacjach ASP.NET można przechowywać odwołania w stanie aplikacji. Jeśli tworzysz tylko pojedyncze wystąpienie pamięci podręcznej w aplikacji, Użyj domyślnej pamięci podręcznej i uzyskaj odwołanie do niego z <xref:System.Runtime.Caching.MemoryCache.Default%2A> właściwości, gdy chcesz uzyskać dostęp do pamięci podręcznej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nie można przeanalizować nazwy <paramref name="config" /> lub wartości w parametrze.</exception>
        <exception cref="T:System.Configuration.ConfigurationException">Wartość w <paramref name="config" /> kolekcji jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection * bool -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config, ignoreConfigSection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa, która ma być używana do wyszukiwania informacji o konfiguracji.</param>
        <param name="config">Kolekcja par nazwa/wartość informacji konfiguracyjnych, które mają być użyte do skonfigurowania pamięci podręcznej.</param>
        <param name="ignoreConfigSection">Wskazuje, czy sekcja konfiguracji powinna być ignorowana.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="memoryCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <summary>Wstawia wpis pamięci podręcznej w postaci <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia i dodaje szczegółowe informacje o sposobie wykluczenia wpisu.</summary>
        <returns>ma wartość true, jeśli wstawianie zakończyło się pomyślnie, lub false, jeśli istnieje już wpis w pamięci podręcznej, który ma ten sam klucz jako element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Przeciążenia metody <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> i nie obsługują właściwości.<xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> <xref:System.Runtime.Caching.ObjectCache.Add%2A> W związku z tym, <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> aby ustawić właściwość dla wpisu pamięci podręcznej, należy zamiast tego <xref:System.Runtime.Caching.MemoryCache.Set%2A> użyć przeciążeń metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia do pamięci podręcznej wpis pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A> metod są używane do wstawiania wpisu pamięci podręcznej do buforu. Jeśli wpis pamięci podręcznej z pasującym kluczem nie istnieje, te metody wstawą nowy wpis. Jeśli wpis pamięci podręcznej z zgodnym kluczem już istnieje, zwracają istniejący wpis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.AddOrGetExisting (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <summary>Dodaje wpis cache do pamięci podręcznej przy użyciu <see cref="T:System.Runtime.Caching.CacheItem" /> określonego wystąpienia i szczegółowych informacji o sposobach wykluczania wpisu.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, istniejący wpis pamięci podręcznej; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `item` Parametr dostarcza klucz i wartość, która jest używana przez metodę. Jeśli pamięć podręczna ma wpis pamięci podręcznej z tym samym kluczem co klucz `item` parametru, metoda zwraca istniejący wpis <xref:System.Runtime.Caching.CacheItem> jako wystąpienie. Jeśli nie ma żadnego wpisu pamięci podręcznej, metoda tworzy nową, przy użyciu klucza i wartości dostarczonej przez `item` parametr oraz ze szczegółami wykluczenia określonymi przez. `policy`  
  
> [!WARNING]
>  Przeciążenia metody <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> i nie obsługują właściwości.<xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> <xref:System.Runtime.Caching.ObjectCache.Add%2A> W związku z tym, <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> aby ustawić właściwość dla wpisu pamięci podręcznej, należy zamiast tego <xref:System.Runtime.Caching.MemoryCache.Set%2A> użyć przeciążeń metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Runtime.Caching.CacheItem.Value" /> Właściwość jest<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Zarówno bezwzględne, jak i ruchome <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> wartości wygaśnięcia dla obiektu są ustawione na wartość inną niż <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> wartości <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> domyślne pól i. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa nie może ustawiać zasad wygasania na podstawie kombinacji bezwzględnego wygaśnięcia i przewinięcie. Podczas używania <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia można jawnie ustawić tylko jedno ustawienie wygaśnięcia. Inne ustawienie wygasania musi mieć wartość <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> pole lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pole.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Właściwość jest ustawiona na wartość mniejszą niż <see cref="F:System.TimeSpan.Zero" />. <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość większą niż jeden rok.  
  
—lub— 
Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia. <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej, który ma zostać dodany.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="absoluteExpiration">Stała Data i godzina wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której można dodać wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Dodaje wpis cache do pamięci podręcznej przy użyciu określonego klucza i wartości oraz bezwzględnej wartości wygaśnięcia.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, istniejący wpis pamięci podręcznej; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pamięć podręczna nie ma wpisu pamięci podręcznej, którego `key` klucz pasuje do parametru, tworzony jest nowy wpis pamięci podręcznej <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> i `null`zostanie zwrócony Przeciążenie metody. Jeśli istnieje odpowiedni wpis pamięci podręcznej, zostanie zwrócony istniejący wpis.  
  
> [!WARNING]
>  Przeciążenia metody <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> i nie obsługują właściwości.<xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> <xref:System.Runtime.Caching.ObjectCache.Add%2A> W związku z tym, <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> aby ustawić właściwość dla wpisu pamięci podręcznej, należy zamiast tego <xref:System.Runtime.Caching.MemoryCache.Set%2A> użyć przeciążeń metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />nie <see langword="null" />jest.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentException">Zarówno bezwzględne, jak i ruchome <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> wartości wygaśnięcia dla obiektu są ustawione na wartość inną niż <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> wartości <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> domyślne pól i. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa nie może ustawiać zasad wygasania na podstawie kombinacji bezwzględnego wygaśnięcia i przewinięcie. Podczas używania <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia można jawnie ustawić tylko jedno ustawienie wygaśnięcia. Pozostałe ustawienie wygasania musi być ustawione na <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> wartość lub.<see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Właściwość jest ustawiona na wartość mniejszą niż <see cref="F:System.TimeSpan.Zero" />. <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość większą niż jeden rok.  
  
—lub— 
Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia. <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej do dodania lub pobrania.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której można dodać wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Domyślnie ten parametr jest <see langword="null" />, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Wstawia do pamięci podręcznej wpis pamięci podręcznej przy użyciu określonego klucza i wartości oraz określone szczegóły dotyczące sposobu jego wykluczenia.</summary>
        <returns>Jeśli pasujący wpis pamięci podręcznej już istnieje, wpis pamięci podręcznej; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Przeciążenia metody <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> i nie obsługują właściwości.<xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> <xref:System.Runtime.Caching.ObjectCache.Add%2A> W związku z tym, <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> aby ustawić właściwość dla wpisu pamięci podręcznej, należy zamiast tego <xref:System.Runtime.Caching.MemoryCache.Set%2A> użyć przeciążeń metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartości <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> wygaśnięcia bezwzględne i przesuwane obiektu są ustawiane na wartości inne niż <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ustawienia domyślne i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa nie może ustawiać zasad wygasania na podstawie kombinacji czasu wygaśnięcia bezwzględnego i przewijania. Podczas używania <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy można jawnie ustawić tylko jedno ustawienie wygaśnięcia. Drugie ustawienie musi mieć wartość <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub. <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />  
  
—lub— 
Określono zarówno wywołanie zwrotne usuwania, jak i wywołanie zwrotne <see cref="T:System.Runtime.Caching.CacheItemPolicy" />aktualizacji dla. Obsługuje <see cref="T:System.Runtime.Caching.MemoryCache" /> tylko jeden typ wywołania zwrotnego na wpis w pamięci podręcznej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Właściwość jest ustawiona na wartość mniejszą niż <see cref="F:System.TimeSpan.Zero" />. <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Ustawiono wartość większą niż jeden rok.  
  
—lub— 
Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia. <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /></exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci na komputerze (w bajtach), która może być używana przez pamięć podręczną.</summary>
        <value>Ilość pamięci w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżące wystąpienie pamięci podręcznej przekracza limit pamięci ustawiony przez <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> właściwość, implementacja pamięci podręcznej spowoduje usunięcie wpisów pamięci podręcznej. Każde wystąpienie pamięci podręcznej w aplikacji może korzystać z ilości pamięci określonej przez <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> właściwość.  
  
 Ustawienia <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> właściwości można określić w pliku konfiguracyjnym aplikacji. Alternatywnie można je przesłać w konstruktorze, gdy <xref:System.Runtime.Caching.MemoryCache> Klasa jest inicjowana. Aby uzyskać więcej informacji o sposobie konfigurowania tej właściwości, zobacz [ &lt;namedCaches&gt; element (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Aby uzyskać więcej informacji na temat sposobu ustawiania tej wartości podczas <xref:System.Runtime.Caching.MemoryCache> inicjowania klasy, <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> Zobacz metodę.  
  
 <xref:System.Runtime.Caching.MemoryCache>nie jest natychmiast wymuszane <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> za każdym razem, gdy nowy element zostanie dodany <xref:System.Runtime.Caching.MemoryCache> do wystąpienia. Wewnętrzne algorytmy heurystyczne, które wykluczają dodatkowe <xref:System.Runtime.Caching.MemoryCache> elementy z programu, robią to stopniowo i uwzględniają informacje z modułu wyrzucania elementów bezużytecznych (zobacz [odzyskiwanie pamięci](~/docs/standard/garbage-collection/index.md)) i inne czynniki, takie jak bieżący rozmiar pamięci podręcznej i ogólna pamięć systemowa wykorzystania. W związku z tym <xref:System.Runtime.Caching.MemoryCache> mimo że próby utrzymania rozmiaru pamięci podręcznej <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> w skonfigurowanym czasie jest możliwe do tymczasowego przekroczenia limitu przez dodanie elementów pamięci podręcznej z dużą szybkością.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; , element (ustawienia pamięci podręcznej)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Contains : string * string -&gt; bool" Usage="memoryCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej, który ma zostać wyszukany.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Określa, czy wpis pamięci podręcznej istnieje w pamięci podręcznej.</summary>
        <returns><see langword="true" />Jeśli pamięć podręczna zawiera wpis pamięci podręcznej <paramref name="key" />, którego klucz <see langword="false" />pasuje; w przeciwnym razie,.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="override this.CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="memoryCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Wyliczenie unikatowych kluczy wpisów pamięci podręcznej <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> dla obiektu.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której można dodać wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary><see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> Tworzy obiekt, który może wyzwalać zdarzenia w odpowiedzi na zmiany określonych wpisów pamięci podręcznej.</summary>
        <returns>Monitor zmian monitorujący wpisy w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> Metoda<xref:System.Runtime.Caching.CacheEntryChangeMonitor> tworzy wystąpienie. Ten wyspecjalizowany monitor zmian służy do monitorowania wpisów pamięci podręcznej, które są `keys` określone w kolekcji, oraz do wyzwalania zdarzeń po zmianie wpisów.  
  
 Monitorowany wpis jest uznawany za zmieniony z jednego z następujących powodów:  
  
-   Klucz nie istnieje w momencie wywołania <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> metody. W takim przypadku wystąpienie wyniku <xref:System.Runtime.Caching.CacheEntryChangeMonitor> zostanie natychmiast ustawione na zmieniony stan. Oznacza to, że gdy kod następnie powiąże wywołanie zwrotne z powiadomieniem o zmianie, wywołanie zwrotne zostanie wyzwolone natychmiast.  
  
-   Skojarzony wpis pamięci podręcznej został usunięty z pamięci podręcznej. Taka sytuacja może wystąpić, Jeśli wpis zostanie jawnie usunięty, jeśli go wygaśnie lub jeśli zostanie wykluczony w celu odzyskania pamięci  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element w <paramref name="keys" /> kolekcji to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Caching.MemoryCache" Usage="System.Runtime.Caching.MemoryCache.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do wystąpienia domyślnego <see cref="T:System.Runtime.Caching.MemoryCache" /> .</summary>
        <value>Domyślne wystąpienie pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca odwołanie do domyślnego wystąpienia pamięci podręcznej. W przypadku typowych scenariuszy aplikacji wymagane jest tylko jedno <xref:System.Runtime.Caching.MemoryCache> wystąpienie programu.  
  
 Ponieważ domyślne wystąpienie pamięci podręcznej nie jest tworzone przez Konstruktor, należy użyć konfiguracji, aby jawnie ustawić wartości pamięci i sondowania dla domyślnego wystąpienia pamięci podręcznej. Aby uzyskać więcej informacji, [ &lt;zobacz&gt; elemencie MemoryCache element (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/182a622f-f7cf-472d-9d0b-451d2fd94525">&lt;elemencie MemoryCache&gt; , element (ustawienia pamięci podręcznej)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opis funkcji zapewnianych przez pamięć podręczną.</summary>
        <value>Bitowa kombinacja flag wskazujących domyślne możliwości implementacji pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwości implementacji pamięci podręcznej są kombinacją następujących wartości:  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryCache.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są używane przez bieżące wystąpienie <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każde <xref:System.Runtime.Caching.MemoryCache> wystąpienie jest powiązane <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> ze zdarzeniem. Jednak podczas zamykania domeny aplikacji, jeśli pamięć podręczna oparta na pamięci nie została jawnie usunięta, wystąpienie pamięci podręcznej automatycznie wywoła <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> metodę.  
  
 Usunięte wystąpienie pamięci podręcznej jest zamykane przy użyciu następujących kroków:  
  
1.  Stan pamięci podręcznej jest ustawiony tak, aby wskazywał, że pamięć podręczna jest usuwana. Każda próba wywołania metod buforowania publicznego, które zmieniają stan pamięci podręcznej, takich jak metody dodawania, usuwania lub pobierania wpisów pamięci podręcznej, może spowodować nieoczekiwane zachowanie. Na przykład, jeśli wywołasz <xref:System.Runtime.Caching.MemoryCache.Set%2A> metodę po usunięciu pamięci podręcznej, wystąpi błąd braku operacji. Jeśli spróbujesz pobrać elementy z pamięci podręcznej, <xref:System.Runtime.Caching.MemoryCache.Get%2A> Metoda zawsze zwróci `null`wartość.  
  
2.  Informacje o liczniku wydajności nie są już zgłaszane z bieżącego wystąpienia pamięci podręcznej.  
  
3.  Zostaną wydane wszystkie odwołania do buforowanych obiektów przechowywanych w bieżącym wystąpieniu pamięci podręcznej.  
  
4.  Zostaną <xref:System.Runtime.Caching.CacheEntryChangeMonitor> powiadomione wszystkie wystąpienia, które aktualnie monitorują wpisy w pamięci podręcznej.  
  
5.  Obiekty wywołania zwrotnego, które dostarczają powiadomienia o zmianach dla tych monitorów, są wywoływane.  
  
6.  Wszystkie <xref:System.Web.Caching.CacheItemRemovedCallback> wystąpienia zarejestrowane przy użyciu wpisów w pamięci podręcznej są wywoływane. Powód usunięcia, który jest przesyłany do wywołania zwrotnego <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction>, to.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Get : string * string -&gt; obj" Usage="memoryCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej, który ma zostać pobrany.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Zwraca wpis z pamięci podręcznej.</summary>
        <returns>Odwołanie do wpisu pamięci podręcznej, który jest <paramref name="key" />identyfikowany przez, Jeśli wpis istnieje; <see langword="null" />w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="override this.GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej, który ma zostać pobrany.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Zwraca określony wpis z pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienie.</summary>
        <returns>Odwołanie do wpisu pamięci podręcznej identyfikowanego przez <paramref name="key" /> Jeśli wpis istnieje; <see langword="null" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wpis pamięci podręcznej `key` określony przez istnieje w pamięci podręcznej <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> , <xref:System.Runtime.Caching.CacheItem> Metoda zwraca ją jako wystąpienie. Zostaną ustawione <xref:System.Runtime.Caching.CacheItem.Value%2A> właściwości <xref:System.Runtime.Caching.CacheItem.Key%2A> i wystąpienia.<xref:System.Runtime.Caching.CacheItem> Właściwość będzie jednak ,ponieważ<xref:System.Runtime.Caching.MemoryCache> regiony nie są zaimplementowane w klasie. `null` <xref:System.Runtime.Caching.CacheItem.RegionName%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="override this.GetCount : string -&gt; int64" Usage="memoryCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Zwraca łączną liczbę wpisów w pamięci podręcznej.</summary>
        <returns>Liczba wpisów w pamięci podręcznej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="memoryCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy moduł wyliczający, który może być używany do iteracji w kolekcji wpisów pamięci podręcznej.</summary>
        <returns>Obiekt modułu wyliczającego, który zapewnia dostęp do elementów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający, który jest zwracany <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> przez metodę, może być używany do iteracji wpisów w pamięci podręcznej.  
  
> [!IMPORTANT]
>  Pobranie modułu wyliczającego <xref:System.Runtime.Caching.MemoryCache> dla wystąpienia jest operacją czasochłonną i blokującą. W związku z tym moduł wyliczający nie powinien być używany w aplikacjach produkcyjnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="member this.GetLastSize : string -&gt; int64" Usage="memoryCache.GetLastSize regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="regionName">Nazwa regionu.</param>
        <summary>Pobiera rozmiar nazwanego regionu.</summary>
        <returns>Rozmiar nazwanego regionu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="override this.GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="memoryCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Zestaw unikatowych identyfikatorów dla wpisów pamięci podręcznej do zwrócenia.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Zwraca zestaw wpisów pamięci podręcznej odpowiadających określonym kluczom.</summary>
        <returns>Zestaw wpisów pamięci podręcznej, który odpowiada określonym kluczom.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wpis pamięci podręcznej, który jest `keys` reprezentowany przez nie istnieje, odpowiadająca wartość dla zwracanego obiektu w słowniku jest ustawiona `null`na. W związku z tym zwracany słownik zawsze ma taką samą liczbę elementów jak liczba elementów w `keys`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Pojedynczy klucz w kolekcji to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.MemoryCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wartości pamięci podręcznej do pobrania lub ustawienia.</param>
        <summary>Pobiera lub ustawia wartość w pamięci podręcznej przy użyciu domyślnej właściwości indeksatora dla wystąpienia <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <value>Wartość w wystąpieniu pamięci podręcznej dla określonego klucza, Jeśli wpis istnieje; w przeciwnym razie. <see langword="null" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ustawieniu tej właściwości wartość zostanie wstawiona do pamięci podręcznej. Zasady wygasania dla wpisu pamięci podręcznej są <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration>ustawione na wartość. Jeśli wpis pamięci podręcznej z pasującym kluczem już istnieje, jego wartość jest aktualizowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.  
  
—lub— 
Wstawiona wartość to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.MemoryCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę pamięci podręcznej.</summary>
        <value>Nazwa pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zwraca nazwę bieżącego wystąpienia <xref:System.Runtime.Caching.MemoryCache> klasy. <xref:System.Runtime.Caching.MemoryCache.Name%2A> W aplikacji, która korzysta z wielu wystąpień pamięci podręcznej, <xref:System.Runtime.Caching.MemoryCache.Name%2A> można użyć właściwości, aby ułatwić odróżnienie wystąpień. Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> metodę. Domyślna pamięć podręczna oparta na pamięci zwraca nazwę domyślną.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość procentową pamięci fizycznej, która może być używana w pamięci podręcznej.</summary>
        <value>Wartość procentowa pamięci fizycznej, która może być używana przez pamięć podręczną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zwraca procentową łączną ilość pamięci komputera fizycznego, która może być używana przez pojedyncze wystąpienie <xref:System.Runtime.Caching.MemoryCache> klasy. <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> Jeśli wystąpienie pamięci podręcznej przekracza określony limit, wpisy pamięci podręcznej zostaną usunięte.  
  
 Ustawienia <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> właściwości można określić w pliku konfiguracyjnym aplikacji. Alternatywnie mogą być przesyłane przez obiekt wywołujący po <xref:System.Runtime.Caching.MemoryCache> zainicjowaniu klasy. Aby uzyskać więcej informacji o sposobie konfigurowania tej właściwości, zobacz [ &lt;namedCaches&gt; element (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Aby uzyskać więcej informacji na temat sposobu konfigurowania właściwości podczas <xref:System.Runtime.Caching.MemoryCache> inicjowania klasy, <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> Zobacz metodę.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; , element (ustawienia pamięci podręcznej)</related>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PollingInterval : TimeSpan" Usage="System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalny czas, po upływie którego pamięć podręczna aktualizuje dane statystyczne pamięci.</summary>
        <value>Maksymalny czas, jaki może wystąpić przed zaktualizowaniem statystyk pamięci.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienia <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A> właściwości można określić w pliku konfiguracyjnym aplikacji. Alternatywnie można je przesłać po <xref:System.Runtime.Caching.MemoryCache> zainicjowaniu klasy. Aby uzyskać więcej informacji o sposobie konfigurowania tej właściwości, zobacz [ &lt;namedCaches&gt; element (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Aby uzyskać więcej informacji na temat sposobu konfigurowania właściwości podczas <xref:System.Runtime.Caching.MemoryCache> inicjowania klasy, <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> Zobacz metodę.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; , element (ustawienia pamięci podręcznej)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa określony element z pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * string -&gt; obj" Usage="memoryCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej do usunięcia.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Usuwa wpis pamięci podręcznej z pamięci podręcznej.</summary>
        <returns>Jeśli wpis zostanie znaleziony w pamięci podręcznej, usunięty wpis pamięci podręcznej; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wpis określony przez `key` istnieje w pamięci podręcznej, usunięcie elementu wyzwala wszystkie skojarzone monitory zmian. Jeśli usunięty element został skojarzony z <xref:System.Web.Caching.CacheItemUpdateCallback> obiektem <xref:System.Web.Caching.CacheItemRemovedCallback> lub obiektem, powód <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed>przekazano do wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * System.Runtime.Caching.CacheEntryRemovedReason * string -&gt; obj" Usage="memoryCache.Remove (key, reason, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="regionName" Type="System.String" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej do usunięcia.</param>
        <param name="reason">Przyczyna usunięcia elementu.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Usuwa wpis pamięci podręcznej z pamięci podręcznej przy użyciu przyczyny.</summary>
        <returns>Jeśli wpis zostanie znaleziony w pamięci podręcznej, usunięty wpis pamięci podręcznej; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia do pamięci podręcznej wpis pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony wpis nie istnieje, zostanie utworzony. Jeśli określony wpis istnieje, zostanie zaktualizowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="memoryCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który reprezentuje wpis pamięci podręcznej do wstawienia.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <summary>Wstawia do pamięci podręcznej wpis pamięci podręcznej przy użyciu <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia, aby podać klucz i wartość wpisu pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podobnie jak <xref:System.Runtime.Caching.MemoryCache.Set%2A> w przypadku innych przeciążeń metod <xref:System.Runtime.Caching.MemoryCache.Set%2A> , Metoda zawsze umieszcza wartość pamięci podręcznej w pamięci podręcznej, niezależnie od tego, czy istnieje już wpis, który ma ten sam klucz. Jeśli określony wpis nie istnieje w pamięci podręcznej, zostanie wstawiony nowy wpis pamięci podręcznej. Jeśli określony wpis już istnieje, jego wartość jest aktualizowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" />jest <see langword="null" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItem.Key" /> Właściwość jest<see langword="null" />.  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItem.Value" /> Właściwość jest<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Przekazano nieprawidłową kombinację argumentów dla wpisu pamięci podręcznej. Dzieje się tak, jeśli w obiekcie zasad dla wpisu pamięci podręcznej są ustawione następujące szczegóły dotyczące wygasania: 
-Jeśli zarówno bezwzględne, jak i ruchome <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> wartości wygaśnięcia obiektu są ustawione na wartość inną niż wartości <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> domyślne <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pól i. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa nie może ustawiać zasad wygasania na podstawie bezwzględnego wygaśnięcia i przewinięcie. Podczas używania <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy można jawnie ustawić tylko jedno ustawienie wygaśnięcia. Drugie ustawienie musi mieć wartość <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> Property.  
  
— Jeśli określono zarówno wywołanie zwrotne usuwania, jak i wywołanie zwrotne aktualizacji dla <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa obsługuje tylko użycie jednego typu wywołania zwrotnego na wpis w pamięci podręcznej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Właściwość jest ustawiona na wartość mniejszą niż <see cref="F:System.TimeSpan.Zero" />. <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość większą niż jeden rok.  
  
—lub— 
Nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" />wyliczenia. <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="memoryCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej, który ma zostać wstawiony.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="absoluteExpiration">Stała Data i godzina wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której można dodać wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Wstawia do pamięci podręcznej wpis pamięci podręcznej przy użyciu klucza i wartości, a następnie określa szczegóły wygaśnięcia na podstawie czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podobnie jak <xref:System.Runtime.Caching.MemoryCache.Set%2A> w przypadku innych przeciążeń metod <xref:System.Runtime.Caching.MemoryCache.Set%2A> , Metoda zawsze umieszcza wartość pamięci podręcznej w pamięci podręcznej, niezależnie od tego, czy istnieje już wpis z tym samym kluczem. Jeśli określony wpis nie istnieje, zostanie wstawiony nowy wpis pamięci podręcznej. Jeśli określony wpis istnieje, zostanie zaktualizowany.  
  
 `absoluteExpiration` Parametr wskazuje, kiedy wpis powinien zostać usunięty z pamięci podręcznej.  
  
 Usunięcie wpisu wyzwala wszystkie powiązane monitory zmian. Jeśli usunięty element został skojarzony z <xref:System.Web.Caching.CacheItemUpdateCallback> obiektem lub <xref:System.Web.Caching.CacheItemRemovedCallback> obiektem, powód usunięcia, który jest przesyłany do wywołania zwrotnego, jest zawarty we <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="Value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">-Przekazano nieprawidłową kombinację argumentów dla wpisu pamięci podręcznej. Dzieje się tak, jeśli w obiekcie zasad dla wpisu pamięci podręcznej są ustawione następujące szczegóły dotyczące wygasania: 
— Jeśli zarówno wartości wygaśnięcia bezwzględne i przesuwane w <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiekcie są ustawione na wartości inne niż <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ustawienia domyślne <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />i. Dzieje się tak, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie obsługuje wpisów wygasania na podstawie zarówno bezwzględnej, jak i ruchomej ważności. Podczas używania <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy można jawnie ustawić tylko jedno ustawienie wygaśnięcia. Drugie ustawienie musi mieć wartość <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub. <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />  
  
-Jeśli w <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiekcie określono zarówno wywołanie zwrotne usuwania, jak i wywołanie zwrotne aktualizacji. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa obsługuje tylko użycie jednego typu wywołania zwrotnego na wpis w pamięci podręcznej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Właściwość jest ustawiona na wartość mniejszą niż <see cref="F:System.TimeSpan.Zero" />. <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość większą niż jeden rok.  
  
—lub— 
-Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia. <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="memoryCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej, który ma zostać wstawiony.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="policy">Obiekt, który zawiera szczegóły wykluczenia dla wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczania niż proste bezwzględne wygaśnięcie.</param>
        <param name="regionName">Nazwany region w pamięci podręcznej, do której można dodać wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, <see cref="T:System.Runtime.Caching.MemoryCache" /> ponieważ Klasa nie implementuje regionów.</param>
        <summary>Wstawia do pamięci podręcznej wpis pamięci podręcznej przy użyciu klucza i wartości i wykluczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podobnie jak <xref:System.Runtime.Caching.MemoryCache.Set%2A> w przypadku innych przeciążeń metod <xref:System.Runtime.Caching.MemoryCache.Set%2A> , Metoda zawsze umieszcza wartość pamięci podręcznej w pamięci podręcznej, niezależnie od tego, czy pasujący wpis już istnieje. Jeśli określony wpis nie istnieje w pamięci podręcznej, zostanie wstawiony nowy wpis pamięci podręcznej. Jeśli określony wpis istnieje, zostanie zaktualizowany.  
  
 Usunięcie wpisu wyzwala wszystkie powiązane monitory zmian. Jeśli usunięty element został skojarzony z <xref:System.Web.Caching.CacheItemUpdateCallback> obiektem lub <xref:System.Web.Caching.CacheItemRemovedCallback> obiektem, powód usunięcia, który jest przesyłany do wywołania zwrotnego, jest zawarty we <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="value" />była<see langword="null" />  
  
—lub— 
Odwołanie wywołania zwrotnego, które zostało przesłane do metody pomocnika <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" /> we właściwości <see langword="null" />, to.</exception>
        <exception cref="T:System.ArgumentException">-Istnieje Nieprawidłowa kombinacja argumentów dla wpisu pamięci podręcznej. Dzieje się tak, jeśli w obiekcie zasad dla wpisu pamięci podręcznej są ustawione następujące szczegóły dotyczące wygasania: 
— Jeśli zarówno wartości wygaśnięcia bezwzględne i przesuwane w <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiekcie są ustawione na wartości inne niż <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ustawienia domyślne <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />i. Wynika to z faktu, że <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa nie obsługuje wpisów wygasania na podstawie zarówno bezwzględnej, jak i ruchomej ważności. Podczas używania <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy można jawnie ustawić tylko jedno ustawienie wygaśnięcia. Drugie ustawienie musi mieć wartość <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub. <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />  
  
-Jeśli w <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> klasie określono zarówno wywołanie zwrotne usuwania, jak i wywołanie zwrotne aktualizacji. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa obsługuje tylko użycie jednego typu wywołania zwrotnego na wpis w pamięci podręcznej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Właściwość jest ustawiona na wartość mniejszą niż <see cref="F:System.TimeSpan.Zero" />. <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />  
  
—lub— 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona na wartość większą niż jeden rok.  
  
—lub— 
Właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia. <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /></exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" />nie <see langword="null" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia obsługę iteracji w kolekcji ogólnej.</summary>
        <returns>Obiekt modułu wyliczającego, który zapewnia dostęp do wpisów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Runtime.Caching.MemoryCache> gdy wystąpienie jest rzutowane <xref:System.Collections.IEnumerable> do interfejsu.  
  
 Tej metody można użyć do iteracji w ogólnej kolekcji wpisów pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberSignature Language="F#" Value="member this.Trim : int -&gt; int64" Usage="memoryCache.Trim percent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">Wartość procentowa wszystkich wpisów pamięci podręcznej do usunięcia.</param>
        <summary>Usuwa określoną wartość procentową wpisów w pamięci podręcznej.</summary>
        <returns>Liczba wpisów usuniętych z pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.Trim%2A> Właściwość najpierw usuwa wpisy, które przekroczyły ważność bezwzględną lub przewinięcie. Wszystkie wywołania zwrotne zarejestrowane dla elementów, które są usuwane, zostaną przesłane z usuniętego powodu <xref:System.Web.Caching.CacheItemRemovedReason.Expired>.  
  
 Jeśli usuwanie przeterminowanych wpisów jest niewystarczające do osiągnięcia podanej wartości procentowej przycinania, dodatkowe wpisy zostaną usunięte z pamięci podręcznej na podstawie najmniejszego użycia algorytmu (LRU), dopóki nie zostanie osiągnięty żądany procent przycinania. Wszystkie wywołania zwrotne zarejestrowane dla elementów, które zostały usunięte w ten sposób, zostaną przesłane z powodu usunięcia <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted>przyczyny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

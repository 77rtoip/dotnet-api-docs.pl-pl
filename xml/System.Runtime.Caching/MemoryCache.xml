<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37eadac5a9304b10a05ba5da93ce39d7ddceff4f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36541965" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryCache = class&#xA;    inherit ObjectCache&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje typ, który implementuje w pamięci podręcznej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache> Konkretną implementację klasy abstrakcyjnej jest klasa <xref:System.Runtime.Caching.ObjectCache> klasy.  
  
> [!NOTE]
>  <xref:System.Runtime.Caching.MemoryCache> Klasy jest podobna do platformy ASP.NET <xref:System.Web.Caching.Cache> klasy. <xref:System.Runtime.Caching.MemoryCache> Klasa ma wiele właściwości i metod dostępu do pamięci podręcznej, który ma być znane, jeśli używasz programu ASP.NET <xref:System.Web.Caching.Cache> klasy. Główne różnice między <xref:System.Web.Caching.Cache> i <xref:System.Runtime.Caching.MemoryCache> klasy, które są <xref:System.Runtime.Caching.MemoryCache> klasy został zmieniony, tak aby można było używać przez [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] aplikacje, które nie są aplikacji ASP.NET. Na przykład <xref:System.Runtime.Caching.MemoryCache> klasa nie ma żadnych zależności `System.Web` zestawu. Inna różnica polega na, możesz utworzyć wiele wystąpień <xref:System.Runtime.Caching.MemoryCache> klasy do użycia w tej samej aplikacji w taki sam <xref:System.AppDomain> wystąpienia.  
  
 <xref:System.Runtime.Caching.MemoryCache> Klasy nie zezwala na `null` jako wartość w pamięci podręcznej. Próby dodać lub zmienić wpis pamięci podręcznej z wartością `null` zakończy się niepowodzeniem.  
  
 <xref:System.Runtime.Caching.MemoryCache> Typ nie implementuje *pamięci podręcznej regionów*. W związku z tym podczas wywoływania <xref:System.Runtime.Caching.MemoryCache> metody implementujących metod bazowych zawierających parametr regionach, nie przekazuj wartości dla parametru. Metody, które należy użyć parametru region wszystkich podać wartości domyślnej `null` wartość. Na przykład <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> przeciążenie metody ma `regionName` parametru, którego wartość domyślna to `null`.  
  
   
  
## Examples  
 Poniższy przykład deklaruje odwołanie do domyślnego wystąpienia pamięci podręcznej pamięci. Wpis pamięci podręcznej <xref:System.Runtime.Caching.CacheItemPolicy> obiekt, aby podać szczegóły wykluczenia i wygaśnięcia wpisu pamięci podręcznej. Ponadto użyto <xref:System.Runtime.Caching.ChangeMonitor> obiekt, aby monitorować stan źródła danych (czyli pliku) w systemie plików.  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = null)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia w celu wyszukania informacji o konfiguracji.  
  
 <c>Uwaga</c> nie jest wymagane dla każdej nazwy istnieją informacje o konfiguracji.  Jeśli pozycja konfiguracji istnieje, informacje o konfiguracji jest używany do konfigurowania <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia. Jeśli pozycja konfiguracji nie istnieje, nazwa jest możliwy za pośrednictwem <see cref="P:System.Runtime.Caching.MemoryCache.Name" /> właściwości, ponieważ podana nazwa jest skojarzona z <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia. Aby uzyskać informacje o konfigurację pamięci podręcznej pamięci, zobacz <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />.</param>
        <param name="config">Kolekcja par nazwa/wartość informacji o konfiguracji na potrzeby konfigurowanie pamięci podręcznej.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Runtime.Caching.MemoryCache> klasy został zainicjowany, sprawdza w nich pozycje konfiguracji, które może poprawić przy użyciu opcjonalnego `config` parametru w konstruktorze. Można przekazać następujących parametrów w `config` parametru. Wszystkie wartości mogą być przekazywane jako liczby całkowite.  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 Po wywołaniu tego konstruktora ustawienia konfiguracji najpierw są pobierane z pliki konfiguracji aplikacji. Jeśli nie istnieją żadne wpisy konfiguracji w pliku konfiguracji aplikacji, tylko ustawienia podane w `config` są stosowane. Jeśli istnieje pozycji konfiguracji w konfiguracji aplikacji, a także przekazywania informacji w `config`, informacje w `config` zastępuje informacje, które zostanie odczytany z pliku konfiguracji.  
  
 Wartość Nazwa, która jest przypisana do wystąpienia pamięci podręcznej jest używany na dwa sposoby:  
  
-   Aby pomóc Ci śledzić wiele wystąpień w pamięci podręcznej, jeśli istnieje więcej niż jedno wystąpienie.  
  
-   Odwołanie do ustawienia w konfiguracji plików podczas <xref:System.Runtime.Caching.MemoryCache> zainicjowano wystąpienia.  
  
    > [!NOTE]
    >  Nie istnieje mechanizm wymusić unikatowej nazwy dla wystąpienia pamięci podręcznej. W związku z tym użytkownik może istnieć wiele wystąpień w pamięci podręcznej o takiej samej nazwie.  
  
    > [!CAUTION]
    >  Nie twórz <xref:System.Runtime.Caching.MemoryCache> wystąpienia, chyba że jest to wymagane. W przypadku utworzenia wystąpienia pamięci podręcznej klienta i aplikacji sieci Web, <xref:System.Runtime.Caching.MemoryCache> wystąpień powinny zostać utworzone wcześniej w cyklu życia aplikacji. Należy utworzyć tylko liczby wystąpień pamięci podręcznej, które będą używane w aplikacji i przechowywania odwołań do wystąpienia pamięci podręcznej w zmiennych, które mogą być udostępniane globalnie. Na przykład w aplikacji ASP.NET można przechowywać odwołania w stan aplikacji. Jeśli tworzysz tylko pamięci podręcznej pojedynczego wystąpienia aplikacji przy użyciu pamięci podręcznej domyślne i odwołać się do niego z <xref:System.Runtime.Caching.MemoryCache.Default%2A> właściwości, gdy trzeba uzyskać dostępu do pamięci podręcznej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa lub wartość w <paramref name="config" /> nie można przeanalizować parametru.</exception>
        <exception cref="T:System.Configuration.ConfigurationException">Wartość w <paramref name="config" /> kolekcji jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection * bool -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config, ignoreConfigSection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do użycia w celu wyszukania informacji o konfiguracji.</param>
        <param name="config">Kolekcja par nazwa/wartość informacji o konfiguracji na potrzeby konfigurowanie pamięci podręcznej.</param>
        <param name="ignoreConfigSection">Wskazuje, czy sekcja konfiguracji należy ją ignorować.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="memoryCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia i dodaje szczegółowe informacje dotyczące sposobu wykluczyć wpis.</summary>
        <returns>wartość true, jeśli wstawienie powiodło się, lub FAŁSZ, jeśli istnieje już wpis w pamięci podręcznej, która ma ten sam klucz elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> i <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> nie obsługują przeciążenia metody <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości. W związku z tym aby ustawić <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości wpisu pamięci podręcznej, użyj <xref:System.Runtime.Caching.MemoryCache.Set%2A> metoda przeciąża zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A> Przeciążenia metody są używane do wstawiania wpis pamięci podręcznej w pamięci podręcznej. Jeśli wpis pamięci podręcznej z dopasowany klucz nie istnieje, te metody wstawić nowy wpis. Jeśli wpis pamięci podręcznej z dopasowany klucz już istnieje, że oba operatory zwracają istniejący wpis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.AddOrGetExisting (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <summary>Dodaje wpis pamięci podręcznej w pamięci podręcznej przy użyciu określonego <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia i szczegółowe informacje na temat wykluczyć wpis.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, istniejący wpis pamięci podręcznej; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `item` Parametr dostarcza klucz i wartość, która jest używana przez metodę. Jeśli pamięć podręczna zawiera wpis pamięci podręcznej mający ten klucz jako klucz `item` parametr, metoda zwraca istniejący wpis jako <xref:System.Runtime.Caching.CacheItem> wystąpienia. Jeśli nie nie istniejący wpis pamięci podręcznej, metoda tworzy nowy przy użyciu klucza i wartości dostarczone przez `item` parametru i szczegóły wykluczenia określony przez `policy`.  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> i <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> nie obsługują przeciążenia metody <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości. W związku z tym aby ustawić <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości wpisu pamięci podręcznej, użyj <xref:System.Runtime.Caching.MemoryCache.Set%2A> metoda przeciąża zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Runtime.Caching.CacheItem.Value" /> Jest właściwość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Bezwzględna i przedłużanie ważności wartości <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości inne niż ustawienia domyślne <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pól. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy nie można ustawić zasady wygasania oparty na kombinacji wygaśnięcia bezwzględne i wygasanie przewijania. Tylko jedno ustawienie wygaśnięcia może zostać jawnie ustawiona, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia. Ustawienia wygaśnięcia musi mieć ustawioną <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> pola lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pola.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona wartość mniejsza niż <see cref="F:System.TimeSpan.Zero" />.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> właściwości ustawiono wartość większa niż jeden rok.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej dodać.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="absoluteExpiration">Stałe datę i godzinę wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Dodaje wpis pamięci podręcznej w pamięci podręcznej przy użyciu określonego klucza i wartość i wartość dla wygaśnięcia bezwzględne.</summary>
        <returns>Jeśli istnieje wpis pamięci podręcznej z tym samym kluczem, istniejący wpis pamięci podręcznej; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pamięć podręczna nie ma wpisu pamięci podręcznej którego klucza dopasowań `key` parametru jest tworzony nowy wpis pamięci podręcznej i <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> zwraca przeciążenie metody `null`. Jeśli zgodnego wpisu pamięci podręcznej istnieje, zwracany jest istniejący wpis.  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> i <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> nie obsługują przeciążenia metody <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości. W związku z tym aby ustawić <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości wpisu pamięci podręcznej, użyj <xref:System.Runtime.Caching.MemoryCache.Set%2A> metoda przeciąża zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Bezwzględna i przedłużanie ważności wartości <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości inne niż ustawienia domyślne <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pól. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy nie można ustawić zasady wygasania oparty na kombinacji wygaśnięcia bezwzględne i wygasanie przewijania. Tylko jedno ustawienie wygaśnięcia może zostać jawnie ustawiona, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia. Ustawienia wygaśnięcia musi mieć ustawioną <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona wartość mniejsza niż <see cref="F:System.TimeSpan.Zero" />.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> właściwości ustawiono wartość większa niż jeden rok.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator wpisu pamięci podręcznej dodać lub pobrać.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Domyślnie ten parametr jest <see langword="null" />, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej przy użyciu określonego klucza i wartości i podanych szczegółów dla jego wykluczenie.</summary>
        <returns>Jeśli odpowiadający mu wpis w pamięci podręcznej już istnieje, wpis pamięci podręcznej; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> i <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> nie obsługują przeciążenia metody <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości. W związku z tym aby ustawić <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> właściwości wpisu pamięci podręcznej, użyj <xref:System.Runtime.Caching.MemoryCache.Set%2A> metoda przeciąża zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Bezwzględna i przedłużanie ważności wartości <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości inne niż ustawienia domyślne <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy nie można ustawić zasady wygasania oparty na kombinacji bezwzględnym i wygasanie przewijania. Tylko jedno ustawienie wygaśnięcia może zostać jawnie ustawiona, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy. Inne ustawienie musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  - lub - usunięcie zarówno wywołania zwrotnego i wywołania zwrotnego aktualizacji zostały określone dla <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. <see cref="T:System.Runtime.Caching.MemoryCache" /> Obsługuje tylko przy użyciu jednego typu wywołania zwrotnego dla pamięci podręcznej zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona wartość mniejsza niż <see cref="F:System.TimeSpan.Zero" />.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> została ustawiona jako wartość większa niż jeden rok.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci na komputerze, w bajtach, które mogą być używane przez pamięci podręcznej.</summary>
        <value>Ilość pamięci w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżące wystąpienie pamięci podręcznej przekracza limit pamięci ustawione przez <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> właściwość implementację buforu usuwa wpisy w pamięci podręcznej. Każde wystąpienie pamięci podręcznej w aplikacji można użyć ilość pamięci, która jest określona przez <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> właściwości.  
  
 Ustawienia dla <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> właściwość może zostać określona w pliku konfiguracyjnym aplikacji. Alternatywnie mogą być przekazywane w Konstruktorze podczas <xref:System.Runtime.Caching.MemoryCache> klasy został zainicjowany. Aby uzyskać więcej informacji na temat konfigurowania tej właściwości, zobacz [ &lt;namedCaches&gt; elementu (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Aby uzyskać więcej informacji o sposobie Ustaw tę wartość przy <xref:System.Runtime.Caching.MemoryCache> klasy jest inicjowany, zobacz <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> metody.  
  
 <xref:System.Runtime.Caching.MemoryCache> teraz nie wymusza <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> każdym dodaniu nowego elementu do <xref:System.Runtime.Caching.MemoryCache> wystąpienia. Wewnętrzne algorytmy heurystyczne, który wyklucza mogą dodatkowe elementy z <xref:System.Runtime.Caching.MemoryCache> jest stopniowo i uwzględnia informacje o koncie z modułu zbierającego elementy bezużyteczne (zobacz [wyrzucanie elementów bezużytecznych](~/docs/standard/garbage-collection/index.md)) i innych czynników, takich jak bieżący rozmiar pamięci podręcznej i ogólne wykorzystanie pamięci systemu. Dlatego nawet jeśli <xref:System.Runtime.Caching.MemoryCache> próbuje zachować rozmiar pamięci podręcznej w ciągu skonfigurowanego <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> można tymczasowo przekraczają limit przez dodanie elementów pamięci podręcznej bardzo dużą szybkością.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Contains : string * string -&gt; bool" Usage="memoryCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej wyszukiwania.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Określa, czy w pamięci podręcznej istnieje wpis pamięci podręcznej.</summary>
        <returns>
          <see langword="true" /> Jeśli pamięć podręczna zawiera wpis pamięci podręcznej, którego klucz odpowiada <paramref name="key" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="override this.CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="memoryCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Wyliczenie wpisu pamięci podręcznej unikatowy kluczy dla <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> obiektu.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Tworzy <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> obiektów, które mogą wyzwalać zdarzenia w odpowiedzi na zmiany we określone wpisy w pamięci podręcznej.</summary>
        <returns>Monitor zmian, który monitoruje wpisów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> Metoda tworzy <xref:System.Runtime.Caching.CacheEntryChangeMonitor> wystąpienia. Ten monitor specjalne zmiany służy do monitorowania wpisy w pamięci podręcznej, które są określone w `keys` kolekcji i wyzwalacza zdarzenia zmiany wpisów.  
  
 Wpis monitorowanych jest uważany za zostały zmienione z następujących powodów:  
  
-   Klucz nie istnieje w tym czasie wywołania <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> metody. W takim przypadku powstałe w ten sposób <xref:System.Runtime.Caching.CacheEntryChangeMonitor> wystąpienia natychmiast ustawiono zmiany stanu. Oznacza to, że gdy kod wiąże następnie zmiany zwrotnego, wywołania zwrotnego zostanie wywołany bezpośrednio.  
  
-   Wpis pamięci podręcznej skojarzonych został usunięty z pamięci podręcznej. Taka sytuacja może wystąpić, jeśli wpis zostanie usunięty jawnie, gdy wygaśnie lub zostanie usunięty w celu odzyskania pamięci  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element <paramref name="keys" /> kolekcja jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Caching.MemoryCache" Usage="System.Runtime.Caching.MemoryCache.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do domyślnej <see cref="T:System.Runtime.Caching.MemoryCache" /> wystąpienia.</summary>
        <value>Domyślne wystąpienie pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca odwołanie do domyślnego wystąpienia pamięci podręcznej. W przypadku scenariuszy Typowa aplikacja tylko jedno wystąpienie <xref:System.Runtime.Caching.MemoryCache> jest wymagana.  
  
 Ponieważ domyślne wystąpienie pamięci podręcznej nie jest tworzony przez konstruktora, należy użyć konfiguracji jawnie ustaw wartości sondowania dla domyślnego wystąpienia pamięci podręcznej i ilość pamięci. Aby uzyskać więcej informacji, zobacz [ &lt;memoryCache&gt; elementu (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opis funkcji dostępnych w pamięci podręcznej.</summary>
        <value>Bitowe połączenie flag, które wskazują możliwości domyślną implementację buforu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwości wdrażania pamięci podręcznej są kombinacją następujące wartości:  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryCache.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są używane przez bieżące wystąpienie klasy <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy <xref:System.Runtime.Caching.MemoryCache> jest powiązane wystąpienie <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> zdarzeń. Jednak podczas zamykania domeny aplikacji, jeśli pamięć podręczna oparty na pamięci nie został jawnie zlikwidowany, wystąpienia pamięci podręcznej automatycznie wywoła <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> metody.  
  
 Wystąpienia usuniętego pamięci podręcznej jest wyłączona w następujących krokach:  
  
1.  Stan pamięci podręcznej wynosi wskazują, że pamięć podręczna jest usunięty. Każda próba wywołać publicznej buforowanie metod, które spowodują zmianę stanu pamięci podręcznej, takich jak metody dodawania, usuwania lub pobrać Wpisy w pamięci podręcznej, może spowodować nieoczekiwane zachowanie. Na przykład, jeśli wywołujesz <xref:System.Runtime.Caching.MemoryCache.Set%2A> występuje błąd pusta — metoda po usunięciu pamięci podręcznej. Jeśli próba pobrania elementów z pamięci podręcznej, <xref:System.Runtime.Caching.MemoryCache.Get%2A> metoda zawsze zwraca `null`.  
  
2.  Informacje o liczniku wydajności nie jest wywoływane z bieżącego wystąpienia pamięci podręcznej.  
  
3.  Wszystkie odwołania do obiektów posiadanych przez bieżące wystąpienie pamięci podręcznej są wydawane.  
  
4.  Wszelkie <xref:System.Runtime.Caching.CacheEntryChangeMonitor> są powiadamiani o wystąpień, które są aktualnie monitorowane wpisów w pamięci podręcznej.  
  
5.  Wywołuje się obiektów wywołania zwrotnego, które dostarczają powiadomienia o zmianach dla tych monitorów.  
  
6.  Wszelkie <xref:System.Web.Caching.CacheItemRemovedCallback> noszą nazwę wystąpienia, które są zarejestrowane w usłudze wpisów w pamięci podręcznej. Powód usunięcia, który jest przekazywany do wywołania zwrotne jest <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Get : string * string -&gt; obj" Usage="memoryCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej do pobrania.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Zwraca wpis z pamięci podręcznej.</summary>
        <returns>Odwołanie do wpisu pamięci podręcznej, który jest identyfikowany przez <paramref name="key" />, jeśli istnieje wpis; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="override this.GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej do pobrania.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Zwraca określony wpis z pamięci podręcznej jako <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia.</summary>
        <returns>Odwołanie do wpisu pamięci podręcznej identyfikowane przez <paramref name="key" /> Jeśli istnieje wpis; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wpis pamięci podręcznej określony przez `key` istnieje w pamięci podręcznej, <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> metoda zwraca go jako <xref:System.Runtime.Caching.CacheItem> wystąpienia. <xref:System.Runtime.Caching.CacheItem.Key%2A> i <xref:System.Runtime.Caching.CacheItem.Value%2A> właściwości <xref:System.Runtime.Caching.CacheItem> wystąpienie zostanie ustawiona. Jednak <xref:System.Runtime.Caching.CacheItem.RegionName%2A> właściwość będzie `null`, ponieważ nie zaimplementowano w regionach <xref:System.Runtime.Caching.MemoryCache> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="override this.GetCount : string -&gt; int64" Usage="memoryCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Zwraca sumę wpisy w pamięci podręcznej w pamięci podręcznej.</summary>
        <returns>Liczba wpisów w pamięci podręcznej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="memoryCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy moduł wyliczający, który może służyć do iterowania po kolekcji wpisów pamięci podręcznej.</summary>
        <returns>Obiekt moduł wyliczający, który zapewnia dostęp do elementów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający, który jest zwracany przez <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> metoda może służyć do wykonywania iteracji wpisów w pamięci podręcznej.  
  
> [!IMPORTANT]
>  Pobieranie modułu wyliczającego dla <xref:System.Runtime.Caching.MemoryCache> wystąpienia jest operacją intensywnie i blokowania. W związku z tym moduł wyliczający nie należy używać w aplikacji produkcyjnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="member this.GetLastSize : string -&gt; int64" Usage="memoryCache.GetLastSize regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Nazwa regionu.</param>
        <summary>Pobiera rozmiar obszaru nazwanego.</summary>
        <returns>Rozmiar obszaru nazwanego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="override this.GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="memoryCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Zestaw unikatowych identyfikatorów dla wpisów pamięci podręcznej do zwrócenia.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Zwraca zestaw wpisy w pamięci podręcznej, które odpowiadają na określone klucze.</summary>
        <returns>Zestaw wpisy w pamięci podręcznej, które odpowiadają na określone klucze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wpis pamięci podręcznej, która jest reprezentowana przez `keys` nie istnieje, wartość odpowiadająca dla zwrócony obiekt w słowniku jest ustawiony na `null`. W związku z tym słowniku zwrócony zawsze ma taką samą liczbę elementów jako liczba elementów w `keys`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Poszczególne klucz w kolekcji jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.MemoryCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla do pobierania lub ustawiania wartości pamięci podręcznej.</param>
        <summary>Pobiera lub ustawia wartość w pamięci podręcznej przy użyciu domyślnej właściwości indeksatora dla wystąpienia <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy.</summary>
        <value>Wartość wystąpienia pamięci podręcznej dla określonego klucza, jeśli istnieje wpis; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ustawieniu tej właściwości wartości zostaną wstawione do pamięci podręcznej. Ustawiono zasady wygaśnięcia wpisu pamięci podręcznej <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration>. Jeśli wpis pamięci podręcznej z dopasowany klucz już istnieje, jego wartość jest aktualizowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.  - lub - jest wstawiona wartość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.MemoryCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę pamięci podręcznej.</summary>
        <value>Nazwa pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.Name%2A> Właściwość zwraca nazwę bieżące wystąpienie klasy <xref:System.Runtime.Caching.MemoryCache> klasy. W aplikacji, która używa wielu wystąpień w pamięci podręcznej, można użyć <xref:System.Runtime.Caching.MemoryCache.Name%2A> właściwości ułatwia odróżnienie wystąpień. Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> metody. Domyślne oparty na pamięci pamięci podręcznej zwraca nazwę domyślną.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartości procentowej pamięci fizycznej pamięci podręcznej można użyć.</summary>
        <value>Procent używanego w pamięci podręcznej pamięci fizycznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> Właściwość zwraca procent całkowitej komputera fizycznego pamięci, które mogą być używane przez pojedyncze wystąpienie <xref:System.Runtime.Caching.MemoryCache> klasy. Jeśli wystąpienie pamięci podręcznej przekracza limit określony, wpisy w pamięci podręcznej są usuwane.  
  
 Ustawienia dla <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> właściwość może zostać określona w pliku konfiguracyjnym aplikacji. Alternatywnie mogą być przekazywane przez obiekt wywołujący podczas <xref:System.Runtime.Caching.MemoryCache> klasy został zainicjowany. Aby uzyskać więcej informacji na temat konfigurowania tej właściwości, zobacz [ &lt;namedCaches&gt; elementu (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Aby uzyskać więcej informacji o sposobie konfigurowania właściwości podczas <xref:System.Runtime.Caching.MemoryCache> klasy jest inicjowany, zobacz <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PollingInterval : TimeSpan" Usage="System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalny czas, po którym pamięci podręcznej aktualizuje statystyki jego pamięci.</summary>
        <value>Maksymalny czas, które mogą wystąpić przed pamięci statystyki są aktualizowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienia dla <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A> właściwość może zostać określona w pliku konfiguracyjnym aplikacji. Można również one mogą zostać przekazane podczas <xref:System.Runtime.Caching.MemoryCache> klasy został zainicjowany. Aby uzyskać więcej informacji na temat konfigurowania tej właściwości, zobacz [ &lt;namedCaches&gt; elementu (ustawienia pamięci podręcznej)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Aby uzyskać więcej informacji o sposobie konfigurowania właściwości podczas <xref:System.Runtime.Caching.MemoryCache> klasy jest inicjowany, zobacz <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa określony element z pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * string -&gt; obj" Usage="memoryCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej do usunięcia.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Usuwa wpis pamięci podręcznej z pamięci podręcznej.</summary>
        <returns>Jeśli wpis zostanie znaleziony w pamięci podręcznej, wpis pamięci podręcznej usunięte; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wpis określony przez `key` istnieje w pamięci podręcznej, usuwanie wyzwalaczy elementu wszelkie zmiany skojarzone monitory. Jeśli usunięty element został skojarzony z <xref:System.Web.Caching.CacheItemUpdateCallback> obiektu lub <xref:System.Web.Caching.CacheItemRemovedCallback> obiekt Przyczyna przekazany do wywołania zwrotnego <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * System.Runtime.Caching.CacheEntryRemovedReason * string -&gt; obj" Usage="memoryCache.Remove (key, reason, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej do usunięcia.</param>
        <param name="reason">Przyczyny, dla której element został usunięty.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której dodano wpis pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Usuwa wpis pamięci podręcznej z pamięci podręcznej, za pomocą przyczyny.</summary>
        <returns>Jeśli wpis zostanie znaleziony w pamięci podręcznej, wpis pamięci podręcznej usunięte; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony wpis nie istnieje, jest tworzony. Jeśli określony wpis istnieje, jest aktualizowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="memoryCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który reprezentuje wpis pamięci podręcznej do wstawienia.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej przy użyciu <see cref="T:System.Runtime.Caching.CacheItem" /> wystąpienia, aby podać klucz i wartość wpisu pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Takich jak inne <xref:System.Runtime.Caching.MemoryCache.Set%2A> przeciążenia metody <xref:System.Runtime.Caching.MemoryCache.Set%2A> metody zawsze umieszcza wartość pamięci podręcznej w pamięci podręcznej, niezależnie od tego, czy wpis już istnieje z tym samym kluczem. Jeśli określony wpis nie istnieje w pamięci podręcznej, jest wstawiany nowy wpis pamięci podręcznej. Jeśli określony wpis już istnieje, jego wartość jest aktualizowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.  - lub - <see cref="P:System.Runtime.Caching.CacheItem.Key" /> jest właściwość <see langword="null" />.  - lub - <see cref="P:System.Runtime.Caching.CacheItem.Value" /> jest właściwość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Przekazano nieprawidłową kombinację argumentów dla wpisu pamięci podręcznej. Dzieje się tak, jeśli następujące szczegóły ważności są ustawiane w obiekcie zasad dla wpisu pamięci podręcznej: - Jeśli bezwzględne i przedłużanie ważności wartości <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości inne niż ustawienia domyślne <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> pól. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasy nie można ustawić zasady wygasania na podstawie zarówno wygaśnięcia bezwzględne, jak i wygasanie przewijania. Tylko jedno ustawienie wygaśnięcia może zostać jawnie ustawiona, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy. Inne ustawienie musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> właściwości.  — Jeśli jest określony zarówno wywołania zwrotnego usuwania, jak i wywołanie zwrotne aktualizacji dla <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa obsługuje tylko przy użyciu jednego typu wywołania zwrotnego dla pamięci podręcznej zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona wartość mniejsza niż <see cref="F:System.TimeSpan.Zero" />.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> właściwości ustawiono wartość większa niż jeden rok.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="memoryCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej do wstawienia.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="absoluteExpiration">Stałe datę i godzinę wygaśnięcia wpisu pamięci podręcznej.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej przy użyciu klucza i wartości i określa szczegóły na podstawie czasu wygaśnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Takich jak inne <xref:System.Runtime.Caching.MemoryCache.Set%2A> przeciążenia metody <xref:System.Runtime.Caching.MemoryCache.Set%2A> — metoda zawsze umieszcza wartość pamięci podręcznej w pamięci podręcznej, niezależnie od tego, czy istnieje już wpis z takim samym kluczu. Jeśli określony wpis nie istnieje, jest wstawiany nowy wpis pamięci podręcznej. Jeśli określony wpis istnieje, jest aktualizowana.  
  
 `absoluteExpiration` Parametr wskazuje, kiedy należy usunąć wpis z pamięci podręcznej.  
  
 Usuwanie wpisu wyzwala wszelkie zmiany skojarzone monitory. Jeśli usunięty element został skojarzony z <xref:System.Web.Caching.CacheItemUpdateCallback> obiektu lub <xref:System.Web.Caching.CacheItemRemovedCallback> obiektu o przyczynie usunięcia, który jest przekazywany do wywołania zwrotne znajduje się w <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.  - lub - <paramref name="Value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">— Przekazano Nieprawidłowa kombinacja argumentów dla wpisu pamięci podręcznej. Dzieje się tak, jeśli następujące szczegóły ważności są ustawiane w obiekcie zasad dla wpisu pamięci podręcznej: - w przypadku wygaśnięcia bezwzględne i przesuwanego wartości na <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości inne niż ustawienia domyślne <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Dzieje się tak dlatego <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie obsługuje wygasające wpisy na podstawie zarówno bezwzględnym i wygasanie przewijania. Tylko jedno ustawienie wygaśnięcia może zostać jawnie ustawiona, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy. Inne ustawienie musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  — Jeśli jest określony zarówno wywołania zwrotnego usuwania, jak i wywołanie zwrotne aktualizacji na <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa obsługuje tylko przy użyciu jednego typu wywołania zwrotnego dla pamięci podręcznej zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona wartość mniejsza niż <see cref="F:System.TimeSpan.Zero" />.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> właściwości ustawiono wartość większa niż jeden rok.  - lub - - <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="memoryCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla wpisu pamięci podręcznej do wstawienia.</param>
        <param name="value">Dane dla wpisu pamięci podręcznej.</param>
        <param name="policy">Obiekt zawierający szczegóły wykluczenia wpisu pamięci podręcznej. Ten obiekt zawiera więcej opcji wykluczenia niż proste wygaśnięcia bezwzględne.</param>
        <param name="regionName">Nazwane region w pamięci podręcznej, do której można dodać wpisu pamięci podręcznej. Nie przekazuj wartości dla tego parametru. Ten parametr jest <see langword="null" /> domyślnie, ponieważ <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie implementuje regionów.</param>
        <summary>Wstawia wpis pamięci podręcznej w pamięci podręcznej przy użyciu klucza i wartości i wykluczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Takich jak inne <xref:System.Runtime.Caching.MemoryCache.Set%2A> przeciążenia metody <xref:System.Runtime.Caching.MemoryCache.Set%2A> metody zawsze umieszcza wartość pamięci podręcznej w pamięci podręcznej, niezależnie od tego, czy pozycja już istnieje. Jeśli określony wpis nie istnieje w pamięci podręcznej, jest wstawiany nowy wpis pamięci podręcznej. Jeśli określony wpis istnieje, jest aktualizowana.  
  
 Usuwanie wpisu wyzwala wszelkie zmiany skojarzone monitory. Jeśli usunięty element został skojarzony z <xref:System.Web.Caching.CacheItemUpdateCallback> obiektu lub <xref:System.Web.Caching.CacheItemRemovedCallback> obiektu o przyczynie usunięcia, który jest przekazywany do wywołania zwrotne znajduje się w <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.  - lub - <paramref name="value" /> jest <see langword="null" /> - lub - odwołania do wywołania zwrotnego, który został przekazany do metody pomocnika w <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" /> jest właściwość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">— Istnieje nieprawidłowa kombinacja argumentów dla wpisu pamięci podręcznej. Dzieje się tak, jeśli następujące szczegóły ważności są ustawiane w obiekcie zasad dla wpisu pamięci podręcznej: - w przypadku wygaśnięcia bezwzględne i przesuwanego wartości na <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> obiektu są ustawione na wartości inne niż ustawienia domyślne <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> i <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Jest to spowodowane <see cref="T:System.Runtime.Caching.MemoryCache" /> klasa nie obsługuje wygasające wpisy na podstawie zarówno bezwzględnym i wygasanie przewijania. Tylko jedno ustawienie wygaśnięcia może zostać jawnie ustawiona, gdy używasz <see cref="T:System.Runtime.Caching.MemoryCache" /> klasy. Inne ustawienie musi być równa <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> lub <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  — Jeśli jest określony zarówno wywołania zwrotnego usuwania, jak i wywołanie zwrotne aktualizacji na <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> klasy. <see cref="T:System.Runtime.Caching.MemoryCache" /> Klasa obsługuje tylko przy użyciu jednego typu wywołania zwrotnego dla pamięci podręcznej zapisu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> Właściwość jest ustawiona wartość mniejsza niż <see cref="F:System.TimeSpan.Zero" />.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> właściwości ustawiono wartość większa niż jeden rok.  - lub - <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> właściwość nie jest wartością <see cref="T:System.Runtime.Caching.CacheItemPriority" /> wyliczenia.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> nie jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia obsługę iteracji przez kolekcję ogólną.</summary>
        <returns>Obiekt moduł wyliczający, który zapewnia dostęp do wpisów w pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Runtime.Caching.MemoryCache> wystąpienia jest rzutowane na <xref:System.Collections.IEnumerable> interfejsu.  
  
 Ta metoda służy do iteracji ogólnych kolekcji wpisów pamięci podręcznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberSignature Language="F#" Value="member this.Trim : int -&gt; int64" Usage="memoryCache.Trim percent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">Procent całkowitej wpisów pamięci podręcznej do usunięcia.</param>
        <summary>Usuwa określoną wartość procentową wpisy w pamięci podręcznej z obiektu pamięci podręcznej.</summary>
        <returns>Liczba wpisów usunięty z pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.Trim%2A> Właściwość najpierw usuwa wpisy, które przekroczyły bezwzględną lub przedłużanie ważności. Wszystkie wywołania zwrotne zarejestrowane dla elementów, które zostały usunięte zostaną przekazane usunięto przyczynę <xref:System.Web.Caching.CacheItemRemovedReason.Expired>.  
  
 Jeśli usuwanie wygasłych wpisów jest niewystarczający w celu osiągnięcia określonej wartości procentowej przycinania, dodatkowe wpisy zostaną usunięte z pamięci podręcznej oparte na ostatnio używanych algorytm (LRU), aż do osiągnięcia żądanej wartości procentowej przycinania. Wszystkie wywołania zwrotne, które są zarejestrowane dla elementów, które są usuwane w ten sposób zostanie przekazany Usuń przyczynę <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="WorkflowInstance" FullName="System.Workflow.Runtime.WorkflowInstance">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3f6722f462218341de377b996c28536f8dae9901" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52222298" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInstance extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowInstance" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInstance sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInstance = class" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje wystąpienie przepływu pracy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 <xref:System.Workflow.Runtime.WorkflowInstance> Klasa udostępnia metody i właściwości, które mogą służyć do kontrolowania wykonywania wystąpienia przepływu pracy; jest zasadniczo serwera proxy do wystąpienia faktyczny przepływ pracy, używany przez aparatu wykonawczego przepływów pracy. Hosta lub usługi można nakazać aparatu wykonawczego przepływów pracy do wykonywania akcji względem wystąpienia przepływu pracy przez wywołanie odpowiedniej metody, które są zawarte w <xref:System.Workflow.Runtime.WorkflowInstance> klasy.  Jeśli żądana akcja nie jest prawidłowy, na przykład, jeśli host nie wywoła <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> w wystąpieniu przepływu pracy, który został już ukończony, aparatu wykonawczego przepływów pracy zgłosi wyjątek odpowiednie.  
  
> [!NOTE]
>  Jeśli wystąpienie przepływu pracy przestanie odpowiadać, ponieważ nie zwraca wywołanie aplikacji hosta, jedynym sposobem odzyskania wystąpienie jest ponowne uruchomienie w czasie wykonywania. Jednak jeśli wystąpienie zostało wymuszone zwolniony, zostało przerwane lub wstrzymana, jego może być kontynuowane, wywołując <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak utworzyć i uruchomić <xref:System.Workflow.Runtime.WorkflowInstance> hosta przepływu pracy. Ten kod tworzy wystąpienie <xref:System.Workflow.Runtime.WorkflowRuntime>, dodanie usługi do środowiska uruchomieniowego, a następnie pokazuje zalecany sposób tworzenia <xref:System.Workflow.Runtime.WorkflowInstance> obiektu. Inicjuje kod <xref:System.Workflow.Runtime.WorkflowInstance> przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> metody i przekazanie wcześniej utworzony typ do niego. <xref:System.Workflow.Runtime.WorkflowInstance> Zostanie uruchomiony przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> wywołania metody.  
  
 Ten przykład kodu jest częścią anulowanie przepływu pracy zestawu SDK przykładowe z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [anulowanie przepływu pracy](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Trwa anulowanie przepływu pracy</related>
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="workflowInstance.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przerywa wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie przepływu pracy zostało przerwane w sposób synchroniczne. oznacza to metoda zwraca po wystąpienia przepływu pracy zostało przerwane. Aparatu wykonawczego przepływów pracy unieważnia wystąpienia przepływu pracy w pamięci i czyszczenia <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. Jeśli usługa stanu trwałego użył wystąpienia przepływu pracy, wszystkich działań wykonanych od czasu ostatniego punktu trwałości jest wyrzucać. Po jego przerywa wystąpienia przepływu pracy, aparatu wykonawczego przepływów pracy zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted> zdarzeń. Możesz wywołać <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> Aby ponownie załadować wystąpienia przepływu pracy i Rozpocznij od ostatniego punktu stanu trwałego.  
  
 `Abort` różni się od <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> tego czasu `Abort` po prostu usuwa wystąpienie przepływu pracy w pamięci i może zostać uruchomiony ponownie z ostatniego punktu trwałości przerwania usuwa wystąpienie przepływu pracy w pamięci i informuje o trwałości usługę wystąpienie zostało wyczyszczone z pamięci. Aby uzyskać <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>, oznacza to, że wszystkie informacje o stanie dla tego wystąpienia przepływu pracy zostanie usunięta z bazy danych po zakończeniu. Nie można ponownie załadować wystąpienia przepływu pracy od punktu poprzednio zapisanego stanu trwałego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano przerwania wywoływania na wystąpienie przepływu pracy typu Workflow1.  
  
 [!code-csharp[WF_Samples#13](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#13)]
 [!code-vb[WF_Samples#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyWorkflowChanges">
      <MemberSignature Language="C#" Value="public void ApplyWorkflowChanges (System.Workflow.ComponentModel.WorkflowChanges workflowChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyWorkflowChanges(class System.Workflow.ComponentModel.WorkflowChanges workflowChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ApplyWorkflowChanges(System.Workflow.ComponentModel.WorkflowChanges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyWorkflowChanges(System::Workflow::ComponentModel::WorkflowChanges ^ workflowChanges);" />
      <MemberSignature Language="F#" Value="member this.ApplyWorkflowChanges : System.Workflow.ComponentModel.WorkflowChanges -&gt; unit" Usage="workflowInstance.ApplyWorkflowChanges workflowChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowChanges" Type="System.Workflow.ComponentModel.WorkflowChanges" />
      </Parameters>
      <Docs>
        <param name="workflowChanges">A <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> określenie aktualizacji dynamicznych dla wystąpienia przepływu pracy.</param>
        <summary>Zastosowanie zmian dla wystąpienia przepływu pracy, określony przez <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie przepływu pracy nie jest już wstrzymany, aparatu wykonawczego przepływów pracy tymczasowo wstrzymuje wystąpienie przed zastosowaniem zmian.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wywoływania ApplyWorkflowChanges do <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  W tym przykładzie pochodzi z przykładu porządkowanie SDK maszyny stanu z pliku Mainform.cs.  Aby uzyskać więcej informacji, zobacz [porządkowanie przykładowe maszyny stanu](https://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#89](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#89)]
 [!code-vb[WF_Samples#89](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItem">
      <MemberSignature Language="C#" Value="public void EnqueueItem (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItem(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItem(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItem (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItem(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItem : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItem (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Nazwa <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Obiekt, który można umieścić w kolejce.</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" /> Umożliwiającą nadawcy Aby otrzymywać powiadomienia, gdy <paramref name="item" /> są dostarczane.</param>
        <param name="workItem">Obiekt, który zostanie przekazany do <see cref="T:System.Workflow.Runtime.IPendingWork" /> metody.</param>
        <summary>Synchronicznie wysyła komunikat do kolejki określonego przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wysyła `item` określonej <xref:System.Workflow.Runtime.WorkflowQueue>. Jeśli chcesz otrzymywać powiadomienia, gdy komunikat jest dostarczany, można zaimplementować <xref:System.Workflow.Runtime.IPendingWork> w usłudze i w przebiegu `workItem` i <xref:System.Workflow.Runtime.IPendingWork> obiekt <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Jeśli nie chcesz takiego powiadomienia, można przekazać odwołanie o wartości null (`Nothing` w języku Visual Basic) dla `pendingWork` i `workItem`.  
  
 Przy użyciu tej metody za pomocą przepływ pracy automatu stanów, możesz otrzymać wyjątek z komunikatem "kolejki"{0}"nie jest włączona." Dzieje się tak, gdy bieżący stan automatu stanów nie potrafi obsłużyć określonego zdarzenia. Na przykład, jeśli pewnego stanu, innym niż bieżący stan zawiera <xref:System.Workflow.Activities.EventDrivenActivity> zawierający <xref:System.Workflow.Activities.HandleExternalEventActivity> reprezentowaną przez kolejkę "{0}".  
  
> [!NOTE]
>  Komunikaty nie gwarantuje odbierane przez wystąpienie przepływu pracy, w kolejności, w której zostały wysłane. Na przykład jeśli odebranie komunikatu w istniejącym kolejki przepływu pracy można utworzyć kolejki innej kolejki B, który następnie będzie nasłuchiwać pod kątem kolejną wiadomość wysłana po pierwszy komunikat powoduje, że (kolejki A), jest możliwe, że drugi komunikat zostanie wyświetlony pierwszy i nie będą odbierane ze względu na jej kolejki nie są jeszcze utworzona. Aby uniknąć tego problemu, drugi komunikat nie należy jej wysyłać dopóki nie zostanie zweryfikowana obecności drugi kolejki (przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>.)  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Gdy <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> wystąpi zdarzenie, `OnWorkflowIdled` metody zdefiniowanej w tym przykładzie jest wywoływana. Określa, który przepływ pracy jest bezczynny, za pomocą <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> właściwości, a następnie pobiera kolekcję elementów umieszczonych w kolejce dla przepływu pracy wystąpienie przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> metody. Kod iteruje po kolekcji, aby określić, które działania oczekuje na zdarzenie, które bezczynny przepływu pracy. Następnie wysyła wyjątek do kolejki przepływu pracy przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> metoda wraz z nazwą elementu do kolejki zdarzeń.  
  
 Ten przykład kodu jest częścią anulowanie przepływu pracy zestawu SDK przykładowe z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [anulowanie przepływu pracy](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> to odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.  
  
—lub— 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> Określony przez <paramref name="queueName" /> nie istnieje.  
  
—lub— 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> Określony przez <paramref name="queueName" /> nie jest włączona.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Trwa anulowanie przepływu pracy</related>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItemOnIdle">
      <MemberSignature Language="C#" Value="public void EnqueueItemOnIdle (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItemOnIdle(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItemOnIdle (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItemOnIdle(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItemOnIdle : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItemOnIdle (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Nazwa <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Obiekt, który można umieścić w kolejce.</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" /> Umożliwiającą nadawcy Aby otrzymywać powiadomienia, gdy <paramref name="item" /> są dostarczane.</param>
        <param name="workItem">Obiekt, który zostanie przekazany do <see cref="T:System.Workflow.Runtime.IPendingWork" /> metody.</param>
        <summary>Wysyła komunikat do kolejki określonego przepływu pracy, gdy przepływ pracy jest w stanie bezczynności. <see cref="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" /> czeka, aż przepływ pracy osiąga punkt bezczynności i umieszczeniu po zweryfikowaniu, że harmonogram przepływu pracy jest w stanie bezczynności (oznacza to, że żadna aktywna operacja jest wykonywana).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czeka, aż wystąpienie przepływu pracy przejdzie w stan bezczynności, a następnie wysyła `item` określonej <xref:System.Workflow.Runtime.WorkflowQueue>. Jeśli wywołasz <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle%2A> gdy wystąpienie przepływu pracy jest wstrzymane, aparatu wykonawczego przepływów pracy zgłosi <xref:System.InvalidOperationException>. Jeśli chcesz otrzymywać powiadomienia, gdy komunikat jest dostarczany, można zaimplementować <xref:System.Workflow.Runtime.IPendingWork> w usłudze i w przebiegu `workItem` i <xref:System.Workflow.Runtime.IPendingWork> obiekt <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Jeśli nie chcesz takiego powiadomienia, można przekazać odwołanie o wartości null (`Nothing` w języku Visual Basic) dla `pendingWork` i `workItem`.  
  
 Używając tej metody za pomocą przepływ pracy automatu stanów, możesz otrzymać wyjątek, który zawiera komunikat "kolejki"{0}"nie jest włączona." Dzieje się tak, gdy bieżący stan automatu stanów nie potrafi obsłużyć określonego zdarzenia. Na przykład, jeśli pewnego stanu, innym niż bieżący stan zawiera <xref:System.Workflow.Activities.EventDrivenActivity> zawierający <xref:System.Workflow.Activities.HandleExternalEventActivity> reprezentowaną przez kolejkę "{0}".  
  
   
  
## Examples  
 W poniższym przykładzie pokazano proces wysyłania informacji do wystąpienia przepływu pracy przy użyciu `EnqueueItemOnIdle` metody. Po pierwsze utworzeniu i uruchomieniu; obiektu wystąpienia przepływu pracy następnie, obiekt, który implementuje <xref:System.Workflow.Runtime.IPendingWork> jest tworzony interfejs. `EnqueueItemOnIdle` następnie jest wywoływana, przekazując ciąg wartości dla nazwy kolejki elementów umieszczonych w kolejce i element roboczy, który zostanie przekazany do metody obiektu pendingWork.  
  
 [!code-csharp[WF_Samples#12](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#12)]
 [!code-vb[WF_Samples#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> to odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.  
  
—lub— 
Wystąpienie przepływu pracy jest zawieszone.  
  
—lub— 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> Określony przez <paramref name="queueName" /> nie istnieje.  
  
—lub— 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> Określony przez <paramref name="queueName" /> nie jest włączona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="workflowInstance.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony obiekt jest równy <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</summary>
        <returns>
          <see langword="true" /> Jeśli określony obiekt jest taki sam, tym <see cref="T:System.Workflow.Runtime.WorkflowInstance" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt musi być wystąpieniem elementu <xref:System.Workflow.Runtime.WorkflowInstance> klasy i mają taką samą <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> ponieważ <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="workflowInstance.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego wystąpienia przepływu pracy.</summary>
        <returns>Wartość skrótu dla tego <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetHashCode%2A> Zwraca wartość skrótu na podstawie wartości <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowDefinition">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity GetWorkflowDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.ComponentModel.Activity GetWorkflowDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowDefinition () As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::ComponentModel::Activity ^ GetWorkflowDefinition();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowDefinition : unit -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowInstance.GetWorkflowDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera działania głównego dla tego wystąpienia przepływu pracy.</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Działania głównego umożliwia nawigować po hierarchii działania przepływu pracy.  
  
 Ta metoda nie jest bezpieczny wątkowo, więc hosta powinien synchronizować się jej wywołania tej metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano pobierania definicji przepływu pracy z wystąpieniem przepływu pracy.  W tym przykładzie pochodzi z przykładu porządkowanie SDK maszyny stanu z pliku Mainform.cs.  Aby uzyskać więcej informacji, zobacz [porządkowanie przykładowe maszyny stanu](https://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#86](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#86)]
 [!code-vb[WF_Samples#86](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#86)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowNextTimerExpiration">
      <MemberSignature Language="C#" Value="public DateTime GetWorkflowNextTimerExpiration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetWorkflowNextTimerExpiration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowNextTimerExpiration () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetWorkflowNextTimerExpiration();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowNextTimerExpiration : unit -&gt; DateTime" Usage="workflowInstance.GetWorkflowNextTimerExpiration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca następnego punktu w czasie, że <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> jest zaplanowane do dostarczenia komunikatu czasomierza.</summary>
        <returns>Wartość daty/godziny, która reprezentuje następnego <see cref="P:System.Workflow.Runtime.TimerEventSubscription.ExpiresAt" /> czasu to <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> , otrzymają komunikat czasomierza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration%2A> metodę, aby sprawdzić, czy więcej wiadomości czasomierza przepływu pracy są dodawane do kolejki. W tym przykładzie pochodzi z przykładu WorkflowThreading zestawu SDK z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [wątkowości przepływu pracy — przykład](https://msdn.microsoft.com/library/5b650be7-09fa-47db-a2f6-523dc8ea5ee9).  
  
 [!code-csharp[WF_Samples#284](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#284)]
 [!code-vb[WF_Samples#284](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#284)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Workflow.Runtime.TimerEventSubscription" />
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowQueueData">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowQueueData () As ReadOnlyCollection(Of WorkflowQueueInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowQueueInfo ^&gt; ^ GetWorkflowQueueData();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowQueueData : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;" Usage="workflowInstance.GetWorkflowQueueData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> obiektów, które zawiera elementy oczekujące i subskrybowanego działania dla kolejek przepływu pracy skojarzonego z tym wystąpieniem przepływu pracy.</summary>
        <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> z <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> Zwraca kolekcję <xref:System.Workflow.Runtime.WorkflowQueueInfo> obiektów, z których każdy zawiera informacje o stanie kolejki przepływu pracy skojarzonego z tym wystąpieniem przepływu pracy. <xref:System.Workflow.Runtime.WorkflowQueueInfo.Items%2A?displayProperty=nameWithType> zawiera elementy oczekujące na <xref:System.Workflow.Runtime.WorkflowQueue> i <xref:System.Workflow.Runtime.WorkflowQueueInfo.SubscribedActivityNames%2A?displayProperty=nameWithType> zawiera listę działań, które są zasubskrybowano dostarczania elementu <xref:System.Workflow.Runtime.WorkflowQueue>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można użyć <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> metodę, aby uzyskać informacje o stanie wszystkich kolejek przepływu pracy skojarzonego z <xref:System.Workflow.Runtime.WorkflowInstance> obiektu. Gdy <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> wystąpi zdarzenie, `OnWorkflowIdled` metody zdefiniowanej w tym przykładzie jest wywoływana. Określa, który przepływ pracy jest bezczynny, za pomocą <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> właściwości, a następnie pobiera kolekcję elementów umieszczonych w kolejce dla przepływu pracy wystąpienie przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> metody. Kod iteruje po kolekcji, aby określić, które działania oczekuje na zdarzenie, które bezczynny przepływu pracy. Następnie wysyła wyjątek do kolejki przepływu pracy przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> metoda wraz z nazwą elementu do kolejki zdarzeń.  
  
 Ten przykład kodu jest częścią anulowanie przepływu pracy zestawu SDK przykładowe z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [anulowanie przepływu pracy](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Trwa anulowanie przepływu pracy</related>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public Guid InstanceId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid InstanceId" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid InstanceId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceId : Guid" Usage="System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator dla wystąpienia przepływu pracy.</summary>
        <value>
          <see cref="T:System.Guid" /> Wystąpienia przepływu pracy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> można odwoływać się do wystąpienia przepływu pracy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można użyć <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> właściwość, aby uzyskać informacje na temat <xref:System.Workflow.Runtime.WorkflowInstance> obiektu. Pierwszy fragment kodu tworzy <xref:System.Workflow.Runtime.WorkflowInstance> zmiennej o nazwie `instanceId`.  
  
 [!code-csharp[WF_Samples#210](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#210)]
 [!code-vb[WF_Samples#210](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#210)]  
  
 Drugi fragment kodu używa <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> właściwość jako pierwszy obiekt `OrderEventArgs` wywołanie konstruktora, kiedy `CallBackForApproval` metoda jest wywoływana.  
  
 Ten przykład kodu jest częścią Przykładowy zestaw SDK nasłuchiwania z pliku OrderServiceImple.cs. Aby uzyskać więcej informacji, zobacz [nasłuchiwania przykładowe](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90)).  
  
 [!code-csharp[WF_Samples#211](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#211)]
 [!code-vb[WF_Samples#211](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#211)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90)">Nasłuchiwania — przykład</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Load" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load();" />
      <MemberSignature Language="F#" Value="member this.Load : unit -&gt; unit" Usage="workflowInstance.Load " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ładuje wystąpienie przepływu pracy wcześniej usunięty z pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> jest synchroniczne; Jeśli wystąpienie przepływu pracy mogą być ładowane, <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> zostanie zakończone po wystąpienia przepływu pracy zostało załadowane do pamięci i zaplanowane przez aparatu wykonawczego przepływów pracy. Środowisko wykonawcze zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> zdarzenie po usługi trwałości został przywrócony wystąpienia przepływu pracy w pamięci, ale przed przepływu pracy aparatu wykonawczego planuje wystąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób ładowania wcześniej zwolnione <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#10](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#10)]
 [!code-vb[WF_Samples#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReloadTrackingProfiles">
      <MemberSignature Language="C#" Value="public void ReloadTrackingProfiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReloadTrackingProfiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ReloadTrackingProfiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReloadTrackingProfiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReloadTrackingProfiles();" />
      <MemberSignature Language="F#" Value="member this.ReloadTrackingProfiles : unit -&gt; unit" Usage="workflowInstance.ReloadTrackingProfiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Załaduj ponownie profile śledzenia dla tego wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Infrastruktura śledzenia środowiska uruchomieniowego spowoduje ponowne załadowanie każdego <xref:System.Workflow.Runtime.Tracking.TrackingProfile> dla tego wystąpienia przepływu pracy, skojarzone z jego kanały śledzenia. Jeśli nie jest już w stanie wstrzymania, przepływ pracy jest tymczasowo wstrzymane przez środowisko uruchomieniowe śledzenia infrastruktury, podczas gdy profile śledzenia są ponownie załadowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="workflowInstance.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia działanie wystąpienia przepływu pracy wstrzymanej wcześniej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Host może wywołać <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A> można wznowić wykonywania wystąpienia przepływu pracy, który wcześniej zawiesiłeś. Jeśli wystąpienie przepływu pracy nie jest w stanie wstrzymania, nie podjęto żadnej akcji. Środowisko wykonawcze zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> zdarzeń przed wznowieniem wykonywania wystąpienia przepływu pracy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wznowienia wywołującego w wystąpieniu wcześniej Wstrzymany przepływ pracy.  W tym przykładzie pochodzi z przykładu Wstrzymaj i zakończyć zestawu SDK.  Aby uzyskać więcej informacji, zobacz [wstrzymywanie i zakończyć przykładowe](https://msdn.microsoft.com/library/f4dffa58-d01e-44fb-b5a1-3b283d2c4517).  
  
 [!code-csharp[WF_Samples#172](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#172)]
 [!code-vb[WF_Samples#172](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#172)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="workflowInstance.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się wykonywania wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> wywołania <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ExecuteActivity%2A> działania głównego tego wystąpienia przepływu pracy. Jeśli <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> napotka wyjątek, kończy działanie wystąpienia przepływu pracy przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> z <xref:System.Exception.Message%2A> właściwości wyjątku jest przekazywany jako powód zakończenia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można użyć <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> metodę, aby uruchomić <xref:System.Workflow.Runtime.WorkflowInstance> hosta przepływu pracy. Ten kod tworzy wystąpienie <xref:System.Workflow.Runtime.WorkflowRuntime>, dodanie usługi do środowiska uruchomieniowego, a następnie pokazuje zalecany sposób tworzenia <xref:System.Workflow.Runtime.WorkflowInstance> obiektu. Tworzy <xref:System.Type> obiektu i rzutuje je na jednym z obiektów przepływu pracy, z którymi skojarzono hosta. Kod następnie inicjuje <xref:System.Workflow.Runtime.WorkflowInstance> przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> metody i przekazanie wcześniej utworzony typ do niego. <xref:System.Workflow.Runtime.WorkflowInstance> Zostanie uruchomiony przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> wywołania metody.  
  
 Ten przykład kodu jest częścią anulowanie przepływu pracy zestawu SDK przykładowe z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [anulowanie przepływu pracy](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.  
  
—lub— 
Wystąpienie przepływu pracy została już uruchomiona.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Trwa anulowanie przepływu pracy</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Suspend(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Suspend : string -&gt; unit" Usage="workflowInstance.Suspend error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Opis powodu zawieszanie wystąpienia przepływu pracy.</param>
        <summary>Wstrzymuje wystąpienie przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie przepływu pracy jest zawieszone w sposób synchroniczne. Jeśli wystąpienie przepływu pracy jest już zawieszony, nie podjęto żadnej akcji; w przeciwnym razie aparatu wykonawczego przepływów pracy wstrzymuje wystąpienie przepływu pracy zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> zdarzenia i przekazuje `reason` w <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs>.  
  
> [!NOTE]
>  <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> nie spowoduje usunięcia wystąpienia przepływu pracy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wstrzymaj wywoływania na <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#9](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#9)]
 [!code-vb[WF_Samples#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowInstance.Terminate error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Opis Przyczyna zakończenia wystąpienia przepływu pracy.</param>
        <summary>Kończy działanie wystąpienia przepływu pracy w sposób synchroniczne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie przepływu pracy zostało przerwane w sposób synchroniczne. Wywołania hosta <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> zakończenie wystąpienia przepływu pracy. Aparatu wykonawczego przepływów pracy czyści wystąpienia przepływu pracy w pamięci i informuje usługi trwałości, że wystąpienie został wyczyszczony z pamięci. Aby uzyskać <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>, oznacza to, że wszystkie informacje o stanie dla tego wystąpienia przepływu pracy zostanie usunięta z bazy danych po zakończeniu. Nie można ponownie załadować wystąpienia przepływu pracy od punktu poprzednio zapisanego stanu trwałego.  
  
 Po wyczyszczeniu wystąpienia przepływu pracy w pamięci i usługi trwałości jest informowany o rozwiązaniu, `Terminate` wywołuje metodę <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> zdarzenia i przekazuje `reason` w <xref:System.Exception.Message%2A> właściwość <xref:System.Workflow.ComponentModel.WorkflowTerminatedException> zawarte w <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs>.  
  
 `Terminate` różni się od <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A> w tym podczas Zakończ usuwa wystąpienie przepływu pracy w pamięci i informuje usługi trwałości przed zakończeniem, `Abort` po prostu usuwa wystąpienie przepływu pracy w pamięci, który następnie może zostać uruchomiony ponownie w ciągu ostatnich punkt stanu trwałego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje przerwania wywoływania na <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#8](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#8)]
 [!code-vb[WF_Samples#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparatu wykonawczego przepływów pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryUnload">
      <MemberSignature Language="C#" Value="public bool TryUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.TryUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUnload();" />
      <MemberSignature Language="F#" Value="member this.TryUnload : unit -&gt; bool" Usage="workflowInstance.TryUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wystąpienie przepływu pracy z pamięci w sklepie trwałości, gdy wystąpienie programu jest zawieszone lub w stanie bezczynności.</summary>
        <returns>
          <see langword="true" /> Jeśli wystąpienie przepływu pracy został usunięty z pamięci; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wystąpienie przepływu pracy jest w stanie bezczynności lub wstrzymania, <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> korzysta z usługi trwałości, aby usunąć wystąpienie przepływu pracy z pamięci i utrwalić je do magazynu danych. W przypadku żadna usługa trwałości zarejestrowany za pomocą <xref:System.Workflow.Runtime.WorkflowRuntime>, <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> zgłasza <xref:System.InvalidOperationException>. Jeśli wystąpienie przepływu pracy pomyślnie jest trwały, środowisko uruchomieniowe zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> zdarzeń i zwraca `true`. <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> Zwraca `false` wystąpienia przepływu pracy został już zwolniony, operacja została przerwana, została przerwana czy zostało już ukończone.  
  
 Hosta można użyć <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> do odzyskania zasobów systemowych z bezczynności przepływu pracy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu metody TryUnload wyładować przepływu pracy podczas <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> generowane zdarzenie. W tym przykładzie pochodzi z przykładu przy użyciu stanów trwałych usługi SDK z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [za pomocą przykładowej usługi trwałości](https://msdn.microsoft.com/library/3176b7e7-ae49-4d5c-802b-85032d6ebde6).  
  
 [!code-csharp[WF_Samples#280](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#280)]
 [!code-vb[WF_Samples#280](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#280)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma usługi trwałości zarejestrowane przy użyciu aparatu wykonawczego przepływów pracy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowInstance.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wystąpienie przepływu pracy od ilości pamięci do magazynu stanu trwałego. To wywołanie blokuje aż po zakończeniu obecnie zaplanowanych zadań lub na końcu zakresu transakcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> jest synchroniczne; oznacza to zwraca po zakończeniu dowolną akcję, która wykonuje. Jeśli wystąpienie przepływu pracy nie jest w stanie bezczynności, środowisko uruchomieniowe czeka, aż wystąpienie może zostać przerwane. Tylko zostać przerwane wystąpienia, po zakończeniu element roboczy obecnie zaplanowanych; jest to zazwyczaj gdy aktualnie uruchomione działanie zwraca z jego <xref:System.Workflow.ComponentModel.Activity.Execute%2A> metody. Jednakże jeśli wystąpienie jest wykonywane <xref:System.Workflow.ComponentModel.TransactionScopeActivity>, zakresu transakcji należy ukończyć wykonywania wystąpienie może zostać przerwane. Zwolnij następnie korzysta z usługi trwałości, aby usunąć wystąpienie przepływu pracy z pamięci i zapisuje je w magazynie danych. W przypadku żadna usługa trwałości zarejestrowany za pomocą <xref:System.Workflow.Runtime.WorkflowRuntime>, <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> zgłasza <xref:System.InvalidOperationException>. Jeśli wystąpienie przepływu pracy pomyślnie jest trwały, środowisko uruchomieniowe zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> zdarzeń.  
  
 Hosta można użyć <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> do odzyskania zasobów systemowych z bezczynności przepływu pracy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wywołanie <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> na <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#11](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#11)]
 [!code-vb[WF_Samples#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma usługi trwałości zarejestrowane przy użyciu aparatu wykonawczego przepływów pracy.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowRuntime">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkflowRuntime As WorkflowRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::Runtime::WorkflowRuntime ^ WorkflowRuntime { System::Workflow::Runtime::WorkflowRuntime ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkflowRuntime : System.Workflow.Runtime.WorkflowRuntime" Usage="System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> dla tego wystąpienia przepływu pracy.</summary>
        <value>A <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> reprezentujący środowiska wykonawczego, w którym to wystąpienie przepływu pracy jest uruchomiony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano uzyskiwanie dostępu do wykonywania <xref:System.Workflow.Runtime.WorkflowRuntime> z <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#7](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#7)]
 [!code-vb[WF_Samples#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
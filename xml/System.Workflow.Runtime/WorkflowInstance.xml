<Type Name="WorkflowInstance" FullName="System.Workflow.Runtime.WorkflowInstance">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0478d4988a0187a6cb381578e5b343625385d9d0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36445716" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInstance extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowInstance" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInstance sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInstance = class" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje wystąpienie przepływu pracy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 <xref:System.Workflow.Runtime.WorkflowInstance> Klasa udostępnia metody i właściwości, których można użyć do kontrolowania wykonywania wystąpienia przepływu pracy; jest zasadniczo serwera proxy do wystąpienia przepływu pracy w rzeczywistych używane przez aparat środowiska uruchomieniowego przepływu pracy. Na hoście lub usługi można nakazać aparatu wykonawczego workflow do wykonania akcji w wystąpieniu przepływu pracy, wywołując odpowiednie metody, które są zawarte w <xref:System.Workflow.Runtime.WorkflowInstance> klasy.  Jeśli żądana akcja nie jest prawidłowy, na przykład jeśli host wymaga <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> w wystąpieniu przepływu pracy, które zostało już zakończone, aparatu wykonawczego workflow zgłosi wyjątek odpowiednie.  
  
> [!NOTE]
>  Jeśli wystąpienie przepływu pracy przestanie odpowiadać, ponieważ wywołanie aplikacji hosta nie może zwracać, jedynym sposobem odzyskania wystąpienie jest ponowne uruchomienie środowiska uruchomieniowego. Jednak jeśli wystąpienie zostało wymuszone zwolniony, przerwana lub wstrzymana, jego może być kontynuowane przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak utworzyć i uruchomić <xref:System.Workflow.Runtime.WorkflowInstance> hosta przepływu pracy. Kod tworzy wystąpienie <xref:System.Workflow.Runtime.WorkflowRuntime>, dodaje do środowiska wykonawczego usług i następnie przedstawiono zalecany sposób tworzenia <xref:System.Workflow.Runtime.WorkflowInstance> obiektu. Inicjuje kod <xref:System.Workflow.Runtime.WorkflowInstance> przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> — metoda i przekazywanie wcześniej utworzony typ do niego. <xref:System.Workflow.Runtime.WorkflowInstance> Zostanie uruchomiony przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> wywołania metody.  
  
 Ten przykładowy kod jest częścią Cancelling przepływu pracy SDK przykładowe z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [anulowanie przepływu pracy](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="workflowInstance.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przerywa wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie przepływu pracy zostało przerwane w sposób synchroniczne; oznacza to metoda zwraca po wystąpienia przepływu pracy zostało przerwane. Aparatu wykonawczego workflow unieważnia wystąpienia przepływu pracy w pamięci i czyszczenia <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. Jeśli usługi utrwalania był używany przez wystąpienie przepływu pracy, wszystkich działań wykonanych od czasu ostatniego punktu trwałości jest odrzucone. Po jego przerwanie wystąpienia przepływu pracy, aparatu środowiska uruchomieniowego przepływu pracy zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted> zdarzeń. Możesz wywołać <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> Aby ponownie załadować wystąpienia przepływu pracy i rozpocząć od ostatniego punktu trwałości.  
  
 `Abort` różni się od <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> tego czasu `Abort` po prostu usuwa wystąpienie przepływu pracy w pamięci i może zostać uruchomiony ponownie z ostatniego punktu trwałości przerwania czyści wystąpienia przepływu pracy w pamięci i informuje o trwałości usługa wystąpienie zostało wyczyszczone z pamięci. Aby uzyskać <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>, oznacza to, że wszystkie informacje o stanie dla tego wystąpienia przepływu pracy została usunięta z bazy danych po zakończeniu. Nie można ponownie załadować wystąpienia przepływu pracy z punktu zapisanych wcześniej trwałości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wywołanie przerwania w wystąpieniu przepływu pracy typu Workflow1.  
  
 [!code-csharp[WF_Samples#13](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#13)]
 [!code-vb[WF_Samples#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyWorkflowChanges">
      <MemberSignature Language="C#" Value="public void ApplyWorkflowChanges (System.Workflow.ComponentModel.WorkflowChanges workflowChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyWorkflowChanges(class System.Workflow.ComponentModel.WorkflowChanges workflowChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ApplyWorkflowChanges(System.Workflow.ComponentModel.WorkflowChanges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyWorkflowChanges(System::Workflow::ComponentModel::WorkflowChanges ^ workflowChanges);" />
      <MemberSignature Language="F#" Value="member this.ApplyWorkflowChanges : System.Workflow.ComponentModel.WorkflowChanges -&gt; unit" Usage="workflowInstance.ApplyWorkflowChanges workflowChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowChanges" Type="System.Workflow.ComponentModel.WorkflowChanges" />
      </Parameters>
      <Docs>
        <param name="workflowChanges">A <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> określenie aktualizacji dynamicznych dla wystąpienia przepływu pracy.</param>
        <summary>Stosuje zmiany do wystąpienia przepływu pracy, określony przez <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie przepływu pracy nie jest już wstrzymany, aparatu wykonawczego workflow tymczasowo wstrzymuje wystąpienia przed zastosowaniem zmian.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wywoływania ApplyWorkflowChanges do <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  W tym przykładzie pochodzi z porządkowanie stanu maszyna przykład zestawu SDK, z pliku Mainform.cs.  Aby uzyskać więcej informacji, zobacz [porządkowanie próbki maszyny stanu](http://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#89](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#89)]
 [!code-vb[WF_Samples#89](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItem">
      <MemberSignature Language="C#" Value="public void EnqueueItem (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItem(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItem(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItem (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItem(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItem : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItem (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Nazwa <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Obiekt, który można umieścić w kolejce.</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" /> , Która umożliwia nadawcy zgłaszane po <c>elementu</c> jest dostarczany.</param>
        <param name="workItem">Obiekt do przekazania do <see cref="T:System.Workflow.Runtime.IPendingWork" /> metody.</param>
        <summary>Zapisuje synchronicznie wiadomości do kolejki określonego przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wysyła `item` do określonego <xref:System.Workflow.Runtime.WorkflowQueue>. Jeśli chcesz otrzymać powiadomienie, gdy wiadomość zostanie dostarczona, można zaimplementować <xref:System.Workflow.Runtime.IPendingWork> usługi i przebiegu `workItem` i <xref:System.Workflow.Runtime.IPendingWork> do obiektu <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Jeśli nie chcesz, aby takie powiadomienie, można przekazać odwołanie o wartości null (`Nothing` w języku Visual Basic) dla `pendingWork` i `workItem`.  
  
 Przy użyciu tej metody z przepływ pracy automatu stanów, może zostać wyświetlony komunikat o wyjątku "kolejki"{0}"nie jest włączona." Dzieje się tak, gdy bieżący stan komputera stanu nie może określić sposób obsługi określonego zdarzenia. Na przykład, jeśli niektóre stanie innym niż bieżący stan zawiera <xref:System.Workflow.Activities.EventDrivenActivity> zawierający <xref:System.Workflow.Activities.HandleExternalEventActivity> reprezentowaną przez kolejkę "{0}".  
  
> [!NOTE]
>  Komunikaty nie dotrą do odebrania przez wystąpienie przepływu pracy w kolejności, w której zostały wysłane. Na przykład jeśli odbieranie wiadomości w istniejącym kolejka przepływu pracy można utworzyć innej kolejki kolejki B, który następnie nasłuchuje kolejną wiadomość wysłana po pierwszej wiadomości przyczyny (kolejki A), jest możliwe, że to drugi komunikat pojawią się najpierw i nie będą odbierane z powodu swojej kolejki nie jest jeszcze utworzony. Aby uniknąć tego problemu, to drugi komunikat nie powinna być wysyłana dopóki nie zostanie zweryfikowana obecności drugi kolejki (przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>.)  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Gdy <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> wystąpi zdarzenie, `OnWorkflowIdled` zdefiniowane w tym przykładzie metoda jest wywoływana. Określa, który przepływ pracy jest idled przy użyciu <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> właściwości, a następnie pobiera kolekcję elementów w kolejce dla przepływu pracy wystąpienia przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> metody. Kod iteracji w kolekcji, aby określić działanie (activity) oczekuje na zdarzenie, które idled przepływu pracy. Następnie wysyła wyjątek do kolejki przepływu pracy przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> metody wraz z nazwą elementu kolejki zdarzeń.  
  
 Ten przykładowy kod jest częścią Cancelling przepływu pracy SDK przykładowe z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [anulowanie przepływu pracy](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> to odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.  - lub - <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> określonego przez <paramref name="queueName" /> nie istnieje.  - lub - <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> określonego przez <paramref name="queueName" /> nie jest włączone.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItemOnIdle">
      <MemberSignature Language="C#" Value="public void EnqueueItemOnIdle (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItemOnIdle(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItemOnIdle (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItemOnIdle(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItemOnIdle : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItemOnIdle (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Nazwa <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Obiekt, który można umieścić w kolejce.</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" /> , Która umożliwia nadawcy zgłaszane po <c>elementu</c> jest dostarczany.</param>
        <param name="workItem">Obiekt do przekazania do <see cref="T:System.Workflow.Runtime.IPendingWork" /> metody.</param>
        <summary>Zapisuje komunikat do kolejki określonego przepływu pracy, gdy przepływ pracy jest w stanie bezczynności. <see cref="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" /> czeka, aż przepływ pracy osiągnie punkt bezczynności i enqueues po sprawdzeniu, czy harmonogram przepływu pracy jest w stanie bezczynności (to znaczy nie aktywnych operacji nie jest wykonywane).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czeka na wystąpienie przepływu pracy w stan bezczynności, a następnie wysyła `item` do określonego <xref:System.Workflow.Runtime.WorkflowQueue>. Jeśli należy wywołać <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle%2A> podczas wystąpienia przepływu pracy jest wstrzymana, aparatu wykonawczego workflow zgłosi <xref:System.InvalidOperationException>. Jeśli chcesz otrzymać powiadomienie, gdy wiadomość zostanie dostarczona, można zaimplementować <xref:System.Workflow.Runtime.IPendingWork> usługi i przebiegu `workItem` i <xref:System.Workflow.Runtime.IPendingWork> do obiektu <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Jeśli nie chcesz, aby takie powiadomienie, można przekazać odwołanie o wartości null (`Nothing` w języku Visual Basic) dla `pendingWork` i `workItem`.  
  
 Gdy przepływ pracy automatu stanów za pomocą tej metody, można uzyskać wyjątek, który zawiera komunikat "kolejki"{0}"nie jest włączona." Dzieje się tak, gdy bieżący stan komputera stanu nie może określić sposób obsługi określonego zdarzenia. Na przykład, jeśli niektóre stanie innym niż bieżący stan zawiera <xref:System.Workflow.Activities.EventDrivenActivity> zawierający <xref:System.Workflow.Activities.HandleExternalEventActivity> reprezentowaną przez kolejkę "{0}".  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wysyłania informacji do wystąpienia przepływu pracy przy użyciu `EnqueueItemOnIdle` metody. Po pierwsze utworzeniu i uruchomieniu; obiekt WorkflowInstance następnie, obiekt, który implementuje <xref:System.Workflow.Runtime.IPendingWork> interfejs został utworzony. `EnqueueItemOnIdle` następnie jest wywoływana, przekazując wartości ciągu dla nazwy kolejki, elementu umieszczonych w kolejce, a element roboczy do przekazania do metody pendingWork obiektu.  
  
 [!code-csharp[WF_Samples#12](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#12)]
 [!code-vb[WF_Samples#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> to odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.  - lub - wystąpienia przepływu pracy jest wstrzymana.  - lub - <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> określonego przez <paramref name="queueName" /> nie istnieje.  - lub - <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> określonego przez <paramref name="queueName" /> nie jest włączone.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="workflowInstance.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony obiekt jest taki sam <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</summary>
        <returns>
          <see langword="true" /> Jeśli określony obiekt jest taki sam <see cref="T:System.Workflow.Runtime.WorkflowInstance" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt musi być wystąpieniem elementu <xref:System.Workflow.Runtime.WorkflowInstance> klasy i tej samej <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> jako to <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="workflowInstance.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego wystąpienia przepływu pracy.</summary>
        <returns>Wartość skrótu dla tego <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetHashCode%2A> Zwraca wartość skrótu na podstawie wartości z <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowDefinition">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity GetWorkflowDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.ComponentModel.Activity GetWorkflowDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowDefinition () As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::ComponentModel::Activity ^ GetWorkflowDefinition();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowDefinition : unit -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowInstance.GetWorkflowDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera działania głównego dla tego wystąpienia przepływu pracy.</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Działanie główne umożliwia przechodzenie hierarchii działania przepływu pracy.  
  
 Ta metoda nie jest wielowątkowość, więc hosta powinien synchronizować się jego wywołania tej metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, pobieranie definicji przepływu pracy z wystąpieniem przepływu pracy.  W tym przykładzie pochodzi z porządkowanie stanu maszyna przykład zestawu SDK, z pliku Mainform.cs.  Aby uzyskać więcej informacji, zobacz [porządkowanie próbki maszyny stanu](http://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#86](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#86)]
 [!code-vb[WF_Samples#86](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#86)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowNextTimerExpiration">
      <MemberSignature Language="C#" Value="public DateTime GetWorkflowNextTimerExpiration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetWorkflowNextTimerExpiration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowNextTimerExpiration () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetWorkflowNextTimerExpiration();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowNextTimerExpiration : unit -&gt; DateTime" Usage="workflowInstance.GetWorkflowNextTimerExpiration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca następnego punktu w czasie tego <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> jest zaplanowane do dostarczenia komunikatu czasomierza.</summary>
        <returns>Wartość daty/godziny, która reprezentuje następnej <see cref="P:System.Workflow.Runtime.TimerEventSubscription.ExpiresAt" /> czasu to <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> można dostarczyć komunikatu czasomierza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration%2A> metodę, aby sprawdzić, czy komunikaty czasomierza przepływu pracy są dodawane do kolejki. W tym przykładzie jest z próbki WorkflowThreading zestawu SDK, z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [próbki wątkowość przepływu pracy](http://msdn.microsoft.com/library/5b650be7-09fa-47db-a2f6-523dc8ea5ee9).  
  
 [!code-csharp[WF_Samples#284](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#284)]
 [!code-vb[WF_Samples#284](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#284)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Workflow.Runtime.TimerEventSubscription" />
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowQueueData">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowQueueData () As ReadOnlyCollection(Of WorkflowQueueInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowQueueInfo ^&gt; ^ GetWorkflowQueueData();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowQueueData : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;" Usage="workflowInstance.GetWorkflowQueueData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> obiekty, które zawiera elementy oczekujące i subskrybowane działań dla kolejek przepływu pracy skojarzonego z tym wystąpieniem przepływu pracy.</summary>
        <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> z <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> Zwraca kolekcję <xref:System.Workflow.Runtime.WorkflowQueueInfo> obiektów, z których każdy zawiera informacje o stanie kolejki przepływu pracy skojarzonego z tym wystąpieniem przepływu pracy. <xref:System.Workflow.Runtime.WorkflowQueueInfo.Items%2A?displayProperty=nameWithType> zawiera elementy oczekujące dla <xref:System.Workflow.Runtime.WorkflowQueue> i <xref:System.Workflow.Runtime.WorkflowQueueInfo.SubscribedActivityNames%2A?displayProperty=nameWithType> zawiera listę działań, które są zasubskrybowano w celu dostarczania elementu <xref:System.Workflow.Runtime.WorkflowQueue>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak używasz <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> metodę, aby uzyskać informacje o stanie wszystkich kolejek przepływu pracy skojarzonego z <xref:System.Workflow.Runtime.WorkflowInstance> obiektu. Gdy <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> wystąpi zdarzenie, `OnWorkflowIdled` zdefiniowane w tym przykładzie metoda jest wywoływana. Określa, który przepływ pracy jest idled przy użyciu <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> właściwości, a następnie pobiera kolekcję elementów w kolejce dla przepływu pracy wystąpienia przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> metody. Kod iteracji w kolekcji, aby określić działanie (activity) oczekuje na zdarzenie, które idled przepływu pracy. Następnie wysyła wyjątek do kolejki przepływu pracy przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> metody wraz z nazwą elementu kolejki zdarzeń.  
  
 Ten przykładowy kod jest częścią Cancelling przepływu pracy SDK przykładowe z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [anulowanie przepływu pracy](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public Guid InstanceId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid InstanceId" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid InstanceId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceId : Guid" Usage="System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator dla wystąpienia przepływu pracy.</summary>
        <value>
          <see cref="T:System.Guid" /> Wystąpienia przepływu pracy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> do odwołania do wystąpienia przepływu pracy.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak używasz <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> właściwość, aby uzyskać informacje na temat <xref:System.Workflow.Runtime.WorkflowInstance> obiektu. Tworzy pierwszego fragmentu kodu <xref:System.Workflow.Runtime.WorkflowInstance> zmiennej o nazwie `instanceId`.  
  
 [!code-csharp[WF_Samples#210](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#210)]
 [!code-vb[WF_Samples#210](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#210)]  
  
 Drugi fragment używa <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> właściwość jako pierwszy obiekt w `OrderEventArgs` wywołać konstruktora, kiedy `CallBackForApproval` metoda jest wywoływana.  
  
 Ten przykładowy kod jest częścią przykład zestawu SDK nasłuchiwanie z pliku OrderServiceImple.cs. Aby uzyskać więcej informacji, zobacz [nasłuchiwania próbki](http://msdn.microsoft.com/library/1cec0e82-7544-429f-b717-0fc25eb42b7f).  
  
 [!code-csharp[WF_Samples#211](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#211)]
 [!code-vb[WF_Samples#211](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#211)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Load" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load();" />
      <MemberSignature Language="F#" Value="member this.Load : unit -&gt; unit" Usage="workflowInstance.Load " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ładuje wystąpienia przepływu pracy wcześniej usunięty z pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> synchroniczna; Jeśli wystąpienie przepływu pracy mogą być ładowane, <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> zwróci po wystąpienia przepływu pracy zostało załadowane do pamięci i zaplanowane przez aparat środowiska uruchomieniowego przepływu pracy. Środowisko uruchomieniowe zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> zdarzeń po usługi utrwalania przywróciła wystąpienia przepływu pracy w pamięci, ale przed przepływu pracy aparatu wykonawczego planuje wystąpienie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak załadować wcześniej zwolniony <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#10](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#10)]
 [!code-vb[WF_Samples#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReloadTrackingProfiles">
      <MemberSignature Language="C#" Value="public void ReloadTrackingProfiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReloadTrackingProfiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ReloadTrackingProfiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReloadTrackingProfiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReloadTrackingProfiles();" />
      <MemberSignature Language="F#" Value="member this.ReloadTrackingProfiles : unit -&gt; unit" Usage="workflowInstance.ReloadTrackingProfiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Załaduj ponownie profile śledzenia dla tego wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Infrastrukturze środowiska uruchomieniowego śledzenia spowoduje ponowne załadowanie każdego <xref:System.Workflow.Runtime.Tracking.TrackingProfile> dla tego wystąpienia przepływu pracy skojarzonego z jego kanały śledzenia. Jeśli nie jest w stanie wstrzymanym, przepływ pracy jest tymczasowo wstrzymane przez środowisko uruchomieniowe śledzenia infrastruktury, gdy są ładowane profile śledzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="workflowInstance.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia wykonywanie wystąpienia przepływu pracy wstrzymanej wcześniej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosta można wywołać <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A> można wznowić wykonywania wystąpienia przepływu pracy, który został wcześniej zawieszony. Jeśli wystąpienie przepływu pracy nie jest w stanie wstrzymanym, nie podjęto żadnej akcji. Środowisko uruchomieniowe zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> zdarzeń tuż przed wznowieniem wykonywania wystąpienia przepływu pracy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wywoływania wznowienia w wystąpieniu wcześniej Wstrzymany przepływ pracy.  W tym przykładzie jest z próbki wstrzymywanie i zakończyć zestawu SDK.  Aby uzyskać więcej informacji, zobacz [zawieszenia i zakończyć przykładowa](http://msdn.microsoft.com/library/f4dffa58-d01e-44fb-b5a1-3b283d2c4517).  
  
 [!code-csharp[WF_Samples#172](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#172)]
 [!code-vb[WF_Samples#172](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#172)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="workflowInstance.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna wykonywanie wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> wywołania <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ExecuteActivity%2A> w działaniu głównym tego wystąpienia przepływu pracy. Jeśli <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> napotkał wyjątek, zostaje zakończone wystąpienia przepływu pracy, wywołując <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> z <xref:System.Exception.Message%2A> właściwość wyjątku przekazany jako przyczyna dla zakończenia połączenia.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak używasz <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> metodę, aby uruchomić <xref:System.Workflow.Runtime.WorkflowInstance> hosta przepływu pracy. Kod tworzy wystąpienie <xref:System.Workflow.Runtime.WorkflowRuntime>, dodaje do środowiska wykonawczego usług i następnie przedstawiono zalecany sposób tworzenia <xref:System.Workflow.Runtime.WorkflowInstance> obiektu. Tworzy <xref:System.Type> obiektu i rzutuje na jednym z obiektów przepływu pracy, z którymi skojarzono hosta. Kod obok inicjuje <xref:System.Workflow.Runtime.WorkflowInstance> przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> — metoda i przekazywanie wcześniej utworzony typ do niego. <xref:System.Workflow.Runtime.WorkflowInstance> Zostanie uruchomiony przy użyciu <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> wywołania metody.  
  
 Ten przykładowy kod jest częścią Cancelling przepływu pracy SDK przykładowe z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [anulowanie przepływu pracy](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.  - lub - wystąpienie przepływu pracy zostało już uruchomione.</exception>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Suspend(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Suspend : string -&gt; unit" Usage="workflowInstance.Suspend error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Opis powodu wstrzymanie tego wystąpienia przepływu pracy.</param>
        <summary>Wstrzymuje wykonywanie wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie przepływu pracy został wstrzymany w sposób synchronicznego. Jeśli wystąpienie przepływu pracy jest już wstrzymana, nie podjęto żadnej akcji; w przeciwnym razie aparatu wykonawczego workflow wstrzymuje wystąpienia przepływu pracy, generuje <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> zdarzenia i przekazuje `reason` w <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs>.  
  
> [!NOTE]
>  <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> nie spowoduje usunięcia wystąpienia przepływu pracy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywoływania zawieszenia na <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#9](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#9)]
 [!code-vb[WF_Samples#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowInstance.Terminate error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Opis Przyczyna przerywanie wystąpienia przepływu pracy.</param>
        <summary>Kończy wystąpienia przepływu pracy w sposób synchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie przepływu pracy zostało przerwane w sposób synchronicznego. Wywołania hosta <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> zakończenie wystąpienia przepływu pracy. Aparatu wykonawczego workflow czyści wystąpienia przepływu pracy w pamięci i informuje usługi utrwalania, że wystąpienie zostało wyczyszczone z pamięci. Aby uzyskać <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>, oznacza to, że wszystkie informacje o stanie dla tego wystąpienia przepływu pracy została usunięta z bazy danych po zakończeniu. Nie można ponownie załadować wystąpienia przepływu pracy z punktu zapisanych wcześniej trwałości.  
  
 Po wystąpienia przepływu pracy w pamięci jest wyczyszczone i usługi utrwalania zostanie poinformowany o rozwiązaniu, `Terminate` metoda zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> zdarzenia i przekazuje `reason` w <xref:System.Exception.Message%2A> właściwość <xref:System.Workflow.ComponentModel.WorkflowTerminatedException> zawarte w <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs>.  
  
 `Terminate` różni się od <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A> w tym podczas przerwania czyści wystąpienia przepływu pracy w pamięci i informuje o trwałości usługa przerwanie, `Abort` po prostu usuwa wystąpienia przepływu pracy w pamięci, która może zostać uruchomiony ponownie w ciągu ostatnich punkt trwałości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie przerwania na <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#8](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#8)]
 [!code-vb[WF_Samples#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aparat środowiska uruchomieniowego przepływu pracy nie jest uruchomiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryUnload">
      <MemberSignature Language="C#" Value="public bool TryUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.TryUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUnload();" />
      <MemberSignature Language="F#" Value="member this.TryUnload : unit -&gt; bool" Usage="workflowInstance.TryUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wystąpienie przepływu pracy z pamięci w magazynie trwałości, gdy wystąpienie jest wstrzymane lub bezczynności.</summary>
        <returns>
          <see langword="true" /> Jeśli wystąpienie przepływu pracy został zwolniony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wystąpienia przepływu pracy jest w stanie bezczynności lub wstrzymania, <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> usunąć wystąpienia przepływu pracy z pamięci i utrwala go do magazynu danych przy użyciu usługi trwałości. Jeśli jest zarejestrowana żadna usługa trwałości z <xref:System.Workflow.Runtime.WorkflowRuntime>, <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> zgłasza <xref:System.InvalidOperationException>. Jeśli wystąpienie przepływu pracy jest poprawnie utrwalona, środowisko uruchomieniowe zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> zdarzeń i zwraca `true`. <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> Zwraca `false` wystąpienia przepływu pracy został już zwolniony, zostało zakończone, została przerwana czy zostało już zakończone.  
  
 Można używać hosta <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> odzyskiwaniu zasoby systemowe z bezczynności przepływu pracy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu metody TryUnload do zwolnienia przepływu pracy podczas <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> generowane zdarzenie. W tym przykładzie jest z próbki przy użyciu trwałości usługi SDK, z pliku Program.cs. Aby uzyskać więcej informacji, zobacz [przy użyciu przykładowych usług trwałości](http://msdn.microsoft.com/library/3176b7e7-ae49-4d5c-802b-85032d6ebde6).  
  
 [!code-csharp[WF_Samples#280](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#280)]
 [!code-vb[WF_Samples#280](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#280)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma usługi utrwalania zarejestrowana w usłudze aparatu wykonawczego workflow.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowInstance.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wystąpienie przepływu pracy z pamięci w magazynie trwałości. To wywołanie blokuje dopiero po zakończeniu obecnie zaplanowanych zadań, lub na końcu zakresu transakcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> synchroniczna; oznacza to zwraca po zakończeniu wykonywania akcji. Jeśli wystąpienie przepływu pracy nie jest bezczynny, środowisko uruchomieniowe oczekuje, aż wystąpienie może zostać przerwane. Tylko można przerwać wystąpienia, po zakończeniu elementu obecnie zaplanowanych zadań; jest to zazwyczaj gdy aktualnie uruchomione działanie zwróci z jego <xref:System.Workflow.ComponentModel.Activity.Execute%2A> metody. Jednak jeśli wystąpienie jest wykonywany <xref:System.Workflow.ComponentModel.TransactionScopeActivity>, zakresu transakcji należy ukończyć wykonywania wystąpienia może zostać przerwane. Zwolnienie następnie używa usługi trwałości można usunąć wystąpienia przepływu pracy z pamięci i będzie się utrzymywał w magazynie danych. Jeśli jest zarejestrowana żadna usługa trwałości z <xref:System.Workflow.Runtime.WorkflowRuntime>, <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> zgłasza <xref:System.InvalidOperationException>. Jeśli wystąpienie przepływu pracy jest poprawnie utrwalona, środowisko uruchomieniowe zgłasza <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> zdarzeń.  
  
 Można używać hosta <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> odzyskiwaniu zasoby systemowe z bezczynności przepływu pracy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wywoływania <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> na <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#11](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#11)]
 [!code-vb[WF_Samples#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma usługi utrwalania zarejestrowana w usłudze aparatu wykonawczego workflow.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowRuntime">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkflowRuntime As WorkflowRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::Runtime::WorkflowRuntime ^ WorkflowRuntime { System::Workflow::Runtime::WorkflowRuntime ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkflowRuntime : System.Workflow.Runtime.WorkflowRuntime" Usage="System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> dla tego wystąpienia przepływu pracy.</summary>
        <value>A <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> reprezentujący środowiska wykonawczego, w której to wystąpienie przepływu pracy jest uruchomiony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, uzyskiwanie dostępu do wykonywania <xref:System.Workflow.Runtime.WorkflowRuntime> z <xref:System.Workflow.Runtime.WorkflowInstance> obiektu.  
  
 [!code-csharp[WF_Samples#7](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#7)]
 [!code-vb[WF_Samples#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
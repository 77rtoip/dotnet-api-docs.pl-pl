<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileIO.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d1e0c04b5245a93699d8ea4005cf9c2bff263e76" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36727628" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia właściwości i metody do pracy z dysków, plików i katalogów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem` obiektu.  
  
|Do|Zobacz|  
|-|-|  
|Odczyt z pliku tekstowego|[Porady: Odczyt z plików tekstowych](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Odczyt z pliku tekstowego z separatorami|[Instrukcje: odczyt z rozdzielonych przecinkami plików testowych](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Odczyt z plików testowych o stałej szerokości|[Instrukcje: odczyt z plików testowych o stałej szerokości](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Odczyt z pliku tekstowego w wielu formatach|[Instrukcje: odczyt z plików tekstowych w wielu formatach](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Odczyt z pliku binarnego|[Instrukcje: odczyt z plików binarnych](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Odczyt z pliku tekstowego z <xref:System.IO.StreamReader>|[Instrukcje: odczyt tekstu z plików za pomocą StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Zapis w pliku tekstowym|[Instrukcje: zapisywanie tekstu w plikach](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Dołącz do pliku tekstowego|[Instrukcje: dołączanie do plików tekstowych](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Zapis w pliku binarnym|[Instrukcje: zapisywanie w plikach binarnych](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Zapisywanie do plików tekstowych w **Moje dokumenty** katalogu|[Instrukcje: zapisywanie tekstu w plikach w katalogu Moje dokumenty](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Zapis do pliku tekstowego z `StreamWriter`|[Instrukcje: zapisywanie tekstu w plikach za pomocą StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Kopiowanie plików z określonym wzorcem|[Instrukcje: kopiowanie plików z określonym wzorcem do katalogu](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Skopiuj plik do katalogu|[Instrukcje: tworzenie kopii pliku w tym samym katalogu](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopiowanie pliku do innego katalogu|[Instrukcje: tworzenie kopii pliku w innym katalogu](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Utwórz plik|[Instrukcje: tworzenie pliku](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Usuwanie pliku|[Instrukcje: usuwanie pliku](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Znajdowanie plików z określonym wzorcem|[Instrukcje: znajdowanie plików z określonym wzorcem](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Przenoszenie pliku|[Instrukcje: przenoszenie pliku](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Zmiana nazwy pliku|[Instrukcje: zmienianie nazwy pliku](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Kopiowanie katalogu do innego katalogu|[Instrukcje: kopiowanie katalogu do innego katalogu](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Tworzenie katalogu|[Instrukcje: tworzenie katalogu](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Znajdowanie podkatalogów z określonym wzorcem|[Instrukcje: znajdowanie podkatalogów z określonym wzorcem](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Pobieranie kolekcji plików z katalogu|[Instrukcje: pobieranie kolekcji plików z katalogu](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Odczyt z **Moje dokumenty** katalogu|[Instrukcje: pobieranie zawartości katalogu Moje dokumenty](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Przeanalizowania ścieżki pliku|[Instrukcje: analizowanie ścieżek plików](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 W tym przykładzie sprawdza, czy folder `C:\backup\logs` istnieje i sprawdza jego właściwości.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [Obiekty (Visual Basic)](http://msdn.microsoft.com/library/651c73e4-dca8-402b-9c6b-e3902b3a3f4b)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public static string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="static member CombinePath : string * string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory">
          <see langword="String" />. Pierwsza ścieżka do połączenia.</param>
        <param name="relativePath">
          <see langword="String" />. Drugi ścieżka do połączenia.</param>
        <summary>Łączy dwie ścieżki i zwraca ścieżkę prawidłowo sformatowane.</summary>
        <returns>Kombinacja określonych ścieżek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa nadmiarowe ułamkowa znaków można utworzyć ścieżki prawidłowo sformatowane.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.CombinePath` metody.  
  
|Do|Zobacz|  
|-|-|  
|Łączenie ścieżkę i nazwę katalogu|[Porady: analizowanie ścieżek pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 W tym przykładzie łączy ścieżkę i nazwę katalogu można utworzyć ścieżki prawidłowo sformatowane.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 W tym przykładzie łączy dwie ścieżki, aby utworzyć ścieżkę prawidłowo sformatowane.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 W tym przykładzie zwraca `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseDirectory" /> lub <paramref name="relativePath" /> ścieżek nieprawidłowo sformułowany.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje zawartość katalogu do innego katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Katalog do skopiowania.</param>
        <param name="destinationDirectoryName">Lokalizacja, do którego powinien zostać skopiowany zawartości katalogu.</param>
        <summary>Kopiuje zawartość katalogu do innego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje zawartość katalogu źródłowego do katalogu docelowego. Jeśli katalog docelowy nie istnieje, jest tworzony. Jeśli katalog o tej samej nazwie istnieje w lokalizacji docelowej, zawartość dwa katalogi są łączone. Podczas operacji można określić nową nazwę katalogu.  
  
 Podczas kopiowania plików w katalogu, wyjątki może zostać zgłoszony, które są spowodowane przez określonego pliku. Gdy takie wyjątki są zgłaszane, ich są konsolidowane w jednym wyjątek którego `Data` właściwość przechowuje wpisów w formie <xref:System.Collections.IDictionary> w którym ścieżka pliku lub katalogu jest klucz i komunikat o wyjątku określonych znajduje się w odpowiadającej jej wartości. Użyj `For…Each` do sortowania wpisów.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.CopyDirectory` metody.  
  
|Do|Zobacz|  
|-|-|  
|Kopiowanie katalogu|[Porady: kopiowanie katalogu do innego katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Poniższy przykładowy kod kopiuje zawartość katalogu `TestDirectory1` do `TestDirectory2`, zastępując istniejące pliki.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Zastąp `C:\TestDirectory1` i `C:\TestDirectory2` ścieżkę i nazwę katalogu, który chcesz skopiować oraz lokalizacji, do którego chcesz skopiować go.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> lub <paramref name="sourceDirectoryName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog źródłowy nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Ścieżka źródłowa i ścieżka docelowa są takie same.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest cykliczne.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwa folderu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Plik docelowy istnieje, ale nie ma dostępu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Katalog do skopiowania.</param>
        <param name="destinationDirectoryName">Lokalizacja, do którego powinien zostać skopiowany zawartości katalogu.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Kopiuje zawartość katalogu do innego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje zawartość katalogu źródłowego do katalogu docelowego. Jeśli katalog docelowy nie istnieje, jest tworzony. Jeśli katalog o tej samej nazwie istnieje w lokalizacji docelowej, zawartość dwa katalogi są łączone. Podczas operacji można określić nową nazwę katalogu.  
  
 Podczas kopiowania plików w katalogu, wyjątki może zostać zgłoszony, które są spowodowane przez określonego pliku. Gdy takie wyjątki są zgłaszane, ich są konsolidowane w jednym wyjątek którego `Data` właściwość przechowuje wpisów w formie <xref:System.Collections.IDictionary> w którym ścieżka pliku lub katalogu jest klucz i komunikat o wyjątku określonych znajduje się w odpowiadającej jej wartości. Użyj `For…Each` do sortowania wpisów.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.CopyDirectory` metody.  
  
|Do|Zobacz|  
|-|-|  
|Kopiowanie katalogu|[Porady: kopiowanie katalogu do innego katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Poniższy przykładowy kod kopiuje zawartość katalogu `TestDirectory1` do `TestDirectory2`, zastępując istniejące pliki.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Zastąp `C:\TestDirectory1` i `C:\TestDirectory2` ścieżkę i nazwę katalogu, który chcesz skopiować oraz lokalizacji, do którego chcesz skopiować go.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> lub <paramref name="sourceDirectoryName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog źródłowy nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Ścieżka źródłowa i ścieżka docelowa są takie same.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest cykliczne.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwa folderu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Plik docelowy istnieje, ale nie ma dostępu.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> ustawiono <see langword="UIOption.AllDialogs" /> użytkownik anulował operację, i nie można skopiować jeden lub więcej plików w katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Katalog do skopiowania.</param>
        <param name="destinationDirectoryName">Lokalizacja, do którego powinien zostać skopiowany zawartości katalogu.</param>
        <param name="overwrite">
          <see langword="True" /> Aby zastąpić istniejące pliki; w przeciwnym razie <see langword="False" />. Wartość domyślna to <see langword="False" />.</param>
        <summary>Kopiuje zawartość katalogu do innego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje zawartość katalogu źródłowego do katalogu docelowego. Jeśli katalog docelowy nie istnieje, jest tworzony. Jeśli katalog o tej samej nazwie istnieje w lokalizacji docelowej, zawartość dwa katalogi są łączone. Podczas operacji można określić nową nazwę katalogu.  
  
 Podczas kopiowania plików w katalogu, wyjątki może zostać zgłoszony, które są spowodowane przez określonego pliku, na przykład plik istniejących podczas scalania podczas `overwrite` ma ustawioną wartość `False`. Gdy takie wyjątki są zgłaszane, ich są konsolidowane w jednym wyjątek którego `Data` właściwość przechowuje wpisów w formie <xref:System.Collections.IDictionary> w którym ścieżka pliku lub katalogu jest klucz i komunikat o wyjątku określonych znajduje się w odpowiadającej jej wartości. Użyj `For…Each` do sortowania wpisów.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.CopyDirectory` metody.  
  
|Do|Zobacz|  
|-|-|  
|Kopiowanie katalogu|[Porady: kopiowanie katalogu do innego katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Poniższy przykładowy kod kopiuje zawartość katalogu `TestDirectory1` do `TestDirectory2`, zastępując istniejące pliki.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Zastąp `C:\TestDirectory1` i `C:\TestDirectory2` ścieżkę i nazwę katalogu, który chcesz skopiować oraz lokalizacji, do którego chcesz skopiować go.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> lub <paramref name="sourceDirectoryName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog źródłowy nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Ścieżka źródłowa i ścieżka docelowa są takie same.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest cykliczne.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwa folderu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Plik docelowy istnieje, ale nie ma dostępu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Katalog do skopiowania.</param>
        <param name="destinationDirectoryName">Lokalizacja, do którego powinien zostać skopiowany zawartości katalogu.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Określa, co należy zrobić, jeśli użytkownik klika polecenie ** Anuluj ** podczas operacji. Wartość domyślna to <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Kopiuje zawartość katalogu do innego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje zawartość katalogu źródłowego do katalogu docelowego. Jeśli katalog docelowy nie istnieje, jest tworzony. Jeśli katalog o tej samej nazwie istnieje w lokalizacji docelowej, zawartość dwa katalogi są łączone. Podczas operacji można określić nową nazwę katalogu.  
  
 Podczas kopiowania plików w katalogu, wyjątki może zostać zgłoszony, które są spowodowane przez określonego pliku. Gdy takie wyjątki są zgłaszane, ich są konsolidowane w jednym wyjątek którego `Data` właściwość przechowuje wpisów w formie <xref:System.Collections.IDictionary> w którym ścieżka pliku lub katalogu jest klucz i komunikat o wyjątku określonych znajduje się w odpowiadającej jej wartości. Użyj `For…Each` do sortowania wpisów.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.CopyDirectory` metody.  
  
|Do|Zobacz|  
|-|-|  
|Kopiowanie katalogu|[Porady: kopiowanie katalogu do innego katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Poniższy przykładowy kod kopiuje zawartość katalogu `TestDirectory1` do `TestDirectory2`, zastępując istniejące pliki.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Zastąp `C:\TestDirectory1` i `C:\TestDirectory2` ścieżkę i nazwę katalogu, który chcesz skopiować oraz lokalizacji, do którego chcesz skopiować go.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> lub <paramref name="sourceDirectoryName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog źródłowy nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Ścieżka źródłowa i ścieżka docelowa są takie same.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest cykliczne.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwa folderu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Plik docelowy istnieje, ale nie ma dostępu.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> ustawiono <see langword="UIOption.AllDialogs" /> użytkownik anulował operację, i nie można skopiować jeden lub więcej plików w katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje plik do nowej lokalizacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Plik do skopiowania.</param>
        <param name="destinationFileName">Lokalizacja, do którego powinien zostać skopiowany plik.</param>
        <summary>Kopiuje plik do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` Nie zachowuj ACE (wpisy kontroli dostępu). Nowo utworzony plik dziedziczy ACE domyślnego katalogu, w którym został utworzony.  
  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.CopyFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Skopiuj plik do katalogu.|[Porady: tworzenie kopii pliku w tym samym katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Skopiuj plik do innego katalogu.|[Porady: tworzenie kopii pliku w innym katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Ten przykładowy kod kopiuje plik `Test.txt` do katalogu `TestFiles2` bez zastąpienie istniejących plików.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Zamień ścieżki plików ścieżki, który ma być używany w kodzie.  
  
 Ten przykładowy kod kopiuje plik `Test.txt` do katalogu `TestFiles2` i zmienia jego nazwę `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Zamień ścieżki plików ścieżki, który ma być używany w kodzie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> zawiera informacje o ścieżce.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> lub <paramref name="sourceFileName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik źródłowy jest nieprawidłowy lub nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik w katalogu docelowym o takiej samej nazwie jest już używana.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Kontroluje możliwość dostępu wszystkich systemowych zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steruje możliwością dostęp do zmiennych rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Plik do skopiowania.</param>
        <param name="destinationFileName">Lokalizacja, do którego powinien zostać skopiowany plik.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Kopiuje plik do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` Nie zachowuj ACE (wpisy kontroli dostępu). Nowo utworzony plik dziedziczy ACE domyślnego katalogu, w którym został utworzony.  
  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.CopyFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Skopiuj plik do katalogu.|[Porady: tworzenie kopii pliku w tym samym katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Skopiuj plik do innego katalogu.|[Porady: tworzenie kopii pliku w innym katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Ten przykładowy kod kopiuje plik `Test.txt` do katalogu `TestFiles2` bez zastąpienie istniejących plików.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Zamień ścieżki plików ścieżki, który ma być używany w kodzie.  
  
 Ten przykładowy kod kopiuje plik `Test.txt` do katalogu `TestFiles2` i zmienia jego nazwę `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Zamień ścieżki plików ścieżki, który ma być używany w kodzie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> zawiera informacje o ścieżce.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> lub <paramref name="sourceFileName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik źródłowy jest nieprawidłowy lub nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik docelowy istnieje i <paramref name="overwrite" /> ma ustawioną wartość <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Kontroluje możliwość dostępu wszystkich systemowych zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steruje możliwością dostęp do zmiennych rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Plik do skopiowania.</param>
        <param name="destinationFileName">Lokalizacja, do którego powinien zostać skopiowany plik.</param>
        <param name="overwrite">
          <see langword="True" /> Jeśli istniejące pliki powinny być zastąpione; w przeciwnym razie <see langword="False" />. Wartość domyślna to <see langword="False" />.</param>
        <summary>Kopiuje plik do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` Nie zachowuj ACE (wpisy kontroli dostępu). Nowo utworzony plik dziedziczy ACE domyślnego katalogu, w którym został utworzony.  
  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.CopyFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Skopiuj plik do katalogu.|[Porady: tworzenie kopii pliku w tym samym katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Skopiuj plik do innego katalogu.|[Porady: tworzenie kopii pliku w innym katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Ten przykładowy kod kopiuje plik `Test.txt` do katalogu `TestFiles2` bez zastąpienie istniejących plików.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Zamień ścieżki plików ścieżki, który ma być używany w kodzie.  
  
 Ten przykładowy kod kopiuje plik `Test.txt` do katalogu `TestFiles2` i zmienia jego nazwę `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Zamień ścieżki plików ścieżki, który ma być używany w kodzie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> zawiera informacje o ścieżce.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> lub <paramref name="sourceFileName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik źródłowy jest nieprawidłowy lub nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik docelowy istnieje i <paramref name="overwrite" /> ma ustawioną wartość <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Kontroluje możliwość dostępu wszystkich systemowych zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steruje możliwością dostęp do zmiennych rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Plik do skopiowania.</param>
        <param name="destinationFileName">Lokalizacja, do którego powinien zostać skopiowany plik.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Określa, co należy zrobić, jeśli użytkownik klika polecenie ** Anuluj ** podczas operacji. Wartość domyślna to <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Kopiuje plik do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` Nie zachowuj ACE (wpisy kontroli dostępu). Nowo utworzony plik dziedziczy ACE domyślnego katalogu, w którym został utworzony.  
  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.CopyFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Skopiuj plik do katalogu.|[Porady: tworzenie kopii pliku w tym samym katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Skopiuj plik do innego katalogu.|[Porady: tworzenie kopii pliku w innym katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Ten przykładowy kod kopiuje plik `Test.txt` do katalogu `TestFiles2` bez zastąpienie istniejących plików.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Zamień ścieżki plików ścieżki, który ma być używany w kodzie.  
  
 Ten przykładowy kod kopiuje plik `Test.txt` do katalogu `TestFiles2` i zmienia jego nazwę `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Zamień ścieżki plików ścieżki, który ma być używany w kodzie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> zawiera informacje o ścieżce.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> lub <paramref name="sourceFileName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik źródłowy jest nieprawidłowy lub nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik docelowy istnieje i <paramref name="overwrite" /> ma ustawioną wartość <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="UICancelOption" /> ustawiono <see langword="ThrowException" />, a użytkownik anulował operację lub występuje Wystąpił nieokreślony błąd We/Wy.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Kontroluje możliwość dostępu wszystkich systemowych zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steruje możliwością dostęp do zmiennych rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nazwa i lokalizacja katalogu.</param>
        <summary>Tworzy katalog.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli katalog już istnieje, nie jest wyjątek.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.CreateDirectory` metody.  
  
|Do|Zobacz|  
|-|-|  
|Tworzenie katalogu|[Porady: Tworzenie katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 To przykładowe polecenie tworzy katalog, `NewDirectory`w `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa katalogu jest nieprawidłowo sformułowany. Na przykład zawiera niedozwolone znaki lub jest tylko biały znak.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa katalogu jest zbyt długa.</exception>
        <exception cref="T:System.NotSupportedException">Nazwa katalogu jest tylko dwukropka (:).</exception>
        <exception cref="T:System.IO.IOException">Katalog ma zostać utworzony w katalogu nadrzędnym jest tylko do odczytu</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma uprawnień do tworzenia katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący katalog.</summary>
        <value>Bieżący katalog dla operacji We/Wy pliku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` jest zmienną środowiskową całego systemu.  
  
   
  
## Examples  
 W tym przykładzie zwraca bieżący katalog i wyświetla go w oknie komunikatu.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 W tym przykładzie ustawia bieżący katalog `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka jest nieprawidłowa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wystarczających uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa katalog.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Katalog do usunięcia.</param>
        <param name="onDirectoryNotEmpty">Określa, co należy zrobić, jeśli katalog, który ma zostać usunięty zawiera pliki lub katalogi. Wartość domyślna to <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Usuwa katalog.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W przykładzie usunięto katalog `OldDirectory` tylko wtedy, gdy nie jest pusty.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 W tym przykładzie powoduje usunięcie katalogu `OldDirectory` i całą jego zawartość.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 W tym przykładzie powoduje usunięcie katalogu `OldDirectory` i wszystkie jego zawartość, prośbą o potwierdzenie usunięcia, ale nie będzie przesyłał zawartość do **Kosza**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 W tym przykładzie powoduje usunięcie katalogu `OldDirectory` i całą jego zawartość, wysyłając je do **Kosza**, ale nie jest wyświetlany postęp operacji.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka to ciąg o zerowej długości, jest nieprawidłowo sformułowany, zawiera tylko biały znak lub zawiera nieprawidłowe znaki (w tym symbole wieloznaczne). Ścieżka jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog nie istnieje lub jest plikiem.</exception>
        <exception cref="T:System.IO.IOException">Plik w katalogu lub podkatalogu jest używany.</exception>
        <exception cref="T:System.NotSupportedException">Nazwa katalogu zawiera dwukropek (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.OperationCanceledException">Użytkownik anulował operację lub nie można usunąć katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Katalog do usunięcia.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Określa, czy powinny być wysłane usuniętego pliku ** Odtwórz Bin **. Wartość domyślna to <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Usuwa katalog.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI` i `recycle` parametry nie są obsługiwane w aplikacjach, które nie są użytkownika interaktywnego, takie jak usługi systemu Windows.  
  
   
  
## Examples  
 W przykładzie usunięto katalog `OldDirectory` tylko wtedy, gdy nie jest pusty.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 W tym przykładzie powoduje usunięcie katalogu `OldDirectory` i całą jego zawartość.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 W tym przykładzie powoduje usunięcie katalogu `OldDirectory` i wszystkie jego zawartość, prośbą o potwierdzenie usunięcia, ale nie będzie przesyłał zawartość do **Kosza**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 W tym przykładzie powoduje usunięcie katalogu `OldDirectory` i całą jego zawartość, wysyłając je do **Kosza**, ale nie jest wyświetlany postęp operacji.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka to ciąg o zerowej długości, jest nieprawidłowo sformułowany, zawiera tylko biały znak lub zawiera nieprawidłowe znaki (w tym symbole wieloznaczne). Ścieżka jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog nie istnieje lub jest plikiem.</exception>
        <exception cref="T:System.IO.IOException">Plik w katalogu lub podkatalogu jest używany.</exception>
        <exception cref="T:System.NotSupportedException">Nazwa katalogu zawiera dwukropek (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.OperationCanceledException">Użytkownik anulował operację lub nie można usunąć katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Katalog do usunięcia.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Określa, czy powinny być wysłane usuniętego pliku ** Odtwórz Bin **. Wartość domyślna to <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Określa, czy należy zgłosić wyjątek, gdy użytkownik kliknie ** Anuluj **.</param>
        <summary>Usuwa katalog.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI`, `recycle`, I `onUserCancel` parametry nie są obsługiwane w aplikacjach, które nie są użytkownika interaktywnego, takie jak usługi systemu Windows.  
  
   
  
## Examples  
 W przykładzie usunięto katalog `OldDirectory` tylko wtedy, gdy nie jest pusty.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 W tym przykładzie powoduje usunięcie katalogu `OldDirectory` i całą jego zawartość.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 W tym przykładzie powoduje usunięcie katalogu `OldDirectory` i wszystkie jego zawartość, prośbą o potwierdzenie usunięcia, ale nie będzie przesyłał zawartość do **Kosza**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 W tym przykładzie powoduje usunięcie katalogu `OldDirectory` i całą jego zawartość, wysyłając je do **Kosza**, ale nie jest wyświetlany postęp operacji.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka to ciąg o zerowej długości, jest nieprawidłowo sformułowany, zawiera tylko biały znak lub zawiera nieprawidłowe znaki (w tym symbole wieloznaczne). Ścieżka jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog nie istnieje lub jest plikiem.</exception>
        <exception cref="T:System.IO.IOException">Plik w katalogu lub podkatalogu jest używany.</exception>
        <exception cref="T:System.NotSupportedException">Nazwa katalogu zawiera dwukropek (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.OperationCanceledException">Użytkownik anulował operację lub nie można usunąć katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa plik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nazwa i ścieżka pliku do usunięcia.</param>
        <summary>Usuwa plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.DeleteFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Aby usunąć plik|[Porady: usuwanie pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 W tym przykładzie powoduje usunięcie pliku `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 W tym przykładzie powoduje usunięcie pliku `Test.txt` i umożliwia użytkownikowi upewnić się, że plik powinien zostać usunięty.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 W tym przykładzie powoduje usunięcie pliku `Test.txt` i wysyła je do **Kosza**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; ma ona ukośnika gdzie należy określić plik; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.IOException">Plik jest w użyciu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma uprawnień do usuwania pliku lub plik jest tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Nazwa i ścieżka pliku do usunięcia.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Określa, czy powinny być wysłane usuniętego pliku ** Odtwórz Bin **. Wartość domyślna to <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Usuwa plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI` i `recycle` parametry nie są obsługiwane w aplikacjach, które nie są użytkownika interaktywnego, takie jak usługi systemu Windows.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.DeleteFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Aby usunąć plik|[Porady: usuwanie pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 W tym przykładzie powoduje usunięcie pliku `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 W tym przykładzie powoduje usunięcie pliku `Test.txt` i umożliwia użytkownikowi upewnić się, że plik powinien zostać usunięty.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 W tym przykładzie powoduje usunięcie pliku `Test.txt` i wysyła je do **Kosza**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; ma ona ukośnika gdzie należy określić plik; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.IOException">Plik jest w użyciu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma uprawnień do usuwania pliku lub plik jest tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Nazwa i ścieżka pliku do usunięcia.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Określa, czy powinny być wysłane usuniętego pliku ** Odtwórz Bin **. Wartość domyślna to <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Określa, czy jest zwracany wyjątek, gdy użytkownik anuluje operację. Wartość domyślna to <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Usuwa plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI`, `recycle`, I `onUserCancel` parametry nie są obsługiwane w aplikacjach, które nie są użytkownika interaktywnego, takie jak usługi systemu Windows.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.DeleteFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Aby usunąć plik|[Porady: usuwanie pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 W tym przykładzie powoduje usunięcie pliku `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 W tym przykładzie powoduje usunięcie pliku `Test.txt` i umożliwia użytkownikowi upewnić się, że plik powinien zostać usunięty.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 W tym przykładzie powoduje usunięcie pliku `Test.txt` i wysyła je do **Kosza**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; ma ona ukośnika gdzie należy określić plik; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.IOException">Plik jest w użyciu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma uprawnień do usuwania pliku lub plik jest tylko do odczytu.</exception>
        <exception cref="T:System.OperationCanceledException">Użytkownik anulował operację i <paramref name="onUserCancel" /> ma ustawioną wartość <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public static bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member DirectoryExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Ścieżka katalogu.</param>
        <summary>Zwraca <see langword="True" /> istnienie określonego katalogu.</summary>
        <returns>
          <see langword="True" /> Jeśli katalog istnieje; w przeciwnym razie <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie określa, czy katalog `C:\backup\logs` istnieje i sprawdza jego właściwości.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca kolekcję wszystkich nazw dysku tylko do odczytu.</summary>
        <value>Zbiór wszystkich dostępnych dysków jako tylko do odczytu <see cref="T:System.IO.DriveInfo" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wszystkie dyski logiczne.  
  
   
  
## Examples  
 W tym przykładzie wyświetla nazwy dostępnych dysków w oknie komunikatu.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None" />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public static bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member FileExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nazwa i ścieżka pliku.</param>
        <summary>Zwraca <see langword="True" /> Jeśli istnieje określony plik.</summary>
        <returns>Zwraca <see langword="True" /> Jeśli plik istnieje; w przeciwnym razie ta metoda zwraca <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli aplikacja nie ma wystarczających uprawnień do odczytu określonego pliku `FileExists` metoda zwraca `False`, bez względu na istnienie path; metoda nie zgłasza wyjątek.  
  
   
  
## Examples  
 W tym przykładzie sprawdza, czy plik `Check.txt` istnieje i dostarcza informacje w oknie komunikatu.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa pliku jest zakończony ukośnikiem (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję tylko do odczytu ciągów reprezentujących nazwy plików zawierających określony tekst.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Katalog, który ma zostać wyszukany.</param>
        <param name="containsText">Tekst wyszukiwania.</param>
        <param name="ignoreCase">
          <see langword="True" /> Jeśli wyszukiwanie ma być uwzględniana wielkość liter; w przeciwnym razie <see langword="False" />. Wartość domyślna to <see langword="True" />.</param>
        <param name="searchType">Określa, czy uwzględnić podfoldery. Wartość domyślna to <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Zwraca kolekcję tylko do odczytu ciągów reprezentujących nazwy plików zawierających określony tekst.</summary>
        <returns>Kolekcji tylko do odczytu nazw plików zawierających określony tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pusta kolekcja jest zwracany, jeśli znaleziono nie plików zgodnych z określonym wzorcem.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.FindInFiles` metody.  
  
|Do|Zobacz|  
|-|-|  
|Wyszukaj katalog dla plików zawierających określony ciąg znaków|[Wskazówki: Manipulowanie plikami i katalogami w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 W tym przykładzie wyszukuje w katalogu `C:\TestDir` pliki zawierające ciąg `"sample string"` i wyświetla wyniki w `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Aby pracować, musi zawierać projekt `ListBox` o nazwie `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od <c> \\. \</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określony katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Określony katalog wskazuje istniejący plik.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Ścieżka określony katalog zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wystarczających uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Katalog, który ma zostać wyszukany.</param>
        <param name="containsText">Tekst wyszukiwania.</param>
        <param name="ignoreCase">
          <see langword="True" /> Jeśli wyszukiwanie ma być uwzględniana wielkość liter; w przeciwnym razie <see langword="False" />. Wartość domyślna to <see langword="True" />.</param>
        <param name="searchType">Określa, czy uwzględnić podfoldery. Wartość domyślna to <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Wzorzec do dopasowania.</param>
        <summary>Zwraca kolekcję tylko do odczytu ciągów reprezentujących nazwy plików zawierających określony tekst.</summary>
        <returns>Kolekcji tylko do odczytu nazw plików zawierających określony tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pusta kolekcja jest zwracany, jeśli znaleziono nie plików zgodnych z określonym wzorcem.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.FindInFiles` metody.  
  
|Do|Zobacz|  
|-|-|  
|Wyszukaj katalog dla plików zawierających określony ciąg znaków|[Wskazówki: Manipulowanie plikami i katalogami w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 W tym przykładzie wyszukuje w katalogu `C:\TestDir` pliki zawierające ciąg `"sample string"` i wyświetla wyniki w `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Aby pracować, musi zawierać projekt `ListBox` o nazwie `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od <c> \\. \</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określony katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Określony katalog wskazuje istniejący plik.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Ścieżka określony katalog zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wystarczających uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję ciągów reprezentujących nazw ścieżek podkatalogów w katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nazwa i ścieżka katalogu.</param>
        <summary>Zwraca kolekcję ciągów reprezentujących nazw ścieżek podkatalogów w katalogu.</summary>
        <returns>Kolekcji tylko do odczytu nazw ścieżek podkatalogów w określonym katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.GetDirectories` metody.  
  
|Do|Zobacz|  
|-|-|  
|Lista podkatalogów z określonym wzorcem|[Porady: znajdowanie podkatalogów z określonym wzorcem w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Poniższy przykład zwraca wszystkie katalogi w strukturze katalogu, który zawiera słowo `Logs` w nazwach i dodaje je do `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 W tym przykładzie wymaga `ListBox` o nazwie `ListBox1` w formularzu.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określony katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Określony katalog wskazuje istniejący plik.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wystarczających uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Nazwa i ścieżka katalogu.</param>
        <param name="searchType">Określa, czy uwzględnić podfoldery. Wartość domyślna to <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Wzorzec do dopasowania nazwy.</param>
        <summary>Zwraca kolekcję ciągów reprezentujących nazw ścieżek podkatalogów w katalogu.</summary>
        <returns>Kolekcja tylko do odczytu nazw ścieżek podkatalogów w określonym katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć `wildcards` parametr, aby określić określonego wzorca. Jeśli chcesz w wyszukiwaniu uwzględnić zawartość podkatalogów, ustaw `searchType` parametr `SearchAllSubDirectories`.  
  
 Pusta kolekcja jest zwracany, gdy zostaną znalezione nie katalogi zgodne z określonym wzorcem.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.GetDirectories` metody.  
  
|Do|Zobacz|  
|-|-|  
|Lista podkatalogów z określonym wzorcem|[Porady: znajdowanie podkatalogów z określonym wzorcem w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Poniższy przykład zwraca wszystkie katalogi w strukturze katalogu, który zawiera słowo `Logs` w nazwach i dodaje je do `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 W tym przykładzie wymaga `ListBox` o nazwie `ListBox1` w formularzu.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden określony symboli wieloznacznych jest <see langword="Nothing" />, ciągiem pustym lub zawiera tylko spacje.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określony katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Określony katalog wskazuje istniejący plik.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wystarczających uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">
          <see langword="String" />. Ścieżka katalogu.</param>
        <summary>Zwraca <see cref="T:System.IO.DirectoryInfo" /> obiektu dla określonej ścieżki.</summary>
        <returns>
          <see cref="T:System.IO.DirectoryInfo" /> obiekt dla określonej ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli katalog nie istnieje, jest zwracany wyjątek, nie dopiero po raz pierwszy właściwości <xref:System.IO.DirectoryInfo> uzyskać dostępu do obiektu.  
  
   
  
## Examples  
 W tym przykładzie pobiera <xref:System.IO.DirectoryInfo> obiektu katalogu `C:\Documents and Settings` i wyświetla katalogu czasu utworzenia ostatniego czas dostępu i ostatniej godziny zapisu.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Ścieżka katalogu zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="static member GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Dysk należy zbadać.</param>
        <summary>Zwraca <see cref="T:System.IO.DriveInfo" /> obiektu na określonym dysku.</summary>
        <returns>
          <see cref="T:System.IO.DriveInfo" /> obiekt do określonego dysku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DriveInfo> Klasy modeli dysku i udostępnia metody i właściwości, aby wyszukać informacje o stacji. Użyj <xref:System.IO.DriveInfo> do określenia dysków, które są dostępne i jakiego rodzaju dyski są. Możesz także zbadać właściwości do określenia pojemności i dostępne wolne miejsce na dysku.  
  
   
  
## Examples  
 W tym przykładzie uzyskuje <xref:System.IO.DriveInfo> obiektu dla dysku C i używa go do wyświetlania informacji o dysku.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Informacje o typach inny dysk, zobacz <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="drive" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public static System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member GetFileInfo : string -&gt; System.IO.FileInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nazwa i ścieżka pliku.</param>
        <summary>Zwraca <see cref="T:System.IO.FileInfo" /> obiektu określonego pliku.</summary>
        <returns>
          <see cref="T:System.IO.FileInfo" /> obiekt do określonego pliku</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zgłaszany wyjątek, jeśli plik nie istnieje; zamiast go będą zgłaszane przy pierwszym uruchomieniu właściwości obiektu są dostępne.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.GetFileInfo` metody.  
  
|Do|Zobacz|  
|-|-|  
|Określić nazwę pliku i ścieżki|[Porady: analizowanie ścieżek pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 W tym przykładzie pobierana <xref:System.IO.FileInfo?displayProperty=nameWithType> obiektu pliku `MyLogFile.log` i używa go do raportów Pełna nazwa pliku, czas ostatniego dostępu i długości.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa ścieżki jest nieprawidłowo sformułowany. Na przykład zawiera nieprawidłowe znaki lub jest tylko biały znak. Nazwa pliku ma ukośnikiem na końcu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.NotSupportedException">Ścieżka zawiera dwukropek w środku ciągu.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka jest za długa.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma listy kontroli dostępu (listy kontroli dostępu) dostępu do pliku.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję tylko do odczytu ciągów reprezentujących nazwy plików w katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Katalog ma zostać wyszukany.</param>
        <summary>Zwraca kolekcję tylko do odczytu ciągów reprezentujących nazwy plików w katalogu.</summary>
        <returns>Kolekcja tylko do odczytu nazw plików z określonego katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pusta kolekcja jest zwracany, jeśli znaleziono nie plików zgodnych z określonym wzorcem.  
  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.GetFiles` metody.  
  
|Do|Zobacz|  
|-|-|  
|Pobieranie kolekcji plików z katalogu|[Porady: pobieranie kolekcji plików z katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Znajdowanie plików z określonym wzorcem w katalogu|[Porady: znajdowanie plików z określonym wzorcem w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Poniższy przykład zwraca wszystkie pliki w katalogu i dodaje je do `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 W tym przykładzie wymaga `ListBox` o nazwie `ListBox1` w formularzu.  
  
 W tym przykładzie zwraca wszystkie pliki w katalogu z rozszerzeniem `.txt` i dodaje je do `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 W tym przykładzie wymaga `ListBox` o nazwie `ListBox1` w formularzu.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog wyszukiwania nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> Wskazuje istniejący plik.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wystarczających uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Katalog ma zostać wyszukany.</param>
        <param name="searchType">Określa, czy uwzględnić podfoldery. Wartość domyślna to <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Wzorzec do dopasowania.</param>
        <summary>Zwraca kolekcję tylko do odczytu ciągów reprezentujących nazwy plików w katalogu.</summary>
        <returns>Kolekcja tylko do odczytu nazw plików z określonego katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pusta kolekcja jest zwracany, jeśli znaleziono nie plików zgodnych z określonym wzorcem.  
  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.GetFiles` metody.  
  
|Do|Zobacz|  
|-|-|  
|Pobieranie kolekcji plików z katalogu|[Porady: pobieranie kolekcji plików z katalogu w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Znajdowanie plików z określonym wzorcem w katalogu|[Porady: znajdowanie plików z określonym wzorcem w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Poniższy przykład zwraca wszystkie pliki w katalogu i dodaje je do `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 W tym przykładzie wymaga `ListBox` o nazwie `ListBox1` w formularzu.  
  
 W tym przykładzie zwraca wszystkie pliki w katalogu z rozszerzeniem `.txt` i dodaje je do `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 W tym przykładzie wymaga `ListBox` o nazwie `ListBox1` w formularzu.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog wyszukiwania nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> Wskazuje istniejący plik.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wystarczających uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetName : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Wymagana. Ścieżka do przeanalizowania. <see langword="String" />.</param>
        <summary>Analizuje nazwa pliku poza podanej ścieżce.</summary>
        <returns>Nazwa pliku z określonej ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to operacja ciągu; `FileSystem` nie jest kontrolowana.  
  
 `GetName` Metody ignoruje kreska ułamkowa występujące na końcu ścieżki.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.GetFileName` metody.  
  
|Do|Zobacz|  
|-|-|  
|Przeanalizowania ścieżki pliku|[Porady: analizowanie ścieżek pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Poniższy przykład analizuje ścieżkę pliku i zwraca nazwę pliku.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Zamień na ścieżkę `C:\Testdirectory\Testfile` ze ścieżką chcesz przeanalizować.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public static string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParentPath : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do badania.</param>
        <summary>Zwraca ścieżkę nadrzędną podana ścieżka.</summary>
        <returns>Ścieżki nadrzędnej podana ścieżka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to operacja ciągu; system plików nie jest kontrolowana.  
  
   
  
## Examples  
 W tym przykładzie pobiera ścieżki nadrzędnej `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie ma ścieżki nadrzędnej, ponieważ jest to ścieżka katalogu głównego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy o unikatowej nazwie pliku tymczasowego zero bajtów na dysku i zwraca pełną ścieżkę pliku.</summary>
        <returns>
          <see langword="String" /> zawierający pełną ścieżkę pliku tymczasowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia pliku tymczasowego.  
  
   
  
## Examples  
 W tym przykładzie powoduje utworzenie pliku tymczasowego i zwraca jego ścieżki.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przenosi katalogu z jednej lokalizacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ścieżka katalogu do przeniesienia.</param>
        <param name="destinationDirectoryName">Ścieżka katalogu, do którego katalog źródłowy jest przenoszony.</param>
        <summary>Przenosi katalogu z jednej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku próby przeniesienia katalogu w katalogu, który nie istnieje, zostanie utworzona strukturze docelowej.  
  
   
  
## Examples  
 W tym przykładzie przenosi `Directory1` wewnątrz `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 W tym przykładzie przenosi `Directory1` wewnątrz `Directory2`, zastępując katalogu, jeśli już istnieje.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> lub <paramref name="destinationDirectoryName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Źródło jest katalogiem głównym lub ścieżka źródłowa i ścieżka docelowa są takie same.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest cykliczne.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ścieżka katalogu do przeniesienia.</param>
        <param name="destinationDirectoryName">Ścieżka katalogu, do którego katalog źródłowy jest przenoszony.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Przenosi katalogu z jednej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku próby przeniesienia katalogu w katalogu, który nie istnieje, zostanie utworzona strukturze docelowej.  
  
   
  
## Examples  
 W tym przykładzie przenosi `Directory1` wewnątrz `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 W tym przykładzie przenosi `Directory1` wewnątrz `Directory2`, zastępując katalogu, jeśli już istnieje.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> lub <paramref name="destinationDirectoryName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Katalog docelowy już istnieje i <paramref name="overwrite" /> ma ustawioną wartość <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest cykliczne.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ścieżka katalogu do przeniesienia.</param>
        <param name="destinationDirectoryName">Ścieżka katalogu, do którego katalog źródłowy jest przenoszony.</param>
        <param name="overwrite">
          <see langword="True" /> Jeśli istniejące katalogi powinny być zastąpione; w przeciwnym razie <see langword="False" />. Wartość domyślna to <see langword="False" />.</param>
        <summary>Przenosi katalogu z jednej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku próby przeniesienia katalogu w katalogu, który nie istnieje, zostanie utworzona strukturze docelowej.  
  
   
  
## Examples  
 W tym przykładzie przenosi `Directory1` wewnątrz `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 W tym przykładzie przenosi `Directory1` wewnątrz `Directory2`, zastępując katalogu, jeśli już istnieje.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> lub <paramref name="destinationDirectoryName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Katalog docelowy już istnieje i <paramref name="overwrite" /> ma ustawioną wartość <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest cykliczne.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ścieżka katalogu do przeniesienia.</param>
        <param name="destinationDirectoryName">Ścieżka katalogu, do którego katalog źródłowy jest przenoszony.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Określa, czy jest zwracany wyjątek, gdy użytkownik anuluje operację. Wartość domyślna to <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Przenosi katalogu z jednej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku próby przeniesienia katalogu w katalogu, który nie istnieje, zostanie utworzona strukturze docelowej.  
  
   
  
## Examples  
 W tym przykładzie przenosi `Directory1` wewnątrz `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 W tym przykładzie przenosi `Directory1` wewnątrz `Directory2`, zastępując katalogu, jeśli już istnieje.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> lub <paramref name="destinationDirectoryName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="onUserCancel" /> ustawiono <see langword="ThrowException" /> i nie można skopiować podkatalogu pliku.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> ustawiono <see langword="ThrowException" />, użytkownik anulował operację, i nie można ukończyć operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja jest cykliczne.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przenosi plik do nowej lokalizacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ścieżka pliku do przeniesienia.</param>
        <param name="destinationFileName">Ścieżka katalogu, w którym można przenieść pliku.</param>
        <summary>Przenosi plik do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli strukturze docelowej nie istnieje, zostanie on utworzony.  
  
 `MoveFile` Metody zachowuje ACE (wpisy kontroli dostępu) tylko podczas przenoszenia pliku w tym samym woluminie. W tym dziedziczone wpisy kontroli dostępu, które stają się ACE bezpośrednio po przeniesieniu (bezpośrednie ACE mają wyższy priorytet nad ACE dziedziczone). Jeśli plik zostanie przeniesiony między woluminami, ACE nie zostaną skopiowane.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.MoveFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Przenoszenie pliku|[Porady: przenoszenie pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 W tym przykładzie przenosi plik `Test.txt` z `TestDir1` do `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 W tym przykładzie przenosi plik `Test.txt` z `TestDir1` do `TestDir2` i zmienia jego nazwę `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik źródłowy jest nieprawidłowy lub nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Kontroluje możliwość dostępu wszystkich systemowych zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steruje możliwością dostęp do zmiennych rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ścieżka pliku do przeniesienia.</param>
        <param name="destinationFileName">Ścieżka katalogu, w którym można przenieść pliku.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Przenosi plik do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli strukturze docelowej nie istnieje, zostanie on utworzony.  
  
 `MoveFile` Metody zachowuje ACE (wpisy kontroli dostępu) tylko podczas przenoszenia pliku w tym samym woluminie. W tym dziedziczone wpisy kontroli dostępu, które stają się ACE bezpośrednio po przeniesieniu (bezpośrednie ACE mają wyższy priorytet nad ACE dziedziczone). Jeśli plik zostanie przeniesiony między woluminami, ACE nie zostaną skopiowane.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.MoveFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Przenoszenie pliku|[Porady: przenoszenie pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 W tym przykładzie przenosi plik `Test.txt` z `TestDir1` do `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 W tym przykładzie przenosi plik `Test.txt` z `TestDir1` do `TestDir2` i zmienia jego nazwę `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik źródłowy jest nieprawidłowy lub nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Kontroluje możliwość dostępu wszystkich systemowych zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steruje możliwością dostęp do zmiennych rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ścieżka pliku do przeniesienia.</param>
        <param name="destinationFileName">Ścieżka katalogu, w którym można przenieść pliku.</param>
        <param name="overwrite">
          <see langword="True" /> Aby zastąpić istniejące pliki; w przeciwnym razie <see langword="False" />. Wartość domyślna to <see langword="False" />.</param>
        <summary>Przenosi plik do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli strukturze docelowej nie istnieje, zostanie on utworzony.  
  
 `MoveFile` Metody zachowuje ACE (wpisy kontroli dostępu) tylko podczas przenoszenia pliku w tym samym woluminie. W tym dziedziczone wpisy kontroli dostępu, które stają się ACE bezpośrednio po przeniesieniu (bezpośrednie ACE mają wyższy priorytet nad ACE dziedziczone). Jeśli plik zostanie przeniesiony między woluminami, ACE nie zostaną skopiowane.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.MoveFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Przenoszenie pliku|[Porady: przenoszenie pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 W tym przykładzie przenosi plik `Test.txt` z `TestDir1` do `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 W tym przykładzie przenosi plik `Test.txt` z `TestDir1` do `TestDir2` i zmienia jego nazwę `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik źródłowy jest nieprawidłowy lub nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Kontroluje możliwość dostępu wszystkich systemowych zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steruje możliwością dostęp do zmiennych rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ścieżka pliku do przeniesienia.</param>
        <param name="destinationFileName">Ścieżka katalogu, w którym można przenieść pliku.</param>
        <param name="showUI">Określa, czy będzie śledzić postęp operacji. Wartość domyślna to <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Określa, czy jest zwracany wyjątek, gdy użytkownik anuluje operację. Wartość domyślna to <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Przenosi plik do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli strukturze docelowej nie istnieje, zostanie on utworzony.  
  
 `MoveFile` Metody zachowuje ACE (wpisy kontroli dostępu) tylko podczas przenoszenia pliku w tym samym woluminie. W tym dziedziczone wpisy kontroli dostępu, które stają się ACE bezpośrednio po przeniesieniu (bezpośrednie ACE mają wyższy priorytet nad ACE dziedziczone). Jeśli plik zostanie przeniesiony między woluminami, ACE nie zostaną skopiowane.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.MoveFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Przenoszenie pliku|[Porady: przenoszenie pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 W tym przykładzie przenosi plik `Test.txt` z `TestDir1` do `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 W tym przykładzie przenosi plik `Test.txt` z `TestDir1` do `TestDir2` i zmienia jego nazwę `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik źródłowy jest nieprawidłowy lub nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> ustawiono <see langword="ThrowException" />oraz wystąpienia Wystąpił nieokreślony błąd We/Wy lub użytkownik anulował operację.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Kontroluje możliwość dostępu wszystkich systemowych zmiennych środowiskowych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steruje możliwością dostęp do zmiennych rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Określa uprawnienia związane z interfejsów użytkownika i Schowka. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see langword="OpenTextFieldParser" /> Metoda służy do tworzenia <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> obiektu, który umożliwia łatwe i wydajne przeanalizować strukturyzowanych plików tekstowych, takich jak dzienniki. <see langword="TextFieldParser" /> Obiekt może służyć do odczytu plików rozdzielanych i stałej szerokości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Plik można otworzyć za pomocą <see langword="TextFieldParser" />.</param>
        <summary>
          <see langword="OpenTextFieldParser" /> Metoda służy do tworzenia <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> obiektu, który umożliwia łatwe i wydajne przeanalizować strukturyzowanych plików tekstowych, takich jak dzienniki. <see langword="TextFieldParser" /> Obiekt może służyć do odczytu plików rozdzielanych i stałej szerokości.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> można odczytać określonego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.OpenTextFieldParser` metody.  
  
|Do|Zobacz|  
|-|-|  
|Odczyt z pliku tekstowego z separatorami|[Porady: Odczyt z plików tekstowych rozdzielanych przecinkami w języku Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Odczyt z plików testowych o stałej szerokości|[Porady: Odczyt z plików testowych o stałej szerokości w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Odczyt z pliku tekstowego w wielu formatach|[Porady: Odczyt z plików tekstowych w wielu formatach w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 W tym przykładzie otwiera `TextFieldParser.reader` i używa go do odczytu z `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Nie można analizować wiersza w określonym formacie. Komunikat o wyjątku Określa wiersz przyczyną tego wyjątku, podczas gdy <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> właściwości przypisano tekst znajdujący się w wierszu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">W tym artykule opisano zestaw uprawnień zabezpieczeń zastosowane do kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Plik można otworzyć za pomocą <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Szerokość pola.</param>
        <summary>
          <see langword="OpenTextFieldParser" /> Metoda służy do tworzenia <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> obiektu, który umożliwia łatwe i wydajne przeanalizować strukturyzowanych plików tekstowych, takich jak dzienniki. <see langword="TextFieldParser" /> Obiekt może służyć do odczytu plików rozdzielanych i stałej szerokości.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> można odczytać określonego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.OpenTextFieldParser` metody.  
  
|Do|Zobacz|  
|-|-|  
|Odczyt z pliku tekstowego z separatorami|[Porady: Odczyt z plików tekstowych rozdzielanych przecinkami w języku Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Odczyt z plików testowych o stałej szerokości|[Porady: Odczyt z plików testowych o stałej szerokości w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Odczyt z pliku tekstowego w wielu formatach|[Porady: Odczyt z plików tekstowych w wielu formatach w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 W tym przykładzie otwiera `TextFieldParser.reader` i używa go do odczytu z `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Nie można analizować wiersza w określonym formacie. Komunikat o wyjątku Określa wiersz przyczyną tego wyjątku, podczas gdy <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> właściwości przypisano tekst znajdujący się w wierszu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">W tym artykule opisano zestaw uprawnień zabezpieczeń zastosowane do kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Plik można otworzyć za pomocą <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Ogranicznik pola.</param>
        <summary>
          <see langword="OpenTextFieldParser" /> Metoda służy do tworzenia <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> obiektu, który umożliwia łatwe i wydajne przeanalizować strukturyzowanych plików tekstowych, takich jak dzienniki. <see langword="TextFieldParser" /> Obiekt może służyć do odczytu plików rozdzielanych i stałej szerokości.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> można odczytać określonego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.OpenTextFieldParser` metody.  
  
|Do|Zobacz|  
|-|-|  
|Odczyt z pliku tekstowego z separatorami|[Porady: Odczyt z plików tekstowych rozdzielanych przecinkami w języku Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Odczyt z plików testowych o stałej szerokości|[Porady: Odczyt z plików testowych o stałej szerokości w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Odczyt z pliku tekstowego w wielu formatach|[Porady: Odczyt z plików tekstowych w wielu formatach w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 W tym przykładzie otwiera `TextFieldParser.reader` i używa go do odczytu z `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Nie można analizować wiersza w określonym formacie. Komunikat o wyjątku Określa wiersz przyczyną tego wyjątku, podczas gdy <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> właściwości przypisano tekst znajdujący się w wierszu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">W tym artykule opisano zestaw uprawnień zabezpieczeń zastosowane do kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera <see cref="T:System.IO.StreamReader" /> obiektu do odczytu z pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Plik do odczytu.</param>
        <summary>Otwiera <see cref="T:System.IO.StreamReader" /> obiektu do odczytu z pliku.</summary>
        <returns>
          <see cref="T:System.IO.StreamReader" /> obiekt do odczytu z pliku</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mogą być odczytywane tylko pliki tekstowe z <xref:System.IO.StreamReader>.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.OpenTextFileReader` metody.  
  
|Do|Zobacz|  
|-|-|  
|Otwórz plik z <xref:System.IO.StreamReader>|[Porady: Odczyt tekstu z plików za pomocą StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 W tym przykładzie otwiera plik `Testfile.txt`odczytuje wiersz z niego i wyświetla wiersz w `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa pliku jest zakończony ukośnikiem (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć określonego pliku.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień do odczytu z pliku.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Plik do odczytu.</param>
        <param name="encoding">Kodowanie do użycia dla zawartości pliku. Domyślnie jest ASCII.</param>
        <summary>Otwiera <see cref="T:System.IO.StreamReader" /> obiektu do odczytu z pliku.</summary>
        <returns>
          <see cref="T:System.IO.StreamReader" /> obiekt do odczytu z pliku</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mogą być odczytywane tylko pliki tekstowe z <xref:System.IO.StreamReader>.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.OpenTextFileReader` metody.  
  
|Do|Zobacz|  
|-|-|  
|Otwórz plik z <xref:System.IO.StreamReader>|[Porady: Odczyt tekstu z plików za pomocą StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 W tym przykładzie otwiera plik `Testfile.txt`odczytuje wiersz z niego i wyświetla wiersz w `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa pliku jest zakończony ukośnikiem (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć określonego pliku.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień do odczytu z pliku.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera <see cref="T:System.IO.StreamWriter" /> obiektu do zapisania do określonego pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Plik do zapisania.</param>
        <param name="append">
          <see langword="True" /> Aby dołączyć do zawartości pliku. <see langword="False" /> zastąpić zawartość pliku. Wartość domyślna to <see langword="False" />.</param>
        <summary>Otwiera <see cref="T:System.IO.StreamWriter" /> obiektu do zapisania do określonego pliku.</summary>
        <returns>
          <see cref="T:System.IO.StreamWriter" /> obiekt do zapisania do określonego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `OpenTextFileWriter` Metody otwiera i inicjuje strumienia pliku, a następnie zwraca <xref:System.IO.StreamWriter> obiekt dla tego strumienia. Możesz zapisać pary tyle razy, w razie potrzeby i zamknij go po zakończeniu.  
  
> [!NOTE]
>  Należy wywołać <xref:System.IO.StreamWriter.Close%2A> metoda <xref:System.IO.StreamWriter> obiekt, aby upewnić się, że wszystkie dane są poprawnie zapisywane do źródłowego strumienia.  
  
 Jeśli piszesz tylko kilka ciągi do pliku, może być łatwiejsze do użycia <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> metody.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.OpenTextFileWriter` metody.  
  
|Do|Zobacz|  
|-|-|  
|Zapisywanie tekstu do pliku z `StreamWriter`|[Porady: zapisywanie tekstu do plików za pomocą StreamWriter w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 W tym przykładzie otwiera <xref:System.IO.StreamWriter> z `My.Computer.FileSystem.OpenTextFileWriter` — metoda i używa go do zapisu do pliku tekstowego z ciągiem `WriteLine` metody `StreamWriter` klasy.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa pliku kończy się znakiem ukośnika.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Plik do zapisania.</param>
        <param name="append">
          <see langword="True" /> Aby dołączyć do zawartości w pliku. <see langword="False" /> zastąpić zawartość pliku. Wartość domyślna to <see langword="False" />.</param>
        <param name="encoding">Kodowanie ma być używana podczas zapisywania do pliku. Domyślnie jest ASCII.</param>
        <summary>Otwiera <see cref="T:System.IO.StreamWriter" /> można zapisać w określonym pliku.</summary>
        <returns>
          <see cref="T:System.IO.StreamWriter" /> obiekt do zapisania do określonego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `OpenTextFileWriter` Metody otwiera i inicjuje strumienia pliku, a następnie zwraca <xref:System.IO.StreamWriter> obiekt dla tego strumienia. Możesz zapisać pary tyle razy, w razie potrzeby i zamknij go po zakończeniu.  
  
> [!NOTE]
>  Należy wywołać <xref:System.IO.StreamWriter.Close%2A> metoda <xref:System.IO.StreamWriter> obiekt, aby upewnić się, że wszystkie dane są poprawnie zapisywane do źródłowego strumienia.  
  
 Jeśli piszesz tylko kilka ciągi do pliku, może być łatwiejsze do użycia <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> metody.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.OpenTextFileWriter` metody.  
  
|Do|Zobacz|  
|-|-|  
|Zapisywanie tekstu do pliku z `StreamWriter`|[Porady: zapisywanie tekstu do plików za pomocą StreamWriter w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 W tym przykładzie otwiera <xref:System.IO.StreamWriter> z `My.Computer.FileSystem.OpenTextFileWriter` — metoda i używa go do zapisu do pliku tekstowego z ciągiem `WriteLine` metody `StreamWriter` klasy.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa pliku kończy się znakiem ukośnika.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Plik do odczytu.</param>
        <summary>Zwraca zawartość pliku w postaci tablicy bajtów.</summary>
        <returns>
          <see langword="Byte" /> Tablica zawierająca zawartość pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReadAllBytes` Metody `My.Computer.FileSystem` obiektu można odczytać z pliku binarnego. Zawartość pliku są zwracane w postaci tablicy bajtów.  
  
 Nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik Form1.vb nie może być plik źródłowy języka Visual Basic. Sprawdź wszystkie dane wejściowe, zanim użyjesz danych w aplikacji.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.ReadAllBytes` metody.  
  
|Do|Zobacz|  
|-|-|  
|Odczyt z pliku binarnego|[Porady: Odczyt z plików binarnych w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 Ten przykład odczytuje z pliku `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci do zapisania ciągu do buforu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca zawartość pliku tekstowego jako <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nazwa i ścieżka pliku do odczytu.</param>
        <summary>Zwraca zawartość pliku tekstowego jako <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> z zawartością pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReadAllText` Metody `My.Computer.FileSystem` obiektu służy do odczytu z pliku tekstowego. Zawartość pliku są zwracane jako ciąg.  
  
 Kodowanie pliku może być określony, jeśli zawartość pliku znajdują się w kodowania, takich jak ASCII lub UTF-8. Podczas czytania z pliku za pomocą rozszerzonych znaków, należy określić kodowanie pliku przy użyciu innego przeciążenia metody <xref:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText%2A> metody.  
  
 Nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik Form1.vb nie może być plik źródłowy języka Visual Basic. Sprawdź wszystkie dane wejściowe, zanim użyjesz danych w aplikacji.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.ReadAllText` metody.  
  
|Do|Zobacz|  
|-|-|  
|Odczyt z pliku tekstowego|[Porady: Odczyt z plików tekstowych w języku Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Ten przykład odczytuje zawartość `Test.txt` na ciąg znaków, a następnie wyświetla w oknie komunikatu.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Ten przykład odczytuje zawartość pliku ASCII `Test.txt` na ciąg znaków, a następnie wyświetla w oknie komunikatu.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci do zapisania ciągu do buforu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Nazwa i ścieżka pliku do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia podczas odczytu pliku. Domyślne to UTF-8.</param>
        <summary>Zwraca zawartość pliku tekstowego jako <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> z zawartością pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReadAllText` Metody `My.Computer.FileSystem` obiektu służy do odczytu z pliku tekstowego. Zawartość pliku są zwracane jako ciąg.  
  
 Kodowanie pliku może być określony, jeśli zawartość pliku znajdują się w kodowania, takich jak ASCII lub UTF-8. Podczas czytania z pliku za pomocą rozszerzonych znaków, należy określić kodowanie pliku.  
  
 Nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik Form1.vb nie może być plik źródłowy języka Visual Basic. Sprawdź wszystkie dane wejściowe, zanim użyjesz danych w aplikacji.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.ReadAllText` metody.  
  
|Do|Zobacz|  
|-|-|  
|Odczyt z pliku tekstowego|[Porady: Odczyt z plików tekstowych w języku Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Ten przykład odczytuje zawartość `Test.txt` na ciąg znaków, a następnie wyświetla w oknie komunikatu.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Ten przykład odczytuje zawartość pliku ASCII `Test.txt` na ciąg znaków, a następnie wyświetla w oknie komunikatu.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci do zapisania ciągu do buforu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public static void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Ścieżka i nazwa katalogu, których nazwa zostanie zmieniona.</param>
        <param name="newName">Nowa nazwa katalogu.</param>
        <summary>Zmienia nazwę katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można użyć tej metody można przenieść katalogu; Użyj `MoveDirectory` metody przenoszenia i Zmień nazwę katalogu.  
  
   
  
## Examples  
 W tym przykładzie zmienia nazwę `Test` do katalogu `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> zawiera informacje o ścieżce.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> jest <see langword="Nothing" />.  - lub - <paramref name="newName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Brak istniejący plik lub katalog o nazwie określonej w <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory" />
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public static void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Plik, których nazwa zostanie zmieniona.</param>
        <param name="newName">Nowa nazwa pliku.</param>
        <summary>Zmienia nazwę pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można użyć tej metody można przenieść pliku; Użyj <xref:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile%2A> metody przenoszenia i Zmień nazwę pliku.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.RenameFile` metody.  
  
|Do|Zobacz|  
|-|-|  
|Zmiana nazwy pliku|[Porady: Zmienianie nazwy pliku w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 W tym przykładzie zmienia nazwę pliku `Test.txt` do `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Zmiana "`C:\Test.txt`" na ścieżkę i nazwę pliku, który chcesz zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> zawiera informacje o ścieżce lub kończy się znakiem kreski ułamkowej odwróconej (\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.  - lub - <paramref name="newName" /> jest <see langword="Nothing" /> lub ciąg pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Katalog nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Brak istniejący plik lub katalog o nazwie określonej w <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Ścieżka i nazwa pliku do zapisania.</param>
        <param name="data">Dane są zapisywane do pliku.</param>
        <param name="append">
          <see langword="True" /> Aby dołączyć do zawartości pliku; <see langword="False" /> zastąpić zawartość pliku. Wartość domyślna to <see langword="False" />.</param>
        <summary>Zapisuje dane w pliku binarnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określona ścieżka, z wyłączeniem nazwa pliku nie jest prawidłowy, <xref:System.IO.DirectoryNotFoundException> zostanie wygenerowany wyjątek. Jeśli ścieżka jest prawidłowa, ale plik nie istnieje, plik jest tworzony.  
  
> [!NOTE]
>  `WriteAllBytes` Metody otwiera plik, zapisuje go, a następnie zamyka go. Kod, który używa `WriteAllBytes` metoda jest łatwiejsze niż w przypadku kodu korzystającego z <xref:System.IO.BinaryWriter> obiektu. Jednak w przypadku dodawania danych do pliku przy użyciu pętli, <xref:System.IO.BinaryWriter> obiektu może zapewnić lepszą wydajność, ponieważ masz do otwierania i zamykania pliku raz.  
  
 W poniższej tabeli przedstawiono przykład zadań, obejmujących `My.Computer.FileSystem.WriteAllBytes` metody.  
  
|Do|Zobacz|  
|-|-|  
|Zapis w pliku binarnym|[Porady: zapis w plikach binarnych w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 W tym przykładzie dołącza tablicy danych `CustomerData` do pliku `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci do zapisania ciągu do buforu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje tekst w pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Plik do zapisania.</param>
        <param name="text">Tekst, który ma zostać zapisany do pliku.</param>
        <param name="append">
          <see langword="True" /> Aby dołączyć do zawartości pliku. <see langword="False" /> zastąpić zawartość pliku.</param>
        <summary>Zapisuje tekst w pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie UTF-8 jest używana podczas zapisu do pliku. Aby określić inne kodowanie, użyj innego przeciążenia <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> metody.  
  
 Jeśli określony plik nie istnieje, jest tworzony.  
  
 Jeśli określonego kodowania nie pasują do istniejących kodowania pliku, określonej kodowanie jest ignorowana.  
  
> [!NOTE]
>  `WriteAllText` Metody otwiera plik, zapisuje go, a następnie zamyka go. Kod, który używa `WriteAllText` metoda jest łatwiejsze niż w przypadku kodu korzystającego z <xref:System.IO.StreamWriter> obiektu. Jednak jeśli dodajesz ciągi do pliku przy użyciu pętli, <xref:System.IO.StreamWriter> obiektu może zapewnić lepszą wydajność, ponieważ masz do otwierania i zamykania pliku jeden raz. Aby uzyskać więcej informacji, zobacz <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A> metody.  
  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.WriteAllText` metody.  
  
|Do|Zobacz|  
|-|-|  
|Zapisywanie tekstu do pliku|[Porady: zapisywanie tekstu do plików w języku Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Dołączanie tekstu do pliku|[Porady: łączenie się plikami tekstowymi w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 W tym przykładzie zapisuje linię `"This is new text to be added."` do pliku `Test.txt`, zastępując istniejący tekst w pliku.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 W tym przykładzie zapisuje nazwy plików w `Documents and Settings` folder `FileList.txt`, wstawianie karetki zwracać między nimi w celu zwiększenia czytelności.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci do zapisania ciągu do buforu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Plik do zapisania.</param>
        <param name="text">Tekst, który ma zostać zapisany do pliku.</param>
        <param name="append">
          <see langword="True" /> Aby dołączyć do zawartości pliku. <see langword="False" /> zastąpić zawartość pliku.</param>
        <param name="encoding">Jakie szyfrowanie do użycia podczas zapisywania do pliku.</param>
        <summary>Zapisuje tekst w pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony plik nie istnieje, jest tworzony.  
  
 Jeśli określonego kodowania nie pasują do istniejących kodowania pliku, określonej kodowanie jest ignorowana.  
  
> [!NOTE]
>  `WriteAllText` Metody otwiera plik, zapisuje go, a następnie zamyka go. Kod, który używa `WriteAllText` metoda jest łatwiejsze niż w przypadku kodu korzystającego z <xref:System.IO.StreamWriter> obiektu. Jednak jeśli dodajesz ciągi do pliku przy użyciu pętli, <xref:System.IO.StreamWriter> obiektu może zapewnić lepszą wydajność, ponieważ masz do otwierania i zamykania pliku jeden raz. Aby uzyskać więcej informacji, zobacz <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A> metody.  
  
 W poniższej tabeli przedstawiono przykłady dotyczące zadań `My.Computer.FileSystem.WriteAllText` metody.  
  
|Do|Zobacz|  
|-|-|  
|Zapisywanie tekstu do pliku|[Porady: zapisywanie tekstu do plików w języku Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Dołączanie tekstu do pliku|[Porady: łączenie się plikami tekstowymi w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 W tym przykładzie zapisuje linię `"This is new text to be added."` do pliku `Test.txt`, zastępując istniejący tekst w pliku.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 W tym przykładzie zapisuje nazwy plików w `Documents and Settings` folder `FileList.txt`, wstawianie karetki zwracać między nimi w celu zwiększenia czytelności.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowy dla jednego z następujących powodów: jest ciąg o zerowej długości. zawiera tylko biały znak zawiera ona nieprawidłowe znaki; lub jest ścieżką urządzenia (rozpoczyna się od \\ \\.\\); kończy się znakiem ukośnika.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> jest <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Plik jest używany przez inny proces lub błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Ścieżka przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.NotSupportedException">Nazwę pliku lub katalogu w ścieżce zawiera dwukropek (:) lub jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci do zapisania ciągu do buforu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma wystarczających uprawnień, aby wyświetlić ścieżkę.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Kontroluje możliwość dostępu do plików i folderów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>
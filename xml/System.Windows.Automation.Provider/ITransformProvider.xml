<Type Name="ITransformProvider" FullName="System.Windows.Automation.Provider.ITransformProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9f0d5cce841cd7b8659eeec75d7470a52c7d2041" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36372016" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface ITransformProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ITransformProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Provider.ITransformProvider" />
  <TypeSignature Language="VB.NET" Value="Public Interface ITransformProvider" />
  <TypeSignature Language="C++ CLI" Value="public interface class ITransformProvider" />
  <TypeSignature Language="F#" Value="type ITransformProvider = interface" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationProvider</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("6829ddc4-4f91-4ffa-b86f-bd3e2987cb4c")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.InterfaceType</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia metody i właściwości automatyzacji interfejsu użytkownika klienta dostęp do formantów, które można przenieść, rozmiaru lub obracać dwuwymiarowa miejsce.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zaimplementowany w dostawcy automatyzacji interfejsu użytkownika, który musi obsługiwać <xref:System.Windows.Automation.TransformPattern> — wzorzec formantu.  
  
 Obsługa tego wzorca formantu nie jest ograniczona do obiektów na pulpicie. Ten wzorzec kontroli również musi być implementowana przez element podrzędny obiektu kontenera tak długo, jak elementy podrzędne można przenieść, zmiany rozmiaru lub obracać za darmo w granicach kontenera.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.TransformPattern" />
  </Docs>
  <Members>
    <Member MemberName="CanMove">
      <MemberSignature Language="C#" Value="public bool CanMove { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanMove" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.ITransformProvider.CanMove" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanMove As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanMove { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanMove : bool" Usage="System.Windows.Automation.Provider.ITransformProvider.CanMove" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy można przenosić formant.</summary>
        <value>
          <see langword="true" /> Jeśli można przenieść elementu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono implementacja tej metody dla formantu, który można przenosić.  
  
 [!code-csharp[UIAITransformProvider_snip#CanMove](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAITransformProvider_snip/CSharp/TransformFragment.cs#canmove)]
 [!code-vb[UIAITransformProvider_snip#CanMove](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAITransformProvider_snip/visualbasic/transformfragment.vb#canmove)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanResize">
      <MemberSignature Language="C#" Value="public bool CanResize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.ITransformProvider.CanResize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanResize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanResize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResize : bool" Usage="System.Windows.Automation.Provider.ITransformProvider.CanResize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która określa, czy [! Można zmienić rozmiar elementu include[TLA2#tla_uiautomation](~/includes/tla2sharptla-UIAutomation-MD.MD)].</summary>
        <value>
          <see langword="true" /> Jeśli można zmienić rozmiar elementu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono implementacja tej metody dla formantu, który można zmieniać.  
  
 [!code-csharp[UIAITransformProvider_snip#CanResize](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAITransformProvider_snip/CSharp/TransformFragment.cs#canresize)]
 [!code-vb[UIAITransformProvider_snip#CanResize](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAITransformProvider_snip/visualbasic/transformfragment.vb#canresize)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRotate">
      <MemberSignature Language="C#" Value="public bool CanRotate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRotate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.ITransformProvider.CanRotate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRotate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRotate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRotate : bool" Usage="System.Windows.Automation.Provider.ITransformProvider.CanRotate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy formant można obracać.</summary>
        <value>
          <see langword="true" /> Jeśli element można obracać; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono implementacja tej metody dla formantu nie można obracać.  
  
 [!code-csharp[UIAITransformProvider_snip#CanRotate](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAITransformProvider_snip/CSharp/TransformFragment.cs#canrotate)]
 [!code-vb[UIAITransformProvider_snip#CanRotate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAITransformProvider_snip/visualbasic/transformfragment.vb#canrotate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public void Move (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Move(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITransformProvider.Move(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Move (x As Double, y As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Move(double x, double y);" />
      <MemberSignature Language="F#" Value="abstract member Move : double * double -&gt; unit" Usage="iTransformProvider.Move (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędne ekranu bezwzględną z lewej strony kontrolki.</param>
        <param name="y">Współrzędne ekranu bezwzględną Góra formantu.</param>
        <summary>Przenosi formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt nie można przenieść, rozmiaru lub obracać w taki sposób, że jego wynikowej lokalizacją ekranu będzie całkowicie poza współrzędne swojego kontenera i niedostępne do klawiatury lub myszy. Na przykład po przeniesieniu okien najwyższego poziomu w całkowicie ekranem lub obiekt podrzędny są przenoszone poza granice tego kontenera okienka ekranu. W takich przypadkach obiekt znajduje się maksymalnie zbliżony współrzędne ekranu żądanego możliwie z góry lub lewej współrzędne zastąpiona w granicach kontenera.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono jeden możliwe implementacja tej metody dla kontrolek niestandardowych, które mogą być przenoszone.  
  
 [!code-csharp[UIAITransformProvider_snip#Move](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAITransformProvider_snip/CSharp/TransformFragment.cs#move)]
 [!code-vb[UIAITransformProvider_snip#Move](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAITransformProvider_snip/visualbasic/transformfragment.vb#move)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Jeśli <see cref="P:System.Windows.Automation.Provider.ITransformProvider.CanMove" /> właściwość ma wartość false.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public void Resize (double width, double height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Resize(float64 width, float64 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITransformProvider.Resize(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resize (width As Double, height As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resize(double width, double height);" />
      <MemberSignature Language="F#" Value="abstract member Resize : double * double -&gt; unit" Usage="iTransformProvider.Resize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Double" />
        <Parameter Name="height" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="width">Nową szerokość okna w pikselach.</param>
        <param name="height">Nową wysokość okna w pikselach.</param>
        <summary>Zmienia rozmiar formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanego w formancie obsługującej podzielone okienka, ta metoda może mieć efektem ubocznym zmienianie rozmiarów innych okienek ciągły.  
  
 Obiekt nie można przenieść, rozmiaru lub obracać w taki sposób, że jego wynikowej lokalizacją ekranu będzie całkowicie poza współrzędne swojego kontenera i niedostępne do klawiatury lub myszy. Na przykład po przeniesieniu okien najwyższego poziomu w całkowicie ekranem lub obiekt podrzędny są przenoszone poza granice tego kontenera okienka ekranu. W takich przypadkach obiekt znajduje się maksymalnie zbliżony współrzędne ekranu żądanego możliwie z góry lub lewej współrzędne zastąpiona w granicach kontenera.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono jeden możliwe implementacja tej metody dla kontrolek niestandardowych, które można zmienić rozmiar.  
  
 [!code-csharp[UIAITransformProvider_snip#Resize](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAITransformProvider_snip/CSharp/TransformFragment.cs#resize)]
 [!code-vb[UIAITransformProvider_snip#Resize](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAITransformProvider_snip/visualbasic/transformfragment.vb#resize)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Jeśli <see cref="P:System.Windows.Automation.Provider.ITransformProvider.CanResize" /> właściwość ma wartość false.</exception>
      </Docs>
    </Member>
    <Member MemberName="Rotate">
      <MemberSignature Language="C#" Value="public void Rotate (double degrees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Rotate(float64 degrees) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITransformProvider.Rotate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rotate (degrees As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Rotate(double degrees);" />
      <MemberSignature Language="F#" Value="abstract member Rotate : double -&gt; unit" Usage="iTransformProvider.Rotate degrees" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="degrees" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="degrees">Liczba stopni Obróć formantu. Liczba dodatnia obraca wskazówek zegara; wartość ujemną obraca zegara.</param>
        <summary>Obraca formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt nie można przenieść, rozmiaru lub obracać w taki sposób, że jego wynikowej lokalizacją ekranu będzie całkowicie poza współrzędne swojego kontenera i niedostępne do klawiatury lub myszy. Na przykład po przeniesieniu okien najwyższego poziomu w całkowicie ekranem lub obiekt podrzędny są przenoszone poza granice tego kontenera okienka ekranu. W takich przypadkach obiekt znajduje się maksymalnie zbliżony współrzędne ekranu żądanego możliwie z góry lub lewej współrzędne zastąpiona w granicach kontenera.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono jeden możliwe implementacja tej metody dla kontrolki niestandardowej, która nie można obracać.  
  
 [!code-csharp[UIAITransformProvider_snip#Rotate](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAITransformProvider_snip/CSharp/TransformFragment.cs#rotate)]
 [!code-vb[UIAITransformProvider_snip#Rotate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAITransformProvider_snip/visualbasic/transformfragment.vb#rotate)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Jeśli <see cref="P:System.Windows.Automation.Provider.ITransformProvider.CanRotate" /> właściwość ma wartość false.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
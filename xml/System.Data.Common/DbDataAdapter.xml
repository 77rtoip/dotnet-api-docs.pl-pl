<Type Name="DbDataAdapter" FullName="System.Data.Common.DbDataAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3db191c839c8f56032f735e1fccf95a42edd36ef" /><Meta Name="ms.sourcegitcommit" Value="0609891c89ddaa91e4c02970acb00072fcc29baf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="05/13/2019" /><Meta Name="ms.locfileid" Value="65558336" /></Metadata><TypeSignature Language="C#" Value="public abstract class DbDataAdapter : System.Data.Common.DataAdapter, ICloneable, System.Data.IDbDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DbDataAdapter extends System.Data.Common.DataAdapter implements class System.Data.IDataAdapter, class System.Data.IDbDataAdapter, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.DbDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DbDataAdapter&#xA;Inherits DataAdapter&#xA;Implements ICloneable, IDbDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class DbDataAdapter abstract : System::Data::Common::DataAdapter, ICloneable, System::Data::IDbDataAdapter" />
  <TypeSignature Language="F#" Value="type DbDataAdapter = class&#xA;    inherit DataAdapter&#xA;    interface IDbDataAdapter&#xA;    interface ICloneable&#xA;    interface IDataAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DataAdapter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.IDataAdapter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Data.IDbDataAdapter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Ułatwia implementację <see cref="T:System.Data.IDbDataAdapter" /> interfejsu. Obiektów dziedziczących z <see cref="T:System.Data.Common.DbDataAdapter" /> implementują zestaw funkcji, aby zapewnić silne wpisywanie, ale dziedziczą większość potrzebnych do pełnej implementacji funkcji **DataAdapter**.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter> Klasa dziedziczy <xref:System.Data.Common.DataAdapter> klasy i implementuje <xref:System.Data.IDbDataAdapter> interfejsu. Pomaga ona klasa implementuje **DataAdapter** przeznaczony do użytku z relacyjnej bazy danych.  
  
 Aplikacja nie tworzy wystąpienie <xref:System.Data.Common.DbDataAdapter> klasy bezpośrednio, ale tworzy wystąpienie klasy, która dziedziczy z niego.  
  
 Klasy, które dziedziczą <xref:System.Data.Common.DbDataAdapter> należy zaimplementować dziedziczone elementy członkowskie, a zwykle definiuje dodatkowe elementy członkowskie, aby dodać funkcje właściwe dla dostawcy. Na przykład <xref:System.Data.Common.DbDataAdapter> klasa definiuje <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości i <xref:System.Data.Common.DbDataAdapter> klasa definiuje osiem przeciążenia <xref:System.Data.IDataAdapter.Fill%2A> metody. Z kolei <xref:System.Data.OleDb.OleDbDataAdapter> klasa dziedziczy <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody, a także określa dwa dodatkowe przeciążenia metody <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> , które wymagają zestawu rekordów ADO obiekt jako parametr.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Przy dziedziczeniu z <see cref="T:System.Data.Common.DbDataAdapter" /> klasy, firma Microsoft zaleca, aby zaimplementować następujących konstruktorów: 
 <list type="table"><listheader><term> Element 
 </term><description> Opis 
 </description></listheader><item><term> *Prv*DataAdapter() 
 </term><description> Inicjuje nowe wystąpienie klasy *Prv*DataAdapter klasy.  
  
 </description></item><item><term> *Prv*DataAdapter (*Prv*polecenia *selectCommand*) 
 </term><description> Inicjuje nowe wystąpienie klasy *Prv*DataAdapter klasy z określoną instrukcję SQL SELECT.  
  
 </description></item><item><term> *Prv*DataAdapter (ciąg *selectCommandText*, ciąg *selectConnectionString*) 
 </term><description> Inicjuje nowe wystąpienie klasy *Prv*DataAdapter klasy za pomocą instrukcji SQL SELECT i parametry połączenia.  
  
 </description></item><item><term> *Prv*DataAdapter (ciąg *selectCommandText*, *Prv*połączenia *selectConnection*) 
 </term><description> Inicjuje nowe wystąpienie klasy *Prv*DataAdapter klasy za pomocą instrukcji SQL SELECT a *Prv*obiekt połączenia.  
  
 </description></item></list>  

 Podwyższenie poziomu spójności między dostawcy danych .NET Framework, należy nadać nazwę klasy dziedziczącej, w postaci *Prv*DataAdapter, gdzie *Prv* jest prefiksem jednolite, biorąc pod uwagę wszystkie klasy w określonej platformy .NET Przestrzeń nazw dostawcy danych Framework. Na przykład "Sql" to prefiks wartości <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> klasy w **System.Data.SqlClient** przestrzeni nazw.</para></block>
    <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
    <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="DataAdapter" /> klasy.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy **DataAdapter** klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu wystąpienia <xref:System.Data.Common.DbDataAdapter>, następujące właściwości odczytu/zapisu są ustawione następujące wartości początkowej.  
  
|Właściwości|Wartość początkowa|  
|----------------|-------------------|  
|<xref:System.Data.IDbDataAdapter.SelectCommand%2A>|Nowy <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.IDbDataAdapter.InsertCommand%2A>|Nowy <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>|Nowy <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>|Nowy <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.Common.DataAdapter.MissingMappingAction%2A>|`MissingMappingAction.Passthrough`|  
|<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>|`MissingSchemaAction.Add`|  
  
 Można zmienić wartości tych właściwości, za pośrednictwem oddzielne wywołania do właściwości.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter (System.Data.Common.DbDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.Common.DbDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (adapter As DbDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter(System::Data::Common::DbDataAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="new System.Data.Common.DbDataAdapter : System.Data.Common.DbDataAdapter -&gt; System.Data.Common.DbDataAdapter" Usage="new System.Data.Common.DbDataAdapter adapter" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.Common.DbDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter">A <see langword="DataAdapter" /> obiektu użytego do utworzenia nowego <see langword="DataAdapter" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="DataAdapter" /> klasy z istniejącego obiektu tego samego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Data.Common.DbDataAdapter> Konstruktor jest przeznaczony do użytku przez dostawcę danych .NET Framework podczas implementowania podobne konstruktora do użycia w implementacji klonowania.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddToBatch">
      <MemberSignature Language="C#" Value="protected virtual int AddToBatch (System.Data.IDbCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 AddToBatch(class System.Data.IDbCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function AddToBatch (command As IDbCommand) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int AddToBatch(System::Data::IDbCommand ^ command);" />
      <MemberSignature Language="F#" Value="abstract member AddToBatch : System.Data.IDbCommand -&gt; int&#xA;override this.AddToBatch : System.Data.IDbCommand -&gt; int" Usage="dbDataAdapter.AddToBatch command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.IDbCommand" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="command"><see cref="T:System.Data.IDbCommand" /> Do dodania do danego wsadu.</param>
        <summary>Dodaje <see cref="T:System.Data.IDbCommand" /> do bieżącej partii.</summary>
        <returns>Liczba poleceń w partii, przed dodaniem <see cref="T:System.Data.IDbCommand" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda wyrzuca <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę w celu zapewnienia obsługi partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides"><para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  
  
Jeśli klasa, która dziedziczy po elemencie <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę, aby zezwolić użytkownikom na dodawanie polecenia do usługi batch.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ClearBatch">
      <MemberSignature Language="C#" Value="protected virtual void ClearBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ClearBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearBatch ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearBatch();" />
      <MemberSignature Language="F#" Value="abstract member ClearBatch : unit -&gt; unit&#xA;override this.ClearBatch : unit -&gt; unit" Usage="dbDataAdapter.ClearBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie <see cref="T:System.Data.IDbCommand" /> obiektów z usługi batch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda wyrzuca <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę w celu zapewnienia obsługi partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides"><para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  
  
Jeśli klasa, która dziedziczy po elemencie <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę, aby zezwolić użytkownikom na usuwanie wszystkich poleceń usługi batch.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatedEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatedEventArgs ^ CreateRowUpdatedEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberSignature Language="F#" Value="abstract member CreateRowUpdatedEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatedEventArgs&#xA;override this.CreateRowUpdatedEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatedEventArgs" Usage="dbDataAdapter.CreateRowUpdatedEvent (dataRow, command, statementType, tableMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatedEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow"><see cref="T:System.Data.DataRow" /> Używane do aktualizowania źródła danych.</param>
        <param name="command"><see cref="T:System.Data.IDbCommand" /> Wykonanych podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</param>
        <param name="statementType">Polecenie aktualizacji, czy WSTAWIĆ, usunąć lub instrukcja SELECT.</param>
        <param name="tableMapping">Element <see cref="T:System.Data.Common.DataTableMapping" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> klasy.</summary>
        <returns>Nowe wystąpienie klasy <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> klasy.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> metody.</para></block>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatingEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatingEventArgs ^ CreateRowUpdatingEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberSignature Language="F#" Value="abstract member CreateRowUpdatingEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatingEventArgs&#xA;override this.CreateRowUpdatingEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatingEventArgs" Usage="dbDataAdapter.CreateRowUpdatingEvent (dataRow, command, statementType, tableMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatingEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow"><see cref="T:System.Data.DataRow" /> Aktualizuje się ze źródłem danych.</param>
        <param name="command"><see cref="T:System.Data.IDbCommand" /> Do wykonania podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</param>
        <param name="statementType">Polecenie aktualizacji, czy WSTAWIĆ, usunąć lub instrukcja SELECT.</param>
        <param name="tableMapping">Element <see cref="T:System.Data.Common.DataTableMapping" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> klasy.</summary>
        <returns>Nowe wystąpienie klasy <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> klasy.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> metody.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultSourceTableName">
      <MemberSignature Language="C#" Value="public const string DefaultSourceTableName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DefaultSourceTableName" />
      <MemberSignature Language="DocId" Value="F:System.Data.Common.DbDataAdapter.DefaultSourceTableName" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultSourceTableName As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ DefaultSourceTableName;" />
      <MemberSignature Language="F#" Value="val mutable DefaultSourceTableName : string" Usage="System.Data.Common.DbDataAdapter.DefaultSourceTableName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Domyślna nazwa używana przez <see cref="T:System.Data.Common.DataAdapter" /> obiektu dla mapowania tabel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "Table" jest domyślna nazwa używana przez <xref:System.Data.Common.DataAdapter> obiektu dla mapowania tabel.  
  
 <xref:System.Data.Common.DbDataAdapter.DefaultSourceTableName> jest, gdy aplikacja dodaje mapowania tabeli, ma być używany z <xref:System.Data.Common.DbDataAdapter.Fill%2A>, ale nie określa <xref:System.Data.DataTable> nazwy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.DeleteCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property DeleteCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ DeleteCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.DeleteCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia polecenie do usuwania rekordów z zestawu danych.</summary>
        <value><see cref="T:System.Data.IDbCommand" /> Używane podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> do usuwania rekordów w źródle danych, która ma być usunięte wiersze w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.Data.Common.DbDataAdapter.Update%2A>, jeśli ta właściwość nie jest ustawiona i informacje o kluczu podstawowym znajduje się w <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.DeleteCommand%2A> jest generowany automatycznie.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="dbDataAdapter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Data.Common.DbDataAdapter" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteBatch">
      <MemberSignature Language="C#" Value="protected virtual int ExecuteBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 ExecuteBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ExecuteBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ExecuteBatch () As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int ExecuteBatch();" />
      <MemberSignature Language="F#" Value="abstract member ExecuteBatch : unit -&gt; int&#xA;override this.ExecuteBatch : unit -&gt; int" Usage="dbDataAdapter.ExecuteBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje bieżącej partii.</summary>
        <returns>Wartość zwrócona przez ostatnie polecenie w partii.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda wyrzuca <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę w celu zapewnienia obsługi partii.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  
  
Jeśli klasa, która dziedziczy po elemencie <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę, aby zezwolić użytkownikom na wykonywanie partii. Implementacja tej metody łączy poleceń na karcie w zadaniu wsadowym, a następnie wykonuje zadanie wsadowe i zwraca wartość zwracaną przez zadanie wsadowe.</para></block>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Fill">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wypełnia <see cref="T:System.Data.DataSet" /> lub <see cref="T:System.Data.DataTable" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public override int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet -&gt; int" Usage="dbDataAdapter.Fill dataSet" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Fill(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżane w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy dotyczy instrukcji, które nie zwrócą wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection> Obiekt skojarzony z polecenia select musi być prawidłowy, ale nie musi być otwarty. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarty w celu pobrania danych i następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 Jeśli błąd lub wyjątek podczas wypełniania danych w tabelach, wiersze dodawanych przed wystąpieniem błędu pozostają w tabelach danych. W pozostałej części operacja została przerwana.  
  
 Jeśli polecenie nie zwraca wszystkie wiersze, tabele nie są dodawane do <xref:System.Data.DataSet>, i nie jest zgłaszany żaden wyjątek.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu napotka kolumn podczas wypełniania <xref:System.Data.DataTable>, generuje on nazwy dla kolejnych kolumn przy użyciu wzorca "*columnname*1","*columnname*2", " *columnname*3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Gdy zapytanie określone zwraca wiele wyników, zestawu wyników dla każdego wiersza zwracanie zapytania jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" i tak dalej). Ponieważ tabela nie jest tworzony dla zapytania, która nie zwraca wiersze, jeśli procesu zapytanie wstawiające, a następnie wybierz zapytanie, tabelę utworzoną dla zapytania select nosi nazwę "Table", ponieważ jest to pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 Gdy instrukcja SELECT używany do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takich jak batch instrukcje SQL, jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki zostaną pominięte, a nie są dodawane do <xref:System.Data.DataSet>.  
  
 Korzystając z kolejnych <xref:System.Data.Common.DbDataAdapter.Fill%2A> wywołań, aby odświeżyć zawartość <xref:System.Data.DataSet>, muszą zostać spełnione dwa warunki:  
  
1.  Instrukcja SQL powinny odpowiadać początkowo używaną do wypełniania <xref:System.Data.DataSet>.  
  
2.  **Klucz** informacji o kolumnie musi być obecny.  
  
 Jeśli ma informacje o kluczu podstawowym zduplikowanych wierszy są uzgodnione i są wyświetlane tylko raz w <xref:System.Data.DataTable> , który odpowiada <xref:System.Data.DataSet>. Informacje o kluczu podstawowym można ustawić za pomocą <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, określając <xref:System.Data.DataTable.PrimaryKey%2A> właściwość <xref:System.Data.DataTable>, lub poprzez skonfigurowanie <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> właściwość `AddWithKey`.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartości wynikowe <xref:System.Data.DataTable>. Musisz jawnie zdefiniować klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane prawidłowo. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable -&gt; int" Usage="dbDataAdapter.Fill dataTable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">Nazwa <see cref="T:System.Data.DataTable" /> na potrzeby mapowania tabeli.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> zgadzać się przy użyciu źródła danych <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżane w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy dotyczy instrukcji, które nie zwrócą wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT, określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jego jest otwarta do pobierania danych, a następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Następnie operacja doda wiersze do miejsca docelowego <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiekty, jeśli ich jeszcze nie istnieją. Podczas tworzenia <xref:System.Data.DataTable> obiektów <xref:System.Data.Common.DbDataAdapter.Fill%2A> operacja zazwyczaj tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje on nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Kiedy wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników jest umieszczany w osobnej tabeli.  
  
 Przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A> przyjmującej `DataTable` jako parametr uzyskuje tylko pierwszego wyniku. Używanie przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A> przyjmującej `DataSet` jako parametr do uzyskania wiele wyników.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> wykonuje porównania uwzględniającego wielkość liter można znaleźć odpowiedniej tabeli i tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
 dataset.Tables.Add("AAA");  
 adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
    adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowana. W tym scenariuszu porównania jest uwzględniana wielkość liter. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Możesz użyć <xref:System.Data.Common.DbDataAdapter.Fill%2A> metoda wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli istnieje klucz podstawowy, wiersze przychodzące są scalane z pasujących wierszy, które już istnieją. Jeśli istnieje nie klucza podstawowego, wiersze przychodzące są dołączane do <xref:System.Data.DataTable>.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartości wynikowe <xref:System.Data.DataTable>. Musisz jawnie zdefiniować klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane prawidłowo. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.Fill%2A> i <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dostawcy danych .NET Framework pobiera informacje o schemacie dla pierwszego wyniku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowy.</exception>
        <block subset="none" type="overrides"><para>To przeciążenie <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * string -&gt; int" Usage="dbDataAdapter.Fill (dataSet, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataSet" /> zgadzać się przy użyciu źródła danych <see cref="T:System.Data.DataSet" /> i <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżane w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy dotyczy instrukcji, które nie zwrócą wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection> Obiekt skojarzony z polecenia select musi być prawidłowy, ale nie musi być otwarty. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jego jest otwarta do pobierania danych, a następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 Jeśli polecenie nie zwraca wszystkie wiersze, tabele nie są dodawane do <xref:System.Data.DataSet>, i nie jest zgłaszany żaden wyjątek.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu napotka kolumn podczas wypełniania <xref:System.Data.DataTable>, zostanie wygenerowany nazwy dla kolejnych kolumn, za pomocą wzorca "nazwakolumny1", "nazwakolumny2", "columnname3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Gdy zapytanie określone zwraca wiele wyników, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" i tak dalej). Ponieważ tabela nie jest tworzony dla zapytania, która nie zwraca wiersze, gdyby przetwarzania zapytanie wstawiające, a następnie wybierz zapytanie, tabelę utworzoną dla zapytania select będą miały postać "Table", ponieważ jest to pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> wykonuje porównania uwzględniającego wielkość liter można znaleźć odpowiedniej tabeli i tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowana. W tym scenariuszu porównania jest uwzględniana wielkość liter. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Jeśli błąd lub wyjątek podczas wypełniania danych w tabelach, wiersze dodawanych przed wystąpieniem błędu pozostają w tabelach danych. W pozostałej części operacja została przerwana.  
  
 Gdy instrukcja SELECT używany do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takich jak batch instrukcji SQL, należy pamiętać o następujących:  
  
-   Jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięte, a nie zostały dodane do <xref:System.Data.DataSet>.  
  
 Korzystając z kolejnych <xref:System.Data.Common.DbDataAdapter.Fill%2A> wywołań, aby odświeżyć zawartość <xref:System.Data.DataSet>, muszą zostać spełnione dwa warunki:  
  
1.  Instrukcja SQL powinny odpowiadać początkowo używaną do wypełniania <xref:System.Data.DataSet>.  
  
2.  **Klucz** informacji o kolumnie musi być obecny. Jeśli ma informacje o kluczu podstawowym zduplikowanych wierszy są uzgodnione i są wyświetlane tylko raz w <xref:System.Data.DataTable> , który odpowiada <xref:System.Data.DataSet>. Informacje o kluczu podstawowym można ustawić za pomocą <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, określając <xref:System.Data.DataTable.PrimaryKey%2A> właściwość <xref:System.Data.DataTable>, lub poprzez skonfigurowanie <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> właściwość `AddWithKey`.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartości wynikowe <xref:System.Data.DataTable>. Musisz jawnie zdefiniować klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane prawidłowo. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby wypełnić <xref:System.Data.DataSet> wierszy z tabeli Kategorie. W tym przykładzie założono, że utworzono <xref:System.Data.OleDb.OleDbDataAdapter> i <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Tabela źródłowa jest nieprawidłowy.</exception>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> metody.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDataReader dataReader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable dataTable, class System.Data.IDataReader dataReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataTable ^ dataTable, System::Data::IDataReader ^ dataReader);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable * System.Data.IDataReader -&gt; int" Usage="dbDataAdapter.Fill (dataTable, dataReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="dataReader" Type="System.Data.IDataReader" Index="1" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="dataTable">A <see cref="T:System.Data.DataTable" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="dataReader">Nazwa <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataTable" /> zgadzać się w źródle danych przy użyciu określonego <see cref="T:System.Data.DataTable" /> i <see cref="T:System.Data.IDataReader" /> nazwy.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżane w <see cref="T:System.Data.DataTable" />. Nie zawiera wierszy dotyczy instrukcji, które nie zwrócą wierszy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable dataTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataTable ^ dataTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; int" Usage="dbDataAdapter.Fill (dataTable, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable">A <see cref="T:System.Data.DataTable" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="command">Instrukcja SQL ZAZNACZYĆ służy do pobierania wierszy ze źródła danych.</param>
        <param name="behavior">Jedną z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataTable" /> zgadzać się w źródle danych przy użyciu określonego <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.IDbCommand" /> i <see cref="T:System.Data.CommandBehavior" />.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżane w <see cref="T:System.Data.DataTable" />. Nie zawiera wierszy dotyczy instrukcji, które nie zwrócą wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT, określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarty w celu pobrania danych i następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Następnie operacja doda wiersze do określonej lokalizacji docelowej <xref:System.Data.DataTable> obiektu <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiektu, jeśli go jeszcze nie istnieje. Podczas tworzenia <xref:System.Data.DataTable> obiektu <xref:System.Data.Common.DbDataAdapter.Fill%2A> operacja zazwyczaj tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu napotka kolumn podczas wypełniania <xref:System.Data.DataTable>, zostanie wygenerowany nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2 ","*columnname*3 ", i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A> przyjmującej `DataTable` jako parametr uzyskuje tylko pierwszego wyniku. Używanie przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A> przyjmującej `DataSet` jako parametr do uzyskania wiele wyników.  
  
 Możesz użyć <xref:System.Data.Common.DbDataAdapter.Fill%2A> metoda wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli istnieje klucz podstawowy, wiersze przychodzące są scalane z pasujących wierszy, które już istnieją. Jeśli istnieje nie klucza podstawowego, wiersze przychodzące są dołączane do <xref:System.Data.DataTable>.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartości wynikowe <xref:System.Data.DataTable>. Musisz jawnie zdefiniować klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane prawidłowo. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>To przeciążenie <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (int startRecord, int maxRecords, params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(int32 startRecord, int32 maxRecords, class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Fill (startRecord As Integer, maxRecords As Integer, ParamArray dataTables As DataTable()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(int startRecord, int maxRecords, ... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="override this.Fill : int * int * System.Data.DataTable[] -&gt; int" Usage="dbDataAdapter.Fill (startRecord, maxRecords, dataTables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startRecord" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maxRecords" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startRecord">Liczony od zera numer rekordu powinny zaczynać się.</param>
        <param name="maxRecords">Maksymalna liczba rekordów do pobrania.</param>
        <param name="dataTables"><see cref="T:System.Data.DataTable" /> Obiektów, aby wypełnić ze źródła danych.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataTable" /> zgadzać się w źródle danych, zaczynając od określonego rekordu i pobierania maksymalnie określoną maksymalną liczbę rekordów.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżane w <see cref="T:System.Data.DataTable" />. Ta wartość nie zawiera wierszy dotyczy instrukcji, które nie zwrócą wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DataAdapter.Fill%2A> Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT, określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DataAdapter.Fill%2A> jest wywoływana, został on otwarty w celu pobrania danych, a następnie jest zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.Common.DataAdapter.Fill%2A> Następnie operacja doda wiersze do miejsca docelowego <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiekty, jeśli ich jeszcze nie istnieją. Podczas tworzenia <xref:System.Data.DataTable> obiektów <xref:System.Data.Common.DataAdapter.Fill%2A> operacja zazwyczaj tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartości wynikowe <xref:System.Data.DataTable>. Musisz jawnie zdefiniować klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane prawidłowo. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
 Jeśli adapter danych napotka kolumn podczas wypełniania <xref:System.Data.DataTable>, generuje ona nazwy kolejnych kolumn, za pomocą wzorca "nazwakolumny1", "nazwakolumny2", "columnname3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Kiedy wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" i tak dalej). Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 Gdy instrukcja SELECT używany do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takich jak batch instrukcje SQL, jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięty i nie zostały dodane do <xref:System.Data.DataSet>.  
  
 Możesz użyć <xref:System.Data.Common.DataAdapter.Fill%2A> metoda wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli istnieje klucz podstawowy, wiersze przychodzące są scalane z pasujących wierszy, które już istnieją. Jeśli istnieje nie klucza podstawowego, wiersze przychodzące są dołączane do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * int * int * string -&gt; int" Usage="dbDataAdapter.Fill (dataSet, startRecord, maxRecords, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="startRecord">Liczony od zera numer rekordu powinny zaczynać się.</param>
        <param name="maxRecords">Maksymalna liczba rekordów do pobrania.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> zgadzać się przy użyciu źródła danych <see cref="T:System.Data.DataSet" /> i <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżane w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy dotyczy instrukcji, które nie zwrócą wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `maxRecords` wartość 0 pobiera wszystkie rekordy po rekordu rozpoczęcia. Jeśli `maxRecords` jest większa niż liczba pozostałych wierszy, tylko pozostałe wiersze są zwracane, a błąd nie jest zgłaszany.  
  
 Jeśli odpowiednie polecenie select jest instrukcja zwracania wielu wyników <xref:System.Data.Common.DbDataAdapter.Fill%2A> dotyczy tylko `maxRecords` do pierwszego wyniku.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection> Obiekt skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarty w celu pobrania danych i następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 Jeśli polecenie nie zwraca wszystkie wiersze, tabele nie są dodawane do <xref:System.Data.DataSet>, ale nie jest wyjątek.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu napotka kolumn podczas wypełniania <xref:System.Data.DataTable>, zostanie wygenerowany nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2 ","*columnname*3 ", i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Gdy zapytanie określone zwraca wiele wyników, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" i tak dalej). Ponieważ tabela nie jest tworzony dla zapytania, która nie zwraca wiersze, jeśli procesu zapytanie wstawiające, a następnie wybierz zapytanie, tabelę utworzoną dla zapytania select nosi nazwę "Table", ponieważ jest to pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> wykonuje porównania uwzględniającego wielkość liter można znaleźć odpowiedniej tabeli i tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowana. W tym scenariuszu porównania jest uwzględniana wielkość liter. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Jeśli błąd lub wyjątek podczas wypełniania danych w tabelach, wiersze dodawanych przed wystąpieniem błędu pozostają w tabelach danych. W pozostałej części operacja została przerwana.  
  
 Gdy instrukcja SELECT używany do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takich jak batch instrukcje SQL, należy pamiętać o następujących czynności:  
  
-   Podczas przetwarzania wiele wyników z partii instrukcji SQL `maxRecords` ma zastosowanie tylko do pierwszego wyniku. Dotyczy to także wiersze zawierające wyniki podzielony na rozdziały (.NET Framework Data Provider for OLE DB tylko). Wynik najwyższego poziomu jest ograniczona przez `maxRecords`, ale wszystkie wiersze podrzędne są dodawane.  
  
-   Jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięte, a nie zostały dodane do <xref:System.Data.DataSet>.  
  
 Korzystając z kolejnych <xref:System.Data.Common.DbDataAdapter.Fill%2A> wywołań, aby odświeżyć zawartość <xref:System.Data.DataSet>, muszą zostać spełnione dwa warunki:  
  
1.  Instrukcja SQL powinny odpowiadać początkowo używaną do wypełniania <xref:System.Data.DataSet>.  
  
2.  **Klucz** informacji o kolumnie musi być obecny.  
  
 Jeśli informacje o kluczu podstawowym jest obecny, wszystkie zduplikowane wiersze będą uzgodnić i wystąpić tylko raz w <xref:System.Data.DataTable> , który odpowiada <xref:System.Data.DataSet>. Informacje o kluczu podstawowym można ustawić za pomocą <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, określając <xref:System.Data.DataTable.PrimaryKey%2A> właściwość <xref:System.Data.DataTable>, lub poprzez skonfigurowanie <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> właściwość `AddWithKey`.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartości wynikowe <xref:System.Data.DataTable>. Musisz jawnie zdefiniować klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane prawidłowo. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
> [!NOTE]
>  `DataSet` Nie będzie zawierać więcej niż liczba rekordów wskazywanym przez `maxRecords`. Jednakże cały zestaw wyników generowanych przez zapytanie jest nadal zwrócona z serwera.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby wypełnić <xref:System.Data.DataSet> 15 wierszy, w wierszu 10, rozpoczynający się od **kategorie** tabeli. W tym przykładzie założono, że utworzono <xref:System.Data.OleDb.OleDbDataAdapter> i <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowy.  
  
—lub— 
Połączenie jest nieprawidłowe.</exception>
        <exception cref="T:System.InvalidCastException">Nie można odnaleźć połączenia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="startRecord" /> Parametru jest mniejszy niż 0.  
  
—lub— 
<paramref name="maxRecords" /> Parametru jest mniejszy niż 0.</exception>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> metody.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataSet dataSet, string srcTable, System.Data.IDataReader dataReader, int startRecord, int maxRecords);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet, string srcTable, class System.Data.IDataReader dataReader, int32 startRecord, int32 maxRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String,System.Data.IDataReader,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet, System::String ^ srcTable, System::Data::IDataReader ^ dataReader, int startRecord, int maxRecords);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * string * System.Data.IDataReader * int * int -&gt; int" Usage="dbDataAdapter.Fill (dataSet, srcTable, dataReader, startRecord, maxRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="srcTable" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="dataReader" Type="System.Data.IDataReader" Index="2" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="startRecord" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="maxRecords" Type="System.Int32" Index="4" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="srcTable">Nazwa <see cref="T:System.Data.DataTable" /> na potrzeby mapowania tabeli.</param>
        <param name="dataReader">Nazwa <see cref="T:System.Data.IDataReader" />.</param>
        <param name="startRecord">Liczony od zera numer rekordu powinny zaczynać się.</param>
        <param name="maxRecords">Maksymalna liczba rekordów do pobrania.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> zgadzać się przy użyciu źródła danych <see cref="T:System.Data.DataSet" />, <see cref="T:System.Data.DataTable" />, i <see cref="T:System.Data.IDataReader" /> nazwy.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżane w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy dotyczy instrukcji, które nie zwrócą wierszy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable[] dataTables, int startRecord, int maxRecords, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable[] dataTables, int32 startRecord, int32 maxRecords, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Fill (dataTables As DataTable(), startRecord As Integer, maxRecords As Integer, command As IDbCommand, behavior As CommandBehavior) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables, int startRecord, int maxRecords, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable[] * int * int * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; int" Usage="dbDataAdapter.Fill (dataTables, startRecord, maxRecords, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startRecord" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maxRecords" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="command" Type="System.Data.IDbCommand" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dataTables"><see cref="T:System.Data.DataTable" /> Obiektów, aby wypełnić ze źródła danych.</param>
        <param name="startRecord">Liczony od zera numer rekordu powinny zaczynać się.</param>
        <param name="maxRecords">Maksymalna liczba rekordów do pobrania.</param>
        <param name="command"><see cref="T:System.Data.IDbCommand" /> Wykonywane w celu wypełnienia <see cref="T:System.Data.DataTable" /> obiektów.</param>
        <param name="behavior">Jedną z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> zgadzać się przy użyciu źródła danych <see cref="T:System.Data.DataSet" /> i <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba wierszy dodane do lub odświeżane w tabelach danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `maxRecords` wartość 0 pobiera wszystkie rekordy po rekordu rozpoczęcia. Jeśli `maxRecords` jest większa niż liczba pozostałych wierszy, tylko pozostałe wiersze są zwracane, a błąd nie jest zgłaszany.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection> Obiekt skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jego jest otwarta do pobierania danych, a następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 Jeśli polecenie nie zwraca wszystkie wiersze, tabele nie są dodawane do <xref:System.Data.DataSet>, ale nie jest wyjątek.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu napotka kolumn podczas wypełniania <xref:System.Data.DataTable>, zostanie wygenerowany nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2 ","*columnname*3 ", i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Gdy zapytanie określone zwraca wiele wyników, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" i tak dalej). Ponieważ tabela nie jest tworzony dla zapytania, która nie zwraca wiersze, gdyby przetwarzania zapytanie wstawiające, a następnie wybierz zapytanie, tabelę utworzoną dla zapytania select będą miały postać "Table", ponieważ jest to pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> wykonuje porównania uwzględniającego wielkość liter można znaleźć odpowiedniej tabeli i tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowana. W tym scenariuszu porównania jest uwzględniana wielkość liter. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Jeśli błąd lub wyjątek podczas wypełniania danych w tabelach, wiersze dodawanych przed wystąpieniem błędu pozostają w tabelach danych. W pozostałej części operacja została przerwana.  
  
 Gdy instrukcja SELECT używany do wypełniania <xref:System.Data.DataTable> obiektów zwraca wiele wyników, takich jak batch instrukcji SQL, należy pamiętać o następujących:  
  
-   Podczas przetwarzania wiele wyników z partii instrukcji SQL `maxRecords` ma zastosowanie tylko do pierwszego wyniku. Dotyczy to także wiersze zawierające wyniki podzielony na rozdziały (.NET Framework Data Provider for OLE DB tylko). Wynik najwyższego poziomu jest ograniczona przez `maxRecords`, ale wszystkie wiersze podrzędne są dodawane.  
  
-   Jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pomijane.  
  
> [!NOTE]
>  `DataSet` Nie będzie zawierać więcej niż liczba rekordów wskazywanym przez `maxRecords`. Jednakże cały zestaw wyników, generowane przez zapytanie jest nadal zwrócona z serwera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowy.  
  
—lub— 
Połączenie jest nieprawidłowe.</exception>
        <exception cref="T:System.InvalidCastException">Nie można odnaleźć połączenia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="startRecord" /> Parametru jest mniejszy niż 0.  
  
—lub— 
<paramref name="maxRecords" /> Parametru jest mniejszy niż 0.</exception>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> metody.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * int * int * string * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; int" Usage="dbDataAdapter.Fill (dataSet, startRecord, maxRecords, srcTable, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="startRecord">Liczony od zera numer rekordu powinny zaczynać się.</param>
        <param name="maxRecords">Maksymalna liczba rekordów do pobrania.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <param name="command">Instrukcja SQL ZAZNACZYĆ służy do pobierania wierszy ze źródła danych.</param>
        <param name="behavior">Jedną z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> zgadzać się przy użyciu źródła danych <see cref="T:System.Data.DataSet" /> i źródłowych nazw tabel, ciąg polecenia i zachowanie polecenia.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżane w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy dotyczy instrukcji, które nie zwrócą wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT, określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jego jest otwarta do pobierania danych, a następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Następnie operacja doda wiersze do miejsca docelowego <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiekty, jeśli ich jeszcze nie istnieją. Podczas tworzenia <xref:System.Data.DataTable> obiektów <xref:System.Data.Common.DbDataAdapter.Fill%2A> operacja zazwyczaj tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje on nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Kiedy wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" i tak dalej). Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> wykonuje porównania uwzględniającego wielkość liter można znaleźć odpowiedniej tabeli i tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowana. W tym scenariuszu porównania jest uwzględniana wielkość liter. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Możesz użyć <xref:System.Data.Common.DbDataAdapter.Fill%2A> metoda wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli istnieje klucz podstawowy, wiersze przychodzące są scalane z pasujących wierszy, które już istnieją. Jeśli istnieje nie klucza podstawowego, wiersze przychodzące są dołączane do <xref:System.Data.DataTable>.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartości wynikowe <xref:System.Data.DataTable>. Musisz jawnie zdefiniować klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane prawidłowo. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.Fill%2A> i <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dostawcy danych .NET Framework pobiera informacje o schemacie dla pierwszego wyniku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="startRecord" /> Parametru jest mniejszy niż 0.  
  
—lub— 
<paramref name="maxRecords" /> Parametru jest mniejszy niż 0.</exception>
        <block subset="none" type="overrides"><para>To przeciążenie <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="FillCommandBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Data.CommandBehavior FillCommandBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.CommandBehavior FillCommandBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.FillCommandBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property FillCommandBehavior As CommandBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Data::CommandBehavior FillCommandBehavior { System::Data::CommandBehavior get(); void set(System::Data::CommandBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.FillCommandBehavior : System.Data.CommandBehavior with get, set" Usage="System.Data.Common.DbDataAdapter.FillCommandBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.CommandBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zachowanie polecenia używany do wypełniania adaptera danych.</summary>
        <value><see cref="T:System.Data.CommandBehavior" /> Polecenia używany do wypełniania adaptera danych.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="FillError">
      <MemberSignature Language="C#" Value="public event System.Data.FillErrorEventHandler FillError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.FillErrorEventHandler FillError" />
      <MemberSignature Language="DocId" Value="E:System.Data.Common.DbDataAdapter.FillError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FillError As FillErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::FillErrorEventHandler ^ FillError;" />
      <MemberSignature Language="F#" Value="member this.FillError : System.Data.FillErrorEventHandler " Usage="member this.FillError : System.Data.FillErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DbDataAdapter_FillError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.FillErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwracany, jeśli wystąpi błąd podczas operacji wypełnienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> do <see cref="T:System.Data.DataSet" /> i konfiguruje schemat pasuje do źródła danych.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataSet * System.Data.SchemaType -&gt; System.Data.DataTable[]" Usage="dbDataAdapter.FillSchema (dataSet, schemaType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> do wstawienia schemat w.</param>
        <param name="schemaType">Jedną z <see cref="T:System.Data.SchemaType" /> wartości, które określają sposób wstawiania schematu.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> o nazwie "Table" do określonego <see cref="T:System.Data.DataSet" /> i konfiguruje schemat do dopasowania w źródle danych na podstawie <see cref="T:System.Data.SchemaType" />.</summary>
        <returns>Odwołanie do kolekcji <see cref="T:System.Data.DataTable" /> obiekty, które zostały dodane do <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia pobranie informacji o schemacie ze źródłem danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operacja spowoduje dodanie <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli nie istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> oddzielnie.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości, zgodnie z następującymi zasadami:  
  
-   Jeśli co najmniej jedną kolumnę klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli są zwracane nie kolumny klucza podstawowego, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy, jeśli i tylko wtedy, gdy wszystkie unikatowe kolumny jest kolumną. W przypadku dowolnej kolumny dopuszczające wartość null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zwracane są unikatowe kolumny i kolumny klucza podstawowego, klucz podstawowy są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że klucze podstawowe i unikatowych ograniczeń są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych zasad, ale także inne ograniczenia typów nie są dodawane.  
  
 Jeśli klastrowane unikatowy indeks jest zdefiniowany w kolumnie lub kolumn w tabeli programu SQL Server i ograniczenia klucza podstawowego jest zdefiniowany w osobnym zestawie kolumn, a następnie nazwy kolumn w klastrowanym indeksie zostaną zwrócone. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania przy użyciu instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).  
  
 Informacje o kluczu podstawowym jest używana podczas <xref:System.Data.Common.DbDataAdapter.Fill%2A> Aby znaleźć i zamienić wszystkie wiersze, w których kluczowe kolumny pasują do siebie. Jeśli nie jest to zachowanie, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> bez żąda informacji o schemacie.  
  
 Jeśli <xref:System.Data.IDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje on nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Kiedy wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Tabeli", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 <xref:System.Data.IDbConnection> Obiekt skojarzony z polecenia select musi być prawidłowy, ale nie trzeba otwierać. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jego jest otwarta do pobierania danych, a następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, są pozostawione otwarte.  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE wykonywana instrukcja. Użytkownik powinien należy pamiętać o potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji ON FMTONLY zestawu. Aby uzyskać więcej informacji, zobacz [Ustaw FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.SqlClient.SqlDataAdapter>, aby wypełnić <xref:System.Data.DataSet> schematu i zwraca <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataTable * System.Data.SchemaType -&gt; System.Data.DataTable" Usage="dbDataAdapter.FillSchema (dataTable, schemaType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataTable"><see cref="T:System.Data.DataTable" /> Trzeba napełniać schematu ze źródła danych.</param>
        <param name="schemaType">Jedną z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <summary>Konfiguruje schemat określony <see cref="T:System.Data.DataTable" /> na podstawie <see cref="T:System.Data.SchemaType" />.</summary>
        <returns>Element <see cref="T:System.Data.DataTable" /> zawierający informacje o schemacie zwrócone ze źródła danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda pobiera schematu ze źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A> musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jego jest otwarta do pobierania danych, a następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, pozostaje otwarty.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operacji zwraca <xref:System.Data.DataTable>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli nie istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> oddzielnie.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości, zgodnie z następującymi zasadami:  
  
-   Jeśli <xref:System.Data.DataTable.PrimaryKey%2A> została już zdefiniowana dla `DataTable`, lub `DataTable` zawiera dane, `PrimaryKey` nie można ustawić właściwości.  
  
-   Jeśli co najmniej jedną kolumnę klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla `DataTable`.  
  
-   Jeśli są zwracane nie kolumny klucza podstawowego, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy, jeśli i tylko wtedy, gdy wszystkie unikatowe kolumny jest kolumną. W przypadku dowolnej kolumny dopuszczające wartość null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale `PrimaryKey` nie ustawiono właściwości.  
  
-   Jeśli zwracane są unikatowe kolumny i kolumny klucza podstawowego, klucz podstawowy są używane jako kolumny klucza podstawowego dla `DataTable`.  
  
 Należy pamiętać, że klucze podstawowe i unikatowych ograniczeń są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych zasad, ale także inne ograniczenia typów nie są dodawane. Ten proces może wymagać wielu rund do serwera.  
  
 Jeśli klastrowane unikatowy indeks jest zdefiniowany w kolumnie lub kolumn w tabeli programu SQL Server i ograniczenia klucza podstawowego jest zdefiniowany w osobnym zestawie kolumn, a następnie nazwy kolumn w klastrowanym indeksie zostaną zwrócone. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania przy użyciu instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje on nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Kiedy wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Tabeli", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> nie zwraca żadnych wierszy. Użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> metodę, aby dodać wiersze do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE wykonywana instrukcja. Użytkownik powinien należy pamiętać o potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji ON FMTONLY zestawu. Aby uzyskać więcej informacji, zobacz [Ustaw FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.SqlClient.SqlDataAdapter>, aby wypełnić <xref:System.Data.DataSet> schematu i zwraca <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataSet * System.Data.SchemaType * string -&gt; System.Data.DataTable[]" Usage="dbDataAdapter.FillSchema (dataSet, schemaType, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> do wstawienia schemat w.</param>
        <param name="schemaType">Jedną z <see cref="T:System.Data.SchemaType" /> wartości, które określają sposób wstawiania schematu.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> określonej <see cref="T:System.Data.DataSet" /> i konfiguruje schemat do dopasowania w źródle danych na podstawie określonego <see cref="T:System.Data.SchemaType" /> i <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Odwołanie do kolekcji <see cref="T:System.Data.DataTable" /> obiekty, które zostały dodane do <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia pobranie informacji o schemacie ze źródłem danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operacja spowoduje dodanie <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli nie istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> oddzielnie.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości, zgodnie z następującymi zasadami:  
  
-   Jeśli co najmniej jedną kolumnę klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli są zwracane nie kolumny klucza podstawowego, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy, jeśli i tylko wtedy, gdy wszystkie unikatowe kolumny jest kolumną. W przypadku dowolnej kolumny dopuszczające wartość null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zwracane są unikatowe kolumny i kolumny klucza podstawowego, klucz podstawowy są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że klucze podstawowe i unikatowych ograniczeń są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych zasad, ale także inne ograniczenia typów nie są dodawane.  
  
 Jeśli klastrowane unikatowy indeks jest zdefiniowany w kolumnie lub kolumn w tabeli programu SQL Server i ograniczenia klucza podstawowego jest zdefiniowany w osobnym zestawie kolumn, a następnie nazwy kolumn w klastrowanym indeksie zostaną zwrócone. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania przy użyciu instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).  
  
 Informacje o kluczu podstawowym jest używana podczas <xref:System.Data.Common.DbDataAdapter.Fill%2A> Aby znaleźć i zamienić wszystkie wiersze, w których kluczowe kolumny pasują do siebie. Jeśli nie jest to zachowanie, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> bez żąda informacji o schemacie.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje on nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Kiedy wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Tabeli", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> wykonuje porównania uwzględniającego wielkość liter można znaleźć odpowiedniej tabeli i tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowana. W tym scenariuszu porównania jest uwzględniana wielkość liter. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.IDbConnection> Obiekt skojarzony z polecenia select musi być prawidłowy, ale nie trzeba otwierać. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jego jest otwarta do pobierania danych, a następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, są pozostawione otwarte.  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE wykonywana instrukcja. Użytkownik powinien należy pamiętać o potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji ON FMTONLY zestawu. Aby uzyskać więcej informacji, zobacz [Ustaw FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.SqlClient.SqlDataAdapter>, aby wypełnić <xref:System.Data.DataSet> schematu i zwraca <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można odnaleźć tabeli źródłowej, z którego można pobrać schematu.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataTable * System.Data.SchemaType * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; System.Data.DataTable" Usage="dbDataAdapter.FillSchema (dataTable, schemaType, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable"><see cref="T:System.Data.DataTable" /> Trzeba napełniać schematu ze źródła danych.</param>
        <param name="schemaType">Jedną z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <param name="command">Instrukcja SQL ZAZNACZYĆ służy do pobierania wierszy ze źródła danych.</param>
        <param name="behavior">Jedną z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Konfiguruje schemat określony <see cref="T:System.Data.DataTable" /> na podstawie <see cref="T:System.Data.SchemaType" />, ciąg, polecenia i <see cref="T:System.Data.CommandBehavior" /> wartości.</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> obiekt, który zawiera informacje o schemacie zwrócone ze źródła danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda pobiera schematu ze źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A> musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jego jest otwarta do pobierania danych, a następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, pozostaje otwarty.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operacja spowoduje dodanie <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli nie istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> oddzielnie.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości, zgodnie z następującymi zasadami:  
  
-   Jeśli co najmniej jedną kolumnę klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli są zwracane nie kolumny klucza podstawowego, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy, jeśli i tylko wtedy, gdy wszystkie unikatowe kolumny jest kolumną. W przypadku dowolnej kolumny dopuszczające wartość null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zwracane są unikatowe kolumny i kolumny klucza podstawowego, klucz podstawowy są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że klucze podstawowe i unikatowych ograniczeń są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych zasad, ale także inne ograniczenia typów nie są dodawane.  
  
 Jeśli klastrowane unikatowy indeks jest zdefiniowany w kolumnie lub kolumn w tabeli programu SQL Server i ograniczenia klucza podstawowego jest zdefiniowany w osobnym zestawie kolumn, a następnie nazwy kolumn w klastrowanym indeksie zostaną zwrócone. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania przy użyciu instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).  
  
 Jeśli <xref:System.Data.IDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje on nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Kiedy wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Tabeli", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> nie zwraca żadnych wierszy. Użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> metodę, aby dodać wiersze do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE wykonywana instrukcja. Użytkownik powinien należy pamiętać o potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji ON FMTONLY zestawu. Aby uzyskać więcej informacji, zobacz [Ustaw FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta implementacja <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, System.Data.IDbCommand command, string srcTable, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, string srcTable, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::String ^ srcTable, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataSet * System.Data.SchemaType * System.Data.IDbCommand * string * System.Data.CommandBehavior -&gt; System.Data.DataTable[]" Usage="dbDataAdapter.FillSchema (dataSet, schemaType, command, srcTable, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet"><see cref="T:System.Data.DataSet" /> Trzeba napełniać schematu ze źródła danych.</param>
        <param name="schemaType">Jedną z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <param name="command">Instrukcja SQL ZAZNACZYĆ służy do pobierania wierszy ze źródła danych.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <param name="behavior">Jedną z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> określonej <see cref="T:System.Data.DataSet" /> i konfiguruje schemat do dopasowania w źródle danych na podstawie <see cref="T:System.Data.SchemaType" />.</summary>
        <returns>Tablica <see cref="T:System.Data.DataTable" /> zwróconych obiektów, które zawierają informacje o schemacie ze źródła danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda pobiera schematu ze źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A> musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jego jest otwarta do pobierania danych, a następnie zamknięty. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, pozostaje otwarty.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operacja spowoduje dodanie <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli nie istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> oddzielnie.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości, zgodnie z następującymi zasadami:  
  
-   Jeśli co najmniej jedną kolumnę klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli są zwracane nie kolumny klucza podstawowego, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy, jeśli i tylko wtedy, gdy wszystkie unikatowe kolumny jest kolumną. W przypadku dowolnej kolumny dopuszczające wartość null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zwracane są unikatowe kolumny i kolumny klucza podstawowego, klucz podstawowy są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że klucze podstawowe i unikatowych ograniczeń są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych zasad, ale także inne ograniczenia typów nie są dodawane.  
  
 Jeśli klastrowane unikatowy indeks jest zdefiniowany w kolumnie lub kolumn w tabeli programu SQL Server i ograniczenia klucza podstawowego jest zdefiniowany w osobnym zestawie kolumn, a następnie nazwy kolumn w klastrowanym indeksie zostaną zwrócone. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania przy użyciu instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).  
  
 Jeśli <xref:System.Data.IDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje on nazwy dla kolejnych kolumn, korzystając z wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera nazwy kolumn, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Kiedy wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych, do nazwy określonej tabeli (na przykład "Tabeli", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel należy upewnić się, że powoduje konflikt z tych wzorców nazewnictwa nie występuje.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> wykonuje porównania uwzględniającego wielkość liter można znaleźć odpowiedniej tabeli i tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowana. W tym scenariuszu porównania jest uwzględniana wielkość liter. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> nie zwraca żadnych wierszy. Użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> metodę, aby dodać wiersze do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania instrukcji SQL usługi batch, które zwracają wiele wyników, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB umożliwia pobranie informacji o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> równa `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE wykonywana instrukcja. Użytkownik powinien należy pamiętać o potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji ON FMTONLY zestawu. Aby uzyskać więcej informacji, zobacz [Ustaw FMTONLY (Transact-SQL)](/sql/t-sql/statements/set-fmtonly-transact-sql).
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ta implementacja <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedParameter">
      <MemberSignature Language="C#" Value="protected virtual System.Data.IDataParameter GetBatchedParameter (int commandIdentifier, int parameterIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.IDataParameter GetBatchedParameter(int32 commandIdentifier, int32 parameterIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedParameter (commandIdentifier As Integer, parameterIndex As Integer) As IDataParameter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::IDataParameter ^ GetBatchedParameter(int commandIdentifier, int parameterIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBatchedParameter : int * int -&gt; System.Data.IDataParameter&#xA;override this.GetBatchedParameter : int * int -&gt; System.Data.IDataParameter" Usage="dbDataAdapter.GetBatchedParameter (commandIdentifier, parameterIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier">Indeks polecenie, aby pobrać parametr z.</param>
        <param name="parameterIndex">Indeks parametrów w poleceniu.</param>
        <summary>Zwraca <see cref="T:System.Data.IDataParameter" /> z jednego z poleceń w bieżącej partii.</summary>
        <returns><see cref="T:System.Data.IDataParameter" /> Określony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda wyrzuca <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę w celu zapewnienia obsługi partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides"><para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  
  
Jeśli klasa, która dziedziczy po elemencie <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę, aby zezwolić użytkownikom na wykonywanie partii. Implementacja używa <paramref name="commandIdentifier" /> podane można zlokalizować żądanego polecenia, a następnie używa <paramref name="parameterIndex" /> podane można zlokalizować żądanego parametru. Na przykład <paramref name="commandIdentifier" /> 0 i <paramref name="parameterIndex" /> 0 z pierwszego polecenia w pliku wsadowym zwraca pierwszy parametr.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedRecordsAffected">
      <MemberSignature Language="C#" Value="protected virtual bool GetBatchedRecordsAffected (int commandIdentifier, out int recordsAffected, out Exception error);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GetBatchedRecordsAffected(int32 commandIdentifier, [out] int32&amp; recordsAffected, [out] class System.Exception&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedRecordsAffected (commandIdentifier As Integer, ByRef recordsAffected As Integer, ByRef error As Exception) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GetBatchedRecordsAffected(int commandIdentifier, [Runtime::InteropServices::Out] int % recordsAffected, [Runtime::InteropServices::Out] Exception ^ % error);" />
      <MemberSignature Language="F#" Value="abstract member GetBatchedRecordsAffected : int *  *  -&gt; bool&#xA;override this.GetBatchedRecordsAffected : int *  *  -&gt; bool" Usage="dbDataAdapter.GetBatchedRecordsAffected (commandIdentifier, recordsAffected, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="recordsAffected" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="error" Type="System.Exception" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier">Numer kolumny od zera określonego polecenia w ramach usługi batch.</param>
        <param name="recordsAffected">Liczba wierszy dotyczy określonego polecenia w ramach usługi batch w magazynie danych.</param>
        <param name="error"><see cref="T:System.Exception" /> Zgłoszony podczas wykonywania tego polecenia. Zwraca <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic), jeśli jest zgłaszany żaden wyjątek.</param>
        <summary>Zwraca informacje o próbie indywidualnej aktualizacji w większych aktualizacji wsadowej.</summary>
        <returns>Informacje na temat próba indywidualnej aktualizacji w większych aktualizacji wsadowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dostawcy danych, obsługujące wsadowej logika aktualizacji musisz przesłonić szereg metod wirtualnych na <xref:System.Data.Common.DbDataAdapter> klasy. `GetBatchedRecordsAffected` reprezentuje jedną z tych metod wirtualnych. `DbDataAdapter` Zależy od klasy `GetBatchedRecordsAffected` Aby określić powodzenie lub Niepowodzenie próby indywidualnej aktualizacji w ramach usługi batch, dzięki czemu można oznaczyć, poszczególnych <xref:System.Data.DataRow> odpowiednio.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public override System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberSignature Language="F#" Value="override this.GetFillParameters : unit -&gt; System.Data.IDataParameter[]" Usage="dbDataAdapter.GetFillParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.GetFillParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera parametry ustawiony przez użytkownika podczas wykonywania instrukcji SQL SELECT.</summary>
        <returns>Tablica <see cref="T:System.Data.IDataParameter" /> obiektów, które zawiera parametry ustawiony przez użytkownika.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InitializeBatching">
      <MemberSignature Language="C#" Value="protected virtual void InitializeBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.InitializeBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeBatching();" />
      <MemberSignature Language="F#" Value="abstract member InitializeBatching : unit -&gt; unit&#xA;override this.InitializeBatching : unit -&gt; unit" Usage="dbDataAdapter.InitializeBatching " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje dzielenia na partie dla <see cref="T:System.Data.Common.DbDataAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda wyrzuca <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę w celu zapewnienia obsługi partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides"><para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  
  
Jeśli klasa, która dziedziczy po elemencie <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę. Ta metoda zapewnia klasy możliwość zainicjowania wszystkie zasoby, które są niezbędne do obsługi przetwarzania wsadowego. Na przykład klasa może przydzielić to struktura danych, aby pomieścić zestaw poleceń w partii.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.InsertCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property InsertCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ InsertCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InsertCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.InsertCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia polecenie umożliwia wstawianie nowych rekordów do źródła danych.</summary>
        <value>A <see cref="T:System.Data.IDbCommand" /> używane podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> do wstawiania rekordów do źródła danych dla nowych wierszy w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.Data.Common.DbDataAdapter.Update%2A>, jeśli ta właściwość nie jest ustawiona i informacje o kluczu podstawowym znajduje się w <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.InsertCommand%2A> zostanie automatycznie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnFillError">
      <MemberSignature Language="C#" Value="protected virtual void OnFillError (System.Data.FillErrorEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFillError(class System.Data.FillErrorEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnFillError(System.Data.FillErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFillError (value As FillErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFillError(System::Data::FillErrorEventArgs ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnFillError : System.Data.FillErrorEventArgs -&gt; unit&#xA;override this.OnFillError : System.Data.FillErrorEventArgs -&gt; unit" Usage="dbDataAdapter.OnFillError value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.FillErrorEventArgs" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="value">Dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.Common.DataAdapter.FillError" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdated">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdated (System.Data.Common.RowUpdatedEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdated(class System.Data.Common.RowUpdatedEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdated (value As RowUpdatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdated(System::Data::Common::RowUpdatedEventArgs ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRowUpdated : System.Data.Common.RowUpdatedEventArgs -&gt; unit&#xA;override this.OnRowUpdated : System.Data.Common.RowUpdatedEventArgs -&gt; unit" Usage="dbDataAdapter.OnRowUpdated value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="value">Element <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see langword="RowUpdated" /> zdarzenia dostawcy danych .NET Framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> metody.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdating">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdating (System.Data.Common.RowUpdatingEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdating(class System.Data.Common.RowUpdatingEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdating (value As RowUpdatingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdating(System::Data::Common::RowUpdatingEventArgs ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRowUpdating : System.Data.Common.RowUpdatingEventArgs -&gt; unit&#xA;override this.OnRowUpdating : System.Data.Common.RowUpdatingEventArgs -&gt; unit" Usage="dbDataAdapter.OnRowUpdating value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatingEventArgs" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Data.Common.RowUpdatingEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see langword="RowUpdating" /> zdarzenia dostawcy danych .NET Framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy podstaw <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> metody.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SelectCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.SelectCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ SelectCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.SelectCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia polecenie używane do wybierania rekordów w źródle danych.</summary>
        <value>A <see cref="T:System.Data.IDbCommand" /> używany podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> do wybierania rekordów ze źródła danych do umieszczenia w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.DeleteCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand" />
      <MemberSignature Language="VB.NET" Value=" Property DeleteCommand As IDbCommand Implements IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System::Data::IDbDataAdapter::DeleteCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.IDbDataAdapter.DeleteCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.DeleteCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia instrukcję SQL do usuwania rekordów z zestawu danych.</summary>
        <value><see cref="T:System.Data.IDbCommand" /> Używane podczas <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> do usuwania rekordów w źródle danych, która ma być usunięte wiersze w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowany na <xref:System.Data.IDbDataAdapter> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.InsertCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand" />
      <MemberSignature Language="VB.NET" Value=" Property InsertCommand As IDbCommand Implements IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System::Data::IDbDataAdapter::InsertCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.IDbDataAdapter.InsertCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.InsertCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia instrukcji SQL umożliwia wstawianie nowych rekordów do źródła danych.</summary>
        <value><see cref="T:System.Data.IDbCommand" /> Używane podczas <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> do wstawiania rekordów do źródła danych dla nowych wierszy w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowany na <xref:System.Data.IDbDataAdapter> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDbDataAdapter.InsertCommand%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.SelectCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand" />
      <MemberSignature Language="VB.NET" Value=" Property SelectCommand As IDbCommand Implements IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System::Data::IDbDataAdapter::SelectCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.IDbDataAdapter.SelectCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.SelectCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia instrukcji SQL używany do wybierania rekordów w źródle danych.</summary>
        <value><see cref="T:System.Data.IDbCommand" /> Używany podczas <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> do wybierania rekordów ze źródła danych do umieszczenia w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowany na <xref:System.Data.IDbDataAdapter> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.UpdateCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand" />
      <MemberSignature Language="VB.NET" Value=" Property UpdateCommand As IDbCommand Implements IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System::Data::IDbDataAdapter::UpdateCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.IDbDataAdapter.UpdateCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.UpdateCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia instrukcji SQL używane do aktualizowania rekordów w źródle danych.</summary>
        <value><see cref="T:System.Data.IDbCommand" /> Używane podczas <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> do aktualizowania rekordów w źródle danych, która ma być zmodyfikowane wiersze w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowany na <xref:System.Data.IDbDataAdapter> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("use 'protected DbDataAdapter(DbDataAdapter)' ctor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy obiekt, który jest kopią bieżącego wystąpienia.</summary>
        <returns>Nowy obiekt będący kopią tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowany na <xref:System.ICloneable> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.ICloneable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="TerminateBatching">
      <MemberSignature Language="C#" Value="protected virtual void TerminateBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TerminateBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.TerminateBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TerminateBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TerminateBatching();" />
      <MemberSignature Language="F#" Value="abstract member TerminateBatching : unit -&gt; unit&#xA;override this.TerminateBatching : unit -&gt; unit" Usage="dbDataAdapter.TerminateBatching " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy przetwarzania wsadowego dla <see cref="T:System.Data.Common.DbDataAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda wyrzuca <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę w celu zapewnienia obsługi partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides"><para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  
  
Jeśli klasa, która dziedziczy po elemencie <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę. Ta metoda zapewnia klasy możliwość Zlikwiduj wszelkie zasoby przydzielone do obsługi przetwarzania wsadowego. Na przykład klasa może deallocate struktura danych, która przechowuje poleceń w partii.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Update">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawione, zaktualizowane lub usunąć wiersz w <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataRow[] dataRows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataRow[] dataRows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (dataRows As DataRow()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataRow[] -&gt; int" Usage="dbDataAdapter.Update dataRows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="dataRows">Tablica <see cref="T:System.Data.DataRow" /> obiekty używane do aktualizowania źródła danych.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawione, zaktualizowane lub usunąć wiersza w określonej tablicy w <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymagane instrukcje INSERT, UPDATE lub DELETE iteracyjne dla każdego wiersza, na podstawie kolejności indeksy skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonać instrukcję DELETE, następuje instrukcji INSERT, a następnie inny instrukcji DELETE, właściwym do kolejności wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że te instrukcje nie są wykonywane jako proces wsadowy; Każdy wiersz jest aktualizowane pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym możesz kontrolować sekwencja instrukcji typów (na przykład wstawia przed aktualizacji). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródeł danych za pomocą elementów DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcje INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Jednakże, możesz utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL dla aktualizacji pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, których nie należy ustawiać są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [Generowanie poleceń za pomocą CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli pierwsze mapowania przed przystąpieniem do wykonywania aktualizacji na liście. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Wszystkie dodatkowe wiersze, zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenie jest zgłaszane, co pozwala na sprawdzanie uzgodnić <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe parametry zwróconemu przez polecenie. Po pomyślnym zaktualizowaniu wiersza zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następująca:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenie jest wywoływane.  
  
3.  Polecenie zostanie wykonane.  
  
4.  Jeśli polecenie jest równa `FirstReturnedRecord`, pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenie jest wywoływane.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zazwyczaj ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny, <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odnosi się do nazwy niezamapowaną kolumnę, zanim wszystkie mapowania tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję podejmowaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działania podjęte|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródłowych i nazw tabel w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|Element <xref:System.SystemException> jest generowany. Jeśli jawnie ustawiono mapowania, brakuje mapowania dla parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|Element <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Jest również używana do mapowania wartości dla danych wyjściowych lub parametrów wejściowych/wyjściowych z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasa określa, czy użyć wersji oryginalnego, bieżące lub proponowane wartości kolumny. Ta funkcja jest często używane w oryginalnej wartości mają zostać uwzględnione w klauzuli WHERE w instrukcji UPDATE pod kątem naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersz, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, należy ustawić <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie poszczególnych wierszy w obrębie `RowUpdated` zdarzeń elementu DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzenie, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby zaktualizować źródła danych.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowy.</exception>
        <exception cref="T:System.SystemException">Nie <see cref="T:System.Data.DataRow" /> istnieje w celu aktualizacji.  
  
—lub— 
Nie <see cref="T:System.Data.DataTable" /> istnieje w celu aktualizacji.  
  
—lub— 
Nie <see cref="T:System.Data.DataSet" /> istnieje, aby użyć jako źródła.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Podjęto próbę wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public override int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Update(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataSet -&gt; int" Usage="dbDataAdapter.Update dataSet" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Update(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet"><see cref="T:System.Data.DataSet" /> Używane do aktualizowania źródła danych.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawione, zaktualizowane lub usunąć wiersz w określonym <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymagane instrukcje INSERT, UPDATE lub DELETE iteracyjne dla każdego wiersza, na podstawie kolejności indeksy skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonać instrukcję DELETE, następuje instrukcji INSERT, a następnie inny instrukcji DELETE, właściwym do kolejności wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że te instrukcje nie są wykonywane jako proces wsadowy; Każdy wiersz jest aktualizowane pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym możesz kontrolować sekwencja instrukcji typów (na przykład wstawia przed aktualizacji). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródeł danych za pomocą elementów DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcje INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Jednakże, możesz utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL dla aktualizacji pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, których nie należy ustawiać są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [Generowanie poleceń za pomocą CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli pierwsze mapowania przed przystąpieniem do wykonywania aktualizacji na liście. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Wszystkie dodatkowe wiersze, zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenie jest zgłaszane, co pozwala na sprawdzanie uzgodnić <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe parametry zwróconemu przez polecenie. Po pomyślnym zaktualizowaniu wiersza zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następująca:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenie jest wywoływane.  
  
3.  Polecenie zostanie wykonane.  
  
4.  Jeśli polecenie jest równa `FirstReturnedRecord`, wówczas pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenie jest wywoływane.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zazwyczaj ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny, <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odnosi się do nazwy niezamapowaną kolumnę, zanim wszystkie mapowania tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję podejmowaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działania podjęte|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródłowych i nazw tabel w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|Element <xref:System.SystemException> jest generowany. Jeśli jawnie ustawiono mapowania, brakuje mapowania dla parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|Element <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Jest również używana do mapowania wartości dla danych wyjściowych lub parametrów wejściowych/wyjściowych z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasa określa, czy użyć wersji oryginalnego, bieżące lub proponowane wartości kolumny. Ta funkcja jest często używane w oryginalnej wartości mają zostać uwzględnione w klauzuli WHERE w instrukcji UPDATE pod kątem naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersz, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, należy ustawić <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie poszczególnych wierszy w obrębie `RowUpdated` zdarzeń elementu DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzenie, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby zaktualizować źródła danych.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowy.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Podjęto próbę wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataTable -&gt; int" Usage="dbDataAdapter.Update dataTable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable"><see cref="T:System.Data.DataTable" /> Używane do aktualizowania źródła danych.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawione, zaktualizowane lub usunąć wiersz w określonym <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymagane instrukcje INSERT, UPDATE lub DELETE iteracyjne dla każdego wiersza, na podstawie kolejności indeksy skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonać instrukcję DELETE, następuje instrukcji INSERT, a następnie inny instrukcji DELETE, właściwym do kolejności wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że te instrukcje nie są wykonywane jako proces wsadowy; Każdy wiersz jest aktualizowane pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym możesz kontrolować sekwencja instrukcji typów (na przykład wstawia przed aktualizacji). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródeł danych za pomocą elementów DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcje INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Jednakże, możesz utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL dla aktualizacji pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, których nie należy ustawiać są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [Generowanie poleceń za pomocą CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli pierwsze mapowania przed przystąpieniem do wykonywania aktualizacji na liście. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Wszystkie dodatkowe wiersze, zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenie jest zgłaszane, co pozwala na sprawdzanie uzgodnić <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe parametry zwróconemu przez polecenie. Po pomyślnym zaktualizowaniu wiersza zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następująca:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenie jest wywoływane.  
  
3.  Polecenie zostanie wykonane.  
  
4.  Jeśli polecenie jest równa `FirstReturnedRecord`, wówczas pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenie jest wywoływane.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zazwyczaj ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny, <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odnosi się do nazwy niezamapowaną kolumnę, zanim wszystkie mapowania tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję podejmowaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działania podjęte|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródłowych i nazw tabel w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|Element <xref:System.SystemException> jest generowany. Jeśli jawnie ustawiono mapowania, brakuje mapowania dla parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|Element <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Jest również używana do mapowania wartości dla danych wyjściowych lub parametrów wejściowych/wyjściowych z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasa określa, czy użyć wersji oryginalnego, bieżące lub proponowane wartości kolumny. Ta funkcja jest często używane w oryginalnej wartości mają zostać uwzględnione w klauzuli WHERE w instrukcji UPDATE pod kątem naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersz, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, należy ustawić <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie poszczególnych wierszy w obrębie `RowUpdated` zdarzeń elementu DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzenie, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby zaktualizować źródła danych.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowy.</exception>
        <exception cref="T:System.SystemException">Nie <see cref="T:System.Data.DataRow" /> istnieje w celu aktualizacji.  
  
—lub— 
Nie <see cref="T:System.Data.DataTable" /> istnieje w celu aktualizacji.  
  
—lub— 
Nie <see cref="T:System.Data.DataSet" /> istnieje, aby użyć jako źródła.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Podjęto próbę wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="protected virtual int Update (System.Data.DataRow[] dataRows, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Update(class System.Data.DataRow[] dataRows, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Update (dataRows As DataRow(), tableMapping As DataTableMapping) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataRow[] * System.Data.Common.DataTableMapping -&gt; int" Usage="dbDataAdapter.Update (dataRows, tableMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRows">Tablica <see cref="T:System.Data.DataRow" /> obiekty używane do aktualizowania źródła danych.</param>
        <param name="tableMapping"><see cref="P:System.Data.IDataAdapter.TableMappings" /> Kolekcję ma być używana.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawione, zaktualizowane lub usunąć wiersza w określonej tablicy <see cref="T:System.Data.DataSet" /> obiektów.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymagane instrukcje INSERT, UPDATE lub DELETE iteracyjne dla każdego wiersza, na podstawie kolejności indeksy skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonać instrukcję DELETE, następuje instrukcji INSERT, a następnie inny instrukcji DELETE, właściwym do kolejności wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że te instrukcje nie są wykonywane jako proces wsadowy; Każdy wiersz jest aktualizowane pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym możesz kontrolować sekwencja instrukcji typów (na przykład wstawia przed aktualizacji). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródeł danych za pomocą elementów DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcje INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Jednakże, możesz utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL dla aktualizacji pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, których nie należy ustawiać są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [Generowanie poleceń za pomocą CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli pierwsze mapowania przed przystąpieniem do wykonywania aktualizacji na liście. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Wszystkie dodatkowe wiersze, zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenie jest zgłaszane, co pozwala na sprawdzanie uzgodnić <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe parametry zwróconemu przez polecenie. Po pomyślnym zaktualizowaniu wiersza zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następująca:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenie jest wywoływane.  
  
3.  Polecenie zostanie wykonane.  
  
4.  Jeśli polecenie jest równa `FirstReturnedRecord`, wówczas pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenie jest wywoływane.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zazwyczaj ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny, <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odnosi się do nazwy niezamapowaną kolumnę, zanim wszystkie mapowania tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję podejmowaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działania podjęte|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródłowych i nazw tabel w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|Element <xref:System.SystemException> jest generowany. Jeśli jawnie ustawiono mapowania, brakuje mapowania dla parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|Element <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Jest również używana do mapowania wartości dla danych wyjściowych lub parametrów wejściowych/wyjściowych z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasa określa, czy użyć wersji oryginalnego, bieżące lub proponowane wartości kolumny. Ta funkcja jest często używane w oryginalnej wartości mają zostać uwzględnione w klauzuli WHERE w instrukcji UPDATE pod kątem naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersz, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, należy ustawić <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie poszczególnych wierszy w obrębie `RowUpdated` zdarzeń elementu DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzenie, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowy.</exception>
        <exception cref="T:System.SystemException">Nie <see cref="T:System.Data.DataRow" /> istnieje w celu aktualizacji.  
  
—lub— 
Nie <see cref="T:System.Data.DataTable" /> istnieje w celu aktualizacji.  
  
—lub— 
Nie <see cref="T:System.Data.DataSet" /> istnieje, aby użyć jako źródła.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Podjęto próbę wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataSet * string -&gt; int" Usage="dbDataAdapter.Update (dataSet, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet"><see cref="T:System.Data.DataSet" /> Można użyć, aby zaktualizować źródła danych.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawione, zaktualizowane lub usunąć wiersz w <see cref="T:System.Data.DataSet" /> z określonym <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymagane instrukcje INSERT, UPDATE lub DELETE iteracyjne dla każdego wiersza, na podstawie kolejności indeksy skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonać instrukcję DELETE, następuje instrukcji INSERT, a następnie inny instrukcji DELETE, właściwym do kolejności wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że te instrukcje nie są wykonywane jako proces wsadowy; Każdy wiersz jest aktualizowane pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym możesz kontrolować kolejność typów instrukcji (na przykład, Wstaw przed AKTUALIZACJĄ). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródeł danych za pomocą elementów DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcje INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Jednakże, możesz utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL dla aktualizacji pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, których nie należy ustawiać są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [Generowanie poleceń za pomocą CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. Jeśli istnieje kilka tabel o tej samej nazwie, ale inną wielkość liter, w `DataSet`, <xref:System.Data.Common.DbDataAdapter.Update%2A> wykonuje porównania uwzględniającego wielkość liter można znaleźć odpowiedniej tabeli i generuje wyjątek, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet ds = new DataSet();  
 ds.Tables.Add("aaa");  
 ds.Tables.Add("AAA");  
 adapter.Update(ds, "aaa"); // Updates "aaa", which already exists in the DataSet.  
 adapter.Update(ds, "AAA"); // Updates "AAA", which already exists in the DataSet.  
    adapter.Update(ds, "Aaa"); // Results in an exception.  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Update%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowana. W tym scenariuszu porównania jest uwzględniana wielkość liter. Poniższy kod C# ilustruje ten problem.  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Update(dataset, "AAA"); // Updates table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli pierwsze mapowania przed przystąpieniem do wykonywania aktualizacji na liście. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Wszystkie dodatkowe wiersze, zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenie jest zgłaszane, co pozwala na sprawdzanie uzgodnić <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe parametry zwróconemu przez polecenie. Po pomyślnym zaktualizowaniu wiersza zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następująca:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenie jest wywoływane.  
  
3.  Polecenie zostanie wykonane.  
  
4.  Jeśli polecenie jest równa `FirstReturnedRecord`, wówczas pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenie jest wywoływane.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zazwyczaj ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny, <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odnosi się do nazwy niezamapowaną kolumnę, zanim wszystkie mapowania tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję podejmowaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działania podjęte|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródłowych i nazw tabel w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|Element <xref:System.SystemException> jest generowany. Jeśli jawnie ustawiono mapowania, brakuje mapowania dla parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|Element <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Jest również używana do mapowania wartości dla danych wyjściowych lub parametrów wejściowych/wyjściowych z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasa określa, czy użyć wersji oryginalnego, bieżące lub proponowane wartości kolumny. Ta funkcja jest często używane w oryginalnej wartości mają zostać uwzględnione w klauzuli WHERE w instrukcji UPDATE pod kątem naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersz, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, należy ustawić <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie poszczególnych wierszy w obrębie `RowUpdated` zdarzeń elementu DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzenie, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby zaktualizować źródła danych.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowy.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Podjęto próbę wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="UpdateBatchSize">
      <MemberSignature Language="C#" Value="public virtual int UpdateBatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 UpdateBatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property UpdateBatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int UpdateBatchSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateBatchSize : int with get, set" Usage="System.Data.Common.DbDataAdapter.UpdateBatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która włącza lub wyłącza obsługę przetwarzania wsadowego i określa liczbę poleceń, które mogą być wykonywane w zadaniu wsadowym.</summary>
        <value>Liczba wierszy do przetworzenia na partię.  
  
 <list type="table"><listheader><term> Wartość to 
 </term><description> Efekt 
 </description></listheader><item><term> 0 
 </term><description> Nie ma żadnego limitu rozmiaru partii.  
  
 </description></item><item><term> 1 
 </term><description> Wyłącza aktualizacji usługi batch.  
  
 </description></item><item><term> &gt; 1 
 </term><description> Zmiany są wysyłane przy użyciu partie <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" /> operacje w danym momencie.  
  
 </description></item></list>  

 Gdy ustawienie tej opcji na wartość inna niż 1, wszystkie polecenia są skojarzone z <see cref="T:System.Data.Common.DbDataAdapter" /> musi mieć ich <see cref="P:System.Data.IDbCommand.UpdatedRowSource" /> właściwością **Brak** lub **OutputParameters**. W przeciwnym razie zostanie zgłoszony wyjątek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.Common.DbDataAdapter.UpdateBatchSize%2A> właściwość, aby zaktualizować źródło danych zmiany z <xref:System.Data.DataSet>. Jeśli dostawca danych obsługuje przetwarzania wsadowego, może to zwiększyć wydajność aplikacji dzięki zmniejszeniu liczby rund do serwera. W wersji 2.0 programu ADO.NET ta właściwość jest obsługiwana dla dostawcy danych .NET dla programu SQL Server (SqlClient) i Oracle (programu OracleClient).  
  
 Wykonując bardzo dużych partii może obniżyć wydajność. W związku z tym należy przetestować ustawienie rozmiaru partii optymalne przed wdrożeniem aplikacji.  
  
 <xref:System.ArgumentOutOfRangeException> Zostanie zgłoszony, jeśli wartość jest ustawiona na liczbę, mniejsza od zera.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="UpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ UpdateCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.UpdateCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia polecenie używane do aktualizowania rekordów w źródle danych.</summary>
        <value>A <see cref="T:System.Data.IDbCommand" /> używane podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> do aktualizowania rekordów w źródle danych, która ma być zmodyfikowane wiersze w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.Data.Common.DbDataAdapter.Update%2A>, jeśli ta właściwość nie jest ustawiona i informacje o kluczu podstawowym znajduje się w <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.UpdateCommand%2A> zostanie automatycznie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/retrieving-and-modifying-data.md">Manipulowanie danymi (ADO.NET)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/2a8e2640-3a49-42a1-a3a9-b43026907ae1">DbProviderFactories (ADO.NET)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ado-net-overview.md">Omówienie ADO.NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
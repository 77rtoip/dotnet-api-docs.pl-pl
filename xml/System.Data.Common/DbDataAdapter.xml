<Type Name="DbDataAdapter" FullName="System.Data.Common.DbDataAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="332e7bf7ba0f9c35c1455cd28bcf8d4bd18ca3f3" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36692814" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class DbDataAdapter : System.Data.Common.DataAdapter, ICloneable, System.Data.IDbDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DbDataAdapter extends System.Data.Common.DataAdapter implements class System.Data.IDataAdapter, class System.Data.IDbDataAdapter, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.DbDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DbDataAdapter&#xA;Inherits DataAdapter&#xA;Implements ICloneable, IDbDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class DbDataAdapter abstract : System::Data::Common::DataAdapter, ICloneable, System::Data::IDbDataAdapter" />
  <TypeSignature Language="F#" Value="type DbDataAdapter = class&#xA;    inherit DataAdapter&#xA;    interface IDbDataAdapter&#xA;    interface ICloneable&#xA;    interface IDataAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DataAdapter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.IDbDataAdapter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Ułatwia wykonanie <see cref="T:System.Data.IDbDataAdapter" /> interfejsu. Dziedziczenia z <see cref="T:System.Data.Common.DbDataAdapter" /> implementuje zestaw funkcji, aby zapewnić, wpisując silne, ale dziedziczą większość potrzebnych do pełnego wdrożenia funkcji ** element DataAdapter **.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter> Klasa dziedziczy <xref:System.Data.Common.DataAdapter> klasy i implementuje <xref:System.Data.IDbDataAdapter> interfejsu. Pomaga klasa implementuje **element DataAdapter** przeznaczony do użytku z relacyjnej bazy danych.  
  
 Aplikacja nie tworzy wystąpienie <xref:System.Data.Common.DbDataAdapter> klasy bezpośrednio, ale powoduje utworzenie wystąpienia klasy, która dziedziczy od niego.  
  
 Klasy, które dziedziczą <xref:System.Data.Common.DbDataAdapter> musi implementować dziedziczone elementy członkowskie i zwykle zdefiniować dodatkowe elementy członkowskie Dodawanie funkcji specyficznych dla dostawcy. Na przykład <xref:System.Data.Common.DbDataAdapter> klasa definiuje <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości oraz <xref:System.Data.Common.DbDataAdapter> klasa definiuje osiem przeciążeń <xref:System.Data.IDataAdapter.Fill%2A> — metoda. Z kolei <xref:System.Data.OleDb.OleDbDataAdapter> klasa dziedziczy <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody, a także określa dwa dodatkowe przeciążeń <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> , które wymagają obiektu zestawu rekordów ADO jako parametr.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>When you inherit from the <see cref="T:System.Data.Common.DbDataAdapter" /> class, we recommend that you implement the following constructors:  <list type="table"><listheader><term> Item  </term><description> Description  </description></listheader><item><term> *Prv*DataAdapter()  </term><description> Initializes a new instance of the *Prv*DataAdapter class.  </description></item><item><term> *Prv*DataAdapter(*Prv*Command *selectCommand*)  </term><description> Initializes a new instance of the *Prv*DataAdapter class with the specified SQL SELECT statement.  </description></item><item><term> *Prv*DataAdapter(string *selectCommandText*, string *selectConnectionString*)  </term><description> Initializes a new instance of the *Prv*DataAdapter class with an SQL SELECT statement and a connection string.  </description></item><item><term> *Prv*DataAdapter(string *selectCommandText*, *Prv*Connection *selectConnection*)  </term><description> Initializes a new instance of the *Prv*DataAdapter class with an SQL SELECT statement and a *Prv*Connection object.  </description></item></list>  Wspieranie spójność dostawcy danych .NET Framework, należy nazwę klasy dziedziczące w formularzu * Prv * element DataAdapter, gdzie * Prv * jest prefiksem uniform na wszystkie klasy w określonej przestrzeni nazw dostawcy danych .NET Framework. Na przykład "Sql" to prefiks <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> klas w przestrzeni nazw **System.Data.SqlClient**.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="DataAdapter" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy ** element DataAdapter ** klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia wystąpienia <xref:System.Data.Common.DbDataAdapter>, następujące właściwości odczytu/zapisu są ustawione na następujące wartości początkowej.  
  
|Właściwości|Wartość początkowa|  
|----------------|-------------------|  
|<xref:System.Data.IDbDataAdapter.SelectCommand%2A>|Nowy <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.IDbDataAdapter.InsertCommand%2A>|Nowy <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>|Nowy <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>|Nowy <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.Common.DataAdapter.MissingMappingAction%2A>|`MissingMappingAction.Passthrough`|  
|<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>|`MissingSchemaAction.Add`|  
  
 Można zmienić wartości tych właściwości, za pomocą oddzielnego wywołania do właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter (System.Data.Common.DbDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.Common.DbDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (adapter As DbDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter(System::Data::Common::DbDataAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="new System.Data.Common.DbDataAdapter : System.Data.Common.DbDataAdapter -&gt; System.Data.Common.DbDataAdapter" Usage="new System.Data.Common.DbDataAdapter adapter" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.Common.DbDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter">A <see langword="DataAdapter" /> obiekt używany do tworzenia nowego <see langword="DataAdapter" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="DataAdapter" /> klasy z istniejącego obiektu tego samego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Data.Common.DbDataAdapter> Konstruktor jest przeznaczony do użytku przez dostawcę danych .NET Framework podczas wykonywania konstruktora podobne do użycia w klonowania implementacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToBatch">
      <MemberSignature Language="C#" Value="protected virtual int AddToBatch (System.Data.IDbCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 AddToBatch(class System.Data.IDbCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function AddToBatch (command As IDbCommand) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int AddToBatch(System::Data::IDbCommand ^ command);" />
      <MemberSignature Language="F#" Value="abstract member AddToBatch : System.Data.IDbCommand -&gt; int&#xA;override this.AddToBatch : System.Data.IDbCommand -&gt; int" Usage="dbDataAdapter.AddToBatch command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.IDbCommand" />
      </Parameters>
      <Docs>
        <param name="command">
          <see cref="T:System.Data.IDbCommand" /> Do dodania do wykonywania zadania wsadowego.</param>
        <summary>Dodaje <see cref="T:System.Data.IDbCommand" /> do bieżącej partii.</summary>
        <returns>Liczba poleceń w partii przed dodaniem <see cref="T:System.Data.IDbCommand" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę, aby zapewnić obsługę dla partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  Jeśli klasa, która dziedziczy <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę, aby umożliwić użytkownikom dodawanie polecenia do partii.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ClearBatch">
      <MemberSignature Language="C#" Value="protected virtual void ClearBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ClearBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearBatch ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearBatch();" />
      <MemberSignature Language="F#" Value="abstract member ClearBatch : unit -&gt; unit&#xA;override this.ClearBatch : unit -&gt; unit" Usage="dbDataAdapter.ClearBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie <see cref="T:System.Data.IDbCommand" /> obiektów z partii.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę, aby zapewnić obsługę dla partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  Jeśli klasa, która dziedziczy <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę, aby umożliwić użytkownikom Usuń z partii wszystkie polecenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatedEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatedEventArgs ^ CreateRowUpdatedEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberSignature Language="F#" Value="abstract member CreateRowUpdatedEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatedEventArgs&#xA;override this.CreateRowUpdatedEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatedEventArgs" Usage="dbDataAdapter.CreateRowUpdatedEvent (dataRow, command, statementType, tableMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatedEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow">
          <see cref="T:System.Data.DataRow" /> Używana do aktualizowania źródła danych.</param>
        <param name="command">
          <see cref="T:System.Data.IDbCommand" /> Wykonywanego w <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</param>
        <param name="statementType">Polecenie jest dostępna aktualizacja, wstawianie, usuwanie czy instrukcja SELECT.</param>
        <param name="tableMapping">A <see cref="T:System.Data.Common.DataTableMapping" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> klasy.</summary>
        <returns>Nowe wystąpienie klasy <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> klasy.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatingEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatingEventArgs ^ CreateRowUpdatingEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberSignature Language="F#" Value="abstract member CreateRowUpdatingEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatingEventArgs&#xA;override this.CreateRowUpdatingEvent : System.Data.DataRow * System.Data.IDbCommand * System.Data.StatementType * System.Data.Common.DataTableMapping -&gt; System.Data.Common.RowUpdatingEventArgs" Usage="dbDataAdapter.CreateRowUpdatingEvent (dataRow, command, statementType, tableMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatingEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow">
          <see cref="T:System.Data.DataRow" /> Który aktualizacji źródła danych.</param>
        <param name="command">
          <see cref="T:System.Data.IDbCommand" /> Do wykonania podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</param>
        <param name="statementType">Polecenie jest dostępna aktualizacja, wstawianie, usuwanie czy instrukcja SELECT.</param>
        <param name="tableMapping">A <see cref="T:System.Data.Common.DataTableMapping" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> klasy.</summary>
        <returns>Nowe wystąpienie klasy <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> klasy.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSourceTableName">
      <MemberSignature Language="C#" Value="public const string DefaultSourceTableName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DefaultSourceTableName" />
      <MemberSignature Language="DocId" Value="F:System.Data.Common.DbDataAdapter.DefaultSourceTableName" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultSourceTableName As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ DefaultSourceTableName;" />
      <MemberSignature Language="F#" Value="val mutable DefaultSourceTableName : string" Usage="System.Data.Common.DbDataAdapter.DefaultSourceTableName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Domyślna nazwa używana przez <see cref="T:System.Data.Common.DataAdapter" /> obiektu mapowań tabeli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "Tabela" jest domyślna nazwa używana przez <xref:System.Data.Common.DataAdapter> obiektu mapowań tabeli.  
  
 <xref:System.Data.Common.DbDataAdapter.DefaultSourceTableName> jest w przypadku aplikacji dodaje mapowania tabeli, ma być używany z <xref:System.Data.Common.DbDataAdapter.Fill%2A>, ale nie określa <xref:System.Data.DataTable> nazwy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.DeleteCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property DeleteCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ DeleteCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.DeleteCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia polecenia usuwania rekordów z zestawu danych.</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" /> Używane podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> usunąć rekordy w źródle danych dla usuniętych wierszy w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.Data.Common.DbDataAdapter.Update%2A>, jeśli ta właściwość nie jest ustawiona i informacje o kluczu podstawowym znajduje się w <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.DeleteCommand%2A> jest generowana automatycznie.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="dbDataAdapter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Data.Common.DbDataAdapter" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteBatch">
      <MemberSignature Language="C#" Value="protected virtual int ExecuteBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 ExecuteBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ExecuteBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ExecuteBatch () As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int ExecuteBatch();" />
      <MemberSignature Language="F#" Value="abstract member ExecuteBatch : unit -&gt; int&#xA;override this.ExecuteBatch : unit -&gt; int" Usage="dbDataAdapter.ExecuteBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje bieżącej partii.</summary>
        <returns>Wartość zwrócona przez ostatnie polecenie w partii.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę, aby zapewnić obsługę dla partii.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  Jeśli klasa, która dziedziczy <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę, aby umożliwić użytkownikom do wykonywania partii. Implementacja tej metody łączy poleceń na karcie w partii, a następnie wykonuje partii i zwraca wartość zwracaną partii.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Fill">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wypełnia <see cref="T:System.Data.DataSet" /> lub <see cref="T:System.Data.DataTable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public override int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet -&gt; int" Usage="dbDataAdapter.Fill dataSet" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Fill(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection> Obiekt skojarzony z polecenie select musi być prawidłowy, ale nie musi być otwarty. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarty do pobierania danych i zamykane. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 Jeśli napotka błąd lub wystąpił wyjątek podczas wypełniania tabel danych, w tabelach danych nadal będą wierszy dodawanych przed wystąpieniem błędu. W pozostałej części operacja została przerwana.  
  
 Jeśli polecenie nie zwróci żadnych wierszy, tabele nie są dodawane do <xref:System.Data.DataSet>, i nie jest zgłaszany wyjątek nie.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy kolumn kolejnych przy użyciu wzorca "*columnname*1","*columnname*2", " *columnname*3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Zapytanie określone zwrócona wiele wyników zestawu wyników dla każdego wiersza zwracanie kwerendy znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Ponieważ tabela nie jest tworzony dla zapytania, które niezwracanie wierszy, jeśli przetwarzania zapytania insert następuje zapytania select, tabela utworzona do wykonywania zapytania select nosi "Tabela", ponieważ jest pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takich jak partii instrukcji SQL, jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pomijane i nie są dodawane do <xref:System.Data.DataSet>.  
  
 Korzystając z kolejnych <xref:System.Data.Common.DbDataAdapter.Fill%2A> wywołań, aby odświeżyć zawartość <xref:System.Data.DataSet>, muszą zostać spełnione dwa warunki:  
  
1.  Instrukcja SQL powinna być zgodna początkowo używaną do wypełniania <xref:System.Data.DataSet>.  
  
2.  **Klucza** informacji o kolumnie musi być obecny.  
  
 Jeśli informacje o kluczu podstawowym jest obecny, wszystkie zduplikowane wiersze są uzgadniane i wystąpić tylko raz w <xref:System.Data.DataTable> odpowiadający <xref:System.Data.DataSet>. Informacje o kluczu podstawowym można konfigurować za pośrednictwem <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, określając <xref:System.Data.DataTable.PrimaryKey%2A> właściwość <xref:System.Data.DataTable>, albo ustawiając <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> właściwości `AddWithKey`.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartość powstałe w ten sposób <xref:System.Data.DataTable>. Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable -&gt; int" Usage="dbDataAdapter.Fill dataTable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">Nazwa <see cref="T:System.Data.DataTable" /> do użycia na potrzeby mapowania tabeli.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> do odpowiadają źródła danych przy użyciu <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Operacji następnie dodaje wiersze do miejsca docelowego <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiekty, jeśli nie już istnieją. Podczas tworzenia <xref:System.Data.DataTable> obiektów, <xref:System.Data.Common.DbDataAdapter.Fill%2A> operacji zwykle tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników znajduje się w osobnej tabeli.  
  
 Przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A> pobierającej `DataTable` jako parametr tylko uzyskuje pierwszego wyniku. Użyj przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A> pobierającej `DataSet` jako parametr uzyskanie wiele wyników.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
 dataset.Tables.Add("AAA");  
 adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
    adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowany. W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Można użyć <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartość powstałe w ten sposób <xref:System.Data.DataTable>. Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.Fill%2A> i <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dostawcy danych .NET Framework pobiera informacje o schemacie dla pierwszego wyniku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.</exception>
        <block subset="none" type="overrides">
          <para>To przeciążenie metody <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * string -&gt; int" Usage="dbDataAdapter.Fill (dataSet, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataSet" /> do odpowiadają źródła danych przy użyciu <see cref="T:System.Data.DataSet" /> i <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection> Obiekt skojarzony z polecenie select musi być prawidłowy, ale nie musi być otwarty. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 Jeśli polecenie nie zwróci żadnych wierszy, tabele nie są dodawane do <xref:System.Data.DataSet>, i nie jest zgłaszany wyjątek nie.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, spowoduje wygenerowanie nazw dla kolejnych kolumn, za pomocą wzorca "nazwakolumny1", "nazwakolumny2", "columnname3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Zapytanie określone zwraca wiele wyników, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Ponieważ nie tabela została utworzona dla zapytania, która nie zwraca wiersze, jeśli zostały do przetworzenia zapytania insert następuje zapytania select, tabela utworzona do wykonywania zapytania select będą miały postać "Tabela", ponieważ jest pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowany. W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Jeśli napotka błąd lub wystąpił wyjątek podczas wypełniania tabel danych, w tabelach danych nadal będą wierszy dodawanych przed wystąpieniem błędu. W pozostałej części operacja została przerwana.  
  
 Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takie jak partii instrukcji SQL, należy pamiętać o następujących:  
  
-   Jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięty i nie zostały dodane do <xref:System.Data.DataSet>.  
  
 Korzystając z kolejnych <xref:System.Data.Common.DbDataAdapter.Fill%2A> wywołań, aby odświeżyć zawartość <xref:System.Data.DataSet>, muszą zostać spełnione dwa warunki:  
  
1.  Instrukcja SQL powinna być zgodna początkowo używaną do wypełniania <xref:System.Data.DataSet>.  
  
2.  **Klucza** informacji o kolumnie musi być obecny. Jeśli informacje o kluczu podstawowym jest obecny, wszystkie zduplikowane wiersze są uzgadniane i wystąpić tylko raz w <xref:System.Data.DataTable> odpowiadający <xref:System.Data.DataSet>. Informacje o kluczu podstawowym można konfigurować za pośrednictwem <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, określając <xref:System.Data.DataTable.PrimaryKey%2A> właściwość <xref:System.Data.DataTable>, albo ustawiając <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> właściwości `AddWithKey`.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartość powstałe w ten sposób <xref:System.Data.DataTable>. Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby wypełnić <xref:System.Data.DataSet> z wierszy z tabeli Kategorie. W tym przykładzie przyjęto założenie, że utworzono <xref:System.Data.OleDb.OleDbDataAdapter> i <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Tabela źródłowa jest nieprawidłowa.</exception>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable dataTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataTable ^ dataTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; int" Usage="dbDataAdapter.Fill (dataTable, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable">A <see cref="T:System.Data.DataTable" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="command">W instrukcji SQL SELECT używane do pobierania wierszy ze źródła danych.</param>
        <param name="behavior">Jeden z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataTable" /> zgodnie z regułami w źródle danych przy użyciu określonego <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.IDbCommand" /> i <see cref="T:System.Data.CommandBehavior" />.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataTable" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarty do pobierania danych i zamykane. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Operacji następnie dodaje wiersze do określonej lokalizacji docelowej <xref:System.Data.DataTable> obiektu w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiektu, jeśli go jeszcze nie istnieje. Podczas tworzenia <xref:System.Data.DataTable> obiektu <xref:System.Data.Common.DbDataAdapter.Fill%2A> operacji zwykle tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, spowoduje wygenerowanie nazw dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2 ","*columnname*3 "i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A> pobierającej `DataTable` jako parametr tylko uzyskuje pierwszego wyniku. Użyj przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A> pobierającej `DataSet` jako parametr uzyskanie wiele wyników.  
  
 Można użyć <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartość powstałe w ten sposób <xref:System.Data.DataTable>. Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>To przeciążenie metody <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (int startRecord, int maxRecords, params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(int32 startRecord, int32 maxRecords, class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Fill (startRecord As Integer, maxRecords As Integer, ParamArray dataTables As DataTable()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(int startRecord, int maxRecords, ... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="override this.Fill : int * int * System.Data.DataTable[] -&gt; int" Usage="dbDataAdapter.Fill (startRecord, maxRecords, dataTables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startRecord">Liczony od zera numer rekordu zaczynać.</param>
        <param name="maxRecords">Maksymalna liczba rekordów do pobrania.</param>
        <param name="dataTables">
          <see cref="T:System.Data.DataTable" /> Obiektów, aby wypełnić ze źródła danych.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataTable" /> zgodnie z regułami w źródle danych, zaczynając od określonego rekordu i pobierania maksymalnie określoną maksymalną liczbę rekordów.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataTable" />. Ta wartość nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DataAdapter.Fill%2A> Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DataAdapter.Fill%2A> jest wywoływana, jest otwarty do pobierania danych, a następnie jest ono zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.Common.DataAdapter.Fill%2A> Operacji następnie dodaje wiersze do miejsca docelowego <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiekty, jeśli nie już istnieją. Podczas tworzenia <xref:System.Data.DataTable> obiektów, <xref:System.Data.Common.DataAdapter.Fill%2A> operacji zwykle tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartość powstałe w ten sposób <xref:System.Data.DataTable>. Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
 Jeśli adapter danych napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazw dla kolejnych kolumn, za pomocą wzorca "nazwakolumny1", "nazwakolumny2", "columnname3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>, każdy zestaw wyników znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takich jak partii instrukcji SQL, jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięty i nie zostały dodane do <xref:System.Data.DataSet>.  
  
 Można użyć <xref:System.Data.Common.DataAdapter.Fill%2A> metody wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * int * int * string -&gt; int" Usage="dbDataAdapter.Fill (dataSet, startRecord, maxRecords, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="startRecord">Liczony od zera numer rekordu zaczynać.</param>
        <param name="maxRecords">Maksymalna liczba rekordów do pobrania.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> do odpowiadają źródła danych przy użyciu <see cref="T:System.Data.DataSet" /> i <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `maxRecords` wszystkie rekordy po rekord początkowy pobiera wartość 0. Jeśli `maxRecords` jest większa niż liczba pozostałych wierszy tylko pozostałe wiersze są zwracane, a błąd nie jest wystawiany.  
  
 Jeśli odpowiednie polecenie select jest zwracania wyników wiele instrukcji <xref:System.Data.Common.DbDataAdapter.Fill%2A> dotyczy tylko `maxRecords` do pierwszego wyniku.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection> Obiekt skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarty do pobierania danych i zamykane. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 Jeśli polecenie nie zwróci żadnych wierszy, tabele nie są dodawane do <xref:System.Data.DataSet>, ale nie wystąpił wyjątek.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, spowoduje wygenerowanie nazw dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2 ","*columnname*3 "i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Zapytanie określone zwraca wiele wyników, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Ponieważ tabela nie jest tworzony dla zapytania, które niezwracanie wierszy, jeśli przetwarzania zapytania insert następuje zapytania select, tabela utworzona do wykonywania zapytania select jest o nazwie "Tabela", ponieważ jest pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowany. W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Jeśli napotka błąd lub wystąpił wyjątek podczas wypełniania tabel danych, w tabelach danych nadal będą wierszy dodawanych przed wystąpieniem błędu. W pozostałej części operacja została przerwana.  
  
 Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takich jak partii instrukcji SQL, należy pamiętać o następujących czynności:  
  
-   Podczas przetwarzania wiele wyników z partii instrukcji SQL `maxRecords` ma zastosowanie tylko do pierwszego wyniku. To samo dotyczy wierszy zawierających podzielony na rozdziały wyniki (.NET Framework Data Provider for OLE DB tylko). Wynik najwyższego poziomu jest ograniczona przez `maxRecords`, ale są dodawane wszystkie wiersze podrzędne.  
  
-   Jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięty i nie zostały dodane do <xref:System.Data.DataSet>.  
  
 Korzystając z kolejnych <xref:System.Data.Common.DbDataAdapter.Fill%2A> wywołań, aby odświeżyć zawartość <xref:System.Data.DataSet>, muszą zostać spełnione dwa warunki:  
  
1.  Instrukcja SQL powinna być zgodna początkowo używaną do wypełniania <xref:System.Data.DataSet>.  
  
2.  **Klucza** informacji o kolumnie musi być obecny.  
  
 Jeśli informacje o kluczu podstawowym jest obecny, zduplikowanych wierszy zostanie uzgodniony i wystąpić tylko raz w <xref:System.Data.DataTable> odpowiadający <xref:System.Data.DataSet>. Informacje o kluczu podstawowym można konfigurować za pośrednictwem <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, określając <xref:System.Data.DataTable.PrimaryKey%2A> właściwość <xref:System.Data.DataTable>, albo ustawiając <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> właściwości `AddWithKey`.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartość powstałe w ten sposób <xref:System.Data.DataTable>. Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
> [!NOTE]
>  `DataSet` Nie będzie zawierać więcej niż liczba rekordów wskazywanym przez `maxRecords`. Jednak cały zestaw wyników generowanych przez zapytanie jest nadal zwrócone z serwera.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby wypełnić <xref:System.Data.DataSet> z 15 wiersze, rozpoczynając od wiersza 10, z **kategorii** tabeli. W tym przykładzie przyjęto założenie, że utworzono <xref:System.Data.OleDb.OleDbDataAdapter> i <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">
          <see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.  - lub - połączenia jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidCastException">Nie można odnaleźć połączenia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startRecord" /> Parametru jest mniejszy niż 0.  - lub - <paramref name="maxRecords" /> parametru jest mniejszy niż 0.</exception>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable[] dataTables, int startRecord, int maxRecords, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable[] dataTables, int32 startRecord, int32 maxRecords, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Fill (dataTables As DataTable(), startRecord As Integer, maxRecords As Integer, command As IDbCommand, behavior As CommandBehavior) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables, int startRecord, int maxRecords, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataTable[] * int * int * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; int" Usage="dbDataAdapter.Fill (dataTables, startRecord, maxRecords, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTables">
          <see cref="T:System.Data.DataTable" /> Obiektów, aby wypełnić ze źródła danych.</param>
        <param name="startRecord">Liczony od zera numer rekordu zaczynać.</param>
        <param name="maxRecords">Maksymalna liczba rekordów do pobrania.</param>
        <param name="command">
          <see cref="T:System.Data.IDbCommand" /> Wykonywany w celu wypełnienia <see cref="T:System.Data.DataTable" /> obiektów.</param>
        <param name="behavior">Jeden z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> do odpowiadają źródła danych przy użyciu <see cref="T:System.Data.DataSet" /> i <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba wierszy, dodać lub odświeżane w tabelach danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `maxRecords` wszystkie rekordy po rekord początkowy pobiera wartość 0. Jeśli `maxRecords` jest większa niż liczba pozostałych wierszy tylko pozostałe wiersze są zwracane, a błąd nie jest wystawiany.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection> Obiekt skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 Jeśli polecenie nie zwróci żadnych wierszy, tabele nie są dodawane do <xref:System.Data.DataSet>, ale nie wystąpił wyjątek.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, spowoduje wygenerowanie nazw dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2 ","*columnname*3 "i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej.  
  
 Zapytanie określone zwraca wiele wyników, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Ponieważ nie tabela została utworzona dla zapytania, która nie zwraca wiersze, jeśli zostały do przetworzenia zapytania insert następuje zapytania select, tabela utworzona do wykonywania zapytania select będą miały postać "Tabela", ponieważ jest pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowany. W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Jeśli napotka błąd lub wystąpił wyjątek podczas wypełniania tabel danych, w tabelach danych nadal będą wierszy dodawanych przed wystąpieniem błędu. W pozostałej części operacja została przerwana.  
  
 Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataTable> obiektów zwraca wiele wyników, takie jak partii instrukcji SQL, należy pamiętać o następujących:  
  
-   Podczas przetwarzania wiele wyników z partii instrukcji SQL `maxRecords` ma zastosowanie tylko do pierwszego wyniku. To samo dotyczy wierszy zawierających podzielony na rozdziały wyniki (.NET Framework Data Provider for OLE DB tylko). Wynik najwyższego poziomu jest ograniczona przez `maxRecords`, ale są dodawane wszystkie wiersze podrzędne.  
  
-   Jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pomijane.  
  
> [!NOTE]
>  `DataSet` Nie będzie zawierać więcej niż liczba rekordów wskazywanym przez `maxRecords`. Jednak cały zestaw wyników generowanych przez zapytanie jest nadal zwrócone z serwera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">
          <see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.  - lub - połączenia jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidCastException">Nie można odnaleźć połączenia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startRecord" /> Parametru jest mniejszy niż 0.  - lub - <paramref name="maxRecords" /> parametru jest mniejszy niż 0.</exception>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.Fill : System.Data.DataSet * int * int * string * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; int" Usage="dbDataAdapter.Fill (dataSet, startRecord, maxRecords, srcTable, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <param name="startRecord">Liczony od zera numer rekordu zaczynać.</param>
        <param name="maxRecords">Maksymalna liczba rekordów do pobrania.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <param name="command">W instrukcji SQL SELECT używane do pobierania wierszy ze źródła danych.</param>
        <param name="behavior">Jeden z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> do odpowiadają źródła danych przy użyciu <see cref="T:System.Data.DataSet" /> i źródłowej nazw tabel, ciąg polecenia i zachowanie polecenia.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Operacji następnie dodaje wiersze do miejsca docelowego <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiekty, jeśli nie już istnieją. Podczas tworzenia <xref:System.Data.DataTable> obiektów, <xref:System.Data.Common.DbDataAdapter.Fill%2A> operacji zwykle tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A> przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowany. W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Można użyć <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartość powstałe w ten sposób <xref:System.Data.DataTable>. Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.Fill%2A> i <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dostawcy danych .NET Framework pobiera informacje o schemacie dla pierwszego wyniku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startRecord" /> Parametru jest mniejszy niż 0.  - lub - <paramref name="maxRecords" /> parametru jest mniejszy niż 0.</exception>
        <block subset="none" type="overrides">
          <para>To przeciążenie metody <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FillCommandBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Data.CommandBehavior FillCommandBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.CommandBehavior FillCommandBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.FillCommandBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property FillCommandBehavior As CommandBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Data::CommandBehavior FillCommandBehavior { System::Data::CommandBehavior get(); void set(System::Data::CommandBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.FillCommandBehavior : System.Data.CommandBehavior with get, set" Usage="System.Data.Common.DbDataAdapter.FillCommandBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.CommandBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zachowanie polecenia używany do wypełniania adapter danych.</summary>
        <value>
          <see cref="T:System.Data.CommandBehavior" /> Polecenia używany do wypełniania adapter danych.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> do <see cref="T:System.Data.DataSet" /> i konfiguruje schemat odpowiadać w źródle danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataSet * System.Data.SchemaType -&gt; System.Data.DataTable[]" Usage="dbDataAdapter.FillSchema (dataSet, schemaType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> do wstawienia schematu w.</param>
        <param name="schemaType">Jeden z <see cref="T:System.Data.SchemaType" /> wartości, które określają sposób wstawiania schematu.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> o nazwie "Tabela" do określonego <see cref="T:System.Data.DataSet" /> i konfiguruje schemat do dopasowania w źródle danych, na podstawie której określony <see cref="T:System.Data.SchemaType" />.</summary>
        <returns>Odwołanie do kolekcji <see cref="T:System.Data.DataTable" /> obiektów, które zostały dodane do <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera informacje o schemacie z źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dodaje operacji <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> osobno.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości zgodnie z następującymi zasadami:  
  
-   Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych reguł, ale także inne ograniczenia typów nie zostaną dodane.  
  
 Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Informacje o kluczu podstawowym jest używany podczas <xref:System.Data.Common.DbDataAdapter.Fill%2A> do znajdowania i zamieniania wszystkie wiersze, w których kolumny klucza pasują do siebie. Jeśli nie jest zamierzone zachowanie, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> bez żąda informacji o schemacie.  
  
 Jeśli <xref:System.Data.IDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.IDbConnection> Obiekt skojarzony z polecenie select musi być prawidłowy, ale nie trzeba otworzyć. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jest pozostawiany bez Otwórz.  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE do instrukcji wykonywana. Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.SqlClient.SqlDataAdapter>, aby wypełnić <xref:System.Data.DataSet> schematu i zwraca <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataTable * System.Data.SchemaType -&gt; System.Data.DataTable" Usage="dbDataAdapter.FillSchema (dataTable, schemaType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataTable">
          <see cref="T:System.Data.DataTable" /> Do wypełnienia ze schematem ze źródła danych.</param>
        <param name="schemaType">Jeden z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <summary>Konfiguruje schemat określonego <see cref="T:System.Data.DataTable" /> oparte na określony <see cref="T:System.Data.SchemaType" />.</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> zawierający informacje o schemacie zwracane ze źródła danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda pobiera schemat z źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A> musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, pozostaje otwarty.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> zwraca operacji <xref:System.Data.DataTable>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> osobno.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości zgodnie z następującymi zasadami:  
  
-   Jeśli <xref:System.Data.DataTable.PrimaryKey%2A> został już zdefiniowany dla `DataTable`, lub `DataTable` zawiera dane, `PrimaryKey` właściwość nie zostanie ustawiona.  
  
-   Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla `DataTable`.  
  
-   Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale `PrimaryKey` nie ustawiono właściwości.  
  
-   Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla `DataTable`.  
  
 Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych reguł, ale także inne ograniczenia typów nie zostaną dodane. Proces ten może potrwać kilka przesyłania danych do serwera.  
  
 Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Zwraca wszystkie wiersze. Użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody w celu dodania wierszy do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE do instrukcji wykonywana. Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.SqlClient.SqlDataAdapter>, aby wypełnić <xref:System.Data.DataSet> schematu i zwraca <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataSet * System.Data.SchemaType * string -&gt; System.Data.DataTable[]" Usage="dbDataAdapter.FillSchema (dataSet, schemaType, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> do wstawienia schematu w.</param>
        <param name="schemaType">Jeden z <see cref="T:System.Data.SchemaType" /> wartości, które określają sposób wstawiania schematu.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> do określonego <see cref="T:System.Data.DataSet" /> i konfiguruje schemat do dopasowania, który ustalane na podstawie określonego w źródle danych <see cref="T:System.Data.SchemaType" /> i <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Odwołanie do kolekcji <see cref="T:System.Data.DataTable" /> obiektów, które zostały dodane do <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera informacje o schemacie z źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dodaje operacji <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> osobno.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości zgodnie z następującymi zasadami:  
  
-   Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych reguł, ale także inne ograniczenia typów nie zostaną dodane.  
  
 Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Informacje o kluczu podstawowym jest używany podczas <xref:System.Data.Common.DbDataAdapter.Fill%2A> do znajdowania i zamieniania wszystkie wiersze, w których kolumny klucza pasują do siebie. Jeśli nie jest zamierzone zachowanie, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> bez żąda informacji o schemacie.  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowany. W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.IDbConnection> Obiekt skojarzony z polecenie select musi być prawidłowy, ale nie trzeba otworzyć. Jeśli <xref:System.Data.IDbConnection> jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jest pozostawiany bez Otwórz.  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE do instrukcji wykonywana. Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.SqlClient.SqlDataAdapter>, aby wypełnić <xref:System.Data.DataSet> schematu i zwraca <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można odnaleźć tabeli źródłowej, z którego można pobrać schematu.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataTable * System.Data.SchemaType * System.Data.IDbCommand * System.Data.CommandBehavior -&gt; System.Data.DataTable" Usage="dbDataAdapter.FillSchema (dataTable, schemaType, command, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable">
          <see cref="T:System.Data.DataTable" /> Do wypełnienia ze schematem ze źródła danych.</param>
        <param name="schemaType">Jeden z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <param name="command">W instrukcji SQL SELECT używane do pobierania wierszy ze źródła danych.</param>
        <param name="behavior">Jeden z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Konfiguruje schemat określonego <see cref="T:System.Data.DataTable" /> oparte na określony <see cref="T:System.Data.SchemaType" />, ciąg, polecenia i <see cref="T:System.Data.CommandBehavior" /> wartości.</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> zwrócony obiekt, który zawiera informacje o schemacie ze źródła danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda pobiera schemat z źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A> musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, pozostaje otwarty.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dodaje operacji <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> osobno.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości zgodnie z następującymi zasadami:  
  
-   Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych reguł, ale także inne ograniczenia typów nie zostaną dodane.  
  
 Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Jeśli <xref:System.Data.IDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Zwraca wszystkie wiersze. Użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody w celu dodania wierszy do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE do instrukcji wykonywana. Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta implementacja <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, System.Data.IDbCommand command, string srcTable, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, string srcTable, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::String ^ srcTable, System::Data::CommandBehavior behavior);" />
      <MemberSignature Language="F#" Value="override this.FillSchema : System.Data.DataSet * System.Data.SchemaType * System.Data.IDbCommand * string * System.Data.CommandBehavior -&gt; System.Data.DataTable[]" Usage="dbDataAdapter.FillSchema (dataSet, schemaType, command, srcTable, behavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see cref="T:System.Data.DataSet" /> Do wypełnienia ze schematem ze źródła danych.</param>
        <param name="schemaType">Jeden z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <param name="command">W instrukcji SQL SELECT używane do pobierania wierszy ze źródła danych.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <param name="behavior">Jeden z <see cref="T:System.Data.CommandBehavior" /> wartości.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> do określonego <see cref="T:System.Data.DataSet" /> i konfiguruje schemat do dopasowania w źródle danych, na podstawie której określony <see cref="T:System.Data.SchemaType" />.</summary>
        <returns>Tablica <see cref="T:System.Data.DataTable" /> obiektów, które zawierają informacje o schemacie zwracane ze źródła danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda pobiera schemat z źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A> musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> jest wywoływana, pozostaje otwarty.  
  
 A <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dodaje operacji <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> osobno.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości zgodnie z następującymi zasadami:  
  
-   Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych reguł, ale także inne ograniczenia typów nie zostaną dodane.  
  
 Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Jeśli <xref:System.Data.IDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Table", "Tabela1", "Tabela2" itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowany. W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Zwraca wszystkie wiersze. Użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody w celu dodania wierszy do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE do instrukcji wykonywana. Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta implementacja <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedParameter">
      <MemberSignature Language="C#" Value="protected virtual System.Data.IDataParameter GetBatchedParameter (int commandIdentifier, int parameterIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.IDataParameter GetBatchedParameter(int32 commandIdentifier, int32 parameterIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedParameter (commandIdentifier As Integer, parameterIndex As Integer) As IDataParameter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::IDataParameter ^ GetBatchedParameter(int commandIdentifier, int parameterIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBatchedParameter : int * int -&gt; System.Data.IDataParameter&#xA;override this.GetBatchedParameter : int * int -&gt; System.Data.IDataParameter" Usage="dbDataAdapter.GetBatchedParameter (commandIdentifier, parameterIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="parameterIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier">Indeks polecenie, aby pobrać parametru z.</param>
        <param name="parameterIndex">Indeks parametru w poleceniu.</param>
        <summary>Zwraca <see cref="T:System.Data.IDataParameter" /> z jednego z poleceń w bieżącej partii.</summary>
        <returns>
          <see cref="T:System.Data.IDataParameter" /> Określony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę, aby zapewnić obsługę dla partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  Jeśli klasa, która dziedziczy <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę, aby umożliwić użytkownikom do wykonywania partii. Implementacja używa <paramref name="commandIdentifier" /> podane można znaleźć żądanego polecenia, a następnie używa <paramref name="parameterIndex" /> dostarczone do zlokalizowania żądanej parametru. Na przykład <paramref name="commandIdentifier" /> 0 i <paramref name="parameterIndex" /> 0 zwraca pierwszy parametr z pierwszego polecenia w partii.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedRecordsAffected">
      <MemberSignature Language="C#" Value="protected virtual bool GetBatchedRecordsAffected (int commandIdentifier, out int recordsAffected, out Exception error);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GetBatchedRecordsAffected(int32 commandIdentifier, [out] int32&amp; recordsAffected, [out] class System.Exception&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedRecordsAffected (commandIdentifier As Integer, ByRef recordsAffected As Integer, ByRef error As Exception) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GetBatchedRecordsAffected(int commandIdentifier, [Runtime::InteropServices::Out] int % recordsAffected, [Runtime::InteropServices::Out] Exception ^ % error);" />
      <MemberSignature Language="F#" Value="abstract member GetBatchedRecordsAffected : int *  *  -&gt; bool&#xA;override this.GetBatchedRecordsAffected : int *  *  -&gt; bool" Usage="dbDataAdapter.GetBatchedRecordsAffected (commandIdentifier, recordsAffected, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="recordsAffected" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="System.Exception&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier">Numer kolumny od zera określonego polecenia w partii.</param>
        <param name="recordsAffected">Liczba wierszy w magazynie danych dotyczy określonego polecenia w partii.</param>
        <param name="error">
          <see cref="T:System.Exception" /> Zgłoszony podczas wykonywania tego polecenia. Zwraca <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic), jeśli nie jest wyjątek.</param>
        <summary>Zwraca informacje o próba indywidualnej aktualizacji w większych aktualizacji wsadowych.</summary>
        <returns>Informacje o próba indywidualnej aktualizacji w większych aktualizacji wsadowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dostawcy danych, obsługujące wsadowej logikę aktualizowania przesłonięcie szereg metod wirtualnych na <xref:System.Data.Common.DbDataAdapter> klasy. `GetBatchedRecordsAffected` reprezentuje jedną z tych metod wirtualnych. `DbDataAdapter` Zależy od klasy `GetBatchedRecordsAffected` Aby określić powodzenie lub niepowodzenie prób indywidualnej aktualizacji w partii, dlatego można oznaczyć, każdego odpowiadającego <xref:System.Data.DataRow> odpowiednio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public override System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberSignature Language="F#" Value="override this.GetFillParameters : unit -&gt; System.Data.IDataParameter[]" Usage="dbDataAdapter.GetFillParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.GetFillParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera parametry ustawione przez użytkownika podczas wykonywania instrukcji SQL SELECT.</summary>
        <returns>Tablica <see cref="T:System.Data.IDataParameter" /> obiektów, które zawiera parametry ustawiony przez użytkownika.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeBatching">
      <MemberSignature Language="C#" Value="protected virtual void InitializeBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.InitializeBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeBatching();" />
      <MemberSignature Language="F#" Value="abstract member InitializeBatching : unit -&gt; unit&#xA;override this.InitializeBatching : unit -&gt; unit" Usage="dbDataAdapter.InitializeBatching " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje przetwarzania wsadowego dla <see cref="T:System.Data.Common.DbDataAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę, aby zapewnić obsługę dla partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  Jeśli klasa, która dziedziczy <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę. Ta metoda zapewnia klasy możliwość zainicjować wszystkie zasoby niezbędne do obsługi przetwarzania wsadowego. Na przykład klasa może przydzielić to struktura danych, aby pomieścić zestaw poleceń w partii.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="InsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.InsertCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property InsertCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ InsertCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InsertCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.InsertCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia polecenie służące do wstawianie nowych rekordów do źródła danych.</summary>
        <value>A <see cref="T:System.Data.IDbCommand" /> używane podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> do wstawiania rekordów w źródle danych dla nowych wierszy w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.Data.Common.DbDataAdapter.Update%2A>, jeśli ta właściwość nie jest ustawiona i informacje o kluczu podstawowym znajduje się w <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.InsertCommand%2A> zostanie wygenerowana automatycznie.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdated">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdated (System.Data.Common.RowUpdatedEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdated(class System.Data.Common.RowUpdatedEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdated (value As RowUpdatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdated(System::Data::Common::RowUpdatedEventArgs ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRowUpdated : System.Data.Common.RowUpdatedEventArgs -&gt; unit&#xA;override this.OnRowUpdated : System.Data.Common.RowUpdatedEventArgs -&gt; unit" Usage="dbDataAdapter.OnRowUpdated value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see langword="RowUpdated" /> zdarzenia dostawcy danych .NET Framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdating">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdating (System.Data.Common.RowUpdatingEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdating(class System.Data.Common.RowUpdatingEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdating (value As RowUpdatingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdating(System::Data::Common::RowUpdatingEventArgs ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRowUpdating : System.Data.Common.RowUpdatingEventArgs -&gt; unit&#xA;override this.OnRowUpdating : System.Data.Common.RowUpdatingEventArgs -&gt; unit" Usage="dbDataAdapter.OnRowUpdating value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatingEventArgs" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see langword="RowUpdating" /> zdarzenia dostawcy danych .NET Framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> w klasie pochodnej, należy wywołać Klasa baz <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SelectCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.SelectCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ SelectCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.SelectCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia polecenie, aby wybrać rekordy w źródle danych.</summary>
        <value>A <see cref="T:System.Data.IDbCommand" /> używany podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> aby wybrać rekordy ze źródła danych do umieszczenia w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.DeleteCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand" />
      <MemberSignature Language="VB.NET" Value=" Property DeleteCommand As IDbCommand Implements IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.DeleteCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.DeleteCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia instrukcji SQL podczas usuwania rekordów z zestawu danych.</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" /> Używane podczas <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> usunąć rekordy w źródle danych dla usuniętych wierszy w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowane na <xref:System.Data.IDbDataAdapter> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.InsertCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand" />
      <MemberSignature Language="VB.NET" Value=" Property InsertCommand As IDbCommand Implements IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.InsertCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.InsertCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia instrukcji SQL umożliwia wstawianie nowych rekordów do źródła danych.</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" /> Używane podczas <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> do wstawiania rekordów w źródle danych dla nowych wierszy w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowane na <xref:System.Data.IDbDataAdapter> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDbDataAdapter.InsertCommand%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.SelectCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand" />
      <MemberSignature Language="VB.NET" Value=" Property SelectCommand As IDbCommand Implements IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.SelectCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.SelectCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia instrukcji SQL, aby wybrać rekordy w źródle danych.</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" /> Używany podczas <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> aby wybrać rekordy ze źródła danych do umieszczenia w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowane na <xref:System.Data.IDbDataAdapter> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.UpdateCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand" />
      <MemberSignature Language="VB.NET" Value=" Property UpdateCommand As IDbCommand Implements IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.UpdateCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.UpdateCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia instrukcji SQL używane do aktualizowania rekordów w źródle danych.</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" /> Używane podczas <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> do aktualizowania rekordów w źródle danych dla zmodyfikowanych wierszy w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowane na <xref:System.Data.IDbDataAdapter> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy obiekt, który jest kopią bieżącego wystąpienia.</summary>
        <returns>Nowy obiekt będący kopią tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter> wystąpienia jest rzutowane na <xref:System.ICloneable> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.ICloneable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TerminateBatching">
      <MemberSignature Language="C#" Value="protected virtual void TerminateBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TerminateBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.TerminateBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TerminateBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TerminateBatching();" />
      <MemberSignature Language="F#" Value="abstract member TerminateBatching : unit -&gt; unit&#xA;override this.TerminateBatching : unit -&gt; unit" Usage="dbDataAdapter.TerminateBatching " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się przetwarzanie wsadowe dla <see cref="T:System.Data.Common.DbDataAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>. Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter> przesłonić tę metodę, aby zapewnić obsługę dla partii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Karta nie obsługuje partie.</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda jest chroniona i jest przeznaczony do użytku przez dostawcę danych .NET Framework.  Jeśli klasa, która dziedziczy <see cref="T:System.Data.Common.DbDataAdapter" /> obsługuje partie, że klasa zastępuje tę metodę. Ta metoda zapewnia klasy możliwość Zlikwiduj wszelkie zasoby przydzielone do obsługi przetwarzania wsadowego. Na przykład klasa może cofnąć struktury danych, który zawiera poleceń w partii.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Update">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataRow[] dataRows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataRow[] dataRows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (dataRows As DataRow()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataRow[] -&gt; int" Usage="dbDataAdapter.Update dataRows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="dataRows">Tablica <see cref="T:System.Data.DataRow" /> obiekty używane do aktualizowania źródła danych.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawiania, aktualizacji lub usuwania wiersza w określonej tablicy w <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonania instrukcji DELETE, następuje instrukcji INSERT, a następnie inne instrukcji DELETE, właściwym do kolejność wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład wstawia przed aktualizacji). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Dodatkowe wiersze zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie. Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następujący:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenia.  
  
3.  Wykonuje polecenia.  
  
4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenia.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zwykle ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny który <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działań|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródła i nazwy tabeli w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|A <xref:System.SystemException> jest generowany. Mapowania są jawnie ustawiona, brakuje mapowania parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|A <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby zaktualizować źródła danych.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.</exception>
        <exception cref="T:System.SystemException">Nie <see cref="T:System.Data.DataRow" /> istnieje aktualizacji.  - lub - No <see cref="T:System.Data.DataTable" /> istnieje aktualizacji.  - lub - No <see cref="T:System.Data.DataSet" /> istnieje do użycia jako źródło.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public override int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Update(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataSet -&gt; int" Usage="dbDataAdapter.Update dataSet" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Update(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see cref="T:System.Data.DataSet" /> Używana do aktualizowania źródła danych.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w określonej <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonania instrukcji DELETE, następuje instrukcji INSERT, a następnie inne instrukcji DELETE, właściwym do kolejność wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład wstawia przed aktualizacji). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Dodatkowe wiersze zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie. Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następujący:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenia.  
  
3.  Wykonuje polecenia.  
  
4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, wtedy pierwszy zwrócone wyniki są umieszczane w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenia.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zwykle ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny który <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działań|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródła i nazwy tabeli w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|A <xref:System.SystemException> jest generowany. Mapowania są jawnie ustawiona, brakuje mapowania parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|A <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby zaktualizować źródła danych.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataTable -&gt; int" Usage="dbDataAdapter.Update dataTable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">
          <see cref="T:System.Data.DataTable" /> Używana do aktualizowania źródła danych.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w określonej <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonania instrukcji DELETE, następuje instrukcji INSERT, a następnie inne instrukcji DELETE, właściwym do kolejność wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład wstawia przed aktualizacji). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Dodatkowe wiersze zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie. Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następujący:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenia.  
  
3.  Wykonuje polecenia.  
  
4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, wtedy pierwszy zwrócone wyniki są umieszczane w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenia.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zwykle ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny który <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działań|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródła i nazwy tabeli w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|A <xref:System.SystemException> jest generowany. Mapowania są jawnie ustawiona, brakuje mapowania parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|A <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby zaktualizować źródła danych.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.</exception>
        <exception cref="T:System.SystemException">Nie <see cref="T:System.Data.DataRow" /> istnieje aktualizacji.  - lub - No <see cref="T:System.Data.DataTable" /> istnieje aktualizacji.  - lub - No <see cref="T:System.Data.DataSet" /> istnieje do użycia jako źródło.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="protected virtual int Update (System.Data.DataRow[] dataRows, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Update(class System.Data.DataRow[] dataRows, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Update (dataRows As DataRow(), tableMapping As DataTableMapping) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataRow[] * System.Data.Common.DataTableMapping -&gt; int" Usage="dbDataAdapter.Update (dataRows, tableMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRows">Tablica <see cref="T:System.Data.DataRow" /> obiekty używane do aktualizowania źródła danych.</param>
        <param name="tableMapping">
          <see cref="P:System.Data.IDataAdapter.TableMappings" /> Kolekcji do użycia.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w określonej tablicy <see cref="T:System.Data.DataSet" /> obiektów.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonania instrukcji DELETE, następuje instrukcji INSERT, a następnie inne instrukcji DELETE, właściwym do kolejność wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład wstawia przed aktualizacji). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Dodatkowe wiersze zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie. Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następujący:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenia.  
  
3.  Wykonuje polecenia.  
  
4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, wtedy pierwszy zwrócone wyniki są umieszczane w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenia.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zwykle ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny który <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działań|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródła i nazwy tabeli w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|A <xref:System.SystemException> jest generowany. Mapowania są jawnie ustawiona, brakuje mapowania parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|A <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.</exception>
        <exception cref="T:System.SystemException">Nie <see cref="T:System.Data.DataRow" /> istnieje aktualizacji.  - lub - No <see cref="T:System.Data.DataTable" /> istnieje aktualizacji.  - lub - No <see cref="T:System.Data.DataSet" /> istnieje do użycia jako źródło.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberSignature Language="F#" Value="override this.Update : System.Data.DataSet * string -&gt; int" Usage="dbDataAdapter.Update (dataSet, srcTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see cref="T:System.Data.DataSet" /> Używać do aktualizowania źródła danych.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <summary>Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w <see cref="T:System.Data.DataSet" /> z określonym <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A> metody <xref:System.Data.Common.DbDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DbDataAdapter.Update%2A> może wykonania instrukcji DELETE, następuje instrukcji INSERT, a następnie inne instrukcji DELETE, właściwym do kolejność wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład, Wstaw przed AKTUALIZACJĄ). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda generuje wyjątek. Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet> zawiera wiele <xref:System.Data.DataTable> obiektów, których nazwy różnią się tylko wielkością liter. Jeśli istnieje kilka tabel o tej samej nazwy, ale inną wielkość liter, w `DataSet`, <xref:System.Data.Common.DbDataAdapter.Update%2A> przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie generuje wyjątek, jeśli istnieje dokładnego dopasowania. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet ds = new DataSet();  
 ds.Tables.Add("aaa");  
 ds.Tables.Add("AAA");  
 adapter.Update(ds, "aaa"); // Updates "aaa", which already exists in the DataSet.  
 adapter.Update(ds, "AAA"); // Updates "AAA", which already exists in the DataSet.  
    adapter.Update(ds, "Aaa"); // Results in an exception.  
```  
  
 Jeśli <xref:System.Data.Common.DbDataAdapter.Update%2A> nosi nazwę i <xref:System.Data.DataSet> zawiera tylko jeden <xref:System.Data.DataTable> o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable> jest aktualizowany. W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Update(dataset, "AAA"); // Updates table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A> Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji. <xref:System.Data.Common.DbDataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Dodatkowe wiersze zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie. Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następujący:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenia.  
  
3.  Wykonuje polecenia.  
  
4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, wtedy pierwszy zwrócone wyniki są umieszczane w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenia.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter> zwykle ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny który <xref:System.Data.Common.DbDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działań|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródła i nazwy tabeli w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|A <xref:System.SystemException> jest generowany. Mapowania są jawnie ustawiona, brakuje mapowania parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|A <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby zaktualizować źródła danych.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Data.DataSet" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpdateBatchSize">
      <MemberSignature Language="C#" Value="public virtual int UpdateBatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 UpdateBatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property UpdateBatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int UpdateBatchSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateBatchSize : int with get, set" Usage="System.Data.Common.DbDataAdapter.UpdateBatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która włącza lub wyłącza obsługę przetwarzania wsadowego i określa liczbę poleceń, które mogą być wykonywane w partii.</summary>
        <value>Liczba wierszy do przetwarzania na partię.  
  
 <list type="table"><listheader><term> Wartość jest </term><description> efekt </description></listheader><item><term> 0 </term><description> nie ma żadnego limitu rozmiaru partii.  </description></item><item><term> 1 </term><description> wyłącza aktualizowania wsadowego.  </description></item><item><term> &gt; 1 </term><description> zmiany są wysyłane przy użyciu partii <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" /> operacji w czasie.  </description></item></list>  Jeśli ustawienie to wartość inna niż 1, wszystkie polecenia skojarzony z <see cref="T:System.Data.Common.DbDataAdapter" /> musi mieć ich <see cref="P:System.Data.IDbCommand.UpdatedRowSource" /> ustawioną właściwość ** Brak ** lub ** OutputParameters **. Zostanie wygenerowany wyjątek w przeciwnym razie wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.Common.DbDataAdapter.UpdateBatchSize%2A> właściwości można zaktualizować źródła danych o zmianach wprowadzonych od <xref:System.Data.DataSet>. Jeśli dostawca danych obsługuje przetwarzania wsadowego, to zwiększyć wydajność aplikacji dzięki zmniejszeniu liczby operacji na serwerze. W programie 2.0 ADO.NET ta właściwość jest obsługiwana dla dostawcy danych .NET dla programu SQL Server (SqlClient) i Oracle (OracleClient).  
  
 Wykonywanie wsadowe bardzo dużą może obniżyć wydajność. W związku z tym należy przetestować ustawienie rozmiaru partii optymalne przed wdrożeniem aplikacji.  
  
 <xref:System.ArgumentOutOfRangeException> Zostanie wygenerowany, jeśli wartość jest ustawiona na liczbę, mniejsza od zera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ UpdateCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateCommand : System.Data.Common.DbCommand with get, set" Usage="System.Data.Common.DbDataAdapter.UpdateCommand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia polecenie używane do aktualizowania rekordów w źródle danych.</summary>
        <value>A <see cref="T:System.Data.IDbCommand" /> używane podczas <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> do aktualizowania rekordów w źródle danych dla zmodyfikowanych wierszy w zestawie danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.Data.Common.DbDataAdapter.Update%2A>, jeśli ta właściwość nie jest ustawiona i informacje o kluczu podstawowym znajduje się w <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.UpdateCommand%2A> zostanie wygenerowana automatycznie.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
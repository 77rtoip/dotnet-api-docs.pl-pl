<Type Name="DataAdapter" FullName="System.Data.Common.DataAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="143655eea6524aee886bfc2d1cc4e7da417175a9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36692648" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataAdapter : System.ComponentModel.Component, System.Data.IDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataAdapter extends System.ComponentModel.Component implements class System.Data.IDataAdapter" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.DataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public Class DataAdapter&#xA;Inherits Component&#xA;Implements IDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataAdapter : System::ComponentModel::Component, System::Data::IDataAdapter" />
  <TypeSignature Language="F#" Value="type DataAdapter = class&#xA;    inherit Component&#xA;    interface IDataAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.IDataAdapter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje zestaw poleceń SQL oraz połączenia z bazą danych, które są używane do wypełnienia <see cref="T:System.Data.DataSet" /> i zaktualizować źródła danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DataAdapter> Służy jako mostka między <xref:System.Data.DataSet> i źródła danych do pobierania i zapisywania danych. <xref:System.Data.Common.DataAdapter> Zapewnia to mostek przez mapowanie <xref:System.Data.Common.DataAdapter.Fill%2A>, które zmiany danych w <xref:System.Data.DataSet> do pasują do danych w źródle danych i <xref:System.Data.IDataAdapter.Update%2A>, które zmiany danych w źródle danych w celu dopasowania danych w <xref:System.Data.DataSet>.  
  
 Jeśli łączysz się z bazą danych programu SQL Server, można zwiększyć ogólną wydajność przy użyciu <xref:System.Data.SqlClient.SqlDataAdapter> wraz z jego skojarzony <xref:System.Data.SqlClient.SqlCommand> i <xref:System.Data.SqlClient.SqlConnection> obiektów. Dla źródeł danych OLE DB, obsługiwane, należy użyć <xref:System.Data.Common.DataAdapter> z jego skojarzony <xref:System.Data.OleDb.OleDbCommand> i <xref:System.Data.OleDb.OleDbConnection> obiektów. Dla źródeł danych ODBC, obsługiwane, należy użyć <xref:System.Data.Common.DataAdapter> z jego skojarzony <xref:System.Data.Odbc.OdbcCommand> i <xref:System.Data.Odbc.OdbcConnection> obiektów. W przypadku baz danych Oracle użyć <xref:System.Data.Common.DataAdapter> z jego skojarzony <xref:System.Data.OracleClient.OracleCommand> i <xref:System.Data.OracleClient.OracleConnection> obiektów.  
  
 Gdy wystąpienie klasy <xref:System.Data.Common.DataAdapter> utworzeniu odczytu/zapisu właściwości są ustawione na wartości początkowe. Aby uzyskać listę tych wartości, zobacz <xref:System.Data.Common.DataAdapter> konstruktora.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Common.DataAdapter" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Common.DataAdapter" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wystąpienie klasy <xref:System.Data.Common.DataAdapter> utworzono następujące właściwości są ustawione na następujące wartości początkowej odczytu/zapisu.  
  
|Właściwości|Wartość początkowa|  
|----------------|-------------------|  
|<xref:System.Data.Common.DataAdapter.MissingMappingAction%2A>|`MissingMappingAction.Passthrough`|  
|<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>|`MissingSchemaAction.Add`|  
|<xref:System.Data.Common.DataAdapter.TableMappings%2A>|Tablica <xref:System.Data.Common.DataAdapter.TableMappings%2A> obiektów.|  
  
 Można zmienić wartości tych właściwości, za pomocą oddzielnego wywołania do właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataAdapter (System.Data.Common.DataAdapter from);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.Common.DataAdapter from) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.#ctor(System.Data.Common.DataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (from As DataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataAdapter(System::Data::Common::DataAdapter ^ from);" />
      <MemberSignature Language="F#" Value="new System.Data.Common.DataAdapter : System.Data.Common.DataAdapter -&gt; System.Data.Common.DataAdapter" Usage="new System.Data.Common.DataAdapter from" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="from" Type="System.Data.Common.DataAdapter" />
      </Parameters>
      <Docs>
        <param name="from">A <see cref="T:System.Data.Common.DataAdapter" /> obiekt używany do tworzenia nowego <see cref="T:System.Data.Common.DataAdapter" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Common.DataAdapter" /> klasy z istniejącego obiektu tego samego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Data.Common.DataAdapter> Konstruktor jest przeznaczony do użytku przez dostawcę danych .NET Framework podczas wykonywania konstruktora podobne do użycia w klonowania implementacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChangesDuringFill">
      <MemberSignature Language="C#" Value="public bool AcceptChangesDuringFill { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptChangesDuringFill" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptChangesDuringFill As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AcceptChangesDuringFill { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AcceptChangesDuringFill : bool with get, set" Usage="System.Data.Common.DataAdapter.AcceptChangesDuringFill" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="M:System.Data.DataRow.AcceptChanges" /> jest wywoływana na <see cref="T:System.Data.DataRow" /> po dodaniu do <see cref="T:System.Data.DataTable" /> podczas wszystkich ** wypełnienia ** operacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="M:System.Data.DataRow.AcceptChanges" /> jest wywoływana na <see cref="T:System.Data.DataRow" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `false`, <xref:System.Data.DataRow.AcceptChanges%2A> nie jest wywoływany i nowo dodanych wierszy są traktowane jako wstawionych wierszy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChangesDuringUpdate">
      <MemberSignature Language="C#" Value="public bool AcceptChangesDuringUpdate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptChangesDuringUpdate" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptChangesDuringUpdate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AcceptChangesDuringUpdate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AcceptChangesDuringUpdate : bool with get, set" Usage="System.Data.Common.DataAdapter.AcceptChangesDuringUpdate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czy <see cref="M:System.Data.DataRow.AcceptChanges" /> jest wywoływana podczas <see cref="M:System.Data.Common.DataAdapter.Update(System.Data.DataSet)" />.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="M:System.Data.DataRow.AcceptChanges" /> jest wywoływana podczas <see cref="M:System.Data.Common.DataAdapter.Update(System.Data.DataSet)" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wywoływania `Update` metody `DataAdapter`, bazy danych może wysyłać dane do aplikacji ADO.NET jako parametry wyjściowe lub pierwszy rekord zwróconego zestawu wyników. ADO.NET można pobierać te wartości i zaktualizuj odpowiednie kolumny w <xref:System.Data.DataRow> aktualizowana. Domyślnie wywołuje ADO.NET `AcceptChanges` metody `DataRow` po aktualizacji. Jednak jeśli chcesz scalić zaktualizowany wiersz z powrotem do innego <xref:System.Data.DataTable>, może zajść potrzeba preserver oryginalnej wartości kolumny klucza podstawowego. Na przykład kolumna klucza podstawowego odpowiadający automatycznie zwiększającą kolumny w bazie danych, takich jak kolumny tożsamości, może zawierać nowe wartości, przypisanych przez bazę danych, które nie są zgodne z oryginalnych wartości przypisane w `DataRow`. Domyślnie `AcceptChanges` jest niejawnie wywoływana po wykonaniu aktualizacji i oryginalnych wartości w wierszu, który może zostać <xref:System.Data.DataColumn.AutoIncrement%2A> wartości przypisane przez ADO.NET, zostaną utracone. Można zachować oryginalne wartości w `DataRow` , zapobiegając `ADO.NET` z wywołaniem `AcceptChanges` po przeprowadzi aktualizację w wierszu, ustawiając <xref:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate%2A> właściwości `false`, który zachowuje oryginalne wartości.  
  
> [!NOTE]
>  Ustawienie `AcceptChangesDuringUpdate` właściwości `false` ma zastosowanie do wszystkich modyfikacji danych, nie tylko wstawia. Jeśli chcesz edytować lub usunąć wiersze w tej samej aktualizacji, a jeśli chcesz pominąć wywołanie `AcceptChanges` tylko w przypadku operacji wstawienia, a następnie zamiast ustawienie `AccceptChangesDuringUpdate` do `false`, użyj programu obsługi zdarzeń dla `RowUpdated` zdarzenie `DataAdapter`. W przypadku obsługi można sprawdzić <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> do określenia w przypadku modyfikacji danych insert i jeśli `true`ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.SkipCurrentRow>. Aby uzyskać więcej informacji i przykład zobacz [pobierania tożsamości lub wartości automatycznie numerowane](~/docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md).  
  
   
  
## Examples  
 W tym przykładzie pokazano wyodrębniania zmienionych wierszy z `DataTable` i przy użyciu <xref:System.Data.SqlClient.SqlDataAdapter> do aktualizowania źródła danych i pobierania nowych wartości kolumny tożsamości. Przez ustawienie `AcceptChangesDuringUpdate` właściwość <xref:System.Data.SqlClient.SqlDataAdapter> do `false` Aby zachować oryginalnej wartości przyrostu automatycznie, nowe dane można następnie scalić w oryginalnej <xref:System.Data.DataTable>, nawet jeśli nowa wartość tożsamości jest niezgodny z oryginalnym automatyczne zwiększanie wartość w `DataTable`.  
  
 [!code-csharp[DataWorks SqlClient.AcceptChangesDuringUpdate#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.AcceptChangesDuringUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SqlClient.AcceptChangesDuringUpdate#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.AcceptChangesDuringUpdate/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneInternals">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.DataAdapter CloneInternals ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.DataAdapter CloneInternals() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.CloneInternals" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CloneInternals () As DataAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::DataAdapter ^ CloneInternals();" />
      <MemberSignature Language="F#" Value="abstract member CloneInternals : unit -&gt; System.Data.Common.DataAdapter&#xA;override this.CloneInternals : unit -&gt; System.Data.Common.DataAdapter" Usage="dataAdapter.CloneInternals " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("CloneInternals() has been deprecated.  Use the DataAdapter(DataAdapter from) constructor.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DataAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię tego wystąpienia <see cref="T:System.Data.Common.DataAdapter" />.</summary>
        <returns>Sklonowany wystąpienie <see cref="T:System.Data.Common.DataAdapter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przestarzała. <xref:System.Data.Common.DataAdapter.%23ctor%2A> Konstruktor powinien być używany zamiast tej metody.  
  
 Wszystkie polecenia <xref:System.Data.Common.DataAdapter.TableMappings%2A>, <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>i <xref:System.Data.Common.DataAdapter.MissingMappingAction%2A> są klonowane. Jednak połączenia dla poleceń są nie skopiowane, ale udostępniony. W związku z tym sklonowany <xref:System.Data.Common.DataAdapter> można użyć w odniesieniu do tego samego połączenia co oryginalny.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.Common.DataAdapter.CloneInternals" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.Common.DataAdapter.CloneInternals" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ContinueUpdateOnError">
      <MemberSignature Language="C#" Value="public bool ContinueUpdateOnError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContinueUpdateOnError" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DataAdapter.ContinueUpdateOnError" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueUpdateOnError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContinueUpdateOnError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueUpdateOnError : bool with get, set" Usage="System.Data.Common.DataAdapter.ContinueUpdateOnError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy można wygenerować wyjątek po wystąpieniu błędu napotkano podczas aktualizacji wiersza.</summary>
        <value>
          <see langword="true" /> Aby kontynuować aktualizację bez generowania wyjątku; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `ContinueUpdateOnError` ma ustawioną wartość `true`, nie jest wyjątek po wystąpieniu błędu podczas aktualizacji wiersza. Aktualizacja wiersza zostanie pominięta i informacje o błędzie jest umieszczany w <xref:System.Data.DataRow.RowError%2A> właściwości wiersza w tabeli błędów. <xref:System.Data.Common.DataAdapter> Aktualizuje kolejnych wierszach.  
  
 Jeśli `ContinueUpdateOnError` ma ustawioną wartość `false`, gdy wystąpi błąd podczas aktualizacji wiersza jest zwracany wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTableMappings">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.DataTableMappingCollection CreateTableMappings ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.DataTableMappingCollection CreateTableMappings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.CreateTableMappings" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateTableMappings () As DataTableMappingCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::DataTableMappingCollection ^ CreateTableMappings();" />
      <MemberSignature Language="F#" Value="abstract member CreateTableMappings : unit -&gt; System.Data.Common.DataTableMappingCollection&#xA;override this.CreateTableMappings : unit -&gt; System.Data.Common.DataTableMappingCollection" Usage="dataAdapter.CreateTableMappings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DataTableMappingCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.Data.Common.DataTableMappingCollection" />.</summary>
        <returns>Nowa kolekcja mapowania tabeli.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="dataAdapter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Data.Common.DataAdapter" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.IDisposable.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Data.Common.DataAdapter> odwołania. Ta metoda wywołuje `Dispose` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" />, nie odwołują się obiekty, które zostało zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia Resources](~/docs/standard/garbage-collection/unmanaged.md) niezarządzane i [zastąpienie metody Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Fill">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataSet" /> zgodnie z regułami w źródle danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public virtual int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="abstract member Fill : System.Data.DataSet -&gt; int&#xA;override this.Fill : System.Data.DataSet -&gt; int" Usage="dataAdapter.Fill dataSet" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Fill(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataSet" /> zgodnie z regułami w źródle danych.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DataAdapter.Fill%2A> Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DataAdapter.Fill%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.Common.DataAdapter.Fill%2A> Operacji następnie dodaje wiersze do miejsca docelowego <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiekty, jeśli nie już istnieją. Podczas tworzenia <xref:System.Data.DataTable> obiektów, <xref:System.Data.Common.DataAdapter.Fill%2A> operacji zwykle tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartość powstałe w ten sposób <xref:System.Data.DataTable>. Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
 Jeśli adapter danych napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazw dla kolejnych kolumn, za pomocą wzorca "nazwakolumny1", "nazwakolumny2", "columnname3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takich jak partii instrukcji SQL, jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięty i nie zostały dodane do <xref:System.Data.DataSet>.  
  
 Można użyć <xref:System.Data.Common.DataAdapter.Fill%2A> metody wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Common.DataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDataReader dataReader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable dataTable, class System.Data.IDataReader dataReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.Fill(System.Data.DataTable,System.Data.IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataTable ^ dataTable, System::Data::IDataReader ^ dataReader);" />
      <MemberSignature Language="F#" Value="abstract member Fill : System.Data.DataTable * System.Data.IDataReader -&gt; int&#xA;override this.Fill : System.Data.DataTable * System.Data.IDataReader -&gt; int" Usage="dataAdapter.Fill (dataTable, dataReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="dataReader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="dataTable">A <see cref="T:System.Data.DataTable" /> umożliwia wypełnienie rekordów.</param>
        <param name="dataReader">Wystąpienie <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Dodaje lub odświeża wierszy w <see cref="T:System.Data.DataTable" /> do odpowiadają źródła danych przy użyciu <see cref="T:System.Data.DataTable" /> nazwy i określonego <see cref="T:System.Data.IDataReader" />.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataTable" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz uwagi dla `System.Data.Common.DataAdapter.Fill(System.Data.DataSet)` Aby uzyskać dodatkowe informacje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable[] dataTables, System.Data.IDataReader dataReader, int startRecord, int maxRecords);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable[] dataTables, class System.Data.IDataReader dataReader, int32 startRecord, int32 maxRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.Fill(System.Data.DataTable[],System.Data.IDataReader,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Fill (dataTables As DataTable(), dataReader As IDataReader, startRecord As Integer, maxRecords As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables, System::Data::IDataReader ^ dataReader, int startRecord, int maxRecords);" />
      <MemberSignature Language="F#" Value="abstract member Fill : System.Data.DataTable[] * System.Data.IDataReader * int * int -&gt; int&#xA;override this.Fill : System.Data.DataTable[] * System.Data.IDataReader * int * int -&gt; int" Usage="dataAdapter.Fill (dataTables, dataReader, startRecord, maxRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
        <Parameter Name="dataReader" Type="System.Data.IDataReader" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dataTables">Kolekcja <see cref="T:System.Data.DataTable" /> obiektów, aby wypełnić rekordów.</param>
        <param name="dataReader">Wystąpienie <see cref="T:System.Data.IDataReader" />.</param>
        <param name="startRecord">Liczony od zera indeks początkowy rekordu.</param>
        <param name="maxRecords">Liczba całkowita wskazująca maksymalną liczbę rekordów.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w kolekcji <see cref="T:System.Data.DataTable" /> obiektów, aby były zgodne ze źródłem danych.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataTable" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz uwagi dla `System.Data.Common.DataAdapter.Fill(System.Data.DataSet)` Aby uzyskać dodatkowe informacje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataSet dataSet, string srcTable, System.Data.IDataReader dataReader, int startRecord, int maxRecords);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet, string srcTable, class System.Data.IDataReader dataReader, int32 startRecord, int32 maxRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.Fill(System.Data.DataSet,System.String,System.Data.IDataReader,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet, System::String ^ srcTable, System::Data::IDataReader ^ dataReader, int startRecord, int maxRecords);" />
      <MemberSignature Language="F#" Value="abstract member Fill : System.Data.DataSet * string * System.Data.IDataReader * int * int -&gt; int&#xA;override this.Fill : System.Data.DataSet * string * System.Data.IDataReader * int * int -&gt; int" Usage="dataAdapter.Fill (dataSet, srcTable, dataReader, startRecord, maxRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="dataReader" Type="System.Data.IDataReader" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów.</param>
        <param name="srcTable">Ciąg wskazujący nazwy tabeli źródłowej.</param>
        <param name="dataReader">Wystąpienie <see cref="T:System.Data.IDataReader" />.</param>
        <param name="startRecord">Liczony od zera indeks początkowy rekordu.</param>
        <param name="maxRecords">Liczba całkowita wskazująca maksymalną liczbę rekordów.</param>
        <summary>Dodaje lub odświeża wierszy w określonym zakresie w <see cref="T:System.Data.DataSet" /> do odpowiadają źródła danych przy użyciu <see cref="T:System.Data.DataSet" /> i <see cref="T:System.Data.DataTable" /> nazwy.</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz uwagi dla `System.Data.Common.DataAdapter.Fill(System.Data.DataSet)` Aby uzyskać dodatkowe informacje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillError">
      <MemberSignature Language="C#" Value="public event System.Data.FillErrorEventHandler FillError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.FillErrorEventHandler FillError" />
      <MemberSignature Language="DocId" Value="E:System.Data.Common.DataAdapter.FillError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FillError As FillErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::FillErrorEventHandler ^ FillError;" />
      <MemberSignature Language="F#" Value="member this.FillError : System.Data.FillErrorEventHandler " Usage="member this.FillError : System.Data.FillErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.FillErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwracany, gdy wystąpi błąd podczas operacji fill.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **FillError** zdarzeń pozwala użytkownikowi określić, czy operacja fill powinno być kontynuowane po wystąpieniu błędu. Przykłady sytuacji, w których **FillError** może wystąpić zdarzenie są:  
  
-   Danych dodawanych do `DataSet` nie można przekonwertować typu środowiska uruchomieniowego języka wspólnego bez utraty dokładności.  
  
-   Dodawany wiersz zawiera dane, które narusza ograniczenie, które muszą być wymuszane na `DataColumn` w `DataSet`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillLoadOption">
      <MemberSignature Language="C#" Value="public System.Data.LoadOption FillLoadOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.LoadOption FillLoadOption" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DataAdapter.FillLoadOption" />
      <MemberSignature Language="VB.NET" Value="Public Property FillLoadOption As LoadOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::LoadOption FillLoadOption { System::Data::LoadOption get(); void set(System::Data::LoadOption value); };" />
      <MemberSignature Language="F#" Value="member this.FillLoadOption : System.Data.LoadOption with get, set" Usage="System.Data.Common.DataAdapter.FillLoadOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.LoadOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Data.LoadOption" /> , który określa sposób wypełniania <see cref="T:System.Data.DataTable" /> z <see cref="T:System.Data.Common.DbDataReader" />.</summary>
        <value>A <see cref="T:System.Data.LoadOption" /> wartość.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Data.LoadOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FillSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> do określonego <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberSignature Language="F#" Value="abstract member FillSchema : System.Data.DataSet * System.Data.SchemaType -&gt; System.Data.DataTable[]&#xA;override this.FillSchema : System.Data.DataSet * System.Data.SchemaType -&gt; System.Data.DataTable[]" Usage="dataAdapter.FillSchema (dataSet, schemaType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see cref="T:System.Data.DataSet" /> Do wypełnienia ze schematem ze źródła danych.</param>
        <param name="schemaType">Jeden z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> do określonego <see cref="T:System.Data.DataSet" /> i konfiguruje schemat do dopasowania w źródle danych, na podstawie której określony <see cref="T:System.Data.SchemaType" />.</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> zwrócony obiekt, który zawiera informacje o schemacie ze źródła danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DataAdapter.FillSchema%2A> Metoda pobiera schemat z źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A> musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DataAdapter.FillSchema%2A> jest wywoływana, jest otwarty do pobierania danych i zamykane. Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DataAdapter.FillSchema%2A> jest wywoływana, pozostaje otwarty.  
  
 A <xref:System.Data.Common.DataAdapter.FillSchema%2A> dodaje operacji <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> osobno.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości zgodnie z następującymi zasadami:  
  
-   Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Odpowiedni magazyn danych może umożliwić atrybuty kolumny, które nie są obsługiwane w <xref:System.Data.DataColumn>, co powoduje, że niektóre atrybuty kolumny nie tłumaczenie. Na przykład programu SQL Server umożliwia kolumny tożsamości o typie danych tinyint, natomiast <xref:System.Data.DataColumn> tylko umożliwia Int16, Int32 i Int64 ma <xref:System.Data.DataColumn.AutoIncrement%2A> zestaw właściwości. `FillSchema` ignoruje w trybie dyskretnym przypadkach gdy <xref:System.Data.DataColumn> nie można dokładnie duplikatów źródła danych i nie wyjątek.  
  
 Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z powyższych reguł, ale także inne ograniczenia typów nie zostaną dodane.  
  
Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](/sql/t-sql/queries/hints-transact-sql-query).  
  
 Jeśli <xref:System.Data.Common.DataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca "*columnname*1", "*columnname*2", "*columnname*3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet> każdy zestaw wyników znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.Common.DataAdapter.FillSchema%2A> Zwraca wszystkie wiersze. Użyj <xref:System.Data.Common.DataAdapter.Fill%2A> metody w celu dodania wierszy do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A> z <xref:System.Data.MissingSchemaAction> ustawioną `AddWithKey`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Common.DataAdapter.Fill(System.Data.DataSet)" />
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType, System.Data.IDataReader dataReader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType, class System.Data.IDataReader dataReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType, System::Data::IDataReader ^ dataReader);" />
      <MemberSignature Language="F#" Value="abstract member FillSchema : System.Data.DataTable * System.Data.SchemaType * System.Data.IDataReader -&gt; System.Data.DataTable&#xA;override this.FillSchema : System.Data.DataTable * System.Data.SchemaType * System.Data.IDataReader -&gt; System.Data.DataTable" Usage="dataAdapter.FillSchema (dataTable, schemaType, dataReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="dataReader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="dataTable">
          <see cref="T:System.Data.DataTable" /> Zostać wypełnione z <see cref="T:System.Data.IDataReader" />.</param>
        <param name="schemaType">Jeden z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <param name="dataReader">
          <see cref="T:System.Data.IDataReader" /> Ma być używany jako źródło danych, podczas wypełniania <see cref="T:System.Data.DataTable" />.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> do określonego <see cref="T:System.Data.DataSet" />.</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> zwrócony obiekt, który zawiera informacje o schemacie ze źródła danych.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, string srcTable, System.Data.IDataReader dataReader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, string srcTable, class System.Data.IDataReader dataReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String,System.Data.IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::String ^ srcTable, System::Data::IDataReader ^ dataReader);" />
      <MemberSignature Language="F#" Value="abstract member FillSchema : System.Data.DataSet * System.Data.SchemaType * string * System.Data.IDataReader -&gt; System.Data.DataTable[]&#xA;override this.FillSchema : System.Data.DataSet * System.Data.SchemaType * string * System.Data.IDataReader -&gt; System.Data.DataTable[]" Usage="dataAdapter.FillSchema (dataSet, schemaType, srcTable, dataReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="dataReader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see cref="T:System.Data.DataTable" /> Zostać wypełnione z <see cref="T:System.Data.IDataReader" />.</param>
        <param name="schemaType">Jeden z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <param name="srcTable">Nazwa tabeli źródłowej na potrzeby mapowania tabeli.</param>
        <param name="dataReader">
          <see cref="T:System.Data.IDataReader" /> Ma być używany jako źródło danych, podczas wypełniania <see cref="T:System.Data.DataTable" />.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> do określonego <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Odwołanie do kolekcji <see cref="T:System.Data.DataTable" /> obiektów, które zostały dodane do <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public virtual System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetFillParameters : unit -&gt; System.Data.IDataParameter[]&#xA;override this.GetFillParameters : unit -&gt; System.Data.IDataParameter[]" Usage="dataAdapter.GetFillParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.GetFillParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera parametry ustawione przez użytkownika podczas wykonywania instrukcji SQL SELECT.</summary>
        <returns>Tablica <see cref="T:System.Data.IDataParameter" /> obiektów, które zawiera parametry ustawiony przez użytkownika.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasTableMappings">
      <MemberSignature Language="C#" Value="protected bool HasTableMappings ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasTableMappings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.HasTableMappings" />
      <MemberSignature Language="VB.NET" Value="Protected Function HasTableMappings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool HasTableMappings();" />
      <MemberSignature Language="F#" Value="member this.HasTableMappings : unit -&gt; bool" Usage="dataAdapter.HasTableMappings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="T:System.Data.Common.DataTableMappingCollection" /> został utworzony.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Data.Common.DataTableMappingCollection" /> został utworzony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MissingMappingAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingMappingAction MissingMappingAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingMappingAction MissingMappingAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DataAdapter.MissingMappingAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingMappingAction As MissingMappingAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingMappingAction MissingMappingAction { System::Data::MissingMappingAction get(); void set(System::Data::MissingMappingAction value); };" />
      <MemberSignature Language="F#" Value="member this.MissingMappingAction : System.Data.MissingMappingAction with get, set" Usage="System.Data.Common.DataAdapter.MissingMappingAction" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDataAdapter.MissingMappingAction</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.MissingMappingAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa akcję wykonywaną, gdy przychodzących danych nie ma pasującego tabeli lub kolumny.</summary>
        <value>Jeden z <see cref="T:System.Data.MissingMappingAction" /> wartości. Wartość domyślna to <see langword="Passthrough" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DataAdapter.TableMappings%2A> Właściwość zapewnia wzorca mapowanie między zwróconych rekordów i <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę pochodną, <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DataAdapter.MissingMappingAction Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataAdapter.MissingMappingAction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataAdapter.MissingMappingAction Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataAdapter.MissingMappingAction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podana wartość nie jest jednym z <see cref="T:System.Data.MissingMappingAction" /> wartości.</exception>
        <altmember cref="P:System.Data.Common.DataAdapter.MissingSchemaAction" />
      </Docs>
    </Member>
    <Member MemberName="MissingSchemaAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingSchemaAction MissingSchemaAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingSchemaAction MissingSchemaAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DataAdapter.MissingSchemaAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingSchemaAction As MissingSchemaAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingSchemaAction MissingSchemaAction { System::Data::MissingSchemaAction get(); void set(System::Data::MissingSchemaAction value); };" />
      <MemberSignature Language="F#" Value="member this.MissingSchemaAction : System.Data.MissingSchemaAction with get, set" Usage="System.Data.Common.DataAdapter.MissingSchemaAction" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDataAdapter.MissingSchemaAction</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.MissingSchemaAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa akcję wykonywaną po istniejących <see cref="T:System.Data.DataSet" /> schematu nie pasuje do przychodzących danych.</summary>
        <value>Jeden z <see cref="T:System.Data.MissingSchemaAction" /> wartości. Wartość domyślna to <see langword="Add" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy klasę pochodną, <xref:System.Data.OleDb.OleDbDataAdapter> i ustawia niektóre jego właściwości.  
  
 [!code-csharp[Classic WebData DataAdapter.MissingMappingAction Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataAdapter.MissingMappingAction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataAdapter.MissingMappingAction Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataAdapter.MissingMappingAction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podana wartość nie jest jednym z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</exception>
        <altmember cref="P:System.Data.Common.DataAdapter.MissingMappingAction" />
      </Docs>
    </Member>
    <Member MemberName="OnFillError">
      <MemberSignature Language="C#" Value="protected virtual void OnFillError (System.Data.FillErrorEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFillError(class System.Data.FillErrorEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.OnFillError(System.Data.FillErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFillError (value As FillErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFillError(System::Data::FillErrorEventArgs ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnFillError : System.Data.FillErrorEventArgs -&gt; unit&#xA;override this.OnFillError : System.Data.FillErrorEventArgs -&gt; unit" Usage="dataAdapter.OnFillError value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.FillErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Data.FillErrorEventArgs" /> obiektu.</param>
        <summary>Wywoływane, gdy wystąpi błąd podczas <see langword="Fill" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFillLoadOption">
      <MemberSignature Language="C#" Value="public void ResetFillLoadOption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetFillLoadOption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.ResetFillLoadOption" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetFillLoadOption ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetFillLoadOption();" />
      <MemberSignature Language="F#" Value="member this.ResetFillLoadOption : unit -&gt; unit" Usage="dataAdapter.ResetFillLoadOption " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Data.Common.DataAdapter.FillLoadOption" /> do stanu domyślnego i przyczyny <see cref="M:System.Data.Common.DataAdapter.Fill(System.Data.DataSet)" /> uwzględnić <see cref="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnProviderSpecificTypes">
      <MemberSignature Language="C#" Value="public virtual bool ReturnProviderSpecificTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReturnProviderSpecificTypes" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DataAdapter.ReturnProviderSpecificTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReturnProviderSpecificTypes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReturnProviderSpecificTypes { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReturnProviderSpecificTypes : bool with get, set" Usage="System.Data.Common.DataAdapter.ReturnProviderSpecificTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czy <see langword="Fill" /> metoda powinna zwrócić specyficznego dla dostawcy wartości lub wartości typowych zgodne ze specyfikacją CLS.</summary>
        <value>
          <see langword="true" /> Jeśli <see langword="Fill" /> metoda powinna zwrócić wartości specyficznych dla dostawcy; w przeciwnym razie <see langword="false" /> do zwrócenia wartości typowych zgodne ze specyfikacją CLS.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna to `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeAcceptChangesDuringFill">
      <MemberSignature Language="C#" Value="public virtual bool ShouldSerializeAcceptChangesDuringFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldSerializeAcceptChangesDuringFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.ShouldSerializeAcceptChangesDuringFill" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ShouldSerializeAcceptChangesDuringFill () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ShouldSerializeAcceptChangesDuringFill();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeAcceptChangesDuringFill : unit -&gt; bool&#xA;override this.ShouldSerializeAcceptChangesDuringFill : unit -&gt; bool" Usage="dataAdapter.ShouldSerializeAcceptChangesDuringFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy <see cref="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" /> powinien zostać utrwalony właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" /> właściwość jest utrwalona; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeFillLoadOption">
      <MemberSignature Language="C#" Value="public virtual bool ShouldSerializeFillLoadOption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldSerializeFillLoadOption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.ShouldSerializeFillLoadOption" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ShouldSerializeFillLoadOption () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ShouldSerializeFillLoadOption();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeFillLoadOption : unit -&gt; bool&#xA;override this.ShouldSerializeFillLoadOption : unit -&gt; bool" Usage="dataAdapter.ShouldSerializeFillLoadOption " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy <see cref="P:System.Data.Common.DataAdapter.FillLoadOption" /> powinien zostać utrwalony właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Data.Common.DataAdapter.FillLoadOption" /> właściwość jest utrwalona; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTableMappings">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTableMappings ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTableMappings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.ShouldSerializeTableMappings" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTableMappings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTableMappings();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTableMappings : unit -&gt; bool&#xA;override this.ShouldSerializeTableMappings : unit -&gt; bool" Usage="dataAdapter.ShouldSerializeTableMappings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy jest to jeden lub więcej <see cref="T:System.Data.Common.DataTableMapping" /> istnieją obiekty i powinny one zostać utrwalona.</summary>
        <returns>
          <see langword="true" /> Jeśli co najmniej jeden <see cref="T:System.Data.Common.DataTableMapping" /> obiektów istnieje; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDataAdapter.TableMappings">
      <MemberSignature Language="C#" Value="System.Data.ITableMappingCollection System.Data.IDataAdapter.TableMappings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ITableMappingCollection System.Data.IDataAdapter.TableMappings" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DataAdapter.System#Data#IDataAdapter#TableMappings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property TableMappings As ITableMappingCollection Implements IDataAdapter.TableMappings" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::ITableMappingCollection ^ System.Data.IDataAdapter.TableMappings { System::Data::ITableMappingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Data.Common.DataAdapter.System.Data.IDataAdapter.TableMappings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDataAdapter.TableMappings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.ITableMappingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, jak tabela źródłowa jest zamapowana do tabeli dataset.</summary>
        <value>Kolekcja, która zapewnia wzorca mapowanie między zwróconych rekordów i <see cref="T:System.Data.DataSet" />. Wartość domyślna to pustej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DataAdapter> wystąpienia jest rzutowane na <xref:System.Data.IDataAdapter> interfejsu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDataAdapter.TableMappings%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableMappings">
      <MemberSignature Language="C#" Value="public System.Data.Common.DataTableMappingCollection TableMappings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DataTableMappingCollection TableMappings" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DataAdapter.TableMappings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TableMappings As DataTableMappingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DataTableMappingCollection ^ TableMappings { System::Data::Common::DataTableMappingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TableMappings : System.Data.Common.DataTableMappingCollection" Usage="System.Data.Common.DataAdapter.TableMappings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DataTableMappingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję, która zapewnia wzorca mapowanie między tabeli źródłowej i a <see cref="T:System.Data.DataTable" />.</summary>
        <value>Kolekcja, która zapewnia wzorca mapowanie między zwróconych rekordów i <see cref="T:System.Data.DataSet" />. Wartość domyślna to pustej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas uzgadniania zmian, <xref:System.Data.Common.DataAdapter> używa <xref:System.Data.Common.DataTableMappingCollection> kolekcji do skojarzenia nazwy kolumn używany przez źródło danych z nazwy kolumny używane przez <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto w klasie pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, aby dodać <xref:System.Data.Common.DataTableMapping> obiekty do jego <xref:System.Data.Common.DataAdapter.TableMappings%2A> kolekcji i wyświetlić wykaz mapowane źródła tabel. W tym przykładzie założono, że <xref:System.Data.OleDb.OleDbDataAdapter> został już utworzony.  
  
 [!code-csharp[Classic WebData DataAdapter.TableMappings Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataAdapter.TableMappings Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataAdapter.TableMappings Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataAdapter.TableMappings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public virtual int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Update(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="abstract member Update : System.Data.DataSet -&gt; int&#xA;override this.Update : System.Data.DataSet -&gt; int" Usage="dataAdapter.Update dataSet" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Update(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see cref="T:System.Data.DataSet" /> Używana do aktualizowania źródła danych.</param>
        <summary>Wywołuje odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w określonej <see cref="T:System.Data.DataSet" /> z <see cref="T:System.Data.DataTable" /> o nazwie "Tabela".</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aktualizacja jest wykonywana na podstawie według wierszy. Dla każdego wiersza wstawiony, modyfikacji i usunięto <xref:System.Data.Common.DataAdapter.Update%2A> Metoda określa typ zmiany, która ma zostać wykonane na nim (wstawiania, aktualizacji lub usuwania). W zależności od rodzaju zmiany `Insert`, `Update,` lub `Delete` wykonuje polecenie szablonu propagację zmodyfikowanych wierszy w źródle danych. Gdy aplikacja wywołuje <xref:System.Data.Common.DataAdapter.Update%2A> metody <xref:System.Data.Common.DataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.Common.DataAdapter.Update%2A> może wykonania instrukcji DELETE, następuje instrukcji INSERT, a następnie inne instrukcji DELETE, właściwym do kolejność wierszy w <xref:System.Data.DataTable>.  
  
 Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład, Wstaw przed AKTUALIZACJĄ). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DataAdapter.Update%2A> metoda generuje wyjątek. Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DataAdapter.Update%2A> Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji. <xref:System.Data.Common.DataAdapter.Update%2A> Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Dodatkowe wiersze zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie. Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.Common.DataAdapter.Update%2A>, kolejność wykonywania jest następujący:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenia.  
  
3.  Wykonuje polecenia.  
  
4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, wtedy pierwszy zwrócone wyniki są umieszczane w <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenia.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A?displayProperty=nameWithType> jest wywoływana. To spowoduje podniesienie zarówno <xref:System.Data.DataTable.RowChanging?displayProperty=nameWithType> i <xref:System.Data.DataTable.RowChanged?displayProperty=nameWithType> zdarzenia dla zaktualizowanego <xref:System.Data.DataRow>.  
  
 Każde polecenie skojarzone z <xref:System.Data.Common.DataAdapter> zwykle ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny który <xref:System.Data.Common.DataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działań|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródła i nazwy tabeli w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|A <xref:System.SystemException> jest generowany. Mapowania są jawnie ustawiona, brakuje mapowania parametru wejściowego jest zazwyczaj wynikiem błędu.|  
|`MissingMappingAction.Error`|A <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.  
  
 Wywoływanie <xref:System.Data.DataSet.AcceptChanges%2A> metody lub <xref:System.Data.DataTable.AcceptChanges%2A> metoda będzie potwierdzisz wszystkich zmian w <xref:System.Data.DataSet> lub <xref:System.Data.DataTable>. Jeśli każda z tych metod są wywoływane przed <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda jest wywoływana, żadne zmiany nie będzie zatwierdzone kiedy <xref:System.Data.Common.DbDataAdapter.Update%2A> metoda jest wywoływana, chyba że zostały wprowadzone zmiany od <xref:System.Data.DataSet.AcceptChanges%2A> lub <xref:System.Data.DataTable.AcceptChanges%2A> została wywołana.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
>   
>  Dla każdej kolumny, która propagowane do źródła danych na <xref:System.Data.Common.DataAdapter.Update%2A>, parametr powinien zostać dodany do `InsertCommand`, `UpdateCommand`, lub `DeleteCommand`. `SourceColumn` Właściwość parametru należy ustawić nazwę kolumny. To ustawienie wskazuje, że wartość parametru nie ustawiono ręcznie, ale jest pobierana z określonej kolumny w wierszu przetworzono obecnie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, do <xref:System.Data.Common.DataAdapter.Update%2A> źródła danych.  
  
 [!code-csharp[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tabela źródłowa jest nieprawidłowa.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="HybridDictionary" FullName="System.Collections.Specialized.HybridDictionary">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="92732dfbc835faf5c583b6f7670cdae667875b86" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30440685" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HybridDictionary : System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HybridDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Specialized.HybridDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class HybridDictionary&#xA;Implements IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class HybridDictionary : System::Collections::IDictionary" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Specialized</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementuje <see langword="IDictionary" /> za pomocą <see cref="T:System.Collections.Specialized.ListDictionary" /> gdy kolekcja jest mały, a następnie przechodząc do <see cref="T:System.Collections.Hashtable" /> podczas dużych pobiera kolekcji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest zalecane w przypadku, gdy liczba elementów w słowniku jest nieznany. Korzysta z zwiększonej wydajności <xref:System.Collections.Specialized.ListDictionary> z kolekcjami małe i zapewnia elastyczność przełączania do <xref:System.Collections.Hashtable> który obsługuje większą kolekcje lepszym rozwiązaniem niż <xref:System.Collections.Specialized.ListDictionary>.  
  
 Jeśli początkowy rozmiar kolekcji jest większa niż optymalny rozmiar <xref:System.Collections.Specialized.ListDictionary>, kolekcji znajduje się w <xref:System.Collections.Hashtable> Aby uniknąć ponoszenia dodatkowych nakładów kopiowanie elementów z <xref:System.Collections.Specialized.ListDictionary> do <xref:System.Collections.Hashtable>.  
  
 Konstruktor akceptuje parametrem logicznym, który umożliwia użytkownikowi określenie, czy kolekcja ignoruje wielkość liter podczas porównywania ciągów. Jeśli kolekcja jest rozróżniana wielkość liter, używa klucza implementacje <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Jeśli kolekcja jest rozróżniana wielkość liter, wykonuje proste porównania bez uwzględniania wielkości liter porządkowej, który przestrzega zasad wielkości liter Niezmienna kultura. Domyślnie kolekcja jest rozróżniana wielkość liter. Aby uzyskać więcej informacji dotyczących Niezmienna kultura, zobacz <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>.  
  
 Klucz nie może mieć wartości null, ale można wartość.  
  
 `foreach` Instrukcji języka C# (`For Each` w języku Visual Basic) zwraca obiekt typu elementów w kolekcji. Ponieważ każdy element <xref:System.Collections.Specialized.HybridDictionary> parę klucz/wartość jest typu elementu nie jest typu klucza lub typ wartości. Zamiast tego jest typ elementu <xref:System.Collections.DictionaryEntry>. Na przykład:  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/source2.cpp#2)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/source2.cs#2)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/source2.vb#2)]  
  
 `foreach` Instrukcja jest otokę moduł wyliczający, który zezwala tylko odczyt z bez zapisywania do kolekcji.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka właściwości i metod <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/hybriddictionary.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/hybriddictionary.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/hybriddictionary.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
 Ta implementacja nie zapewnia zsynchronizowany otoki (wielowątkowość) dla <see cref="T:System.Collections.Specialized.HybridDictionary" />, ale klas pochodnych można tworzyć własne zsynchronizowane wersje <see cref="T:System.Collections.Specialized.HybridDictionary" /> przy użyciu <see cref="P:System.Collections.Specialized.HybridDictionary.SyncRoot" /> właściwości.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</threadsafe>
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Specialized.ListDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.CaseInsensitiveHashCodeProvider" />
    <altmember cref="M:System.Object.GetHashCode" />
    <altmember cref="M:System.Object.Equals(System.Object)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Specialized.HybridDictionary" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HybridDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HybridDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy pustą z uwzględnieniem wielkości liter <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie kolekcji jest rozróżniana wielkość liter i używa klucza stosowania <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> jako dostawcy kodu wyznaczania wartości skrótu i stosowania klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType> jako funkcja porównująca.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Specialized.HybridDictionary> muszą być unikatowe.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka właściwości i metod <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/hybriddictionary.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/hybriddictionary.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/hybriddictionary.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HybridDictionary (bool caseInsensitive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool caseInsensitive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (caseInsensitive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HybridDictionary(bool caseInsensitive);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="caseInsensitive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="caseInsensitive">Wartość logiczna, która określa, czy <see cref="T:System.Collections.Specialized.HybridDictionary" /> jest rozróżniana wielkość liter.</param>
        <summary>Tworzy pustą <see cref="T:System.Collections.Specialized.HybridDictionary" /> z określonym uwzględniana wielkość liter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `caseInsensitive` jest `false`, Kolekcja używa klucza implementacje <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Jeśli `caseInsensitive` jest `true`, kolekcji wykonuje proste porównania bez uwzględniania wielkości liter porządkowej, który przestrzega zasad wielkości liter Niezmienna kultura. Aby uzyskać więcej informacji dotyczących Niezmienna kultura, zobacz <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>.  
  
 Ten konstruktor jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HybridDictionary (int initialSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HybridDictionary(int initialSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialSize">Przybliżoną liczbę wpisów który <see cref="T:System.Collections.Specialized.HybridDictionary" /> początkowo może zawierać.</param>
        <summary>Tworzy uwzględniającego wielkość liter <see cref="T:System.Collections.Specialized.HybridDictionary" /> o określonym rozmiarze początkowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli początkowy rozmiar kolekcji jest większa niż optymalny rozmiar <xref:System.Collections.Specialized.ListDictionary>, kolekcji znajduje się w <xref:System.Collections.Hashtable> Aby uniknąć ponoszenia dodatkowych nakładów kopiowanie elementów z <xref:System.Collections.Specialized.ListDictionary> do <xref:System.Collections.Hashtable>.  
  
 Domyślnie kolekcji jest rozróżniana wielkość liter i używa klucza stosowania <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> jako dostawcy kodu wyznaczania wartości skrótu i stosowania klucza <xref:System.Object.Equals%2A?displayProperty=nameWithType> jako funkcja porównująca.  
  
 Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Specialized.HybridDictionary> muszą być unikatowe.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest `initialSize`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HybridDictionary (int initialSize, bool caseInsensitive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialSize, bool caseInsensitive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.#ctor(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialSize As Integer, caseInsensitive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HybridDictionary(int initialSize, bool caseInsensitive);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialSize" Type="System.Int32" />
        <Parameter Name="caseInsensitive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initialSize">Przybliżoną liczbę wpisów który <see cref="T:System.Collections.Specialized.HybridDictionary" /> początkowo może zawierać.</param>
        <param name="caseInsensitive">Wartość logiczna, która określa, czy <see cref="T:System.Collections.Specialized.HybridDictionary" /> jest rozróżniana wielkość liter.</param>
        <summary>Tworzy <see cref="T:System.Collections.Specialized.HybridDictionary" /> z określonym początkowy rozmiar i uwzględnianie wielkości liter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli początkowy rozmiar kolekcji jest większa niż optymalny rozmiar <xref:System.Collections.Specialized.ListDictionary>, kolekcji znajduje się w <xref:System.Collections.Hashtable> Aby uniknąć ponoszenia dodatkowych nakładów kopiowanie elementów z <xref:System.Collections.Specialized.ListDictionary> do <xref:System.Collections.Hashtable>.  
  
 Jeśli `caseInsensitive` jest `false`, Kolekcja używa klucza implementacje <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Jeśli `caseInsensitive` jest `true`, kolekcji wykonuje proste porównania bez uwzględniania wielkości liter porządkowej, który przestrzega zasad wielkości liter Niezmienna kultura. Aby uzyskać więcej informacji dotyczących Niezmienna kultura, zobacz <xref:System.Globalization.CultureInfo?displayProperty=nameWithType>.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest `initialSize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wpisu do dodania.</param>
        <param name="value">Wartość wpisu do dodania. Wartość może być <see langword="null" />.</param>
        <summary>Dodaje wpis o określonym kluczu i wartości do <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj obiekt, który ma korelacja stanu i jego wartość kodu skrótu nie zostać użyta jako klucz. Na przykład ciąg obiekty są lepszym rozwiązaniem niż obiekty StringBuilder do użycia jako klucze.  
  
 Klucz nie może być `null`, ale wartość można.  
  
 Można również użyć <xref:System.Collections.Specialized.HybridDictionary.Item%2A> właściwości, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <xref:System.Collections.Specialized.HybridDictionary>, na przykład `myCollection["myNonexistentKey"] = myValue`. Jednak jeśli określony klucz już istnieje w <xref:System.Collections.Specialized.HybridDictionary>, ustawienie <xref:System.Collections.Specialized.HybridDictionary.Item%2A> stara wartość jest zastąpienie właściwości. Z kolei <xref:System.Collections.Specialized.HybridDictionary.Add%2A> — metoda nie modyfikuje istniejące elementy.  
  
 Gdy liczba elementów staje się większa niż optymalny rozmiar <xref:System.Collections.Specialized.ListDictionary>, elementy są kopiowane z <xref:System.Collections.Specialized.ListDictionary> do <xref:System.Collections.Hashtable>. Jednak to występuje tylko raz. Jeśli kolekcja jest już zapisana w <xref:System.Collections.Hashtable> i liczby elementów spadnie poniżej optymalny rozmiar <xref:System.Collections.Specialized.ListDictionary>, połączenie pozostaje w <xref:System.Collections.Hashtable>.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje i usuwa elementy z <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CPP/hybriddictionary_addremove.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CS/hybriddictionary_addremove.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/VB/hybriddictionary_addremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wpis z tym samym kluczem już istnieje w <see cref="T:System.Collections.Specialized.HybridDictionary" />.</exception>
        <altmember cref="M:System.Collections.Specialized.HybridDictionary.Remove(System.Object)" />
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie wpisy z <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Specialized.HybridDictionary.Count%2A> jest ustawiany na zero, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji.  
  
 Jeśli kolekcja jest już zapisana w <xref:System.Collections.Hashtable>, połączenie pozostaje w <xref:System.Collections.Hashtable>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Specialized.HybridDictionary.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje i usuwa elementy z <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CPP/hybriddictionary_addremove.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CS/hybriddictionary_addremove.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/VB/hybriddictionary_addremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.IDictionary.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Collections.Specialized.HybridDictionary" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Specialized.HybridDictionary" /> zawiera określony klucz.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Specialized.HybridDictionary" /> zawiera wpis z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest operacją O(1).  
  
 Począwszy od programu .NET Framework 2.0, ta metoda używa obiektów kolekcji <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metod `key` ustalenie, czy `item` istnieje. We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `item` parametrów dla obiektów w kolekcji.  
  
   
  
## Examples  
 Poniższy kod przykładowe wyszukiwania dla elementu w <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Contains/CPP/hybriddictionary_contains.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Contains/CS/hybriddictionary_contains.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Contains/VB/hybriddictionary_contains.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> czyli miejsce docelowe <see cref="T:System.Collections.DictionaryEntry" /> obiektów kopiowanych ze <see cref="T:System.Collections.Specialized.HybridDictionary" />. <see cref="T:System.Array" /> Musi mieć indeksowania liczony od zera.</param>
        <param name="index">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopie <see cref="T:System.Collections.Specialized.HybridDictionary" /> wpisy na jednowymiarowe <see cref="T:System.Array" /> wystąpienia pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Specialized.HybridDictionary>.  
  
 Aby skopiować tylko klucze w <xref:System.Collections.Specialized.HybridDictionary>, użyj `HybridDictionary.Keys.CopyTo`.  
  
 Aby skopiować tylko wartości w <xref:System.Collections.Specialized.HybridDictionary>, użyj `HybridDictionary.Values.CopyTo`.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Specialized.HybridDictionary.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykładowy kod kopiuje elementy <xref:System.Collections.Specialized.HybridDictionary> do tablicy.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_CopyTo/CPP/hybriddictionary_copyto.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_CopyTo/CS/hybriddictionary_copyto.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_CopyTo/VB/hybriddictionary_copyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> jest wielowymiarowy.  
  
 —lub—  
  
 Liczba elementów w źródle <see cref="T:System.Collections.Specialized.HybridDictionary" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Typ źródła <see cref="T:System.Collections.Specialized.HybridDictionary" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.Specialized.HybridDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę par klucz/wartość zawartych w <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <value>Liczba par klucz/wartość zawartych w <see cref="T:System.Collections.Specialized.HybridDictionary" />.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wylicza elementy <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IDictionaryEnumerator" /> który iteruje <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> Dla <see cref="T:System.Collections.Specialized.HybridDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> również wprowadzono moduł wyliczający wróć do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> aby pierwszym elementem kolekcji ponownie, należy wywołać <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu wylicza elementy <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Specialized.HybridDictionary" /> ma stały rozmiar.</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Specialized.HybridDictionary> implementuje <xref:System.Collections.Specialized.HybridDictionary.IsFixedSize%2A> właściwości, ponieważ jest to wymagane przez <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu.  
  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 Kolekcja o stałym rozmiarze jest po prostu kolekcji z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym zmian w źródłowej kolekcji, włączając Dodawanie lub usuwanie elementów z kolekcji o stałym rozmiarze odzwierciedla te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Specialized.HybridDictionary" /> jest tylko do odczytu.</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Specialized.HybridDictionary> implementuje <xref:System.Collections.Specialized.HybridDictionary.IsReadOnly%2A> właściwości, ponieważ jest to wymagane przez <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu.  
  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Specialized.HybridDictionary" /> jest synchronizowane (wielowątkowość).</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Specialized.HybridDictionary> implementuje <xref:System.Collections.Specialized.HybridDictionary.IsSynchronized%2A> właściwości, ponieważ jest to wymagane przez <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu.  
  
 Klasy pochodne zapewniają zsynchronizowanej wersji <xref:System.Collections.Specialized.HybridDictionary> przy użyciu <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> właściwości.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> podczas całej wyliczenia.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/source2.cs#3)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/source2.vb#3)]  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wartości, których można pobrać lub ustawić.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z określonym kluczem.</summary>
        <value>Wartość skojarzona z określonym kluczem. Jeśli określony klucz nie zostanie znaleziony, próby pobrania jej zwraca <see langword="null" />, a próba skonfigurowania go tworzy nowy wpis przy użyciu określonego klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]`.  
  
 Można również użyć <xref:System.Collections.Specialized.HybridDictionary.Item%2A> właściwości, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <xref:System.Collections.Specialized.HybridDictionary>, na przykład `myCollection["myNonexistentKey"] = myValue`. Jednak jeśli określony klucz już istnieje w <xref:System.Collections.Specialized.HybridDictionary>, ustawienie <xref:System.Collections.Specialized.HybridDictionary.Item%2A> stara wartość jest zastąpienie właściwości. Z kolei <xref:System.Collections.Specialized.HybridDictionary.Add%2A> — metoda nie modyfikuje istniejące elementy.  
  
 Klucz nie może być `null`, ale wartość można. Aby odróżnić `null` który jest zwracany, ponieważ nie odnaleziono określonego klucza i `null` który jest zwracany, ponieważ wartość określony klucz jest `null`, użyj <xref:System.Collections.Specialized.HybridDictionary.Contains%2A> metodę, aby określić, czy klucz znajduje się na liście.  
  
 Używa języka C# do definiowania indeksatory zamiast implementacja słowa kluczowego <xref:System.Collections.Specialized.HybridDictionary.Item%2A> właściwości. Implementuje Visual Basic <xref:System.Collections.Specialized.HybridDictionary.Item%2A> jako domyślna właściwość, która zapewnia te same funkcje indeksowania.  
  
 Pobieranie wartości tej właściwości jest operacją O(1); Ustawienie właściwości jest również O(1) operacji.  
  
   
  
## Examples  
 Poniższy przykład kodu wylicza elementy <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Specialized.HybridDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ICollection" /> zawierającą klucze ze słownika <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Zawierającą klucze ze słownika <see cref="T:System.Collections.Specialized.HybridDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości w <xref:System.Collections.ICollection> jest nieokreślony, ale takiej samej kolejności jak skojarzone wartości w <xref:System.Collections.ICollection> zwrócony przez <xref:System.Collections.Specialized.HybridDictionary.Values%2A> metody.  
  
 Zwrócona <xref:System.Collections.ICollection> nie jest statyczna kopia; zamiast tego <xref:System.Collections.ICollection> odwołuje się do kluczy w oryginalnym <xref:System.Collections.Specialized.HybridDictionary>. W związku z tym zmiany <xref:System.Collections.Specialized.HybridDictionary> kontynuować zostaną odzwierciedlone w <xref:System.Collections.ICollection>.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu wylicza elementy <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.Values" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wpisu do usunięcia.</param>
        <summary>Usuwa wpis z określonym kluczem z <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Collections.Specialized.HybridDictionary> nie zawiera element z określonym kluczem <xref:System.Collections.Specialized.HybridDictionary> pozostaje niezmieniona. Nie wyjątek.  
  
 Jeśli kolekcja jest już zapisana w <xref:System.Collections.Hashtable> i liczby elementów spadnie poniżej optymalny rozmiar <xref:System.Collections.Specialized.ListDictionary>, połączenie pozostaje w <xref:System.Collections.Hashtable> Aby uniknąć ponoszenia dodatkowych nakładów kopiowanie elementów z <xref:System.Collections.Hashtable> do <xref:System.Collections.Specialized.ListDictionary>.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje i usuwa elementy z <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CPP/hybriddictionary_addremove.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/CS/hybriddictionary_addremove.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_AddRemove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_AddRemove/VB/hybriddictionary_addremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Specialized.HybridDictionary.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.Specialized.HybridDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne zapewniają własne zsynchronizowanej wersji <xref:System.Collections.Specialized.HybridDictionary> przy użyciu <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> właściwości. Synchronizowanie kodu musi wykonywać operacje <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> z <xref:System.Collections.Specialized.HybridDictionary>, nie są bezpośrednio w <xref:System.Collections.Specialized.HybridDictionary>. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie <xref:System.Collections.Specialized.HybridDictionary> obiektu.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <xref:System.Collections.Specialized.HybridDictionary.SyncRoot%2A> podczas całej wyliczenia.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/CS/source2.cs#3)]
 [!code-vb[System.Collections.Specialized.HybridDictionary2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary2/VB/source2.vb#3)]  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.HybridDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IEnumerator" /> który iteruje <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Dla <see cref="T:System.Collections.Specialized.HybridDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> również wprowadzono moduł wyliczający wróć do tej pozycji. At to pozycja, wywoływania <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, wywoływania <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> aby pierwszym elementem kolekcji ponownie, należy wywołać <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie unieważniona, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>. Jeśli kolekcja jest zmodyfikowany między <xref:System.Collections.IEnumerator.MoveNext%2A> i <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> zwraca element, który ma ustawioną, nawet wtedy, gdy moduł wyliczający jest już unieważnione.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu wylicza elementy <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.HybridDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ICollection" /> zawierający wartości w <see cref="T:System.Collections.Specialized.HybridDictionary" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Zawierający wartości w <see cref="T:System.Collections.Specialized.HybridDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność wartości na liście <xref:System.Collections.ICollection> jest nieokreślony, ale takiej samej kolejności jak skojarzonych kluczy w <xref:System.Collections.ICollection> zwrócony przez <xref:System.Collections.Specialized.HybridDictionary.Keys%2A> — metoda.  
  
 Zwrócona <xref:System.Collections.ICollection> nie jest statyczna kopia; zamiast tego <xref:System.Collections.ICollection> odwołuje się do wartości w oryginalnym <xref:System.Collections.Specialized.HybridDictionary>. W związku z tym zmiany <xref:System.Collections.Specialized.HybridDictionary> kontynuować zostaną odzwierciedlone w <xref:System.Collections.ICollection>.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu wylicza elementy <xref:System.Collections.Specialized.HybridDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CPP/hybriddictionary_enumerator.cpp#1)]
 [!code-csharp[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/CS/hybriddictionary_enumerator.cs#1)]
 [!code-vb[System.Collections.Specialized.HybridDictionary_Enumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.HybridDictionary_Enumerator/VB/hybriddictionary_enumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Specialized.HybridDictionary.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>
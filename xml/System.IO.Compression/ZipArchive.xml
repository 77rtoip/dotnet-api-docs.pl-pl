<Type Name="ZipArchive" FullName="System.IO.Compression.ZipArchive">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8aa112e0006bb75b9641b55af12c5e9201d94a50" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51865844" /></Metadata><TypeSignature Language="C#" Value="public class ZipArchive : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ZipArchive extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Compression.ZipArchive" />
  <TypeSignature Language="VB.NET" Value="Public Class ZipArchive&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ZipArchive : IDisposable" />
  <TypeSignature Language="F#" Value="type ZipArchive = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Compression</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje pakiet skompresowanych plików w formacie archiwum zip.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody do manipulowania archiwa zip i ich we wpisach w plikach są dystrybuowane między trzy klasy: <xref:System.IO.Compression.ZipFile>, <xref:System.IO.Compression.ZipArchive>, i <xref:System.IO.Compression.ZipArchiveEntry>.  
  
|Zadanie|Zastosowanie|  
|--------|---------|  
|Utwórz archiwum zip z katalogu|<xref:System.IO.Compression.ZipFile.CreateFromDirectory%2A?displayProperty=nameWithType>|  
|Wyodrębnij zawartość archiwum zip do katalogu|<xref:System.IO.Compression.ZipFile.ExtractToDirectory%2A?displayProperty=nameWithType>|  
|Dodaj nowe pliki do istniejącego archiwum zip|<xref:System.IO.Compression.ZipArchive.CreateEntry%2A?displayProperty=nameWithType>|  
|Pobieranie pliku z archiwum zip|<xref:System.IO.Compression.ZipArchive.GetEntry%2A?displayProperty=nameWithType>|  
|Pobierz wszystkie pliki z archiwum zip|<xref:System.IO.Compression.ZipArchive.Entries%2A?displayProperty=nameWithType>|  
|Otwórz strumień do pojedynczego pliku zawarte w archiwum zip|<xref:System.IO.Compression.ZipArchiveEntry.Open%2A?displayProperty=nameWithType>|  
|Usuwanie pliku z archiwum zip|<xref:System.IO.Compression.ZipArchiveEntry.Delete%2A?displayProperty=nameWithType>|  
  
 Podczas tworzenia nowego wpisu pliku jest skompresowany i dodawane do pakietu zip. <xref:System.IO.Compression.ZipArchive.CreateEntry%2A> Metody umożliwia określenie hierarchii katalogów, dodając wpis. Możesz dołączyć ścieżkę względną nowego wpisu w ramach pakietu zip. Na przykład, tworząc nowy wpis ze ścieżką względną `AddedFolder\NewFile.txt` tworzy plik skompresowany tekstu w katalogu o nazwie AddedFolder.  
  
 Jeśli odwołujesz się `System.IO.Compression.FileSystem` zestawu w projekcie są dostępne trzy metody rozszerzenia (z <xref:System.IO.Compression.ZipFileExtensions> klasy) dla <xref:System.IO.Compression.ZipArchive> klasy: <xref:System.IO.Compression.ZipFileExtensions.CreateEntryFromFile%2A>, <xref:System.IO.Compression.ZipFileExtensions.CreateEntryFromFile%2A>, i <xref:System.IO.Compression.ZipFileExtensions.ExtractToDirectory%2A>. Te metody rozszerzające umożliwiają kompresję i dekompresję zawartości wpis do pliku. `System.IO.Compression.FileSystem` Zestaw nie jest dostępny dla [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji. W [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji, użytkownik może kompresję i dekompresję plików za pomocą <xref:System.IO.Compression.DeflateStream> lub <xref:System.IO.Compression.GZipStream> klas, lub użyć [!INCLUDE[wrt](~/includes/wrt-md.md)] typy [modułu kompresji](https://go.microsoft.com/fwlink/p/?LinkID=246357) i [dekompresor](https://go.microsoft.com/fwlink/p/?LinkID=246358).  
  
   
  
## Examples  
 Pierwszy przykład pokazuje, jak utworzyć nowy wpis i zapisanie w nim przy użyciu strumienia.  
  
 [!code-csharp[System.IO.Compression.ZipArchiveMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipArchiveMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/vb/program1.vb#1)]  
  
 Poniższy przykład pokazuje, jak otworzyć archiwum zip i iterowania po kolekcji wpisów.  
  
 [!code-csharp[System.IO.Compression.ZipArchive#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchive/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipArchive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchive/vb/program1.vb#1)]  
  
 Trzeci przykład pokazuje, jak użyć metod rozszerzających do tworzenia nowego wpisu w archiwum zip z istniejącego pliku i wyodrębnić zawartość archiwum. Należy odwoływać się `System.IO.Compression.FileSystem` zestawu do wykonania kodu.  
  
 [!code-csharp[System.IO.Compression.ZipArchive#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchive/cs/program3.cs#3)]
 [!code-vb[System.IO.Compression.ZipArchive#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchive/vb/program3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Compression.ZipFile" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Compression.ZipArchive" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZipArchive (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZipArchive(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.ZipArchive : System.IO.Stream -&gt; System.IO.Compression.ZipArchive" Usage="new System.IO.Compression.ZipArchive stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, który zawiera archiwum do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Compression.ZipArchive" /> klasy z określonego strumienia.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Strumień jest już zamknięty lub nie obsługuje odczytu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.InvalidDataException">Zawartość strumienia nie są w formacie archiwum zip.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZipArchive (System.IO.Stream stream, System.IO.Compression.ZipArchiveMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.ZipArchiveMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream,System.IO.Compression.ZipArchiveMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZipArchive(System::IO::Stream ^ stream, System::IO::Compression::ZipArchiveMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.ZipArchive : System.IO.Stream * System.IO.Compression.ZipArchiveMode -&gt; System.IO.Compression.ZipArchive" Usage="new System.IO.Compression.ZipArchive (stream, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.IO.Compression.ZipArchiveMode" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień wejściowy lub wyjściowy.</param>
        <param name="mode">Jedna z wartości wyliczenia, które wskazuje, czy archiwum zip jest używana do odczytu, tworzenia i aktualizowania wpisów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Compression.ZipArchive" /> klasy z podanego strumienia i z określonym trybem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `mode` parametr ma wartość <xref:System.IO.Compression.ZipArchiveMode.Read>, strumień musi obsługiwać odczyt. Jeśli `mode` parametr ma wartość <xref:System.IO.Compression.ZipArchiveMode.Create>, strumień musi obsługiwać zapis. Jeśli `mode` parametr ma wartość <xref:System.IO.Compression.ZipArchiveMode.Update>, strumień musi obsługiwać, odczytywanie, zapisywanie i wyszukiwanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strumień jest już zamknięty lub możliwości strumienia nie są zgodne z trybu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> wartość jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.InvalidDataException">Nie można zinterpretować zawartość strumienia jako archiwum zip.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> i wpis brakuje archiwum lub jest uszkodzony i nie można odczytać.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> i wpis jest za duży, aby mieściły się w pamięci.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZipArchive (System.IO.Stream stream, System.IO.Compression.ZipArchiveMode mode, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.ZipArchiveMode mode, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream,System.IO.Compression.ZipArchiveMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZipArchive(System::IO::Stream ^ stream, System::IO::Compression::ZipArchiveMode mode, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.ZipArchive : System.IO.Stream * System.IO.Compression.ZipArchiveMode * bool -&gt; System.IO.Compression.ZipArchive" Usage="new System.IO.Compression.ZipArchive (stream, mode, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.IO.Compression.ZipArchiveMode" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień wejściowy lub wyjściowy.</param>
        <param name="mode">Jedna z wartości wyliczenia, które wskazuje, czy archiwum zip jest używana do odczytu, tworzenia i aktualizowania wpisów.</param>
        <param name="leaveOpen"><see langword="true" /> Aby pozostawić otwarty po strumienia <see cref="T:System.IO.Compression.ZipArchive" /> obiekt jest usunięte; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Compression.ZipArchive" /> klasy na określonego strumienia określony tryb i opcjonalnie pozostawia otworzyć strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `mode` parametr ma wartość <xref:System.IO.Compression.ZipArchiveMode.Read>, strumień musi obsługiwać odczyt. Jeśli `mode` parametr ma wartość <xref:System.IO.Compression.ZipArchiveMode.Create>, strumień musi obsługiwać zapis. Jeśli `mode` parametr ma wartość <xref:System.IO.Compression.ZipArchiveMode.Update>, strumień musi obsługiwać, odczytywanie, zapisywanie i wyszukiwanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strumień jest już zamknięty lub możliwości strumienia nie są zgodne z trybu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> wartość jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.InvalidDataException">Nie można zinterpretować zawartość strumienia jako archiwum zip.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> i wpis brakuje archiwum lub jest uszkodzony i nie można odczytać.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> i wpis jest za duży, aby mieściły się w pamięci.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZipArchive (System.IO.Stream stream, System.IO.Compression.ZipArchiveMode mode, bool leaveOpen, System.Text.Encoding entryNameEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.ZipArchiveMode mode, bool leaveOpen, class System.Text.Encoding entryNameEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream,System.IO.Compression.ZipArchiveMode,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZipArchive(System::IO::Stream ^ stream, System::IO::Compression::ZipArchiveMode mode, bool leaveOpen, System::Text::Encoding ^ entryNameEncoding);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.ZipArchive : System.IO.Stream * System.IO.Compression.ZipArchiveMode * bool * System.Text.Encoding -&gt; System.IO.Compression.ZipArchive" Usage="new System.IO.Compression.ZipArchive (stream, mode, leaveOpen, entryNameEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.IO.Compression.ZipArchiveMode" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
        <Parameter Name="entryNameEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień wejściowy lub wyjściowy.</param>
        <param name="mode">Jedna z wartości wyliczenia, które wskazuje, czy archiwum zip jest używana do odczytu, tworzenia i aktualizowania wpisów.</param>
        <param name="leaveOpen"><see langword="true" /> Aby pozostawić otwarty po strumienia <see cref="T:System.IO.Compression.ZipArchive" /> obiekt jest usunięte; w przeciwnym razie <see langword="false" />.</param>
        <param name="entryNameEncoding">Szyfrowanie do użycia podczas odczytu lub zapisu nazwy wpisów w tym archiwum. Wartość tego parametru należy określić tylko wtedy, gdy jest wymagane do współdziałania z narzędziami archiwum zip i bibliotek, które nie obsługują kodowania UTF-8 dla nazwy wpisów kodowanie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Compression.ZipArchive" /> klasy w określonej usłudze stream dla określonego trybu przy użyciu określonego kodowania dla nazwy wpisów i opcjonalnie pozostawia otwarty strumień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `mode` parametr ma wartość <xref:System.IO.Compression.ZipArchiveMode.Read>, strumień musi obsługiwać odczyt. Jeśli `mode` parametr ma wartość <xref:System.IO.Compression.ZipArchiveMode.Create>, strumień musi obsługiwać zapis. Jeśli `mode` parametr ma wartość <xref:System.IO.Compression.ZipArchiveMode.Update>, strumień musi obsługiwać, odczytywanie, zapisywanie i wyszukiwanie.  
  
 Po otwarciu pliku archiwum zip do odczytu i `entryNameEncoding` ustawiono `null`, wpis nazwy są dekodowane zgodnie z następującymi zasadami:  
  
-   Gdy języka kodowania Flaga (flaga bitowych ogólnego przeznaczenia nagłówek pliku lokalnego) nie jest ustawiona, bieżący domyślną stroną kodową systemu jest używany do zdekodowania nazwy wejścia.  
  
-   Gdy jest ustawiona flaga kodowania języka, UTF-8 służy do zdekodowania nazwy wejścia.  
  
 Po otwarciu pliku archiwum zip do odczytu i `entryNameEncoding` jest równa wartości innych niż `null`, wpis nazwy są dekodowane zgodnie z następującymi zasadami:  
  
-   Podczas kodowania flagi języka nie jest ustawiona, określony `entryNameEncoding` jest używany w celu zdekodowania nazwy wejścia.  
  
-   Gdy jest ustawiona flaga kodowania języka, UTF-8 służy do zdekodowania nazwy wejścia.  
  
 Podczas wpisywania do archiwizacji plików i `entryNameEncoding` ustawiono `null`, wpis nazwy są kodowane zgodnie z następującymi zasadami:  
  
-   Nazwy wpisów, które zawierają znaki spoza zakresu ASCII jest ustawiona flaga kodowania języka i wprowadzania nazwy są kodowane w formacie UTF-8.  
  
-   Dla nazwy wpisów, które zawierają tylko znaki ASCII nie jest ustawiona flaga kodowania języka i wprowadzania nazwy są kodowane za pomocą bieżącego domyślną stroną kodową systemu.  
  
 Podczas wpisywania do archiwizacji plików i `entryNameEncoding` jest równa wartości innych niż `null`, określony `entryNameEncoding` służy do zakodowania nazwy wpisów w bajtach. Standard kodowania Flaga (flaga bitowych ogólnego przeznaczenia nagłówek pliku lokalnego) jest ustawiona tylko wtedy, gdy określone kodowanie jest kodowanie UTF-8.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strumień jest już zamknięty lub możliwości strumienia nie są zgodne z trybu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> wartość jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.InvalidDataException">Nie można zinterpretować zawartość strumienia jako archiwum zip.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> i wpis brakuje archiwum lub jest uszkodzony i nie można odczytać.  
  
—lub— 
 <paramref name="mode" /> jest <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> i wpis jest za duży, aby mieściły się w pamięci.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEntry">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy pusty wpis w archiwum zip.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEntry">
      <MemberSignature Language="C#" Value="public System.IO.Compression.ZipArchiveEntry CreateEntry (string entryName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Compression.ZipArchiveEntry CreateEntry(string entryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.CreateEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntry (entryName As String) As ZipArchiveEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Compression::ZipArchiveEntry ^ CreateEntry(System::String ^ entryName);" />
      <MemberSignature Language="F#" Value="member this.CreateEntry : string -&gt; System.IO.Compression.ZipArchiveEntry" Usage="zipArchive.CreateEntry entryName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchiveEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entryName">Ścieżka względem katalogu głównego, archiwum, który określa nazwę wpisu, który ma zostać utworzony.</param>
        <summary>Tworzy pusty wpis, który ma określoną nazwę ścieżki i zapis w warstwie archiwum zip.</summary>
        <returns>Pusty wpis w archiwum zip.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `entryName` Ciągu powinny odzwierciedlać ścieżki względnej wejścia, którą chcesz utworzyć w archiwum zip. Nie ma żadnych ograniczeń na ciąg, który należy podać. Jednak jeśli nie jest sformatowany jako ścieżka względna, jest tworzony wpis, ale może wystąpić wyjątek podczas wyodrębniania zawartości archiwum zip. Jeśli wpis z określoną ścieżką i nazwą już istnieje w archiwum, drugi wpis zostanie utworzony przy użyciu tej samej ścieżki i nazwy.  
  
 Wartość <xref:System.IO.Compression.ZipArchiveEntry.LastWriteTime%2A> właściwość dla nowego wpisu jest ustawiona na bieżącą godzinę. Wpis jest skompresowany za pomocą domyślny poziom kompresji algorytm kompresji. Aby określić poziom kompresji, należy użyć <xref:System.IO.Compression.ZipArchive.CreateEntry%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wpis i zapisanie w nim przy użyciu strumienia.  
  
 [!code-csharp[System.IO.Compression.ZipArchiveMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipArchiveMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="entryName" /> jest <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="entryName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Archiwum zip nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Archiwum zip został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateEntry">
      <MemberSignature Language="C#" Value="public System.IO.Compression.ZipArchiveEntry CreateEntry (string entryName, System.IO.Compression.CompressionLevel compressionLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Compression.ZipArchiveEntry CreateEntry(string entryName, valuetype System.IO.Compression.CompressionLevel compressionLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.CreateEntry(System.String,System.IO.Compression.CompressionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Compression::ZipArchiveEntry ^ CreateEntry(System::String ^ entryName, System::IO::Compression::CompressionLevel compressionLevel);" />
      <MemberSignature Language="F#" Value="member this.CreateEntry : string * System.IO.Compression.CompressionLevel -&gt; System.IO.Compression.ZipArchiveEntry" Usage="zipArchive.CreateEntry (entryName, compressionLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchiveEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="compressionLevel" Type="System.IO.Compression.CompressionLevel" />
      </Parameters>
      <Docs>
        <param name="entryName">Ścieżka względem katalogu głównego, archiwum, który określa nazwę wpisu, który ma zostać utworzony.</param>
        <param name="compressionLevel">Jedna z wartości wyliczenia, które wskazuje, czy należy podkreślić skuteczności szybkości lub kompresji, tworząc wpis.</param>
        <summary>Tworzy pusty wpis, który ma poziom nazwy i kompresji określony wpis w archiwum zip.</summary>
        <returns>Pusty wpis w archiwum zip.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `entryName` Ciągu powinny odzwierciedlać ścieżki względnej wejścia, którą chcesz utworzyć w archiwum zip. Nie ma żadnych ograniczeń na ciąg, który należy podać. Jednak jeśli nie jest sformatowany jako ścieżka względna, jest tworzony wpis, ale może wystąpić wyjątek podczas wyodrębniania zawartości archiwum zip. Jeśli wpis o określonej nazwie już istnieje w archiwum, drugi wpis jest tworzony o takiej samej nazwie.  
  
 Wartość <xref:System.IO.Compression.ZipArchiveEntry.LastWriteTime%2A> właściwość dla nowego wpisu jest ustawiona na bieżącą godzinę. Ustaw `compressionLevel` parametr <xref:System.IO.Compression.CompressionLevel.Optimal> chcącym plików do skompresowania możliwie. Ustaw `compressionLevel` parametr <xref:System.IO.Compression.CompressionLevel.Fastest> tylko wtedy, gdy użytkownik niepokoisz się, że operacji kompresji nie ukończy wystarczająco szybko dla danego scenariusza.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wpis z poziomu optymalnej kompresji. Usługa również zapisuje do nowego wpisu przy użyciu strumienia.  
  
 [!code-csharp[System.IO.Compression.ZipArchiveMode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/cs/program2.cs#2)]
 [!code-vb[System.IO.Compression.ZipArchiveMode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/vb/program2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="entryName" /> jest <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="entryName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Archiwum zip nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Archiwum zip został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.IO.Compression.ZipArchive" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="zipArchive.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez bieżące wystąpienie <see cref="T:System.IO.Compression.ZipArchive" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zakończy zapisywanie archiwum i zwalnia wszystkie zasoby używane przez <xref:System.IO.Compression.ZipArchive> obiektu. Chyba że skonstruować obiekt za pomocą <xref:System.IO.Compression.ZipArchive.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.ZipArchiveMode%2CSystem.Boolean%29> przeciążenia konstruktora i ustaw jego `leaveOpen` parametr `true`, wszystkie strumienie podstawowej są zamknięte i nie jest już dostępna na potrzeby operacji zapisu kolejne.  
  
 Po zakończeniu korzystania z tego wystąpienia <xref:System.IO.Compression.ZipArchive>, wywołaj <xref:System.IO.Compression.ZipArchive.Dispose> zwolnić wszystkie zasoby używane przez to wystąpienie. Powinno wyeliminować dalsze odwołania do tego <xref:System.IO.Compression.ZipArchive> wystąpienia, aby moduł zbierający elementy bezużyteczne mógł odzyskać pamięć wystąpienia zamiast jego aktywność do finalizacji.  
  
 <xref:System.IO.Compression.ZipArchive.Dispose> wywołania <xref:System.IO.Compression.ZipArchive.Dispose%28System.Boolean%29> metody, która zawiera kod, aby zwolnić zasoby zarządzane i niezarządzane. Aby uzyskać więcej informacji, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="zipArchive.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Zakończ zapisywanie archiwum i zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Wywoływane przez <see cref="M:System.IO.Compression.ZipArchive.Dispose" /> i <see cref="M:System.Object.Finalize" /> metody, aby zwolnić zasoby niezarządzane używane przez bieżące wystąpienie <see cref="T:System.IO.Compression.ZipArchive" /> klasy i opcjonalnie zakończy zapisywanie archiwum i zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `disposing` ustawiono `true`, wszystkie strumienie podstawowej są zamknięte i nie będą już dostępne w przypadku operacji zapisu kolejne, chyba że skonstruować obiekt za pomocą <xref:System.IO.Compression.ZipArchive.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.ZipArchiveMode%2CSystem.Boolean%29> przeciążenia konstruktora i ustaw jego `leaveOpen` parametr `true`.  
  
 Ta metoda jest wywoływana tylko przez publiczny <xref:System.IO.Compression.ZipArchive.Dispose> i <xref:System.Object.Finalize> metod; tej metody nie wywołuje bezpośrednio.  
  
 Podczas implementacji wzorca usuwania parametr logiczny z <xref:System.IO.Compression.ZipArchive.Dispose%28System.Boolean%29> metoda powinna być używana w następujący sposób:  
  
-   <xref:System.IO.Compression.ZipArchive.Dispose> Powinny wywoływać metodę bieżącego obiektu <xref:System.IO.Compression.ZipArchive.Dispose%28System.Boolean%29> z parametr logiczny równa `true` aby zwolnić zasoby zarządzane i niezarządzane.  
  
-   <xref:System.Object.Finalize> Powinny wywoływać metodę bieżącego obiektu <xref:System.IO.Compression.ZipArchive.Dispose%28System.Boolean%29> z parametr logiczny równa `false` aby zwolnić tylko niezarządzane zasoby.
  
 Aby uzyskać więcej informacji, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.Compression.ZipArchiveEntry&gt; Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.Compression.ZipArchiveEntry&gt; Entries" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.ZipArchive.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As ReadOnlyCollection(Of ZipArchiveEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::Compression::ZipArchiveEntry ^&gt; ^ Entries { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::Compression::ZipArchiveEntry ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.Compression.ZipArchiveEntry&gt;" Usage="System.IO.Compression.ZipArchive.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.Compression.ZipArchiveEntry&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wpisów, które są obecnie dostępne w archiwum zip.</summary>
        <value>Kolekcja wpisów, które są obecnie dostępne w archiwum zip.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Compression.ZipArchive.Entries%2A> właściwość służąca do pobierania cały zbiór wpisów. Użyj <xref:System.IO.Compression.ZipArchive.GetEntry%2A> metodę, która pobierze pojedynczy wpis według nazwy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak otworzyć archiwum zip i iterowania po kolekcji wpisów.  
  
 [!code-csharp[System.IO.Compression.ZipArchive#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchive/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipArchive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchive/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Archiwum zip nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Archiwum zip został usunięty.</exception>
        <exception cref="T:System.IO.InvalidDataException">Archiwum zip jest uszkodzony i nie można pobrać jej wpisy.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEntry">
      <MemberSignature Language="C#" Value="public System.IO.Compression.ZipArchiveEntry GetEntry (string entryName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Compression.ZipArchiveEntry GetEntry(string entryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.GetEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEntry (entryName As String) As ZipArchiveEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Compression::ZipArchiveEntry ^ GetEntry(System::String ^ entryName);" />
      <MemberSignature Language="F#" Value="member this.GetEntry : string -&gt; System.IO.Compression.ZipArchiveEntry" Usage="zipArchive.GetEntry entryName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchiveEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entryName">Ścieżka względem katalogu głównego, archiwum, który identyfikuje wpis, aby pobrać.</param>
        <summary>Pobiera otokę dla określonego wpisu w archiwum zip.</summary>
        <returns>Otoka dla określonego wpisu w warstwie archiwum; <see langword="null" /> Jeśli wpis nie istnieje w archiwum.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli istnieje wiele wpisów, które mają określoną nazwę w archiwum, zwracany jest pierwszy z nich. Nazwa wpisu jest porównywany z `entryName` za pomocą porównania porządkowego.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.IO.Compression.ZipArchive.GetEntry%2A> metoda pobierania wpisu.  
  
 [!code-csharp[System.IO.Compression.ZipArchiveEntry#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchiveentry/cs/program2.cs#2)]
 [!code-vb[System.IO.Compression.ZipArchiveEntry#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchiveentry/vb/program2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="entryName" /> jest <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="entryName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Archiwum zip nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Archiwum zip został usunięty.</exception>
        <exception cref="T:System.IO.InvalidDataException">Archiwum zip jest uszkodzony i nie można pobrać jej wpisy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Mode">
      <MemberSignature Language="C#" Value="public System.IO.Compression.ZipArchiveMode Mode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Compression.ZipArchiveMode Mode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.ZipArchive.Mode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mode As ZipArchiveMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Compression::ZipArchiveMode Mode { System::IO::Compression::ZipArchiveMode get(); };" />
      <MemberSignature Language="F#" Value="member this.Mode : System.IO.Compression.ZipArchiveMode" Usage="System.IO.Compression.ZipArchive.Mode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchiveMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która opisuje typ akcji do wykonania archiwum zip we wpisach.</summary>
        <value>Jedną z wartości wyliczenia, które opisuje typ akcji (Odczyt, tworzenie i aktualizowanie) archiwum zip mogą wykonywać na wpisów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ wartość <xref:System.IO.Compression.ZipArchive> właściwości podczas tworzenia wystąpienia <xref:System.IO.Compression.ZipArchive> klasy. Użyj <xref:System.IO.Compression.ZipArchive.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.ZipArchiveMode%29> lub <xref:System.IO.Compression.ZipArchive.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.ZipArchiveMode%2CSystem.Boolean%29> konstruktora, aby podać wartość parametru <xref:System.IO.Compression.ZipArchive.Mode%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
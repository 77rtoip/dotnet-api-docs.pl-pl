<Type Name="StoryFragment" FullName="System.Windows.Documents.DocumentStructures.StoryFragment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c07ce239f829a4284d9ac8435e6c3247d7b18e65" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911483" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StoryFragment : System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StoryFragment extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Documents.DocumentStructures.BlockElement&gt;, class System.Collections.IEnumerable, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.DocumentStructures.StoryFragment" />
  <TypeSignature Language="VB.NET" Value="Public Class StoryFragment&#xA;Implements IAddChild, IEnumerable(Of BlockElement)" />
  <TypeSignature Language="C++ CLI" Value="public ref class StoryFragment : System::Collections::Generic::IEnumerable&lt;System::Windows::Documents::DocumentStructures::BlockElement ^&gt;, System::Windows::Markup::IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("BlockElementList")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje całości lub części artykułu w dokumencie XPS.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek XPS w [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] dokumentu jest z grubsza podobny do wątku w gazecie lub magazynu. Jest fragment tekstu i grafiki zawartości, zwykle na jeden temat w jednym [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] dokumentu. Zwykle obejmuje wiele stron, ale może być krótszy niż strony, takich jak pasek boczny — wątku w ramce — w magazynu. Można też włókien jak wątków gazecie FrontPage, który jest kontynuowany na stronie 4 wątku. W rezultacie danej strony może mieć więcej niż jeden wątek i części więcej niż jeden wątek. Nagłówek lub stopka jest również specjalny rodzaj wątku, który całkowicie znajduje się na jednej stronie.  
  
 A <xref:System.Windows.Documents.DocumentStructures.StoryFragment> reprezentuje wszystkie lub części artykułu. Możliwość łączenia nigdy nie więcej niż jedną stronę, ale może zajmować całej strony lub udostępnić stronę z pozostałych fragmentów. Jeśli wątek znajduje się w więcej niż jednej strony, każdej części na każdej stronie jest oddzielny fragmentu. Chociaż scenariuszy może mieć nieciągłe zestawy fragmenty, fragmentu nie może sam być nieciągły.  
  
 Tylko <xref:System.Windows.Documents.DocumentStructures.StoryFragments> element może być elementem nadrzędnym <xref:System.Windows.Documents.DocumentStructures.StoryFragment>.  Lokalizacja <xref:System.Windows.Documents.DocumentStructures.StoryBreak> elementów w obrębie <xref:System.Windows.Documents.DocumentStructures.StoryFragment> wskazuje, jeśli wątek znajduje się w wielu fragmentów, a dodatkowe fragmenty albo przed lub po bieżącego fragmentu.  
  
 Podczas <xref:System.Windows.Documents.DocumentStructures.StoryFragment> kończy się na środku niektórych typem elementu strukturalnego; powiedzieć `<TableRowGroupStructure>`, następnie [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] tworzenie dokumentów aplikacji należy wstawić tagu końcowego odpowiednie dla elementu (w tym przypadku `</TableRowGroupStructure>`) przed `</StoryFragment>` tagów, nawet Mimo że struktura jest kontynuowana w późniejszym fragmentu. (Jest to konieczne upewnić się, że element drzewa w ramach <xref:System.Windows.Documents.DocumentStructures.StoryFragment> jest prawidłowym kodem XML.) Fragment, który będzie kontynuowane wątku musi zaczynać się od tagu otwierającego dla przerwanego struktury. Całe drzewo struktury przerwania muszą być traktowane tak samo (z wyjątkiem jednej, omówiony poniżej): tagami końcowymi, należy dodać do każdej tagu początkowego niedopasowane powyżej punktu przerwania.  
  
 Wyjątek ma zastosowanie, gdy przerwania wątku pochodzi bezpośrednio po `</TableCellStructure>` tag, a następnie tworzenie aplikacji należy wstawić pusta tabela komórki struktury (`<TableCellStructure></TableCellStructure>`) w punkcie odpowiedni fragment, który będzie kontynuowane wątku. Jest to konieczne, dzięki czemu odbierającą aplikacji, które muszą być scalone wszystkie fragmenty danego scenariusza może używać prosty algorytm w tym celu.  
  
 Załóżmy na przykład, aplikacja chce dodać następujące materiały do [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] dokumentu:  
  
```  
<SectionStructure>  
   <TableStructure>  
      <TableRowGroupStructure>  
         <TableRowStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="SomeContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="MoreContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
         </TableRowStructure>  
         <TableRowStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="EvenMoreContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="LastContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
         </TableRowStructure>  
      </TableRowGroupStructure>  
   </TableStructure>  
</SectionStructure>  
```  
  
 Jeśli podział strony wymusza na końcu fragment tuż po `</TableCellStructure>` dla "SomeContent" aplikacji należy utworzyć podziału, jak pokazano w poniższym przykładzie:  
  
```  
<StoryFragment StoryName="MyStory" FragmentType="Content">  
 <SectionStructure>  
    <TableStructure>  
       <TableRowGroupStructure>  
          <TableRowStructure>  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="SomeContent" />  
                </ParagraphStructure>   
             </TableCellStructure>  
<!-- lines from here to end of fragment added by producer-->  
          </TableRowStructure>  
       </TableRowGroupStructure>  
    </TableStructure>  
 </SectionStructure>  
</StoryFragment>  
  
<StoryFragment StoryName="MyStory" FragmentType="Content">  
 <SectionStructure>  
    <TableStructure>  
       <TableRowGroupStructure>  
          <TableRowStructure>  
             <TableCellStructure>   
              <!-- extra cell added by producer-->  
             </TableCellStructure>  
<!-- lines from here to start of fragment added by producer-->  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="MoreContent" />  
                </ParagraphStructure>  
             </TableCellStructure>  
          </TableRowStructure>  
          <TableRowStructure>  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="EvenMoreContent" />  
                </ParagraphStructure>  
             </TableCellStructure>  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="LastContent" />  
                </ParagraphStructure>  
             </TableCellStructure>  
          </TableRowStructure>  
       </TableRowGroupStructure>  
    </TableStructure>  
 </SectionStructure>  
</StoryFragment>  
```  
  
 Aplikacja, która odczytuje dokument może być konieczne scalania tej zawartości. Należy wziąć pod uwagę, na przykład przeglądarka plików XPS z **cały artykuł kopiowania do Schowka** przycisk; lub **XPS dla Blind** aplikacji, który przekazany wątków do Syntezator głosu.  Niektóre aplikacje, które zapoznały dokumentu może być konieczne scalanie podzestawu fragmenty wątku. Na przykład funkcja, która kopiuje cały akapit do Schowka triple kliknięciem należy wykonywać scalania zawsze, gdy akapitu łączone podziału strony, ponieważ takie akapitu by podzielić między dwiema <xref:System.Windows.Documents.DocumentStructures.StoryFragment>s.  
  
 **Aby scalić przy użyciu tego algorytmu:**  
  
1.  Usuń `</StoryFragment>` na końcu pierwszego fragmentu do scalenia i usuwania `<StoryFragment>` od początku drugiego.  
  
2.  W przypadku ostatniego tagu zamykającego w pierwszym fragmencie tego samego typu jako pierwszy otwierający tag drugi fragmentu (i nie są `<NamedElement>` tagów), usuń je.  
  
3.  Powtórz kroki od 2 do momentu dwa fragmenty w *albo* tych stanów:  
  
    -   Nie ma typu zgodność ostatniego tagu końcowego fragmentu wiodące pierwszy tagu początkowego fragmentu końcowe.  
  
    -   Ostatni tagu końcowego znaku fragmentu pierwszy tagu początkowego fragmentu końcowe są `<NamedElement>` tagów.  
  
 W powyższym przykładzie Jeśli puste komórki nie miał został dodany przez producenta aplikacji, następnie połączenie z fragmentów dałby w efekcie tabelę, której pierwszy wiersz ma tylko jedną komórkę zawierających zarówno "SomeContent" i "MoreContent" odwołania zamiast oryginalnej najpierw wiersz z dwóch komórek zawierających jedno odwołanie  
  
 Po scaleniu cały artykuł algorytm należy powtórzyć dla każdego kolejnych fragmentu, który jest częścią tego samego wątku. Fragmenty, które należą do artykułu są indeksowane w `<Story>` elementu. W sekcji 9.1.15 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] specyfikacji, który można uzyskać w [XPS: specyfikacja i pobiera licencję](http://www.microsoft.com/whdc/xps/downloads.mspx). Ostatni fragment dla danego scenariusza będą miały <xref:System.Windows.Documents.DocumentStructures.StoryBreak> element jako jego ostatnim elementem podrzędnym.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono `<StoryFragment>` częścią [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentu.  
  
 [!code-xaml[DocumentStructure#DocStructStoryFragContent1](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentStructure/CSharp/Content/FixedPage1_structure.xaml#docstructstoryfragcontent1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.DocumentStructures.StoryBreak" />
    <altmember cref="T:System.Windows.Documents.DocumentStructures.StoryFragments" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StoryFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StoryFragment();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Documents.DocumentStructures.StoryFragment" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Windows.Documents.DocumentStructures.BlockElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Windows.Documents.DocumentStructures.BlockElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.Add(System.Windows.Documents.DocumentStructures.BlockElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (element As BlockElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Windows::Documents::DocumentStructures::BlockElement ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.Documents.DocumentStructures.BlockElement" />
      </Parameters>
      <Docs>
        <param name="element">Blok do dodania.</param>
        <summary>Dodaj blok do fragmentu wątku.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Blok przekazany <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FragmentName">
      <MemberSignature Language="C#" Value="public string FragmentName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FragmentName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentName" />
      <MemberSignature Language="VB.NET" Value="Public Property FragmentName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FragmentName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę fragmentu wątku.</summary>
        <value>A <see cref="T:System.String" /> reprezentujący nazwę tego fragmentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat `FragmentName` atrybutu `</StoryFragment>` częścią [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentu, zobacz rozdział 9 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] specyfikacji, który można uzyskać w [XPS: specyfikacja i licencji pobiera](http://www.microsoft.com/whdc/xps/downloads.mspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentType" />
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.StoryName" />
      </Docs>
    </Member>
    <Member MemberName="FragmentType">
      <MemberSignature Language="C#" Value="public string FragmentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FragmentType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentType" />
      <MemberSignature Language="VB.NET" Value="Public Property FragmentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FragmentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ fragmentu.</summary>
        <value>A <see cref="T:System.String" /> reprezentujący typ fragmentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwe wartości to "Nagłówek", "Stopka" i "Zawartość".  
  
 Aby uzyskać więcej informacji na temat `FragmentType` atrybutu `</StoryFragment>` częścią [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentu, zobacz rozdział 9 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] specyfikacji, który można uzyskać w [XPS: specyfikacja i licencji pobiera](http://www.microsoft.com/whdc/xps/downloads.mspx).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono `FragmentType` atrybutu `<StoryFragment>` częścią [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentu.  
  
 [!code-xaml[DocumentStructure#DocStructStoryFragContent1](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentStructure/CSharp/Content/FixedPage1_structure.xaml#docstructstoryfragcontent1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentName" />
      </Docs>
    </Member>
    <Member MemberName="StoryName">
      <MemberSignature Language="C#" Value="public string StoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StoryName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.DocumentStructures.StoryFragment.StoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property StoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę wątku.</summary>
        <value>A <see cref="T:System.String" /> reprezentujący nazwę wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie fragmenty danego scenariusza musi mieć taką samą wartość dla tej właściwości. Musi on być zgodny `StoryName` atrybutu `<Story>` elementu. W sekcji 9.1.15 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] specyfikacji, który można uzyskać w [XPS: specyfikacja i pobiera licencję](http://www.microsoft.com/whdc/xps/downloads.mspx).  
  
 Ta właściwość może być nieokreślony, jeśli <xref:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentType%2A> jest w nagłówku lub stopce strony.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono `StoryName` atrybutu `<StoryFragment>` częścią [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentu.  
  
 [!code-xaml[DocumentStructure#DocStructStoryFragContent1](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentStructure/CSharp/Content/FixedPage1_structure.xaml#docstructstoryfragcontent1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentName" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt; IEnumerable&lt;BlockElement&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.Documents.DocumentStructures.BlockElement&gt; System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Collections#Generic#IEnumerable&lt;System#Windows#Documents#DocumentStructures#BlockElement&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of BlockElement) Implements IEnumerable(Of BlockElement).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Windows::Documents::DocumentStructures::BlockElement ^&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Windows::Documents::DocumentStructures::BlockElement ^&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ta metoda nie została zaimplementowana.</summary>
        <returns>Zawsze zgłasza <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ta metoda nie została zaimplementowana.</summary>
        <returns>Zawsze zgłasza <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt podrzędny <see cref="T:System.Object" /> dodana.</param>
        <summary>Ten element członkowski obsługuje infrastrukturę programu .NET Framework i nie jest przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodaje obiekt podrzędny, aby <xref:System.Windows.Documents.DocumentStructures.StoryFragment>.  
  
 Musi istnieć co najmniej jeden element podrzędny elementu <xref:System.Windows.Documents.DocumentStructures.StoryFragment> i elementy podrzędne może być tylko te typy: <xref:System.Windows.Documents.DocumentStructures.ParagraphStructure>, <xref:System.Windows.Documents.DocumentStructures.FigureStructure>, <xref:System.Windows.Documents.DocumentStructures.ListStructure>, <xref:System.Windows.Documents.DocumentStructures.TableStructure>, <xref:System.Windows.Documents.DocumentStructures.SectionStructure>, i <xref:System.Windows.Documents.DocumentStructures.StoryBreak>.  
  
 A <xref:System.Windows.Documents.DocumentStructures.StoryBreak> mogą być tylko pierwsze lub ostatnie podrzędnym <xref:System.Windows.Documents.DocumentStructures.StoryFragment>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie jest jednym z typów, które może być elementem podrzędnym tej klasy. Zobacz **uwagi**.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Tekst, aby dodać do obiektu.</param>
        <summary>Dodaje tekst węzła do obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
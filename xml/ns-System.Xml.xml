<Namespace Name="System.Xml">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b9d93fd68b550f524fd02f3cb0af6df61ab8e864" />
    <Meta Name="ms.sourcegitcommit" Value="81d387351cc43c342755705908f4a5eb8af153d3" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/05/2018" />
    <Meta Name="ms.locfileid" Value="34758853" />
  </Metadata>
  <Docs>
    <summary>
      <see cref="N:System.Xml" /> Przestrzeń nazw zapewnia obsługę opartych na standardach przetwarzania kodu XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="std"></a>   
## <a name="supported-standards"></a>Obsługiwane standardy  
 <xref:System.Xml> Przestrzeń nazw obsługuje te standardy:  
  
-   XML 1.0, włącznie z obsługą DTD: [http://www.w3.org/TR/2006/REC-xml-20060816/](http://www.w3.org/TR/2006/REC-xml-20060816/)  
  
-   Przestrzenie nazw XML, zarówno strumienia poziomie i w modelu DOM: [http://www.w3.org/TR/REC-xml-names/](http://www.w3.org/TR/REC-xml-names/)  
  
-   Schematy XML: [http://www.w3.org/2001/XMLSchema](http://www.w3.org/2001/XMLSchema)  
  
-   Wyrażenia XPath: [http://www.w3.org/TR/xpath](http://www.w3.org/TR/xpath)  
  
-   Przekształcenia XSLT: [http://www.w3.org/TR/xslt](http://www.w3.org/TR/xslt)  
  
-   DOM poziomu 1 rdzeni: [http://www.w3.org/TR/REC-DOM-Level-1/](http://www.w3.org/TR/REC-DOM-Level-1/)  
  
-   DOM poziomu 2 rdzeni: [http://www.w3.org/TR/DOM-Level-2/](http://www.w3.org/TR/DOM-Level-2/)  
  
 Zobacz sekcję [różnice z specyfikacji W3C](#diff) dla dwóch przypadków, w których klasy XML różnią się od zalecanych W3C.  
  
<a name="related"></a>   
## <a name="related-namespaces"></a>Przestrzenie nazw pokrewne  
 .NET Framework zapewnia także innych przestrzeniach nazw dla operacji związanych z XML. Aby uzyskać listę, opisy i linki, zobacz [przestrzenie nazw System.Xml](http://msdn.microsoft.com/library/gg145036.aspx) strony sieci Web.  
  
<a name="async"></a>   
## <a name="processing-xml-asynchronously"></a>Asynchronicznie przetwarzania kodu XML  
 <xref:System.Xml.XmlReader?displayProperty=nameWithType> i <xref:System.Xml.XmlWriter?displayProperty=nameWithType> klasy zawierają wiele metod asynchronicznych, które są oparte na. Te metody może zostać zidentyfikowane na podstawie ciągu "Async" na końcu nazwy. Z tych metod można napisać kod asynchroniczne, podobny do kodu synchroniczne, a można przenieść istniejący kod synchroniczne asynchroniczne kodu łatwo.  
  
-   Użycie metod asynchronicznych w aplikacjach w przypadku znaczne opóźnienie strumienia. Unikaj używania asynchroniczne interfejsów API dla strumienia pamięci lub operacji odczytu/zapisu strumienia pliku lokalnego. Strumień wejściowy <xref:System.Xml.XmlTextReader>, i <xref:System.Xml.XmlTextWriter> powinna obsługiwać także operacji asynchronicznych. W przeciwnym razie wątków nadal będą zablokowane przez operacje We/Wy.  
  
-   Nie zaleca się łączenie wywołań funkcji synchroniczne i asynchroniczne, ponieważ może Pamiętaj, aby użyć `await` — słowo kluczowe lub użyj API synchronicznego, gdy asynchroniczne jedna jest konieczne.  
  
-   Nie ustawiaj <xref:System.Xml.XmlReaderSettings.Async%2A?displayProperty=nameWithType> lub <xref:System.Xml.XmlWriterSettings.Async%2A?displayProperty=nameWithType> flaga `true` Jeśli nie zamierzasz używać metody asynchronicznej.  
  
-   Jeśli zapomnisz określić `await` — słowo kluczowe podczas wywoływania metody asynchronicznej, wyniki są deterministyczna: może pojawić się w wyniku oczekiwano lub wystąpił wyjątek.  
  
-   Gdy <xref:System.Xml.XmlReader> odczytuje obiekt węzła duży, może pamięci podręcznej tylko wartość tekstową z częściowa i zwracać węzeł tekstowy, dlatego podczas pobierania <xref:System.Xml.XmlReader.Value%2A?displayProperty=nameWithType> właściwość może zostać zablokowany przez operację We/Wy. Użyj <xref:System.Xml.XmlReader.GetValueAsync%2A?displayProperty=nameWithType> metody do pobierania wartości tekstowej w trybie asynchronicznym, lub użyj <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A?displayProperty=nameWithType> bloku metody odczytać dużych tekstu w fragmentów.  
  
-   Jeśli używasz <xref:System.Xml.XmlWriter> obiekt, należy wywołać <xref:System.Xml.XmlWriter.FlushAsync%2A?displayProperty=nameWithType> metoda przed wywołaniem <xref:System.Xml.XmlWriter.Close%2A?displayProperty=nameWithType> celu unikania blokowania operacji We/Wy.  
  
<a name="diff"></a>   
## <a name="differences-from-the-w3c-specs"></a>Różnice z specyfikacji W3C  
 W przypadków obejmujących ograniczenia dotyczące modelu grupy składników schematu <xref:System.Xml> przestrzeni nazw różni się od zaleceń W3C.  
  
 **Spójności w deklaracji elementu:**  
  
 W niektórych przypadkach, gdy są używane grupy podstawienia <xref:System.Xml> implementacji nie spełnia "schematu składnika ograniczenie: Element deklaracje spójne," opisanej w [ograniczenia dotyczące składników schematu modelu grupy ](http://go.microsoft.com/fwlink/?LinkId=137029) sekcji specyfikacji W3C.  
  
 Na przykład następujący schemat zawiera elementy, które mają taką samą nazwę, ale różne typy w tym samym modelu zawartości i grupy podstawienia są używane. Powinno to spowodować błąd, ale <xref:System.Xml> kompiluje i sprawdza poprawność schematu bez błędów.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">  
  
   <xs:element name="e1" type="t1"/>  
   <xs:complexType name="t1"/>  
  
   <xs:element name="e2" type="t2" substitutionGroup="e1"/>  
      <xs:complexType name="t2">  
         <xs:complexContent>  
            <xs:extension base="t1">  
         </xs:extension>  
      </xs:complexContent>  
   </xs:complexType>  
  
   <xs:complexType name="t3">  
      <xs:sequence>  
         <xs:element ref="e1"/>  
         <xs:element name="e2" type="xs:int"/>  
      </xs:sequence>  
   </xs:complexType>  
</xs:schema>  
```  
  
 W tym schemacie wpisz `t3` zawiera sekwencję elementów. Z powodu podstawienia, odwołanie do elementu `e1` z sekwencji może powodować albo w elemencie `e1` typu `t1` lub w elemencie `e2` typu `t2`. Drugim przypadku spowodowałoby sekwencję dwóch `e2` elementów, gdy jest ona typu `t2` i innych jest typu `xs:int`.  
  
 **Autorstwa unikatowości:**  
  
 W następujących warunkach <xref:System.Xml> implementacji nie spełnia "schematu składnika ograniczenie: unikatowy cząstki autorstwa," opisany w [ograniczenia dotyczące składników schematu modelu grupy](http://go.microsoft.com/fwlink/?LinkId=137029) sekcji z specyfikacji W3C.  
  
-   Jeden z elementów w grupie odwołuje się do innego elementu.  
  
-   Przywoływany element jest elementem głównym grupy podstawienia.  
  
-   Grupa podstawienia zawiera element, który ma taką samą nazwę jak jeden z elementów w grupie.  
  
-   Kardynalność element, do którego odwołuje się element head grupy podstawienia i element o takiej samej nazwie jak element grupy podstawienia nie jest stały (minOccurs < maxOccurs).  
  
-   Definicja elementu, który odwołuje się do grupy podstawienia poprzedza definicji elementu z taką samą nazwę jak element grupy podstawienia.  
  
 Na przykład w poniższym schemacie model zawartości jest niejednoznaczne i powinno spowodować błąd kompilacji, ale <xref:System.Xml> kompiluje schematu bez błędów.  
  
```xml  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">  
  
  <xs:element name="e1" type="xs:int"/>  
  <xs:element name="e2" type="xs:int" substitutionGroup="e1"/>  
  
  <xs:complexType name="t3">  
    <xs:sequence>  
      <xs:element ref="e1" minOccurs="0" maxOccurs="1"/>  
      <xs:element name="e2" type="xs:int" minOccurs="0" maxOccurs="1"/>  
    </xs:sequence>  
  </xs:complexType>  
  
  <xs:element name="e3" type="t3"/>  
</xs:schema>  
```  
  
 Jeśli użytkownik próbuje zweryfikować następujących XML względem schematu powyżej, sprawdzania poprawności zakończy się niepowodzeniem z następującym komunikatem: "element 'e3' ma nieprawidłowy element"e2"." i <xref:System.Xml.Schema.XmlSchemaValidationException> zostanie wygenerowany wyjątek.  
  
```xml  
<e3>  
  <e2>1</e2>  
  <e2>2</e2>  
</e3>  
```  
  
 Aby obejść ten problem, można wymienić deklaracji elementu w pliku XSD. Na przykład:  
  
```xml  
<xs:sequence>  
  <xs:element ref="e1" minOccurs="0" maxOccurs="1"/>  
  <xs:element name="e2" type="xs:int" minOccurs="0" maxOccurs="1"/>  
</xs:sequence>  
```  
  
 staje się to:  
  
```xml  
<xs:sequence>  
  <xs:element name="e2" type="xs:int" minOccurs="0" maxOccurs="1"/>  
  <xs:element ref="e1" minOccurs="0" maxOccurs="1"/>  
</xs:sequence>  
```  
  
 Oto inny przykład tego samego problemu:  
  
```xml  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">  
   <xs:element name="e1" type="xs:string"/>  
   <xs:element name="e2" type="xs:string" substitutionGroup="e1"/>  
  
   <xs:complexType name="t3">  
      <xs:sequence>  
         <xs:element ref="e1" minOccurs="0" maxOccurs="1"/>  
         <xs:element name="e2" type="xs:int" minOccurs="0" maxOccurs="1"/>  
      </xs:sequence>  
   </xs:complexType>  
   <xs:element name="e3" type="t3"/>  
</xs:schema>  
```  
  
 Jeśli użytkownik próbuje zweryfikować następujących XML względem schematu powyżej, sprawdzanie poprawności zakończy się niepowodzeniem z powodu następującego wyjątku: "nieobsługiwany wyjątek: System.Xml.Schema.XmlSchemaValidationException: element el"e2"jest nieprawidłowy — wartość"abc"jest nieprawidłowa uwzględnieniu jego typu danych 'http://www.w3.org/2001/XMLSchema:int"— ciąg"abc"nie jest prawidłową wartość Int32."
  
```xml  
<e3><e2>abc</e2></e3>  
```  
  
<a name="security"></a>   
## <a name="security-considerations"></a>Zagadnienia dotyczące bezpieczeństwa  
 Typy i składniki w <xref:System.Xml> zależą od obszaru nazw [systemu zabezpieczeń platformy .NET](~/docs/standard/security/index.md). W poniższych sekcjach omówiono problemy z zabezpieczeniami, które są specyficzne dla technologii XML.
  
 Należy również zauważyć, że gdy używasz <xref:System.Xml> typów i członków, jeśli kod XML zawiera dane, które ma wpływ na prywatność potencjalnych, należy wdrożyć aplikację w taki sposób, aby szanuje prywatność użytkowników końcowych.
  
 **Dostępu zewnętrznego**  
  
 Kilka technologii XML ma możliwość pobierania inne dokumenty podczas przetwarzania. Na przykład definicja typu dokumentu (DTD) może znajdować się w dokumencie podczas analizowania. Element DTD można również na żywo w zewnętrznym dokumencie, który odwołuje się do niego podczas analizowania dokumentu. Język definicji schematu XML (XSD) i technologii XSLT również mieć możliwość uwzględnienia informacji z innych plików. Tych zasobów zewnętrznych może ona powodować problemy z zabezpieczeniami. Należy na przykład Sprawdź, czy aplikacja pobiera pliki tylko z zaufanych witryn i czy plik go pobiera nie zawiera danych złośliwe.  
  
 <xref:System.Xml.XmlUrlResolver> Klasa jest używana do załadowania dokumentów XML i do rozwiązania zasobów zewnętrznych, takich jak jednostek definicje DTD i schematy i zaimportuj lub zawiera dyrektywy, które.  
  
 Można zastąpić tej klasy i określ <xref:System.Xml.XmlResolver> obiekt ma być używany. Użyj <xref:System.Xml.XmlSecureResolver> klasy, jeśli trzeba otworzyć zasobu, która kontroluje, lub niezaufanych. <xref:System.Xml.XmlSecureResolver> Opakowuje <xref:System.Xml.XmlResolver> i pozwala ograniczyć zasoby, do którego odpowiadającego <xref:System.Xml.XmlResolver> ma dostęp do.  
  
 **Odmowa usługi**  
  
 Poniższe scenariusze są uważane za mniej podatny na ataki ponieważ <xref:System.Xml> klasy umożliwiają ochronę z takich ataków.  
  
-   Analizowanie tekstu danych XML.  
  
-   Analizowanie danych binarnych XML, jeśli dane binarne XML został wygenerowany przez program Microsoft SQL Server.  
  
-   Zapisywanie dokumentów XML i fragmentów ze źródeł danych w systemie plików, strumieni <xref:System.IO.TextWriter>, lub <xref:System.Text.StringBuilder>.  
  
-   Ładowanie dokumentów do obiektu modelu DOM (Document Object), jeśli używasz <xref:System.Xml.XmlReader> obiektu i <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A?displayProperty=nameWithType> ustawioną <xref:System.Xml.DtdProcessing.Prohibit?displayProperty=nameWithType>.  
  
-   Nawigowanie po modelu DOM obiektu.  
  
 Następujące scenariusze nie są zalecane, jeśli masz obawy ataki lub jeśli pracujesz w środowisku niezaufanych.  
  
-   Przetwarzanie elementu DTD.  
  
-   Przetwarzanie schematu. W tym dodawanie niezaufanych schematu do kolekcji schematów, kompilowania schematu niezaufanych i sprawdzanie poprawności za pomocą niezaufanego schematu.  
  
-   Przetwarzanie XSLT.  
  
-   Podczas analizowania strumieniem dowolnego użytkownika dostarczonych danych binarnych XML.  
  
-   Dom w LICZBIE operacji, takich jak badania, edytowanie, przenoszenie podrzędne drzewa między dokumentów i zapisywania obiektów modelu DOM.  
  
 Jeśli masz obawy odmowa problemów dotyczących usługi lub jeśli mamy do czynienia ze źródeł niezaufanych, nie należy włączać przetwarzanie elementu DTD. To jest domyślnie wyłączony na <xref:System.Xml.XmlReader> obiekty, które <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metoda tworzy.  
  
> [!NOTE]
>  <xref:System.Xml.XmlTextReader> Umożliwia przetwarzanie domyślnie DTD. Użyj <xref:System.Xml.XmlTextReader.DtdProcessing%2A?displayProperty=nameWithType> właściwości, aby wyłączyć tę funkcję.  
  
 Jeśli masz włączone przetwarzanie elementu DTD, możesz użyć <xref:System.Xml.XmlSecureResolver> klasę, aby ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do. Można również projektować aplikacji, tak aby przetwarzania XML pamięci i ograniczonego czasu. Na przykład można skonfigurować limity czasu w aplikacji ASP.NET.  
  
 **Zagadnienia dotyczące przetwarzania**  
  
 Ponieważ dokumenty XML mogą zawierać odwołania do innych plików, trudno jest określić, ile mocy obliczeniowej jest wymagany do analizy dokumentu XML. Na przykład dokumenty XML mogą zawierać definicji DTD. Jeśli element DTD zawiera zagnieżdżone jednostek lub złożonych modele zawartości, może zająć nadmierne ilości czasu, można przeanalizować dokumentu.  
  
 Korzystając z <xref:System.Xml.XmlReader>, można ograniczyć rozmiar dokumentu, który może zostać przeanalizowany przez ustawienie <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> właściwości. Można ograniczyć liczbę znaków, które są wynikiem rozwijanie jednostek przez ustawienie <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A?displayProperty=nameWithType> właściwości. Zobacz Tematy odpowiednie odwołanie przykłady ustawienie tych właściwości.  
  
 Technologie XSD i XSLT mają dodatkowe funkcje, które mogą wpłynąć na wydajność przetwarzania. Na przykład istnieje możliwość utworzenia schematu XML, który wymaga znacznej ilości czasu na przetwarzanie, gdy obliczanego w dokumencie stosunkowo mały. Istnieje również możliwość osadzania bloków skryptu arkusz stylów XSLT. Obu przypadkach stanowić potencjalne zagrożenie zabezpieczeń dla aplikacji.  
  
 Podczas tworzenia aplikacji, która używa <xref:System.Xml.Xsl.XslCompiledTransform> klasy, należy zwrócić uwagę na następujące elementy i ich wpływ na:  
  
-   Wykonywanie skryptów XSLT jest domyślnie wyłączona. Powinna być włączona obsługa skryptów XSLT, tylko wtedy, gdy wymagana jest obsługa skryptów, podczas pracy w pełni zaufanym środowisku.  
  
-   Przekształcenie XSLT `document()` funkcja jest domyślnie wyłączona. Po włączeniu `document()` funkcji, ograniczyć zasoby, które mogą być udostępniane przez przekazanie <xref:System.Xml.XmlSecureResolver> do obiektu <xref:System.Xml.Xsl.XslCompiledTransform.Transform%2A?displayProperty=nameWithType> metody.  
  
-   Obiekty rozszerzenia są domyślnie włączone. Jeśli <xref:System.Xml.Xsl.XsltArgumentList> obiekt, który zawiera obiekty rozszerzenia jest przekazywany do <xref:System.Xml.Xsl.XslCompiledTransform.Transform%2A?displayProperty=nameWithType> metoda, rozszerzenia obiekty są używane.  
  
-   Arkusze stylów XSLT może zawierać odwołania do innych plików i bloki osadzony skrypt. Złośliwy użytkownik może wykorzystać to poprzez dostarczanie danych lub arkusze stylów w liczbie, gdy wykonywana, może spowodować systemu do przetwarzania, dopóki komputer ma za mało zasobów.  
  
-   Aplikacje XSLT, które działają w środowisku mieszanym zaufania może spowodować fałszowania arkusza stylów. Na przykład, złośliwy użytkownik może załadować obiektu z arkusza stylów szkodliwe i przekazują do innego użytkownika, który następnie wywołuje <xref:System.Xml.Xsl.XslCompiledTransform.Transform%2A?displayProperty=nameWithType> — metoda i wykonuje transformację.  
  
 Te problemy z zabezpieczeniami można zminimalizować przez nie zostanie włączona obsługa skryptów lub `document()` działać, chyba że arkusza stylów pochodzi z zaufanego źródła i nie akceptuje <xref:System.Xml.Xsl.XslCompiledTransform> obiekty, arkusze stylów XSLT lub XML źródła danych z niezaufanego źródła.  
  
 **Obsługa wyjątków**  
  
 Wyjątki zgłaszane przez składniki poziomu niższe może ujawnić informacji ścieżki, która nie ma widoczne dla aplikacji. Aplikacji należy przechwytywać wyjątki i odpowiednio je przetworzyć.  
  
 ]]></format>
    </remarks>
    <altmember cref="N:System.Xml.Xsl" />
    <altmember cref="N:System.Xml.Schema" />
    <altmember cref="N:System.Xml.Linq" />
  </Docs>
</Namespace>
<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ab9a64e8091e1a2ec87eca8cf5d6ecdc6e07ca7c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69435404" /></Metadata><TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <TypeSignature Language="F#" Value="type Dispatcher = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia usługi do zarządzania kolejką elementów roboczych dla wątku.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher> Utrzymuje priorytetową kolejkę elementów roboczych dla określonego wątku.  
  
 Gdy jest tworzony w wątku, stanie się jedynym <xref:System.Windows.Threading.Dispatcher> , który można skojarzyć z <xref:System.Windows.Threading.Dispatcher> wątkiem, nawet jeśli zostanie zamknięty. <xref:System.Windows.Threading.Dispatcher>  
  
 Jeśli spróbujesz uzyskać <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> dla bieżącego wątku, <xref:System.Windows.Threading.Dispatcher> a nie skojarzono <xref:System.Windows.Threading.Dispatcher> z wątkiem, zostanie utworzony. Jest również tworzony podczas <xref:System.Windows.Threading.DispatcherObject>tworzenia. <xref:System.Windows.Threading.Dispatcher> Jeśli tworzysz <xref:System.Windows.Threading.Dispatcher> w wątku w tle, pamiętaj, aby zamknąć dyspozytora przed opuszczeniem wątku.  
  
 <xref:System.Windows.Threading.Dispatcher> Jeśli jest wyłączone, nie można go ponownie uruchomić.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie dostęp <xref:System.Windows.Threading.DispatcherObject> <xref:System.Windows.Threading.Dispatcher> do niego jest możliwy tylko w przypadku, gdy jest skojarzony z.  Na przykład wątek w tle nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> , która jest skojarzona <xref:System.Windows.Threading.Dispatcher> z w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] wątku.  Aby wątek w tle <xref:System.Windows.Controls.ContentControl.Content%2A> mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>, wątek w tle musi <xref:System.Windows.Threading.Dispatcher> delegować swoją służbę [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] do skojarzonej z wątkiem.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana <xref:System.Windows.Threading.Dispatcher> na, która ma wyłączony, właściwość status zwracanej <xref:System.Windows.Threading.DispatcherOperation> jest ustawiona na <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 Wszystkie metody <xref:System.Windows.Threading.Dispatcher>, z <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>wyjątkiem, są wolne od wątku.  
  
 Obiekty pochodne z <xref:System.Windows.Threading.DispatcherObject> mają koligację wątku.  
  
 Obiekty, które pochodzą <xref:System.Windows.Freezable> z są wolne od wątku, gdy są zablokowane.  Aby uzyskać więcej informacji, zobacz [Freezable obiektów — Omówienie](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak umieścić operację na <xref:System.Windows.Threading.Dispatcher>.  Aby uzyskać pełny kod źródłowy tego przykładu, zapoznaj się [z aplikacją Jednowątkową z długotrwałym obliczaniem](https://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Najpierw utworzono delegata, który nie akceptuje żadnych argumentów.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> Następnie jest wywoływana.  To wywołanie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> przyjmuje dwa parametry: priorytet, który jest ustawiony na <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>i wywołanie zwrotne, które jest przesyłane za pomocą wystąpienia delegata `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Przykładowa aplikacja jednowątkowa o długim czasie wykonywania obliczeń</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje delegata asynchronicznie w wątku, <see cref="T:System.Windows.Threading.Dispatcher" /> z którym jest skojarzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>jest asynchroniczny; w związku z tym, formant natychmiast wraca do wywołującego obiektu po wywołaniu.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A><xref:System.Windows.Threading.DispatcherOperation> zwraca obiekt, którego można użyć do współdziałania z delegatem, gdy delegat znajduje się w kolejce zdarzeń.  
  
 Obiekt zwrócony przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> może być używany na kilka sposobów do współpracy z określonym delegatem, na przykład: <xref:System.Windows.Threading.DispatcherOperation>  
  
-   <xref:System.Windows.Threading.DispatcherPriority> Zmiana obiektu delegowanego, ponieważ oczekuje na wykonanie w kolejce zdarzeń.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na zwrócenie przez delegata.  
  
-   Uzyskiwanie wartości zwracanej przez delegata po wykonaniu.  
  
 Jeśli wiele <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> wywołań jest wykonywanych w tym <xref:System.Windows.Threading.DispatcherPriority>samym czasie, zostaną one wykonane w kolejności, w jakiej zostały wykonane.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana <xref:System.Windows.Threading.Dispatcher> na, która ma wyłączony, właściwość status zwracanej <xref:System.Windows.Threading.DispatcherOperation> jest ustawiona na <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat do metody, która pobiera parametry określone w <paramref name="args" />, który jest wypychany <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określony delegat asynchronicznie z określonymi argumentami w wątku, w którym <see cref="T:System.Windows.Threading.Dispatcher" /> został utworzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt zwrócony przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> może być używany na kilka sposobów do współpracy z określonym delegatem, na przykład: <xref:System.Windows.Threading.DispatcherOperation>  
  
-   <xref:System.Windows.Threading.DispatcherPriority> Zmiana obiektu delegowanego, ponieważ oczekuje na wykonanie w kolejce zdarzeń.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na zwrócenie przez delegata.  
  
-   Uzyskiwanie wartości zwracanej przez delegata po wykonaniu.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>jest asynchroniczny; w związku z tym, formant natychmiast wraca do wywołującego obiektu po wywołaniu.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu. Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika. Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika. Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny. Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana <xref:System.Windows.Threading.Dispatcher> na, która ma wyłączony, właściwość status zwracanej <xref:System.Windows.Threading.DispatcherOperation> jest ustawiona na <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="method">Delegat do metody, która nie przyjmuje argumentów, która jest wypychana <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <summary>Wykonuje określony delegat asynchronicznie o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wiele <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> wywołań jest wykonywanych w tym <xref:System.Windows.Threading.DispatcherPriority>samym czasie, zostaną one wykonane w kolejności, w jakiej zostały wykonane.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A><xref:System.Windows.Threading.DispatcherOperation> zwraca obiekt, którego można użyć do współdziałania z delegatem, gdy delegat znajduje się w kolejce zdarzeń.  
  
 Obiekt zwrócony przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> może być używany na kilka sposobów do współpracy z określonym delegatem, na przykład: <xref:System.Windows.Threading.DispatcherOperation>  
  
-   <xref:System.Windows.Threading.DispatcherPriority> Zmiana obiektu delegowanego, ponieważ oczekuje na wykonanie w kolejce zdarzeń.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na zwrócenie przez delegata.  
  
-   Uzyskiwanie wartości zwracanej przez delegata po wykonaniu.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>jest asynchroniczny; w związku z tym, formant natychmiast wraca do wywołującego obiektu po wywołaniu.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana <xref:System.Windows.Threading.Dispatcher> na, która ma wyłączony, właściwość status zwracanej <xref:System.Windows.Threading.DispatcherOperation> jest ustawiona na <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak umieścić operację na <xref:System.Windows.Threading.Dispatcher>.  Aby uzyskać pełny kod źródłowy tego przykładu, zapoznaj się [z aplikacją Jednowątkową z długotrwałym obliczaniem](https://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Najpierw utworzono delegata, który nie akceptuje żadnych argumentów.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> Następnie jest wywoływana.  Ze <xref:System.Windows.Threading.DispatcherObject> względu na to, że każdy <xref:System.Windows.Threading.Dispatcher> ma właściwość, która zwraca, że <xref:System.Windows.Threading.Dispatcher> jest skojarzona z, żądany <xref:System.Windows.Threading.DispatcherObject>jest uzyskiwany za pomocą <xref:System.Windows.Controls.Button> zapytania `startStopButton`do, w tym przypadku nazwana.   Wywołanie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> przyjmuje dwa parametry: priorytet, który jest ustawiony na <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>i wywołanie zwrotne, które jest przesyłane za pomocą wystąpienia delegata `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" />jest nieprawidłowy <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Przykładowa aplikacja jednowątkowa o długim czasie wykonywania obliczeń</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat do metody, która pobiera parametry określone w <paramref name="args" />, który jest wypychany <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określony delegat asynchronicznie z określonymi argumentami o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> , w którym został utworzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt zwrócony przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> może być używany na kilka sposobów do współpracy z określonym delegatem, na przykład: <xref:System.Windows.Threading.DispatcherOperation>  
  
-   <xref:System.Windows.Threading.DispatcherPriority> Zmiana obiektu delegowanego, ponieważ oczekuje na wykonanie w kolejce zdarzeń.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na zwrócenie przez delegata.  
  
-   Uzyskiwanie wartości zwracanej przez delegata po wykonaniu.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>jest asynchroniczny; w związku z tym, formant natychmiast wraca do wywołującego obiektu po wywołaniu.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu. Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika. Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika. Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny. Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana <xref:System.Windows.Threading.Dispatcher> na, która ma wyłączony, właściwość status zwracanej <xref:System.Windows.Threading.DispatcherOperation> jest ustawiona na <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="method">Delegat do metody, która przyjmuje jeden argument, który jest wypychany <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który ma zostać przekazany jako argument do określonej metody.</param>
        <summary>Wykonuje określony delegat asynchronicznie o określonym priorytecie i z określonym argumentem w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`może być `null` niezbędny, jeśli nie są spełnione żadne argumenty.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A><xref:System.Windows.Threading.DispatcherOperation> zwraca obiekt, którego można użyć do współdziałania z delegatem, gdy delegat znajduje się w kolejce zdarzeń.  
  
 Obiekt zwrócony przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> może być używany na kilka sposobów do współpracy z określonym delegatem, na przykład: <xref:System.Windows.Threading.DispatcherOperation>  
  
-   <xref:System.Windows.Threading.DispatcherPriority> Zmiana obiektu delegowanego, ponieważ oczekuje na wykonanie w kolejce zdarzeń.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na zwrócenie przez delegata.  
  
-   Uzyskiwanie wartości zwracanej przez delegata po wykonaniu.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>jest asynchroniczny; w związku z tym, formant natychmiast wraca do wywołującego obiektu po wywołaniu.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 Jeśli wiele <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> wywołań jest wykonywanych w tym <xref:System.Windows.Threading.DispatcherPriority>samym czasie, zostaną one wykonane w kolejności, w jakiej zostały wykonane.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana <xref:System.Windows.Threading.Dispatcher> na, która ma wyłączony, właściwość status zwracanej <xref:System.Windows.Threading.DispatcherOperation> jest ustawiona na <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak umieścić operację na <xref:System.Windows.Threading.Dispatcher>.  
  
 Najpierw tworzony jest delegat, który akceptuje jeden argument, w tym przypadku ciąg.  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> Następnie jest wywoływana.  Ze <xref:System.Windows.Threading.DispatcherObject> względu na to, że każdy <xref:System.Windows.Threading.Dispatcher> ma właściwość, która zwraca, że <xref:System.Windows.Threading.Dispatcher> jest skojarzona z, żądany <xref:System.Windows.Threading.DispatcherObject>jest uzyskiwany za pomocą <xref:System.Windows.Controls.Grid> zapytania `tomorrowsWeather`do, w tym przypadku nazwana. Wywołanie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> przyjmuje trzy parametry: priorytet, który jest ustawiony na <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>; wywołanie zwrotne, które jest przesyłane za pomocą wystąpienia delegata `OneArgDelegate`; i ciąg o nazwie `weather`, który jest argumentem wywołania zwrotnego.  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" />jest nieprawidłowy <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Przykładowa aplikacja jednowątkowa o długim czasie wykonywania obliczeń</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="method">Delegat do metody, która przyjmuje wiele argumentów, które są wypychane <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który ma zostać przekazany jako argument do określonej metody.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do określonej metody.</param>
        <summary>Wykonuje określony delegat asynchronicznie o określonym priorytecie i z określoną tablicą argumentów w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzona.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie <see cref="T:System.Windows.Threading.Dispatcher" /> w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten `arg` parametr może być `null` niezbędny, jeśli nie są spełnione żadne argumenty.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A><xref:System.Windows.Threading.DispatcherOperation> zwraca obiekt, którego można użyć do współdziałania z delegatem, gdy delegat znajduje się w kolejce zdarzeń.  
  
 Obiekt zwrócony przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> może być używany na kilka sposobów do współpracy z określonym delegatem, na przykład: <xref:System.Windows.Threading.DispatcherOperation>  
  
-   <xref:System.Windows.Threading.DispatcherPriority> Zmiana obiektu delegowanego, ponieważ oczekuje na wykonanie w kolejce zdarzeń.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na zwrócenie przez delegata.  
  
-   Uzyskiwanie wartości zwracanej przez delegata po wykonaniu.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>jest asynchroniczny; w związku z tym, formant natychmiast wraca do wywołującego obiektu po wywołaniu.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 Jeśli wiele <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> wywołań jest wykonywanych w tym <xref:System.Windows.Threading.DispatcherPriority>samym czasie, zostaną one wykonane w kolejności, w jakiej zostały wykonane.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana <xref:System.Windows.Threading.Dispatcher> na, która ma wyłączony, właściwość status zwracanej <xref:System.Windows.Threading.DispatcherOperation> jest ustawiona na <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="T:System.Windows.Threading.DispatcherPriority" />nie jest prawidłowym priorytetem.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Przykładowa aplikacja jednowątkowa o długim czasie wykonywania obliczeń</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.BeginInvokeShutdown : System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.BeginInvokeShutdown priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, dla którego należy rozpocząć zamykanie dyspozytora.</param>
        <summary>Inicjuje zamknięcie <see cref="T:System.Windows.Threading.Dispatcher" /> asynchroniczne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A>wymaga uprawnień do nieograniczonego interfejsu użytkownika.  
  
 Gdy rozpocznie się zamykanie <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> , zdarzenie jest wywoływane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest ustawione na `true`. <xref:System.Windows.Threading.Dispatcher>  
  
 Nie <xref:System.Windows.Threading.Dispatcher> zamyka się całkowicie do momentu zakończenia kolejki zdarzeń.  
  
 Gdy Dyspozytor zakończy zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest wywoływane, <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> a właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące elementy robocze w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">do zamykania dyspozytora.  Skojarzone wyliczenia:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberSignature Language="F#" Value="member this.CheckAccess : unit -&gt; bool" Usage="dispatcher.CheckAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy wątek wywołujący jest skojarzony z tym <see cref="T:System.Windows.Threading.Dispatcher" />wątkiem.</summary>
        <returns><see langword="true" />Jeśli wątek wywołujący jest skojarzony z tym <see cref="T:System.Windows.Threading.Dispatcher" />elementem; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher> Tylko ten<xref:System.Windows.Threading.DispatcherObject> , który został utworzony, może uzyskać dostęp do obiektu.  Użyj <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> , aby uzyskać dostęp do obiektu z innego wątku.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>może być wywoływana z dowolnego wątku.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> Różnica między <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> i <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> jest <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> zwraca wartość Boolean wskazującą, <xref:System.Windows.Threading.Dispatcher> czy wątek wywołujący ma dostęp do i zgłasza wyjątek.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> do określenia, czy wątek ma dostęp <xref:System.Windows.Controls.Button>do.  Metoda skojarzona z<xref:System.Windows.Controls.Button> jest wywoływana w celu zweryfikowania dostępu do wątku. <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>  Jeśli wątek wywołujący ma dostęp do programu <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Controls.Button> , zostanie on zaktualizowany przez <xref:System.Windows.Controls.Button>uzyskanie dostępu do elementów członkowskich obiektu; <xref:System.Windows.Controls.Button> w przeciwnym razie delegat, który akceptuje jako argument, jest umieszczony na <xref:System.Windows.Threading.Dispatcher>.  Spowoduje <xref:System.Windows.Threading.Dispatcher> to delegowanie pracy <xref:System.Windows.Controls.Button>aktualizowania.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDispatcher : System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dla aktualnie wykonywanego wątku i tworzy nową <see cref="T:System.Windows.Threading.Dispatcher" /> , jeśli nie jest ona jeszcze skojarzona z wątkiem. <see cref="T:System.Windows.Threading.Dispatcher" /></summary>
        <value>Dyspozytor skojarzony z bieżącym wątkiem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element <xref:System.Windows.Threading.Dispatcher> nie jest skojarzony z bieżącym wątkiem, zostanie utworzony <xref:System.Windows.Threading.Dispatcher> nowy.  Nie jest to przypadek z <xref:System.Windows.Threading.Dispatcher.FromThread%2A> metodą.  <xref:System.Windows.Threading.Dispatcher.FromThread%2A>zwraca `null` , jeśli nie istnieje Dyspozytor skojarzony z określonym wątkiem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberSignature Language="F#" Value="member this.DisableProcessing : unit -&gt; System.Windows.Threading.DispatcherProcessingDisabled" Usage="dispatcher.DisableProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyłącza przetwarzanie <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki.</summary>
        <returns>Struktura używana do ponownego włączenia przetwarzania dyspozytora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyłączanie przetwarzania dyspozytora to metoda zaawansowana, która ma na celu wyeliminowanie możliwości niepowiązanych współużytkowania wątkowości.  
  
 Efekty wyłączania przetwarzania są następujące:  
  
-   Blokady środowiska CLR nie będą przekazywać komunikatów wewnętrznie.  
  
-   <xref:System.Windows.Threading.DispatcherFrame>nie można wypchnąć obiektów.  
  
-   Przetwarzanie komunikatów jest niedozwolone.  
  
 Struktura, która <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> zwraca, gdy jest wywoływana, może zostać użyta do ponownego włączenia przetwarzania dyspozytora. <xref:System.Windows.Threading.DispatcherProcessingDisabled>  Wywołanie <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> w ramach <xref:System.Windows.Threading.DispatcherProcessingDisabled> struktury powoduje ponowne włączenie przetwarzania.  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>można wywołać tylko w wątku, z którym <xref:System.Windows.Threading.Dispatcher> jest skojarzony.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wyłączyć przetwarzanie dyspozytora i ponownie włączyć przetwarzanie dyspozytora.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>jest wywoływana w instrukcji **using** .  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>zwraca strukturę, która jest używana jako obiekt do usunięcia, gdy zostanie zakończone **Używanie bloku.** <xref:System.Windows.Threading.DispatcherProcessingDisabled>  Gdy <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> jest wywoływana <xref:System.Windows.Threading.DispatcherProcessingDisabled> w strukturze, przetwarzanie dyspozytora jest ponownego włączenia.  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberSignature Language="F#" Value="static member ExitAllFrames : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ExitAllFrames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Żądania, które opuszczają wszystkie ramki, w tym zagnieżdżone ramki.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">do wywoływania tej metody. Skojarzone wyliczenia:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberSignature Language="F#" Value="static member FromThread : System.Threading.Thread -&gt; System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.FromThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">Wątek, z którego ma <see cref="T:System.Windows.Threading.Dispatcher" /> zostać uzyskana wartość.</param>
        <summary><see cref="T:System.Windows.Threading.Dispatcher" /> Pobiera dla określonego wątku.</summary>
        <returns>Dyspozytor dla <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli Dyspozytor nie jest dostępny dla określonego wątku, `null` zostanie zwrócony.  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A>nie tworzy <xref:System.Windows.Threading.Dispatcher> w wątku, który nie <xref:System.Windows.Threading.Dispatcher>ma.   Nowy <xref:System.Windows.Threading.Dispatcher> element jest tworzony w wątku, który nie <xref:System.Windows.Threading.Dispatcher> ma jeszcze <xref:System.Windows.Threading.Dispatcher> próby <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> pobrania przy użyciu właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownFinished : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, <see cref="T:System.Windows.Threading.Dispatcher" /> czy zakończono zamykanie.</summary>
        <value><see langword="true" />Jeśli Dyspozytor zakończył zamykanie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy rozpocznie się zamykanie <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> , zdarzenie jest wywoływane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest ustawione na `true`. <xref:System.Windows.Threading.Dispatcher>  
  
 <xref:System.Windows.Threading.Dispatcher> Program nie zostanie całkowicie zamknięty do momentu zakończenia kolejki zdarzeń.  
  
 Gdy Dyspozytor zakończy zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest wywoływane, <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> a właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące elementy robocze w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, <see cref="T:System.Windows.Threading.Dispatcher" /> czy jest zamykany.</summary>
        <value><see langword="true" />Jeśli rozpoczęło się <see cref="T:System.Windows.Threading.Dispatcher" /> zamykanie; w przeciwnym razie, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy rozpocznie się zamykanie <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> , zdarzenie jest wywoływane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest ustawione na `true`. <xref:System.Windows.Threading.Dispatcher>  
  
 Nie <xref:System.Windows.Threading.Dispatcher> zamyka się całkowicie do momentu zakończenia kolejki zdarzeń.  
  
 Gdy Dyspozytor zakończy zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest wywoływane, <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> a właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące elementy robocze w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hooks : System.Windows.Threading.DispatcherHooks" Usage="System.Windows.Threading.Dispatcher.Hooks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję punktów zaczepienia, które zawierają dodatkowe informacje o zdarzeniach <see cref="T:System.Windows.Threading.Dispatcher" />na temat.</summary>
        <value>Punkty zaczepienia skojarzone z tym <see cref="T:System.Windows.Threading.Dispatcher" />elementem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa zawiera dodatkowe informacje <xref:System.Windows.Threading.Dispatcher>o zdarzeniach <xref:System.Windows.Threading.Dispatcher> , takie jak, gdy jest nieaktywny lub Kiedy operacja uległa konkurowaniu. <xref:System.Windows.Threading.DispatcherHooks>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">do uzyskania tej właściwości.  Skojarzone wyliczenia:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje określony delegat synchronicznie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
   
  
## Examples  
 Poniższy przykład umieszcza delegata <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Threading.DispatcherPriority.Normal> na przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action -&gt; unit" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> synchronicznie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> synchronicznie o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat do metody, która pobiera parametry określone w <paramref name="args" />, który jest wypychany <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określony delegat z określonymi argumentami synchronicznie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu. Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika. Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika. Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny. Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="method">Delegat do metody, która nie przyjmuje argumentów, która jest wypychana <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <summary>Wykonuje określony delegat synchronicznie o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
   
  
## Examples  
 Poniższy przykład umieszcza delegata <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Threading.DispatcherPriority.Normal> na przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" />jest równe <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" />nie jest prawidłowym priorytetem.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować akcję.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> synchronicznie o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat do metody, która pobiera parametry określone w <paramref name="args" />, który jest wypychany <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="timeout">Maksymalna ilość czasu oczekiwania na zakończenie operacji.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określony delegat w wyznaczonym przedziale czasu o określonym priorytecie z określonymi argumentami synchronicznie w wątku, <see cref="T:System.Windows.Threading.Dispatcher" /> z którym jest skojarzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu. Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika. Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika. Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny. Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat do metody, która pobiera parametry określone w <paramref name="args" />, który jest wypychany <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określony delegat o określonym priorytecie synchronicznie na wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu. Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika. Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika. Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny. Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="method">Delegat do metody, która przyjmuje jeden argument, który jest wypychany <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który ma zostać przekazany jako argument do danej metody.</param>
        <summary>Wykonuje określony delegat o określonym priorytecie synchronicznie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`może być `null` , jeśli argument nie jest wymagany  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" />jest równe <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" />nie jest prawidłowym priorytetem.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="timeout">Maksymalny czas oczekiwania na zakończenie operacji.</param>
        <param name="method">Delegat do metody, która nie przyjmuje argumentów, która jest wypychana <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <summary>Wykonuje określony delegat synchronicznie o określonym priorytecie i z określoną wartością limitu czasu w wątku, który <see cref="T:System.Windows.Threading.Dispatcher" /> został utworzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować akcję.</param>
        <param name="timeout">Minimalny czas oczekiwania na uruchomienie operacji.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> synchronicznie o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat do metody, która pobiera parametry określone w <paramref name="args" />, który jest wypychany <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="timeout">Maksymalna ilość czasu oczekiwania na zakończenie operacji.</param>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określony delegat w wyznaczonym przedziale czasu o określonym priorytecie z określonymi argumentami synchronicznie w wątku, <see cref="T:System.Windows.Threading.Dispatcher" /> z którym jest skojarzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu. Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika. Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika. Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny. Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="method">Delegat do metody, która przyjmuje wiele argumentów, które są wypychane <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który ma zostać przekazany jako argument do danej metody.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do danej metody.</param>
        <summary>Wykonuje określony delegat o określonym priorytecie synchronicznie na wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`może być `null` , jeśli argument nie jest wymagany  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" />jest równe <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" />nie jest prawidłowym priorytetem.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="timeout">Maksymalny czas oczekiwania na zakończenie operacji.</param>
        <param name="method">Delegat do metody, która przyjmuje wiele argumentów, które są wypychane <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który ma zostać przekazany jako argument do danej metody. Może to być <see langword="null" /> brak argumentów.</param>
        <summary>Wykonuje określony delegat o określonym priorytecie synchronicznie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`może być `null` , jeśli argument nie jest wymagany  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" />jest równe <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" />nie jest prawidłowym priorytetem.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorytet względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejce zdarzeń jest wywoływany przez określoną metodę.</param>
        <param name="timeout">Maksymalny czas oczekiwania na zakończenie operacji.</param>
        <param name="method">Delegat do metody, która przyjmuje wiele argumentów, które są wypychane <see cref="T:System.Windows.Threading.Dispatcher" /> do kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który ma zostać przekazany jako argument do określonej metody.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do określonej metody.</param>
        <summary>Wykonuje określony delegat o określonym priorytecie synchronicznie na wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`może być `null` , jeśli argument nie jest wymagany.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]programie tylko wątek, który utworzył element <xref:System.Windows.Threading.DispatcherObject> , może uzyskać dostęp do tego obiektu.  Na przykład wątek w tle, który jest odsunięty od głównego wątku interfejsu użytkownika, nie może zaktualizować zawartości <xref:System.Windows.Controls.Button> programu, który został utworzony w wątku interfejsu użytkownika.  Aby wątek w tle mógł uzyskać dostęp do właściwości <xref:System.Windows.Controls.Button>zawartości, wątek w tle musi delegować prace <xref:System.Windows.Threading.Dispatcher> do skojarzonego z wątkiem interfejsu użytkownika.  Jest to realizowane za pomocą <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>albo.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest synchroniczny <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest asynchroniczny.  Operacja zostanie dodana do kolejki <xref:System.Windows.Threading.Dispatcher> zdarzeń o określonej <xref:System.Windows.Threading.DispatcherPriority>wartości.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>jest operacją synchroniczną; w związku z tym formant nie zwróci do obiektu wywołującego, dopóki nie zwróci wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" />jest równe <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" />jest nieprawidłowy <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; -&gt; 'Result" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej dla określonego delegata.</typeparam>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> synchronicznie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej dla określonego delegata.</typeparam>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> synchronicznie o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej dla określonego delegata.</typeparam>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować operację.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> synchronicznie o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej dla określonego delegata.</typeparam>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować operację.</param>
        <param name="timeout">Minimalny czas oczekiwania na uruchomienie operacji.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> synchronicznie o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje określony delegat asynchronicznie w wątku, z <see cref="T:System.Windows.Threading.Dispatcher" /> którym jest skojarzony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> asynchronicznie w wątku, z <see cref="T:System.Windows.Threading.Dispatcher" /> którym jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <summary>Wykonuje określone <see cref="T:System.Action" /> asynchroniczne o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować akcję.</param>
        <summary>Wykonuje określone <see cref="T:System.Action" /> asynchroniczne o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej dla określonego delegata.</typeparam>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> asynchronicznie w wątku, z <see cref="T:System.Windows.Threading.Dispatcher" /> którym jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej dla określonego delegata.</typeparam>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <summary>Wykonuje określone <see cref="T:System.Func`1" /> asynchroniczne o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej dla określonego delegata.</typeparam>
        <param name="callback">Delegat do wywołania przez dyspozytora.</param>
        <param name="priority">Priorytet określający kolejność wywoływania określonego wywołania zwrotnego względem innych oczekujących operacji w <see cref="T:System.Windows.Threading.Dispatcher" />elemencie.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować operację.</param>
        <summary>Wykonuje określone <see cref="T:System.Func`1" /> asynchroniczne o określonym priorytecie w wątku, z którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany bezpośrednio po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> wywołaniu, może być używany do współdziałania z delegatem, ponieważ oczekuje na wykonanie w kolejce zdarzeń.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberSignature Language="F#" Value="member this.InvokeShutdown : unit -&gt; unit" Usage="dispatcher.InvokeShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje proces <see cref="T:System.Windows.Threading.Dispatcher" /> zamykania synchronicznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A>wymaga uprawnień do nieograniczonego interfejsu użytkownika.  
  
 Gdy rozpocznie się zamykanie <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> , zdarzenie jest wywoływane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest ustawione na `true`. <xref:System.Windows.Threading.Dispatcher>  
  
 Nie <xref:System.Windows.Threading.Dispatcher> zamyka się całkowicie do momentu zakończenia kolejki zdarzeń.  
  
 Gdy Dyspozytor zakończy zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest wywoływane, <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> a właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące elementy robocze w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">do zamykania dyspozytora.  Skojarzone wyliczenia:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberSignature Language="F#" Value="static member PushFrame : System.Windows.Threading.DispatcherFrame -&gt; unit" Usage="System.Windows.Threading.Dispatcher.PushFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">Ramka do przetworzenia dla dyspozytora.</param>
        <summary>Wprowadza pętlę Execute.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.DispatcherFrame> Reprezentuje pętlę, która przetwarza oczekujące elementy robocze.  
  
 Dyspozytor przetwarza kolejkę elementów roboczych w pętli.  Pętla jest określana jako ramka.  Pętla początkowa jest zwykle inicjowana przez aplikację przez wywołanie <xref:System.Windows.Threading.Dispatcher.Run%2A>metody.  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>wprowadza pętlę reprezentowaną przez `frame`parametr.  W każdej iteracji pętli <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> program sprawdzi Właściwość <xref:System.Windows.Threading.DispatcherFrame> klasy, aby określić, czy pętla powinna być kontynuowana, czy powinna zostać zatrzymana.  
  
 <xref:System.Windows.Threading.DispatcherFrame>umożliwia jawne ustawienie <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> <xref:System.Windows.Threading.Dispatcher>właściwości i przestrzega właściwości w. <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>  Oznacza to, że <xref:System.Windows.Threading.Dispatcher> Kiedy rozpocznie się zamykanie, ramki używające domyślnej <xref:System.Windows.Threading.DispatcherFrame> implementacji zakończą działanie, co spowoduje zakończenie wszystkich zagnieżdżonych ramek.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać a <xref:System.Windows.Threading.DispatcherFrame> , aby osiągnąć podobne wyniki [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> jako metodę.  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="frame" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />była<see langword="true" />  
  
—lub— 
 <paramref name="frame" />działa na innym <see cref="T:System.Windows.Threading.Dispatcher" />.  
  
—lub— 
Przetwarzanie dyspozytora zostało wyłączone.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">do wypychania ramki wykonawczej.  Skojarzone wyliczenia:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wypchnij główną ramkę wykonania do kolejki <see cref="T:System.Windows.Threading.Dispatcher" />zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher> Przetwarza kolejkę zdarzeń w pętli.  Pętla jest określana jako ramka.  Pętla początkowa jest zwykle inicjowana przez aplikację przez wywołanie <xref:System.Windows.Threading.Dispatcher.Run%2A>metody.  
  
 Główna ramka wykonania będzie kontynuowana do momentu <xref:System.Windows.Threading.Dispatcher> zamknięcia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberSignature Language="F#" Value="member this.ShutdownFinished : EventHandler " Usage="member this.ShutdownFinished : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Windows.Threading.Dispatcher" /> zakończeniu zamykania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po uruchomieniu <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> procesu zamykania systemu `true`zdarzenie jest wywoływane i jest ustawione na. <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>  
  
 <xref:System.Windows.Threading.Dispatcher> Program nie zostanie całkowicie zamknięty do momentu zakończenia kolejki zdarzeń.  
  
 Gdy Dyspozytor zakończy zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest wywoływane, <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> a właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące elementy robocze w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberSignature Language="F#" Value="member this.ShutdownStarted : EventHandler " Usage="member this.ShutdownStarted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Windows.Threading.Dispatcher" /> rozpoczęciu zamknięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po uruchomieniu <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> procesu zamykania systemu `true`zdarzenie jest wywoływane i jest ustawione na. <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>  
  
 <xref:System.Windows.Threading.Dispatcher> Program nie zostanie całkowicie zamknięty do momentu zakończenia kolejki zdarzeń.  
  
 Gdy Dyspozytor zakończy zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest wywoływane, <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> a właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące elementy robocze w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thread : System.Threading.Thread" Usage="System.Windows.Threading.Dispatcher.Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wątek <see cref="T:System.Windows.Threading.Dispatcher" /> , z którym jest skojarzony.</summary>
        <value>Wątek.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek wątku jest zgłaszany i nieprzechwycony podczas wykonywania delegata w postaci <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> lub <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, gdy wystąpił wyjątek, który został zgłoszony podczas wykonywania delegata w <xref:System.Windows.Threading.Dispatcher.Invoke%2A> postaci <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> lub nie został przechwycony.  
  
 Program obsługi może oznaczyć wyjątek jako obsłużony, co uniemożliwi wywoływanie wewnętrznego programu obsługi wyjątków.  
  
 Obsługa zdarzeń dla tego zdarzenia musi być zapisywana, aby uniknąć tworzenia wyjątków pomocniczych i wychwycić wystąpienia, które wystąpią. Zaleca się uniknięcie przydzielania pamięci lub wykonywania operacji związanych z intensywnym użyciem zasobów w programie obsługi.  
  
 To <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> zdarzenie zapewnia metodę <xref:System.Windows.Threading.Dispatcher.UnhandledException> niezgłaszania zdarzenia.  <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> <xref:System.Windows.Threading.Dispatcher.UnhandledException> `false`Zdarzenie jest zgłaszane jako pierwsze, a jeśli wartość jest ustawiona na, zdarzenie nie zostanie zgłoszone. <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberSignature Language="F#" Value="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " Usage="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek wątku jest zgłaszany i wyrzucany podczas wykonywania delegata <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> w trybie lub <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> na etapie filtrowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane w fazie filtru dla wyjątku, który jest wywoływany podczas wykonywania delegata w postaci <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i jest odchwycony.  
  
 Stos wywołań nie jest odrany w tym momencie (wyjątek pierwszej szansy).  
  
 Obsługa zdarzeń dla tego zdarzenia musi być zapisywana, aby uniknąć tworzenia wyjątków pomocniczych i wychwycić wystąpienia, które wystąpią.  Zaleca się uniknięcie przydzielania pamięci lub wykonywania operacji związanych z intensywnym użyciem zasobów w programie obsługi.  
  
 To <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> zdarzenie zapewnia metodę <xref:System.Windows.Threading.Dispatcher.UnhandledException> niezgłaszania zdarzenia.  <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> <xref:System.Windows.Threading.Dispatcher.UnhandledException> `false`Zdarzenie jest zgłaszane jako pierwsze, a jeśli wartość jest ustawiona na, zdarzenie nie zostanie zgłoszone. <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu dodania lub usunięcia programu obsługi dla tego zdarzenia.  Skojarzone wyliczenia:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="static member ValidatePriority : System.Windows.Threading.DispatcherPriority * string -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ValidatePriority (priority, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet do sprawdzenia.</param>
        <param name="parameterName">Ciąg, który będzie zwracany przez wyjątek, który występuje, jeśli priorytet jest nieprawidłowy.</param>
        <summary>Określa, czy określony <see cref="T:System.Windows.Threading.DispatcherPriority" /> jest prawidłowy priorytet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" />jest nieprawidłowy <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberSignature Language="F#" Value="member this.VerifyAccess : unit -&gt; unit" Usage="dispatcher.VerifyAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy wątek wywołujący ma dostęp do <see cref="T:System.Windows.Threading.Dispatcher" />tego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko wątek, w <xref:System.Windows.Threading.Dispatcher> którym jest tworzony, może uzyskać <xref:System.Windows.Threading.Dispatcher>dostęp do.  
  
 Ta metoda jest publiczna; w związku z tym każdy wątek może sprawdzić, czy ma dostęp do <xref:System.Windows.Threading.Dispatcher>.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> Różnica między <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> i zwraca wartość logiczną, jeśli wątek <xref:System.Windows.Threading.Dispatcher> wywołujący nie ma dostępu do i zgłasza wyjątek. <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> do określenia, czy wątek ma dostęp do wątku <xref:System.Windows.Controls.Button> , w którym został utworzony.  Metoda przyjmuje obiekt jako argument, który jest rzutowany na <xref:System.Windows.Controls.Button>.  <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> Metoda<xref:System.Windows.Threading.Dispatcher> obiektu jestwywoływanawceluzweryfikowaniadostępudowątku.<xref:System.Windows.Controls.Button>  
  
 Jeśli wątek wywołujący ma dostęp do programu <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Controls.Button> , zostanie on zaktualizowany przez samo <xref:System.Windows.Controls.Button>uzyskanie dostępu do elementów członkowskich.  
  
 Jeśli wątek wywołujący nie ma dostępu, <xref:System.InvalidOperationException> jest zgłaszany.  Ten przykład przechwytuje wyjątek i wypycha delegata, który akceptuje <xref:System.Windows.Controls.Button> jako argument, <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Controls.Button>do.  Spowoduje <xref:System.Windows.Threading.Dispatcher> to wykonanie zadania <xref:System.Windows.Controls.Button>aktualizowania.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wątek wywołujący nie ma dostępu do tego <see cref="T:System.Windows.Threading.Dispatcher" />.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt oczekujący, który asynchronicznie daje kontrolę z powrotem do bieżącego dyspozytora i umożliwia dyspozytorowi przetworzenie innych zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt oczekujący, który asynchronicznie daje kontrolę z powrotem do bieżącego dyspozytora i umożliwia dyspozytorowi przetworzenie innych zdarzeń.</summary>
        <returns>Obiekt oczekujący, który asynchronicznie daje kontrolę z powrotem do bieżącego dyspozytora i umożliwia dyspozytorowi przetworzenie innych zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia sposób tymczasowego zwolnienia kontroli wykonywania do bieżącego dyspozytora, dzięki czemu może wykonywać inne czynności, takie jak przetwarzanie innych zdarzeń. Użyj, lub `Await` w Visual Basic, operatora na zwracanej wartości, aby zwrócić kontrolę do bieżącego dyspozytora. `await` Użyj tej metody, jeśli chcesz, aby aplikacja mogła przetwarzać zdarzenia, podczas gdy aplikacja wykonuje wiele pracy w wątku interfejsu użytkownika. Na przykład można użyć tej metody w długotrwałej pętli, która aktualizuje formant.  
  
 Ta metoda jest równoważna z wywołaniem <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29> metody i <xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>przekazaniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="static member Yield : System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, dla którego ma zostać zaplanowana kontynuacja.</param>
        <summary>Tworzy obiekt oczekujący, który asynchronicznie daje kontrolę z powrotem do bieżącego dyspozytora i umożliwia dyspozytorowi przetworzenie innych zdarzeń.  Pracy, która występuje, gdy sterowanie powraca do kodu oczekującego na wynik tej metody jest zaplanowana z określonym priorytetem.</summary>
        <returns>Obiekt oczekujący, który asynchronicznie daje kontrolę z powrotem do bieżącego dyspozytora i umożliwia dyspozytorowi przetworzenie innych zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia sposób tymczasowego zwolnienia kontroli wykonywania do bieżącego dyspozytora, dzięki czemu może wykonywać inne czynności, takie jak przetwarzanie innych zdarzeń. Użyj, lub `Await` w Visual Basic, operatora na zwracanej wartości, aby zwrócić kontrolę do bieżącego dyspozytora. `await` Użyj tej metody, jeśli chcesz, aby aplikacja mogła przetwarzać zdarzenia, podczas gdy aplikacja wykonuje wiele pracy w wątku interfejsu użytkownika. Na przykład można użyć tej metody w długotrwałej pętli, która aktualizuje formant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

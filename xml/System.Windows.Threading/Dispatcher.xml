<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5ad9e62b91662435080a893038a5962630437e09" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39942344" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <TypeSignature Language="F#" Value="type Dispatcher = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia usługi zarządzania kolejki elementów roboczych dla wątku.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher> Przechowuje priorytetami kolejki elementów roboczych dla określonego wątku.  
  
 Gdy <xref:System.Windows.Threading.Dispatcher> jest tworzony w wątku, staje się tylko <xref:System.Windows.Threading.Dispatcher> , może być skojarzony z wątkiem, nawet wtedy, gdy <xref:System.Windows.Threading.Dispatcher> zostanie zamknięta.  
  
 Jeśli spróbujesz uzyskać <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> dla bieżącego wątku i <xref:System.Windows.Threading.Dispatcher> nie jest skojarzony z wątkiem, <xref:System.Windows.Threading.Dispatcher> zostanie utworzony. A <xref:System.Windows.Threading.Dispatcher> również jest tworzony podczas tworzenia <xref:System.Windows.Threading.DispatcherObject>. Jeśli tworzysz <xref:System.Windows.Threading.Dispatcher> w wątku tła, pamiętaj zamknąć Dyspozytor przed opuszczeniem wątku.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher> ma to miejsce w dół, go nie można uruchomić ponownie.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], <xref:System.Windows.Threading.DispatcherObject> może zostać oceniony jedynie przez <xref:System.Windows.Threading.Dispatcher> jest skojarzony.  Na przykład wątku w tle nie może zaktualizować zawartość <xref:System.Windows.Controls.Button> skojarzony z <xref:System.Windows.Threading.Dispatcher> na [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] wątku.  Aby wątku tła w celu uzyskania dostępu do <xref:System.Windows.Controls.ContentControl.Content%2A> właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] wątku.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana w <xref:System.Windows.Threading.Dispatcher> , został zamknięty, stan właściwości zwracanego <xref:System.Windows.Threading.DispatcherOperation> ustawiono <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 Wszystkie metody na <xref:System.Windows.Threading.Dispatcher>, z wyjątkiem produktów <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, są bezwątkowy.  
  
 Obiekty, które wynikają z <xref:System.Windows.Threading.DispatcherObject> koligacji wątku.  
  
 Obiekty, które wynikają z <xref:System.Windows.Freezable> są bezwątkowy gdy są one zablokowane.  Aby uzyskać więcej informacji, zobacz [Przegląd obiektów Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak umieścić operacji na <xref:System.Windows.Threading.Dispatcher>.  Aby uzyskać pełny kod źródłowy w tym przykładzie, zobacz [Single-Threaded aplikacji z przykładem obliczania długotrwałych](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Po pierwsze delegat jest tworzony, który akceptuje żadnych argumentów.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Następnie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> jest wywoływana.  To wywołanie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> przyjmuje dwa parametry: priorytet, który jest ustawiona na <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>i wywołanie zwrotne, które są przekazywane za pośrednictwem wystąpienia delegata `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie wykonuje delegata w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna; w związku z tym formant powraca niezwłocznie do obiektu wywołującego po jest wywoływana.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Zwraca <xref:System.Windows.Threading.DispatcherOperation> obiektu, który może służyć do interakcji z obiektem delegowanym, kiedy delegat jest w zdarzeniu kolejki.  
  
 <xref:System.Windows.Threading.DispatcherOperation> Obiektu zwróconego przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> można używać na kilka sposobów interakcji z określonym obiektem delegowanym, takich jak:  
  
-   Zmiana <xref:System.Windows.Threading.DispatcherPriority> delegata się oczekujące wykonanie zdarzeń w kolejce.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na delegata do zwrócenia.  
  
-   Uzyskiwanie wartości, która delegata zwraca się po nim jest wykonywany.  
  
 Jeśli wiele <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> wywołań w tym samym <xref:System.Windows.Threading.DispatcherPriority>, zostaną one wykonane w porządku wywołania zostały wprowadzone.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana w <xref:System.Windows.Threading.Dispatcher> , został zamknięty, stan właściwości zwracanego <xref:System.Windows.Threading.DispatcherOperation> ustawiono <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat do metody, która przyjmuje parametrów określonych w <c>argumenty</c>, które są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="args">Tablica obiektów przekazywane jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określonego delegata asynchronicznie z określonymi argumentami w wątku, który <see cref="T:System.Windows.Threading.Dispatcher" /> został utworzony na.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.DispatcherOperation> Obiektu zwróconego przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> można używać na kilka sposobów interakcji z określonym obiektem delegowanym, takich jak:  
  
-   Zmiana <xref:System.Windows.Threading.DispatcherPriority> delegata się oczekujące wykonanie zdarzeń w kolejce.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na delegata do zwrócenia.  
  
-   Uzyskiwanie wartości, która delegata zwraca się po nim jest wykonywany.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna; w związku z tym formant powraca niezwłocznie do obiektu wywołującego po jest wywoływana.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu. Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika. Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika. Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna. Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana w <xref:System.Windows.Threading.Dispatcher> , został zamknięty, stan właściwości zwracanego <xref:System.Windows.Threading.DispatcherOperation> ustawiono <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="method">Delegowany do metody, która nie przyjmuje żadnych argumentów, które są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <summary>Wykonuje określonego delegata asynchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wiele <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> wywołań w tym samym <xref:System.Windows.Threading.DispatcherPriority>, zostaną one wykonane w porządku wywołania zostały wprowadzone.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Zwraca <xref:System.Windows.Threading.DispatcherOperation> obiektu, który może służyć do interakcji z obiektem delegowanym, kiedy delegat jest w zdarzeniu kolejki.  
  
 <xref:System.Windows.Threading.DispatcherOperation> Obiektu zwróconego przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> można używać na kilka sposobów interakcji z określonym obiektem delegowanym, takich jak:  
  
-   Zmiana <xref:System.Windows.Threading.DispatcherPriority> delegata się oczekujące wykonanie zdarzeń w kolejce.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na delegata do zwrócenia.  
  
-   Uzyskiwanie wartości, która delegata zwraca się po nim jest wykonywany.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna; w związku z tym formant powraca niezwłocznie do obiektu wywołującego po jest wywoływana.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana w <xref:System.Windows.Threading.Dispatcher> , został zamknięty, stan właściwości zwracanego <xref:System.Windows.Threading.DispatcherOperation> ustawiono <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak umieścić operacji na <xref:System.Windows.Threading.Dispatcher>.  Aby uzyskać pełny kod źródłowy w tym przykładzie, zobacz [Single-Threaded aplikacji z przykładem obliczania długotrwałych](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Po pierwsze delegat jest tworzony, który akceptuje żadnych argumentów.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Następnie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> jest wywoływana.  Ponieważ każdy <xref:System.Windows.Threading.DispatcherObject> ma właściwość, która zwraca <xref:System.Windows.Threading.Dispatcher> jest skojarzony z żądaną <xref:System.Windows.Threading.Dispatcher> uzyskuje się przez badanie <xref:System.Windows.Threading.DispatcherObject>, w tym przypadku <xref:System.Windows.Controls.Button> o nazwie `startStopButton`.   Wywołanie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> przyjmuje dwa parametry: priorytet, który jest ustawiona na <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>i wywołanie zwrotne, które są przekazywane za pośrednictwem wystąpienia delegata `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> nie jest prawidłowym <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat do metody, która przyjmuje parametrów określonych w <c>argumenty</c>, które są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="args">Tablica obiektów przekazywane jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określonego delegata asynchronicznie z określonymi argumentami, priorytetem określony w wątku, który <see cref="T:System.Windows.Threading.Dispatcher" /> został utworzony na.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.DispatcherOperation> Obiektu zwróconego przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> można używać na kilka sposobów interakcji z określonym obiektem delegowanym, takich jak:  
  
-   Zmiana <xref:System.Windows.Threading.DispatcherPriority> delegata się oczekujące wykonanie zdarzeń w kolejce.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na delegata do zwrócenia.  
  
-   Uzyskiwanie wartości, która delegata zwraca się po nim jest wykonywany.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna; w związku z tym formant powraca niezwłocznie do obiektu wywołującego po jest wywoływana.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu. Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika. Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika. Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna. Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana w <xref:System.Windows.Threading.Dispatcher> , został zamknięty, stan właściwości zwracanego <xref:System.Windows.Threading.DispatcherOperation> ustawiono <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="method">Obiekt delegowany do metody, która przyjmuje jeden argument, który zostanie przypisany do <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="arg">Obiekt do przekazania jako argument do określonej metody.</param>
        <summary>Wykonuje określonego delegata asynchronicznie przy określonym priorytecie i określony argument na wątek <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` może być `null` razie bez argumentów.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Zwraca <xref:System.Windows.Threading.DispatcherOperation> obiektu, który może służyć do interakcji z obiektem delegowanym, kiedy delegat jest w zdarzeniu kolejki.  
  
 <xref:System.Windows.Threading.DispatcherOperation> Obiektu zwróconego przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> można używać na kilka sposobów interakcji z określonym obiektem delegowanym, takich jak:  
  
-   Zmiana <xref:System.Windows.Threading.DispatcherPriority> delegata się oczekujące wykonanie zdarzeń w kolejce.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na delegata do zwrócenia.  
  
-   Uzyskiwanie wartości, która delegata zwraca się po nim jest wykonywany.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna; w związku z tym formant powraca niezwłocznie do obiektu wywołującego po jest wywoływana.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Jeśli wiele <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> wywołań w tym samym <xref:System.Windows.Threading.DispatcherPriority>, zostaną one wykonane w porządku wywołania zostały wprowadzone.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana w <xref:System.Windows.Threading.Dispatcher> , został zamknięty, stan właściwości zwracanego <xref:System.Windows.Threading.DispatcherOperation> ustawiono <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak umieścić operacji na <xref:System.Windows.Threading.Dispatcher>.  
  
 Po pierwsze obiekt delegowany jest tworzony, który przyjmuje jeden argument, w tym przypadku ciąg.  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 Następnie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> jest wywoływana.  Ponieważ każdy <xref:System.Windows.Threading.DispatcherObject> ma właściwość, która zwraca <xref:System.Windows.Threading.Dispatcher> jest skojarzony z żądaną <xref:System.Windows.Threading.Dispatcher> uzyskuje się przez badanie <xref:System.Windows.Threading.DispatcherObject>, w tym przypadku <xref:System.Windows.Controls.Grid> o nazwie `tomorrowsWeather`. Wywołanie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> przyjmuje trzy parametry: priorytet, który jest ustawiona na <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>; wywołanie zwrotne, które są przekazywane za pośrednictwem wystąpienia delegata `OneArgDelegate`; i parametry o nazwie `weather`, czyli argument wywołania zwrotnego.  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> nie jest prawidłowym <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="method">Delegowany do metody, która przyjmuje wiele argumentów, który są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="arg">Obiekt do przekazania jako argument do określonej metody.</param>
        <param name="args">Tablica obiektów przekazywane jako argumenty do określonej metody.</param>
        <summary>Wykonuje określonego delegata asynchronicznie określony priorytet i z określoną tablicę argumentów w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arg` Parametr może być `null` razie bez argumentów.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Zwraca <xref:System.Windows.Threading.DispatcherOperation> obiektu, który może służyć do interakcji z obiektem delegowanym, kiedy delegat jest w zdarzeniu kolejki.  
  
 <xref:System.Windows.Threading.DispatcherOperation> Obiektu zwróconego przez <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> można używać na kilka sposobów interakcji z określonym obiektem delegowanym, takich jak:  
  
-   Zmiana <xref:System.Windows.Threading.DispatcherPriority> delegata się oczekujące wykonanie zdarzeń w kolejce.  
  
-   Usuwanie delegata z kolejki zdarzeń.  
  
-   Oczekiwanie na delegata do zwrócenia.  
  
-   Uzyskiwanie wartości, która delegata zwraca się po nim jest wykonywany.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna; w związku z tym formant powraca niezwłocznie do obiektu wywołującego po jest wywoływana.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Jeśli wiele <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> wywołań w tym samym <xref:System.Windows.Threading.DispatcherPriority>, zostaną one wykonane w porządku wywołania zostały wprowadzone.  
  
 Jeśli <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest wywoływana w <xref:System.Windows.Threading.Dispatcher> , został zamknięty, stan właściwości zwracanego <xref:System.Windows.Threading.DispatcherOperation> ustawiono <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Windows.Threading.DispatcherPriority" /> nie jest prawidłową priorytetu.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.BeginInvokeShutdown : System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.BeginInvokeShutdown priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, od którego należy rozpocząć zamykanie Dyspozytor.</param>
        <summary>Zamknięcie inicjuje <see cref="T:System.Windows.Threading.Dispatcher" /> asynchronicznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A> żądania bez ograniczeń uprawnień interfejsu użytkownika.  
  
 Gdy <xref:System.Windows.Threading.Dispatcher> rozpoczyna się do zamknięcia, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest równa `true`.  
  
 <xref:System.Windows.Threading.Dispatcher> Nie całkowicie wyłączyć do momentu rozwija kolejki zdarzeń.  
  
 Po zakończeniu dyspozytor, zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące robocze elementów w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać zamykanie Dyspozytor.  Skojarzone wyliczeń:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberSignature Language="F#" Value="member this.CheckAccess : unit -&gt; bool" Usage="dispatcher.CheckAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy wątek wywołujący jest wątek skojarzony z tym <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący jest wątek skojarzony z tym <see cref="T:System.Windows.Threading.Dispatcher" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko <xref:System.Windows.Threading.Dispatcher> , <xref:System.Windows.Threading.DispatcherObject> jest tworzony na mogą uzyskiwać dostęp do obiektu.  Użyj <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> dostępu do obiektu z innego wątku.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> może być wywołana z żadnym z wątków.  
  
 Różnica między <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> i <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> jest <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> zwraca wartość Boolean wskazującą, czy wątek wywołujący ma dostęp do <xref:System.Windows.Threading.Dispatcher> i <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> zgłasza wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> do określenia, czy wątek ma dostęp do <xref:System.Windows.Controls.Button>.  <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> Metody <xref:System.Windows.Threading.Dispatcher> skojarzony <xref:System.Windows.Controls.Button> jest wywoływana, aby zweryfikować dostęp do wątku.  Jeśli wątek wywołujący ma dostęp do <xref:System.Windows.Threading.Dispatcher>, <xref:System.Windows.Controls.Button> jest aktualizowany, uzyskując dostęp do elementów członkowskich <xref:System.Windows.Controls.Button>; w przeciwnym razie delegata, który akceptuje <xref:System.Windows.Controls.Button> jako argument, jest umieszczany na <xref:System.Windows.Threading.Dispatcher>.  <xref:System.Windows.Threading.Dispatcher> Oddeleguje pracy aktualizowania <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDispatcher : System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Threading.Dispatcher" /> wątku w trakcie wykonywania i tworzy nową <see cref="T:System.Windows.Threading.Dispatcher" /> Jeśli nie jest już skojarzony z wątkiem.</summary>
        <value>Dyspozytor skojarzone z bieżącym wątkiem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Threading.Dispatcher> nie jest skojarzony z bieżącym wątkiem nową <xref:System.Windows.Threading.Dispatcher> zostanie utworzony.  To nie jest w przypadku <xref:System.Windows.Threading.Dispatcher.FromThread%2A> metody.  <xref:System.Windows.Threading.Dispatcher.FromThread%2A> zwróci `null` Jeśli nie jest dyspozytora, skojarzone z określonego wątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberSignature Language="F#" Value="member this.DisableProcessing : unit -&gt; System.Windows.Threading.DispatcherProcessingDisabled" Usage="dispatcher.DisableProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przetwarzanie wyłącza <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki.</summary>
        <returns>Struktura użyta, aby ponownie włączyć dyspozytora przetwarzania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyłączenie dyspozytora przetwarzania jest zaawansowane metody, która ma na celu wyeliminowanie prawdopodobieństwo niepowiązanych współużytkowania wątkowości.  
  
 Efekty wyłączenia przetwarzania są następujące:  
  
-   Blokady CLR nie będzie wewnętrznie pompy komunikatów.  
  
-   <xref:System.Windows.Threading.DispatcherFrame> obiekty nie są dozwolone ma zostać wypchnięty.  
  
-   Przetwarzanie komunikatu nie jest dozwolone.  
  
 <xref:System.Windows.Threading.DispatcherProcessingDisabled> Struktury, która <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> zwraca, gdy wywoływana jest można ponownie włączyć dyspozytora przetwarzania.  Wywoływanie <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> na <xref:System.Windows.Threading.DispatcherProcessingDisabled> struktury ponownie włączy przetwarzania.  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> można wywołać tylko w wątku <xref:System.Windows.Threading.Dispatcher> jest skojarzony.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wyłączyć dyspozytora przetwarzania i ponownie włączyć dyspozytora przetwarzania.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> jest wywoływana w **przy użyciu** instrukcji.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> Zwraca <xref:System.Windows.Threading.DispatcherProcessingDisabled> strukturę, która jest używana jako obiekt być usunięte, gdy **przy użyciu** block zostanie zakończone.  Gdy <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> jest wywoływana w <xref:System.Windows.Threading.DispatcherProcessingDisabled> struktury, dyspozytora przetwarzanie zostanie ponownie włączony.  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberSignature Language="F#" Value="static member ExitAllFrames : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ExitAllFrames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Żądania, które wyjść wszystkie ramki, w tym zagnieżdżone ramki.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać wywołanie tej metody. Skojarzone wyliczeń:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberSignature Language="F#" Value="static member FromThread : System.Threading.Thread -&gt; System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.FromThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">Wątek, aby uzyskać <see cref="T:System.Windows.Threading.Dispatcher" /> z.</param>
        <summary>Pobiera <see cref="T:System.Windows.Threading.Dispatcher" /> dla określonego wątku.</summary>
        <returns>Dyspozytor dla <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku dispatcher nie jest dostępna dla określonego wątku `null` zostaną zwrócone.  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A> nie powoduje utworzenia <xref:System.Windows.Threading.Dispatcher> w wątku, który nie ma <xref:System.Windows.Threading.Dispatcher>.   Nowy <xref:System.Windows.Threading.Dispatcher> jest tworzony w wątku, który nie ma jeszcze <xref:System.Windows.Threading.Dispatcher> podczas próby pobrania <xref:System.Windows.Threading.Dispatcher> przy użyciu <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownFinished : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy <see cref="T:System.Windows.Threading.Dispatcher" /> zakończył zamykanie.</summary>
        <value>
          <see langword="true" /> Jeśli Dyspozytor zakończył zamykanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Threading.Dispatcher> rozpoczyna się do zamknięcia, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest równa `true`.  
  
 <xref:System.Windows.Threading.Dispatcher> Nie jest zamykany całkowicie aż rozwija kolejki zdarzeń.  
  
 Po zakończeniu dyspozytor, zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące robocze elementów w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy <see cref="T:System.Windows.Threading.Dispatcher" /> jest zamykany.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Threading.Dispatcher" /> Rozpoczęto zamykanie w dół, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Threading.Dispatcher> rozpoczyna się do zamknięcia, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest równa `true`.  
  
 <xref:System.Windows.Threading.Dispatcher> Nie całkowicie wyłączyć do momentu rozwija kolejki zdarzeń.  
  
 Po zakończeniu dyspozytor, zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące robocze elementów w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hooks : System.Windows.Threading.DispatcherHooks" Usage="System.Windows.Threading.Dispatcher.Hooks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję punktów zaczepienia, które zawierają informacje dodatkowe zdarzenia o <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <value>Punkty zaczepienia skojarzony z tym <see cref="T:System.Windows.Threading.Dispatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.DispatcherHooks> Klasy zawiera zdarzenia dodatkowe informacje na temat <xref:System.Windows.Threading.Dispatcher>, takie jak czas <xref:System.Windows.Threading.Dispatcher> jest nieaktywna lub jeśli operacja ma ukończone.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu uzyskania tej właściwości.  Skojarzone wyliczeń:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określonego delegata jest wykonywana synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
   
  
## Examples  
 Poniższy przykład umieszcza delegata na <xref:System.Windows.Threading.Dispatcher> na <xref:System.Windows.Threading.DispatcherPriority.Normal> przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action -&gt; unit" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> synchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Obiekt delegowany do metody, która przyjmuje parametrów określonych w <c>args</c>, które są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="args">Tablica obiektów przekazywane jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określonego delegata z określonymi argumentami synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu. Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika. Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika. Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna. Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="method">Delegowany do metody, która nie przyjmuje żadnych argumentów, które są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <summary>Wykonuje określonego delegata synchronicznie o określonym priorytecie w wątku, na którym <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
   
  
## Examples  
 Poniższy przykład umieszcza delegata na <xref:System.Windows.Threading.Dispatcher> na <xref:System.Windows.Threading.DispatcherPriority.Normal> przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> jest równa <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> nie jest prawidłową priorytetu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować czynność.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> synchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Obiekt delegowany do metody, która przyjmuje parametrów określonych w <c>args</c>, które są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="timeout">Maksymalna ilość czasu oczekiwania na ukończenie tej operacji.</param>
        <param name="args">Tablica obiektów przekazywane jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określonego delegata w zasięgu wyznaczonym czasie, o określonym priorytecie ze specyficznymi argumentami synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu. Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika. Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika. Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna. Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Obiekt delegowany do metody, która przyjmuje parametrów określonych w <c>args</c>, które są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="args">Tablica obiektów przekazywane jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określonego delegata, o określonym priorytecie ze specyficznymi argumentami synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu. Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika. Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika. Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna. Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="method">Obiekt delegowany do metody, która przyjmuje jeden argument, który zostanie przypisany do <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który można przekazać jako argument do danej metody.</param>
        <summary>Określonego delegata, o określonym priorytecie przy użyciu określonego argumentu jest wykonywana synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` może być `null` Jeśli argument nie jest wymagana.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> jest równa <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> nie jest prawidłową priorytetu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="timeout">Maksymalny czas oczekiwania na zakończenie operacji.</param>
        <param name="method">Delegowany do metody, która nie przyjmuje żadnych argumentów, które są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <summary>Wykonuje określonego delegata synchronicznie przy określonym priorytecie i określoną wartość limitu czasu w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> został utworzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować czynność.</param>
        <param name="timeout">Minimalna ilość czasu oczekiwania operacji uruchamiania.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> synchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Obiekt delegowany do metody, która przyjmuje parametrów określonych w <c>args</c>, które są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="timeout">Maksymalna ilość czasu oczekiwania na ukończenie tej operacji.</param>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="args">Tablica obiektów przekazywane jako argumenty do danej metody. Może być <see langword="null" />.</param>
        <summary>Wykonuje określonego delegata w zasięgu wyznaczonym czasie, o określonym priorytecie ze specyficznymi argumentami synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu. Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika. Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika. Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna. Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="method">Delegowany do metody, która przyjmuje wiele argumentów, który są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który można przekazać jako argument do danej metody.</param>
        <param name="args">Tablica obiektów przekazywane jako argumenty do danej metody.</param>
        <summary>Wykonuje określonego delegata, o określonym priorytecie ze specyficznymi argumentami synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` może być `null` Jeśli argument nie jest wymagana.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> jest równa <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> nie jest prawidłową priorytetu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="timeout">Maksymalny czas oczekiwania na zakończenie operacji.</param>
        <param name="method">Delegowany do metody, która przyjmuje wiele argumentów, który są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który można przekazać jako argument do danej metody. Może to być <see langword="null" /> razie bez argumentów.</param>
        <summary>Określonego delegata, o określonym priorytecie przy użyciu określonego argumentu jest wykonywana synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` może być `null` Jeśli argument nie jest wymagana.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> jest równa <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> nie jest prawidłową priorytetu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń, podana metoda jest wywoływana.</param>
        <param name="timeout">Maksymalny czas oczekiwania na zakończenie operacji.</param>
        <param name="method">Delegowany do metody, która przyjmuje wiele argumentów, który są wypychane na <see cref="T:System.Windows.Threading.Dispatcher" /> kolejki zdarzeń.</param>
        <param name="arg">Obiekt, który można przekazać jako argument do określonej metody.</param>
        <param name="args">Tablica obiektów przekazywane jako argumenty do określonej metody.</param>
        <summary>Wykonuje określonego delegata, o określonym priorytecie ze specyficznymi argumentami synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Wartość zwrócona przez delegata wywoływanego lub <see langword="null" /> Jeśli delegat nie zwraca żadnej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` może być `null` Jeśli argument nie jest wymagana.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], wątek, który utworzył <xref:System.Windows.Threading.DispatcherObject> mogą uzyskiwać dostęp do tego obiektu.  Na przykład wątku w tle, która zostanie rozszerzona z wątku głównego interfejsu użytkownika nie można zaktualizować zawartości <xref:System.Windows.Controls.Button> utworzony przez wątek interfejsu użytkownika.  Aby wątku w tle do dostępu do zawartości właściwość <xref:System.Windows.Controls.Button>, wątku w tle musi delegować pracy <xref:System.Windows.Threading.Dispatcher> skojarzony wątek interfejsu użytkownika.  Jest to realizowane przy użyciu <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest synchroniczne i <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest asynchroniczna.  Operacja zostanie dodany do kolejki zdarzeń <xref:System.Windows.Threading.Dispatcher> w określonym <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> jest to operacja synchroniczna; w związku z tym formant nie powróci do obiektu wywołującego, dopóki nie po powrocie wywołania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> jest równa <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> nie jest prawidłowym <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; -&gt; 'Result" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej określonego delegata.</typeparam>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> synchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez obiekt `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej określonego delegata.</typeparam>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> synchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez obiekt `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej określonego delegata.</typeparam>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować operację.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> synchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez obiekt `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej określonego delegata.</typeparam>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować operację.</param>
        <param name="timeout">Minimalna ilość czasu oczekiwania operacji uruchamiania.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> synchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez obiekt `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie wykonuje określonego delegata w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> asynchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> asynchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować czynność.</param>
        <summary>Wykonuje określony <see cref="T:System.Action" /> asynchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej określonego delegata.</typeparam>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> asynchronicznie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej określonego delegata.</typeparam>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> asynchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wartości zwracanej określonego delegata.</typeparam>
        <param name="callback">Delegat wywołania za pośrednictwem Dyspozytor.</param>
        <param name="priority">Priorytet, który określa, w jakiej kolejności określonego wywołania zwrotnego jest wywoływana względem innych oczekujące operacje w <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Obiekt, który wskazuje, czy anulować operację.</param>
        <summary>Wykonuje określony <see cref="T:System.Func`1" /> synchronicznie o określonym priorytecie w wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <returns>Obiekt, który jest zwracany natychmiast po <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> nosi nazwę, która może służyć do interakcji z obiektem delegowanym, ponieważ jest oczekiwanie na wykonanie w zdarzeniu kolejki.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberSignature Language="F#" Value="member this.InvokeShutdown : unit -&gt; unit" Usage="dispatcher.InvokeShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje proces zamykania <see cref="T:System.Windows.Threading.Dispatcher" /> synchronicznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A> żądania bez ograniczeń uprawnień interfejsu użytkownika.  
  
 Gdy <xref:System.Windows.Threading.Dispatcher> rozpoczyna się do zamknięcia, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest równa `true`.  
  
 <xref:System.Windows.Threading.Dispatcher> Nie całkowicie wyłączyć do momentu rozwija kolejki zdarzeń.  
  
 Po zakończeniu dyspozytor, zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące robocze elementów w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać zamykanie Dyspozytor.  Skojarzone wyliczeń:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberSignature Language="F#" Value="static member PushFrame : System.Windows.Threading.DispatcherFrame -&gt; unit" Usage="System.Windows.Threading.Dispatcher.PushFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">Ramka dyspozytora do przetworzenia.</param>
        <summary>Wprowadza pętlę wykonania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Threading.DispatcherFrame> reprezentuje pętli, która przetwarza elementy robocze oczekujących.  
  
 Dyspozytor przetwarza kolejki elementów pracy w pętli.  Pętla jest określany jako ramka.  Początkowa pętli zazwyczaj jest inicjowane przez aplikację przez wywołanie metody <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> wprowadza pętlę reprezentowanego przez parametr `frame`.  W każdej iteracji pętli <xref:System.Windows.Threading.Dispatcher> sprawdzi <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> właściwość <xref:System.Windows.Threading.DispatcherFrame> klasę, aby określić, czy pętla powinno być kontynuowane, lub jeśli ma zostać zatrzymana.  
  
 <xref:System.Windows.Threading.DispatcherFrame> Umożliwia <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> i właściwości można ustawić jawnie szanuje <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> właściwość <xref:System.Windows.Threading.Dispatcher>.  Oznacza to, kiedy <xref:System.Windows.Threading.Dispatcher> rozpoczyna się, aby zamknąć, użyj wartości domyślnej ramki <xref:System.Windows.Threading.DispatcherFrame> implementacji zostanie zakończona, umożliwiająca wszystkich zagnieżdżonych ramek zakończyć pracę.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Threading.DispatcherFrame> do osiągnięcia podobne wyniki w postaci [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> metody.  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="frame" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" /> jest <see langword="true" /> - lub - <paramref name="frame" /> jest uruchomiony na innym <see cref="T:System.Windows.Threading.Dispatcher" />.  - lub - przetwarzania Dyspozytor został wyłączony.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">wypychania ramki wykonywania.  Skojarzone wyliczeń:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wypycha ramki głównej wykonywania na kolejki zdarzeń <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher> Przetwarza kolejki zdarzeń w pętli.  Pętla jest określany jako ramka.  Początkowa pętli zazwyczaj jest inicjowane przez aplikację przez wywołanie metody <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 Ramki głównego wykonywanie będzie kontynuowane do czasu <xref:System.Windows.Threading.Dispatcher> zostanie zamknięty.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberSignature Language="F#" Value="member this.ShutdownFinished : EventHandler " Usage="member this.ShutdownFinished : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Windows.Threading.Dispatcher" /> kończy zamykanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy proces zamykania <xref:System.Windows.Threading.Dispatcher> jest uruchomiona, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest równa `true`.  
  
 <xref:System.Windows.Threading.Dispatcher> Nie jest zamykany całkowicie aż rozwija kolejki zdarzeń.  
  
 Po zakończeniu dyspozytor, zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące robocze elementów w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberSignature Language="F#" Value="member this.ShutdownStarted : EventHandler " Usage="member this.ShutdownStarted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Windows.Threading.Dispatcher" /> rozpoczyna się w celu zamknięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy proces zamykania <xref:System.Windows.Threading.Dispatcher> jest uruchomiona, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> jest równa `true`.  
  
 <xref:System.Windows.Threading.Dispatcher> Nie jest zamykany całkowicie aż rozwija kolejki zdarzeń.  
  
 Po zakończeniu dyspozytor, zamykanie, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> zdarzenie jest zgłaszane i <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> właściwość jest ustawiona na `true`.  
  
 Po rozpoczęciu procesu zamykania wszystkie oczekujące robocze elementów w kolejce zostaną przerwane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thread : System.Threading.Thread" Usage="System.Windows.Threading.Dispatcher.Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wątku <see cref="T:System.Windows.Threading.Dispatcher" /> jest skojarzony.</summary>
        <value>Wątek.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek wątku jest zgłoszony i nieprzechwycony podczas wykonywania obiekt delegowany za <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> lub <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane, gdy wyjątek zgłoszony podczas wykonywania obiekt delegowany za <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> jest nieprzechwyconych.  
  
 Program obsługi można oznaczyć wyjątek jako obsłużony, która uniemożliwi obsługi wyjątku wewnętrznego wywoływana.  
  
 Programy obsługi zdarzeń dla tego zdarzenia muszą być napisane z rozwagą należy unikać tworzenia dodatkowych wyjątków i catch, wszystkie wystąpienia. Zalecane jest, aby uniknąć alokacji pamięci lub wykonujesz dowolnego zasobu intensywnie korzystających z operacji programu obsługi.  
  
 <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Zdarzenia zapewniają sposób zgłaszaj <xref:System.Windows.Threading.Dispatcher.UnhandledException> zdarzeń.  <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Zdarzenie jest wywoływane po pierwsze Jeśli <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> na <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> jest ustawiona na `false`, <xref:System.Windows.Threading.Dispatcher.UnhandledException> zdarzenia nie zostaną wywołane.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberSignature Language="F#" Value="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " Usage="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek wątku jest zgłoszony i nieprzechwycony podczas wykonywania obiekt delegowany za <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> lub <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> w fazie filtru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane podczas etapu filtra wyjątku, który jest wywoływany podczas wykonywania obiekt delegowany za <xref:System.Windows.Threading.Dispatcher.Invoke%2A> lub <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> i nieprzechwycony.  
  
 Stos wywołań nie jest rozwinięty w tym momencie (wyjątku pierwszej szansy).  
  
 Programy obsługi zdarzeń dla tego zdarzenia muszą być napisane z rozwagą należy unikać tworzenia dodatkowych wyjątków i catch, wszystkie wystąpienia.  Zalecane jest, aby uniknąć alokacji pamięci lub wykonujesz dowolnego zasobu intensywnie korzystających z operacji programu obsługi.  
  
 <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Zdarzenia zapewniają sposób zgłaszaj <xref:System.Windows.Threading.Dispatcher.UnhandledException> zdarzeń.  <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Zdarzenie jest wywoływane po pierwsze Jeśli <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> na <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> jest ustawiona na `false`, <xref:System.Windows.Threading.Dispatcher.UnhandledException> zdarzenia nie zostaną wywołane.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">do dodawania lub usuwania programu obsługi dla tego zdarzenia.  Skojarzone wyliczeń:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="static member ValidatePriority : System.Windows.Threading.DispatcherPriority * string -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ValidatePriority (priority, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet do sprawdzenia.</param>
        <param name="parameterName">Ciąg, który zostanie zwrócony przez wyjątek, który występuje, gdy priorytet jest nieprawidłowy.</param>
        <summary>Określa, czy określony <see cref="T:System.Windows.Threading.DispatcherPriority" /> ma nieprawidłowy priorytet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> nie jest prawidłowym <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberSignature Language="F#" Value="member this.VerifyAccess : unit -&gt; unit" Usage="dispatcher.VerifyAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy wątek wywołujący ma dostęp do tego <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko wątek <xref:System.Windows.Threading.Dispatcher> jest tworzony na mogą uzyskiwać dostęp do <xref:System.Windows.Threading.Dispatcher>.  
  
 Ta metoda jest publiczny; w związku z tym, żadnym z wątków można sprawdzić, czy ma ona dostęp do <xref:System.Windows.Threading.Dispatcher>.  
  
 Różnica między <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> i <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> jest <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> zwraca wartość logiczną, jeśli wątek wywołujący nie ma dostępu do <xref:System.Windows.Threading.Dispatcher> i <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> zgłasza wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> do określenia, czy wątek ma dostęp do wątku, który <xref:System.Windows.Controls.Button> został utworzony na.  Ta metoda przyjmuje obiekt jako argument, który jest rzutowany na <xref:System.Windows.Controls.Button>.  <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> Metody <xref:System.Windows.Threading.Dispatcher> z <xref:System.Windows.Controls.Button> jest wywoływana, aby zweryfikować dostęp do wątku.  
  
 Jeśli wątek wywołujący ma dostęp do <xref:System.Windows.Threading.Dispatcher>, <xref:System.Windows.Controls.Button> jest aktualizowany, po prostu uzyskując dostęp do elementów członkowskich <xref:System.Windows.Controls.Button>.  
  
 Jeśli wątek wywołujący nie ma dostępu, <xref:System.InvalidOperationException> zgłaszany.  W tym przykładzie przechwytuje wyjątek i wypycha delegata, który akceptuje <xref:System.Windows.Controls.Button> jako argument, a na <xref:System.Windows.Threading.Dispatcher> z <xref:System.Windows.Controls.Button>.  To <xref:System.Windows.Threading.Dispatcher> będzie wykonywać pracę aktualizowanie <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wątek wywołujący nie ma dostępu do tego <see cref="T:System.Windows.Threading.Dispatcher" />.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt oczekujący, który asynchronicznie oddaje kontrole bieżącym dyspozytorem i stanowi przy tym okazję do dyspozytora na potrzeby przetwarzania innych zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt oczekujący, który asynchronicznie oddaje kontrole bieżącym dyspozytorem i stanowi przy tym okazję do dyspozytora na potrzeby przetwarzania innych zdarzeń.</summary>
        <returns>Oczekujący obiekt asynchronicznie oddaje kontrole bieżącym dyspozytorem i stanowi przy tym okazję do dyspozytora na potrzeby przetwarzania innych zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia sposób tymczasowo zwolnić Kontrola wykonywania na bieżącym dyspozytorem, więc je wykonywać inne zadania, takie jak przetwarzać inne zdarzenia. Użyj `await`, lub `Await` w języku Visual Basic, operator na wartość zwracaną, aby zwrócić kontrolka na bieżącym dyspozytorem. Użyj tej metody, jeśli chcesz nadać szansę na potrzeby przetwarzania zdarzeń, podczas działania aplikacji możesz dużo pracy w wątku interfejsu użytkownika aplikacji. Na przykład służy tej metody w pętli długotrwałych, która aktualizuje formantu.  
  
 Ta metoda jest równoważne z wywoływaniem <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29> metody i przekazywanie w <xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="static member Yield : System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Priorytet, od którego należy zaplanować kontynuację.</param>
        <summary>Tworzy obiekt oczekujący, który asynchronicznie oddaje kontrole bieżącym dyspozytorem i stanowi przy tym okazję do dyspozytora na potrzeby przetwarzania innych zdarzeń.  Pracy, która występuje, gdy sterowanie powraca do kodu, oczekiwanie na wynik tej metody jest zaplanowane z określonym priorytetem.</summary>
        <returns>Oczekujący obiekt asynchronicznie oddaje kontrole bieżącym dyspozytorem i stanowi przy tym okazję do dyspozytora na potrzeby przetwarzania innych zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia sposób tymczasowo zwolnić Kontrola wykonywania na bieżącym dyspozytorem, więc je wykonywać inne zadania, takie jak przetwarzać inne zdarzenia. Użyj `await`, lub `Await` w języku Visual Basic, operator na wartość zwracaną, aby zwrócić kontrolka na bieżącym dyspozytorem. Użyj tej metody, jeśli chcesz nadać szansę na potrzeby przetwarzania zdarzeń, podczas działania aplikacji możesz dużo pracy w wątku interfejsu użytkownika aplikacji. Na przykład służy tej metody w pętli długotrwałych, która aktualizuje formantu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
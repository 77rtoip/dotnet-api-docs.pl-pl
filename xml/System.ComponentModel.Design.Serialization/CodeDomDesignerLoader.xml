<Type Name="CodeDomDesignerLoader" FullName="System.ComponentModel.Design.Serialization.CodeDomDesignerLoader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f379b7c4829dd5da4d4590998dcecaa02001a239" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69331317" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeDomDesignerLoader : System.ComponentModel.Design.Serialization.BasicDesignerLoader, System.ComponentModel.Design.Serialization.IDesignerSerializationService, System.ComponentModel.Design.Serialization.INameCreationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomDesignerLoader extends System.ComponentModel.Design.Serialization.BasicDesignerLoader implements class System.ComponentModel.Design.Serialization.IDesignerSerializationService, class System.ComponentModel.Design.Serialization.INameCreationService" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomDesignerLoader&#xA;Inherits BasicDesignerLoader&#xA;Implements IDesignerSerializationService, INameCreationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomDesignerLoader abstract : System::ComponentModel::Design::Serialization::BasicDesignerLoader, System::ComponentModel::Design::Serialization::IDesignerSerializationService, System::ComponentModel::Design::Serialization::INameCreationService" />
  <TypeSignature Language="F#" Value="type CodeDomDesignerLoader = class&#xA;    inherit BasicDesignerLoader&#xA;    interface INameCreationService&#xA;    interface IDesignerSerializationService" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Design.Serialization.BasicDesignerLoader</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.Design.Serialization.IDesignerSerializationService</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.Design.Serialization.INameCreationService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia klasę bazową do implementowania modułu ładującego projektanta opartego na CodeDOM.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader>jest klasą abstrakcyjną, która zapewnia pełny moduł ładujący projektanta na podstawie Code Document Object Model (CodeDOM). Należy podać Analizator i generator CodeDOM oraz usługę rozpoznawania typów.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać pełny dostęp do zasobów systemowych. Wartości popytu: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Stan skojarzony:</permission>
    <altmember cref="T:System.ComponentModel.Design.Serialization.BasicDesignerLoader" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
    <altmember cref="N:System.CodeDom" />
    <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Dynamiczne generowanie i kompilacja kodu źródłowego</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomDesignerLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomDesignerLoader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeDomProvider">
      <MemberSignature Language="C#" Value="protected abstract System.CodeDom.Compiler.CodeDomProvider CodeDomProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.Compiler.CodeDomProvider CodeDomProvider" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CodeDomProvider As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property System::CodeDom::Compiler::CodeDomProvider ^ CodeDomProvider { System::CodeDom::Compiler::CodeDomProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeDomProvider : System.CodeDom.Compiler.CodeDomProvider" Usage="System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" /> Pobiera ten program ładujący projektanta.</summary>
        <value><see cref="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" /> Ten program ładujący projektanta użyje</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program ładujący projektanta nie analizuje ani nie generuje kodu ze zwróconych <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider%2A>, ale używa dostawcy, aby <xref:System.CodeDom.Compiler.ICodeGenerator> uzyskać, że może użyć do weryfikacji identyfikatorów w usłudze tworzenia nazw. Program ładujący projektanta również sprawdza, <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider%2A> czy <xref:System.ComponentModel.Design.Serialization.ICodeDomDesignerReload> implementuje interfejs. Aby uzyskać więcej informacji na temat analizowania lub generowania kodu, <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Parse%2A> zobacz <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> i metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public override void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="codeDomDesignerLoader.Dispose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader" /> klasę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda usuwa usługi dodane <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Initialize%2A> przez metodę. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A>  
  
 Wywołaj <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A> po zakończeniu korzystania z <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader>. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A> Metoda<xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> pozostawia w stanie niezdatnym do użytku. Po wywołaniu <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A>należy wydać wszystkie odwołania <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> , którą zajmował. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A> przed wydaniem ostatniego odwołania <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader>do. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected override void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Initialize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Initialize();" />
      <MemberSignature Language="F#" Value="override this.Initialize : unit -&gt; unit" Usage="codeDomDesignerLoader.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli opisano przemieszczone usługi, które <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> dodaje do kontenera usługi.  
  
|Termin|Definicja|  
|----------|----------------|  
|<xref:System.ComponentModel.Design.Serialization.INameCreationService>|Zapewnia semantykę do tworzenia nazw obiektów. Usługa używa <xref:System.CodeDom.Compiler.ICodeGenerator> interfejsu dostawcy CodeDOM do tworzenia nazw, które są prawidłowymi identyfikatorami dla danego języka. Ponadto usługa tworzenia nazw obsługuje puste nazwy. Puste nazwy należy interpretować jako tymczasowe zmienne lokalne podczas serializacji.|  
|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationService>|Zezwala innym obiektom na Serializowanie grupy składników do obiektu binarnego. Ta usługa jest najczęściej używana przez funkcje, takie jak kopiowanie i wklejanie lub cofanie i ponawianie. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> Klasa udostępnia usługę serializacji projektanta opartą na tworzeniu drzew CodeDOM dla obiektów.|  
|<xref:System.ComponentModel.Design.Serialization.ComponentSerializationService>|Ta usługa zastępuje <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationService> jako środek, aby serializować składniki do obiektu binarnego.|  
  
 Aby uzyskać szczegółowe informacje na temat wymiennych i niewymiennych usług, zobacz <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderHost" /> Nie została zainicjowana lub moduł ładujący projektanta nie dostarczył usługi rozpoznawania typów, która jest wymagana do serializacji CodeDOM.</exception>
        <altmember cref="T:System.CodeDom.Compiler.ICodeGenerator" />
        <altmember cref="T:System.ComponentModel.Design.ITypeResolutionService" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationService" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.ComponentSerializationService" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.INameCreationService" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Dynamiczne generowanie i kompilacja kodu źródłowego</related>
      </Docs>
    </Member>
    <Member MemberName="IsReloadNeeded">
      <MemberSignature Language="C#" Value="protected override bool IsReloadNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsReloadNeeded() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.IsReloadNeeded" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsReloadNeeded () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsReloadNeeded();" />
      <MemberSignature Language="F#" Value="override this.IsReloadNeeded : unit -&gt; bool" Usage="codeDomDesignerLoader.IsReloadNeeded " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy wymagane jest ponowne załadowanie.</summary>
        <returns><see langword="true" />Jeśli jest wymagane ponowne załadowanie, <see langword="false" />w przeciwnym razie. <see cref="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda sprawdza obecność <xref:System.ComponentModel.Design.Serialization.ICodeDomDesignerReload> interfejsu w <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider%2A>. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.IsReloadNeeded%2A> Dostawca przeanalizuje drzewo CodeDOM i przekaże wyniki analizowanego drzewa do <xref:System.ComponentModel.Design.Serialization.ICodeDomDesignerReload.ShouldReloadDesigner%2A> metody. Jeśli ta metoda zwróci `false`wartość, Projektant nie zostanie ponownie załadowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Język nie dostarczył analizatora kodu dla tego pliku. Ten typ pliku może nie obsługiwać projektanta.</exception>
        <exception cref="T:System.InvalidOperationException">Klasa może być zaprojektowana, ale nie jest pierwszą klasą w pliku lub nie można wyświetlić projektanta dla tego pliku, ponieważ żadna z nich nie może być zaprojektowana.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnBeginLoad">
      <MemberSignature Language="C#" Value="protected override void OnBeginLoad ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBeginLoad() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnBeginLoad" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBeginLoad ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBeginLoad();" />
      <MemberSignature Language="F#" Value="override this.OnBeginLoad : unit -&gt; unit" Usage="codeDomDesignerLoader.OnBeginLoad " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia moduł ładujący projektanta o tym, że ładowanie zostanie rozpoczęte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnBeginLoad%2A> temat metody, <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.OnBeginLoad%2A?displayProperty=nameWithType>Zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginUnload">
      <MemberSignature Language="C#" Value="protected override void OnBeginUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBeginUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnBeginUnload" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBeginUnload ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBeginUnload();" />
      <MemberSignature Language="F#" Value="override this.OnBeginUnload : unit -&gt; unit" Usage="codeDomDesignerLoader.OnBeginUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia program ładujący projektanta o konieczności rozpoczęcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnBeginUnload%2A> temat metody, <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.OnBeginUnload%2A?displayProperty=nameWithType>Zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnComponentRename">
      <MemberSignature Language="C#" Value="protected virtual void OnComponentRename (object component, string oldName, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnComponentRename(object component, string oldName, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnComponentRename(System.Object,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnComponentRename (component As Object, oldName As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnComponentRename(System::Object ^ component, System::String ^ oldName, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="abstract member OnComponentRename : obj * string * string -&gt; unit&#xA;override this.OnComponentRename : obj * string * string -&gt; unit" Usage="codeDomDesignerLoader.OnComponentRename (component, oldName, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="oldName" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, którego nazwa ma zostać zmieniona.</param>
        <param name="oldName">Oryginalna nazwa składnika.</param>
        <param name="newName">Nowa nazwa składnika.</param>
        <summary><see cref="E:System.ComponentModel.Design.IComponentChangeService.ComponentRename" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndLoad">
      <MemberSignature Language="C#" Value="protected override void OnEndLoad (bool successful, System.Collections.ICollection errors);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndLoad(bool successful, class System.Collections.ICollection errors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnEndLoad(System.Boolean,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEndLoad (successful As Boolean, errors As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEndLoad(bool successful, System::Collections::ICollection ^ errors);" />
      <MemberSignature Language="F#" Value="override this.OnEndLoad : bool * System.Collections.ICollection -&gt; unit" Usage="codeDomDesignerLoader.OnEndLoad (successful, errors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="successful" Type="System.Boolean" />
        <Parameter Name="errors" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="successful"><see langword="true" />, aby wskazać, że ładowanie zostało zakończone pomyślnie; w przeciwnym razie. <see langword="false" /></param>
        <param name="errors"><see cref="T:System.Collections.ICollection" /> Obiekty (zazwyczaj wyjątki), które zostały zgłoszone jako błędy.</param>
        <summary>Powiadamia moduł ładujący projektanta, że ładowanie zostało zakończone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnEndLoad%2A> temat metody, <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.OnEndLoad%2A?displayProperty=nameWithType>Zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected abstract System.CodeDom.CodeCompileUnit Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function Parse () As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::CodeDom::CodeCompileUnit ^ Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomDesignerLoader.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analizuje tekst lub inny magazyn trwały i zwraca <see cref="T:System.CodeDom.CodeCompileUnit" />.</summary>
        <returns><see cref="T:System.CodeDom.CodeCompileUnit" /> Wynikiem operacji analizy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wywoływana, <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> gdy trzeba przeanalizować kod źródłowy. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Parse%2A> Lokalizację i format kodu źródłowego należy określić przez wyprowadzanie klas.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Dynamiczne generowanie i kompilacja kodu źródłowego</related>
      </Docs>
    </Member>
    <Member MemberName="PerformFlush">
      <MemberSignature Language="C#" Value="protected override void PerformFlush (System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PerformFlush(class System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush(System.ComponentModel.Design.Serialization.IDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PerformFlush (manager As IDesignerSerializationManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PerformFlush(System::ComponentModel::Design::Serialization::IDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="override this.PerformFlush : System.ComponentModel.Design.Serialization.IDesignerSerializationManager -&gt; unit" Usage="codeDomDesignerLoader.PerformFlush manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">, <see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" /> Z którego ma zostać zażądał serializator.</param>
        <summary>Żąda serializacji głównego składnika projektanta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda uzyskuje element główny <xref:System.ComponentModel.Design.Serialization.CodeDomSerializer> dla głównego składnika projektanta i wywołuje Serializator, aby serializować składnik. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush%2A> Jeśli wynik tej operacji to a <xref:System.CodeDom.CodeTypeDeclaration> <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush%2A> , integruje <xref:System.CodeDom.CodeTypeDeclaration> się z istniejącym drzewem CodeDOM. Wynikiem jest oryginalne drzewo CodeDOM ze zgodnymi elementami członkowskimi i zamienionymi instrukcjami. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> Na koniec <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush%2A> wywołuje metodę abstrakcyjną w celu zapisania tego drzewa CodeDom.  
  
 Jeśli Serializacja głównego składnika projektanta nie spowoduje <xref:System.CodeDom.CodeTypeDeclaration>, wówczas <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush%2A> nic nie robi.  
  
> [!IMPORTANT]
>  Obiekt wywołujący jest odpowiedzialny za zagwarantowanie, że CodeDOM pochodzi z zaufanego źródła. Zaakceptowanie obiektu CodeDOM z niezaufanej strony może umożliwić tej stronie uruchomienie złośliwego kodu. Podczas opróżniania CodeDOM do pliku, struktura uruchomi kod reprezentowany przez obiekt CodeDOM i serializowaną zawartość obiektu zgodnie z podanym elementem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Język nie dostarczył analizatora kodu dla tego pliku. Ten typ pliku może nie obsługiwać projektanta.</exception>
        <exception cref="T:System.InvalidOperationException">Klasa może być zaprojektowana, ale nie jest pierwszą klasą w pliku lub nie można wyświetlić projektanta dla tego pliku, ponieważ żadna z nich nie może być zaprojektowana.</exception>
      </Docs>
    </Member>
    <Member MemberName="PerformLoad">
      <MemberSignature Language="C#" Value="protected override void PerformLoad (System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PerformLoad(class System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad(System.ComponentModel.Design.Serialization.IDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PerformLoad (manager As IDesignerSerializationManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PerformLoad(System::ComponentModel::Design::Serialization::IDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="override this.PerformLoad : System.ComponentModel.Design.Serialization.IDesignerSerializationManager -&gt; unit" Usage="codeDomDesignerLoader.PerformLoad manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">, <see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" /> Z którego ma zostać zażądał serializator.</param>
        <summary>Analizuje kod od dostawcy CodeDOM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda uzyskuje <xref:System.CodeDom.Compiler.ICodeParser> od dostawcy CodeDOM i analizuje kod. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad%2A> <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad%2A>lokalizuje pierwszą klasę w pliku, uzyskuje główny <xref:System.ComponentModel.Design.Serialization.CodeDomSerializer> dla typu danych, a następnie wywołuje Serializator, aby zdeserializować typ danych. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad%2A>przyjęto założenie, że ten proces spowoduje utworzenie wszystkich <xref:System.ComponentModel.IContainer> niezbędnych składników <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.LoaderHost%2A> we właściwości. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad%2A> Na<xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.SetBaseComponentClassName%2A> koniec wywołuje metodę z w pełni kwalifikowaną nazwą typu, który został przesłany do serializatora CodeDOM.  
  
> [!IMPORTANT]
>  Obiekt wywołujący jest odpowiedzialny za zagwarantowanie, że CodeDOM pochodzi z zaufanego źródła. Zaakceptowanie obiektu CodeDOM z niezaufanej strony może umożliwić tej stronie uruchomienie złośliwego kodu. Podczas ładowania CodeDOM do powierzchni projektowej, struktura będzie uruchamiała kod reprezentowany przez obiekt CodeDOM i serializowaną zawartość obiektu zgodnie z podanym elementem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Język nie dostarczył analizatora kodu dla tego pliku. Ten typ pliku może nie obsługiwać projektanta.</exception>
        <exception cref="T:System.InvalidOperationException">Klasa może być zaprojektowana, ale nie jest pierwszą klasą w pliku lub nie można wyświetlić projektanta dla tego pliku, ponieważ żadna z nich nie może być zaprojektowana.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Dynamiczne generowanie i kompilacja kodu źródłowego</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationService.Deserialize">
      <MemberSignature Language="C#" Value="System.Collections.ICollection IDesignerSerializationService.Deserialize (object serializationData);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.ICollection System.ComponentModel.Design.Serialization.IDesignerSerializationService.Deserialize(object serializationData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#IDesignerSerializationService#Deserialize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Deserialize (serializationData As Object) As ICollection Implements IDesignerSerializationService.Deserialize" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::ICollection ^ System.ComponentModel.Design.Serialization.IDesignerSerializationService.Deserialize(System::Object ^ serializationData) = System::ComponentModel::Design::Serialization::IDesignerSerializationService::Deserialize;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationService.Deserialize(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serializationData">Obiekt składający się z serializowanych danych.</param>
        <summary>Deserializacji określonego obiektu danych serializacji i zwraca kolekcję obiektów reprezentowanych przez te dane.</summary>
        <returns>Kolekcja obiektów reprezentowana przez <paramref name="serializationData" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="serializationData" />nie <see cref="T:System.ComponentModel.Design.Serialization.SerializationStore" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationService.Serialize">
      <MemberSignature Language="C#" Value="object IDesignerSerializationService.Serialize (System.Collections.ICollection objects);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationService.Serialize(class System.Collections.ICollection objects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#IDesignerSerializationService#Serialize(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Function Serialize (objects As ICollection) As Object Implements IDesignerSerializationService.Serialize" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationService.Serialize(System::Collections::ICollection ^ objects) = System::ComponentModel::Design::Serialization::IDesignerSerializationService::Serialize;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationService.Serialize(System.Collections.ICollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objects" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="objects">Kolekcja obiektów do serializacji.</param>
        <summary>Serializować określoną kolekcję obiektów i zapisuje je w obiekcie danych serializacji.</summary>
        <returns>Obiekt, który zawiera serializowany stan określonej kolekcji obiektów.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.ComponentModel.Design.Serialization.ComponentSerializationService" /> Nie znaleziono.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.INameCreationService.CreateName">
      <MemberSignature Language="C#" Value="string INameCreationService.CreateName (System.ComponentModel.IContainer container, Type dataType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.ComponentModel.Design.Serialization.INameCreationService.CreateName(class System.ComponentModel.IContainer container, class System.Type dataType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#INameCreationService#CreateName(System.ComponentModel.IContainer,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function CreateName (container As IContainer, dataType As Type) As String Implements INameCreationService.CreateName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.ComponentModel.Design.Serialization.INameCreationService.CreateName(System::ComponentModel::IContainer ^ container, Type ^ dataType) = System::ComponentModel::Design::Serialization::INameCreationService::CreateName;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.INameCreationService.CreateName(System.ComponentModel.IContainer,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
        <Parameter Name="dataType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="container">Kontener, do którego zostanie dodany nowy obiekt.</param>
        <param name="dataType">Typ danych obiektu, który otrzymuje nazwę.</param>
        <summary>Tworzy nową nazwę, która jest unikatowa dla wszystkich składników w określonym kontenerze.</summary>
        <returns>Unikatowa nazwa typu danych.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataType" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.INameCreationService.IsValidName">
      <MemberSignature Language="C#" Value="bool INameCreationService.IsValidName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.ComponentModel.Design.Serialization.INameCreationService.IsValidName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#INameCreationService#IsValidName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsValidName (name As String) As Boolean Implements INameCreationService.IsValidName" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.ComponentModel.Design.Serialization.INameCreationService.IsValidName(System::String ^ name) = System::ComponentModel::Design::Serialization::INameCreationService::IsValidName;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.INameCreationService.IsValidName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do zweryfikowania.</param>
        <summary>Pobiera wartość wskazującą, czy określona nazwa jest prawidłowa.</summary>
        <returns><see langword="true" />Jeśli nazwa jest prawidłowa; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.INameCreationService.ValidateName">
      <MemberSignature Language="C#" Value="void INameCreationService.ValidateName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.INameCreationService.ValidateName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#INameCreationService#ValidateName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub ValidateName (name As String) Implements INameCreationService.ValidateName" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.INameCreationService.ValidateName(System::String ^ name) = System::ComponentModel::Design::Serialization::INameCreationService::ValidateName;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.INameCreationService.ValidateName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do zweryfikowania.</param>
        <summary>Pobiera wartość wskazującą, czy określona nazwa jest prawidłowa.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />nie jest prawidłowym identyfikatorem lub istnieje już składnik o tej samej nazwie.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolutionService">
      <MemberSignature Language="C#" Value="protected abstract System.ComponentModel.Design.ITypeResolutionService TypeResolutionService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.ITypeResolutionService TypeResolutionService" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.TypeResolutionService" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property TypeResolutionService As ITypeResolutionService" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property System::ComponentModel::Design::ITypeResolutionService ^ TypeResolutionService { System::ComponentModel::Design::ITypeResolutionService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeResolutionService : System.ComponentModel.Design.ITypeResolutionService" Usage="System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.TypeResolutionService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.ITypeResolutionService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera usługę rozpoznawania typów, która ma być używana z tym modułem ładującym projektanta.</summary>
        <value><see cref="T:System.ComponentModel.Design.ITypeResolutionService" /> , Że serializatory CodeDOM będą używane podczas rozpoznawania typów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Automatycznie dodaje to <xref:System.ComponentModel.Design.ITypeResolutionService> do kontenera usługi, gdy <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Initialize%2A> wywoływana jest metoda. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> Chociaż usługa rozpoznawania typów jest opcjonalna w wielu scenariuszach, jest wymagana do interpretacji kodu, ponieważ kod źródłowy zawiera nazwy typów, ale nie zawiera odwołań do zestawów.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.ITypeResolutionService" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Dynamiczne generowanie i kompilacja kodu źródłowego</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="protected abstract void Write (System.CodeDom.CodeCompileUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Write(class System.CodeDom.CodeCompileUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write(System.CodeDom.CodeCompileUnit)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Write (unit As CodeCompileUnit)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Write(System::CodeDom::CodeCompileUnit ^ unit);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.CodeDom.CodeCompileUnit -&gt; unit" Usage="codeDomDesignerLoader.Write unit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.CodeDom.CodeCompileUnit" />
      </Parameters>
      <Docs>
        <param name="unit">Wartość <see cref="T:System.CodeDom.CodeCompileUnit" /> , która ma zostać utrwalona.</param>
        <summary>Zapisuje zmiany jednostki kompilacji w magazynie trwałym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> Metoda<xref:System.CodeDom.CodeCompileUnit> zapisuje do magazynu trwałego. Klasa pochodna jest odpowiedzialna za wywoływanie <xref:System.CodeDom.Compiler.ICodeGenerator> na odpowiednim składniku zapisywania tekstu w celu zapisania kodu. Zapewnia, że obiekty CodeDOM, które są przesyłane do <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> są tymi samymi wystąpieniami obiektów, które zostały <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Parse%2A>pobrane z, z wyjątkiem przypadków, gdy proces serializacji musiał wprowadzić zmiany w kodzie. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> Umożliwia to zoptymalizowanemu programowi ładującemu projektanta przechowywanie dodatkowych danych <xref:System.CodeDom.CodeObject.UserData%2A> we właściwości elementów kodu. Te dane będą dostępne w ramach <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> metody dla wszystkich elementów, które nie zostały zastąpione przez proces serializacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Dynamiczne generowanie i kompilacja kodu źródłowego</related>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="DesignerSerializationManager" FullName="System.ComponentModel.Design.Serialization.DesignerSerializationManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e4a005e0451f128854a14f9e2a11fbf960f7114e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30440769" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DesignerSerializationManager : IServiceProvider, System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DesignerSerializationManager extends System.Object implements class System.ComponentModel.Design.Serialization.IDesignerSerializationManager, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class DesignerSerializationManager&#xA;Implements IDesignerSerializationManager, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DesignerSerializationManager : IServiceProvider, System::ComponentModel::Design::Serialization::IDesignerSerializationManager" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.Design.Serialization.IDesignerSerializationManager</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia implementację elementu <see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" /> interfejsu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager> Interfejsu została zaprojektowana jako interfejs format niezależny do obiektu, który kontroluje serializacji. Zasadniczo zapewnia kontekstu i usług do serializatorów, które wykonują rzeczywiste deserializacji. <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager> pomaga w procesie deserializacji przez śledzenie obiektów. Jest to podobna metoda <xref:System.ComponentModel.Design.IDesignerHost> interfejsu: projektantów faktycznie udostępnia interfejs użytkownika (UI), i <xref:System.ComponentModel.Design.IDesignerHost> zapewnia sklejki, umożliwiający projektantom różnych współdziałają ze sobą.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> Klasa implementuje <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager>. Zaprojektowano w celu ogólnego formy deserializacji podobny do środowiska wykonawczego serializatorów, takich jak <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> Klas uzyskuje trzy cele:  
  
-   Jest proste, gotowy obiekt, który może służyć do deserializacji różnych formatach.  
  
-   Jest ogólny i nie wiązanej do dowolnego określonego formatu. Może służyć jednakowo CodeDOM deserializacji, a także deserializacji znaczników.  
  
-   Jest rozszerzony i obsługuje serializacji różnych metod, które są używane w scenariuszach, skopiuj i Wklej i Cofnij/Ponów.  
  
 Serializacja czasu projektowania ma następujące różnice serializacji obiektów czasu wykonywania:  
  
-   Obiektu wykonującego serializacji jest zazwyczaj oddzielony od obiektów czasu wykonywania, tak, aby logiki czasu projektowania można usunąć ze składnika.  
  
-   Schemat serializacji zakłada, zostanie utworzony obiekt pełni zainicjowane, a następnie zmodyfikować za pomocą właściwości i metody wywołań podczas deserializacji.  
  
-   Właściwości obiektu, które mają wartości, które nigdy nie zostały określone w obiekcie (właściwości zawierają wartości domyślnej) nie są serializowane. Z drugiej strony strumienia deserializacji może być luk.  
  
-   Nacisk jest kładziony na jakość zawartości w ramach strumień serializacji, a nie pełny serializacji obiektu. Oznacza to, że jeśli nie istnieje sposób zdefiniowanych szeregowania obiektu, ten obiekt mogą zostać pominięte zamiast generowania wyjątku. Mechanizm serializacji może zapewnić heurystyki tutaj zdecydować, które błędy można zignorować, które jest nieodwracalny.  
  
-   Strumień serializacji może mieć więcej danych niż jest niezbędna do deserializacji. Na przykład serializacji kodu źródłowego, ma łączyć się przy użyciu kodu potrzebne do deserializacji wykresu obiektów kodu użytkownika. Ten kod użytkownika należy ignorowane przy deserializacji i zachowane na serializacji.  
  
 Z powodu różnic model różnych serializacji ma zastosowanie do serializacji w czasie projektowania. Ten model korzysta z obiektu oddzielne serializator dla każdego typu danych serializacji. Każdy serializator zapewnia jej małych udziału problem jako całość. Te serializatorów są wszystkie skoordynowane za pośrednictwem wspólnego menedżera serializacji. Tego menedżera serializacji jest odpowiedzialny za konserwację stanu między tymi różnych serializatorów. Na przykład wziąć pod uwagę następujące klasy:  
  
 [!code-csharp[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/CS/Program.cs#2)]
 [!code-vb[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/VB/Program.vb#2)]  
  
 Wystąpienie tej klasy może korzystać z trzech różnych serializatorów: jeden dla `SampleObject`, jeden dla ciągów i drugi dla liczb całkowitych. Serializator dla `SampleObject` jest nazywany serializator głównego, ponieważ `SampleObject` jest głównym wykresu serializacji. Można również utworzyć bardziej złożoną wykresów obiektów. Rozważmy na przykład, co się stanie, jeśli `SampleObject` zostały zmienione w następujący sposób:  
  
 [!code-csharp[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/CS/SampleObject.cs#11)]
 [!code-vb[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/VB/SampleObject.vb#11)]  
  
 Dzięki temu `SampleObject` mieć obiektu podrzędnego, który jest inny wystąpienia samej siebie. Poniższy kod wypełnia wykres obiektu:  
  
 [!code-csharp[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/CS/SampleObject.cs#12)]
 [!code-vb[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/VB/SampleObject.vb#12)]  
  
 Podczas `root` jest serializowana, będzie cztery serializatorów używane: serializator jednego katalogu głównego, co serializatora dla obiekt podrzędny `SampleObject`, jeden serializatora dla `int`i jedną serializatora dla `string`. Serializatorów są buforowane na podstawie typu, dlatego nie ma potrzeby tworzenia serializator dla każdego wystąpienia `SampleObject`.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> Klasy jest oparta na pomysł sesji serializacji. Sesja zachowuje swój stan, które są dostępne dla różnych serializatorów. Jeśli sesja zostanie usunięty, ten stan zostanie zniszczony. Pomaga to zapewnić serializatorów pozostają w dużej mierze bezstanowych, czy pozwala wyczyścić serializatorów, które są są uszkodzone. W poniższych tabelach opisano sposób zarządzania stanu w i między sesjami.  
  
## <a name="global-state"></a>Stan globalny  
 Ten stan jest właścicielem obiektu menedżera serializacji, ale jest niezależna od bieżącej sesji serializacji.  
  
|Obiekt|Użycie|  
|------------|-----------|  
|Serializacja dostawców|Obiekty można dodać siebie jako dostawcy niestandardowej serializacji. Ponieważ te dostawcy są używane do lokalizowania serializatorów, ich outlive sesji serializacji.|  
  
## <a name="session-owned-state"></a>Stan należące do sesji  
 Ten stan jest własnością sesji i zostanie zniszczony podczas sesji zostanie zniszczony. W związku z tym uzyskiwanie dostępu do żadnych właściwości ani metod sterującymi ten stan spowoduje zgłoszenie wyjątku, jeśli menedżera serializacji nie jest aktywna sesja.  
  
|Obiekt|Użycie|  
|------------|-----------|  
|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName> Zdarzenia|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName> Zdarzeń jest dołączony przez serializator zapewnienie dodatkowych rozpoznawania nazw. Wszystkie programy obsługi są odłączone od tego zdarzenia, gdy zakończenie sesji.|  
|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete> Zdarzenia|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete> Zdarzenie jest wywoływane bezpośrednio przed zamknięciem sesji zostanie usunięty. Następnie wszystkie programy obsługi są odłączone od tego zdarzenia.|  
|Nazwa tabeli|Tego menedżera serializacji przechowuje tabelę, która mapuje między obiektami i ich nazw. Serializatorów może nadaj nazwę obiektów łatwo zidentyfikować. Ta nazwa tabela jest czyszczona, gdy zakończenie sesji.|  
|Serializator pamięci podręcznej|Tego menedżera serializacji obsługuje pamięć podręczną serializatorów, który został poproszony o podanie. Ta pamięć podręczna jest wyczyszczone, gdy zakończenie sesji. Publicznego <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer%2A> bezpiecznie można wywołać metody w dowolnym momencie, ale jego wartość jest buforowana tylko wtedy, gdy jest wywoływana z sesji.|  
|Stos kontekstu|Menedżer serializacji zapisuje obiekt o nazwie Stos kontekstu, które można otworzyć z <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context%2A> właściwości. Serializatorów można użyć tego stosu do przechowywania dodatkowych informacji, która jest dostępna dla innych serializatorów. Na przykład element serializujący, która wykonuje serializację wartości właściwości mogą przyczynić się nazwę właściwości na stosie serializacji przed żądaniem wartość do zserializowania. Ten stos jest wyczyszczone, gdy sesja zostanie zakończona.|  
|Lista błędów|Tego menedżera serializacji przechowuje listę błędów, które wystąpiły podczas serializacji. Tej listy, który jest dostępny za pośrednictwem <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors%2A> właściwości, zostanie wyczyszczona po sesja zostanie zakończona. Uzyskiwanie dostępu do <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors%2A> właściwości między sesjami spowodują wyjątek.|  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.ContextStack" />
    <altmember cref="T:System.IServiceProvider" />
    <altmember cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignerSerializationManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignerSerializationManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor ustawia <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> i <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> właściwości `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignerSerializationManager (IServiceProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (provider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignerSerializationManager(IServiceProvider ^ provider);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.IServiceProvider" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> klasy z danego usługodawcy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element serializujący żądania usług, które nie mogą być spełnione przez tego menedżera serializacji, domyślna implementacja będzie przesyłać tych żądań w celu `provider` parametru.  
  
 Ten konstruktor ustawia <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> i <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> właściwości `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.IServiceProvider" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName="Container">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IContainer Container { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IContainer Container" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Container" />
      <MemberSignature Language="VB.NET" Value="Public Property Container As IContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IContainer ^ Container { System::ComponentModel::IContainer ^ get(); void set(System::ComponentModel::IContainer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontener dla tego menedżera serializacji.</summary>
        <value>
          <see cref="T:System.ComponentModel.IContainer" /> Do którego dodać składniki menedżera serializacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli istnieje kontener, wszystkie składniki, które są tworzone przez tego menedżera serializacji zostaną dodane do kontenera. Domyślna implementacja tej właściwości umożliwia wyszukiwanie dostawcy usług dla <xref:System.ComponentModel.Design.IDesignerHost> i użyć dostarczonych przez projektanta hosta kontenera, powinien taka istnieje. W przeciwnym razie wartość tej właściwości, którą będzie zwracać `null` i żadne składniki nie zostanie dodany do kontenera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tego menedżera serializacji ma już aktywna sesja serializacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual object CreateInstance (Type type, System.Collections.ICollection arguments, string name, bool addToContainer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateInstance(class System.Type type, class System.Collections.ICollection arguments, string name, bool addToContainer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateInstance(Type ^ type, System::Collections::ICollection ^ arguments, System::String ^ name, bool addToContainer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.ICollection" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="addToContainer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ do utworzenia wystąpienia.</param>
        <param name="arguments">Parametry Konstruktora typu. Może to być <see langword="null" /> lub pustą kolekcję do wywołania konstruktora domyślnego.</param>
        <param name="name">Nazwa Aby obiekt. Jeśli <see langword="null" />, obiekt nie ma nazwy, chyba że obiekt jest dodany do kontenera i kontener nadaje obiektu nazwę.</param>
        <param name="addToContainer">
          <see langword="true" /> Aby dodać obiekt do kontenera, jeśli obiekt implementuje <see cref="T:System.ComponentModel.IComponent" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy wystąpienie typu.</summary>
        <returns>Nowe wystąpienie klasy typu określonego przez <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez serializatorów po podjęciu próby utworzenia wystąpienia typu. Domyślna implementacja tworzy nowe wystąpienie typu lub może zwrócić istniejącego wystąpienia w zależności od wartości <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> i <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> właściwości. <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance%2A> Metoda odbicia do tworzenia wystąpień i będzie wykonywać pewne ogólne <xref:System.IConvertible> przekształcenia na parametry można znaleźć zgodnego konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <paramref name="type" /> nie ma konstruktora, który przyjmuje parametry zawarte w <paramref name="arguments" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName="CreateSession">
      <MemberSignature Language="C#" Value="public IDisposable CreateSession ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable CreateSession() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSession () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ CreateSession();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową sesję serializacji.</summary>
        <returns>
          <see cref="T:System.IDisposable" /> Reprezentujący nowej sesji serializacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość danych w ramach tego menedżera serializacji jest przejściowy i działa tylko dla sesji serializacji. Jeśli sesja zostanie usunięty, serializacji jest traktowany jako ukończone, a ten przejściowy stan jest usuwany. Umożliwia to pojedyncze wystąpienie menedżera serializacji ma być używany do serializacji wieloma drzewami obiektu. Niektóre stanu, w tym dostawcy usług i wszystkich dostawców niestandardowej serializacji, które zostały dodane do tego menedżera serializacji span sesji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tego menedżera serializacji jest już w ramach sesji. Ta wersja <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> nie obsługuje jednoczesnych sesji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Errors">
      <MemberSignature Language="C#" Value="public System.Collections.IList Errors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList Errors" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Errors As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ Errors { System::Collections::IList ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę błędów, które wystąpiły podczas serializacji lub deserializacji.</summary>
        <value>Lista błędów, które wystąpiły podczas serializacji lub deserializacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lista błędów mogą odczytywać tylko wtedy, gdy jest aktywna sesja serializacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość uzyskano poza sesji serializacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeType">
      <MemberSignature Language="C#" Value="public Type GetRuntimeType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetRuntimeType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetRuntimeType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRuntimeType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetRuntimeType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu w celu pobrania.</param>
        <summary>Pobiera typ odpowiadający określonej nazwy typu.</summary>
        <returns>Określonego typu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializer">
      <MemberSignature Language="C#" Value="public object GetSerializer (Type objectType, Type serializerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSerializer(class System.Type objectType, class System.Type serializerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSerializer (objectType As Type, serializerType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSerializer(Type ^ objectType, Type ^ serializerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="serializerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Typ obiektu, który można pobrać serializatora.</param>
        <param name="serializerType">Typ serializatora do pobrania.</param>
        <summary>Pobiera serializator dla typu danego obiektu.</summary>
        <returns>Serializator dla <paramref name="objectType" />, lub <see langword="null" />, jeśli nie można odnaleźć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ elementu serializującego, którą chcesz może wysłać żądanie. Ta metoda zwraca `null` Jeśli żadnego elementu serializującego żądanego typu dla typu określony obiekt nie istnieje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="objectType" /> lub <paramref name="serializerType" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="protected virtual object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Typ usługi do pobrania.</param>
        <summary>Pobiera żądaną usługę.</summary>
        <returns>Żądana usługa lub <see langword="null" /> Jeśli usługi nie można rozpoznać.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetService%2A> Metoda zapewnia dostęp do kontenera podstawowej lub dostawcy usług, która została ustawiona w konstruktorze.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="protected virtual Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu do pobrania.</param>
        <summary>Pobiera żądanego typu.</summary>
        <returns>Żądany typ lub <see langword="null" /> , jeśli nie można rozpoznać typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetType%2A> Metoda umożliwia wyszukiwanie dostawcy usług dla <xref:System.ComponentModel.Design.ITypeResolutionService> i, jeśli jest dostępny, zostanie on delegować do tej usługi można rozpoznać typu. Jeśli <xref:System.ComponentModel.Design.ITypeResolutionService> jest niedostępny, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetType%2A> wywoła <xref:System.Object.GetType%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveName">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveName (System.ComponentModel.Design.Serialization.ResolveNameEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveName(class System.ComponentModel.Design.Serialization.ResolveNameEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveName (e As ResolveNameEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveName(System::ComponentModel::Design::Serialization::ResolveNameEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.Serialization.ResolveNameEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.Design.Serialization.ResolveNameEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SetName(System.Object,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionCreated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionCreated" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionDisposed">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionDisposed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionDisposed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionDisposed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionDisposed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionDisposed" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="PreserveNames">
      <MemberSignature Language="C#" Value="public bool PreserveNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveNames" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveNames As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveNames { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> metody należy sprawdzić obecność o podanej nazwie w kontenerze.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> przekazuje nazwę danego składnika; <see langword="false" /> Jeśli <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> sprawdza obecność o podanej nazwie w kontenerze. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> Właściwość określa zachowanie <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> metody. Jeśli `true`, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> przekazywać nazwy danego składnika. Jeśli `false`, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> sprawdza obecność o podanej nazwie w kontenerze. Jeśli nazwa nie istnieje w kontenerze, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> użyje o podanej nazwie. Jeśli nazwa istnieje w kontenerze, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> przekazuje wartość null jako nazwa składnika podczas dodawania go do tego kontenera, w tym samym nadanie mu nazwy nowego. Ta druga jest przydatne w przypadku implementowania serializatora zawsze powielają obiektów, a nie przy założeniu, że te obiekty nie istnieją. Wklej polecenia często używają tego typu serializatora.  
  
 Tę właściwość można zmienić tylko, jeśli nie pracujesz w sesji serializacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość została zmieniona z sesji serializacji.</exception>
        <altmember cref="Overload:System.ComponentModel.Design.Serialization.DesignerSerializationManager.#ctor" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PropertyProvider">
      <MemberSignature Language="C#" Value="public object PropertyProvider { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object PropertyProvider" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PropertyProvider" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyProvider As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ PropertyProvider { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, które mają być używane w celu zapewnienia właściwości do tego menedżera serializacji <see cref="P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" /> właściwości.</summary>
        <value>Obiekt, które mają być używane w celu zapewnienia właściwości do tego menedżera serializacji <see cref="P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PropertyProvider%2A> Właściwości umożliwia zapewniają zestaw właściwości serializacji, które serializatorów służy do przeprowadzenia ich zachowanie tego menedżera serializacji.  
  
 Właściwości publiczne tego obiektu zostanie inspekcji i ujęte w nowych deskryptorów właściwości mających obiektu docelowego menedżera serializacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecycleInstances">
      <MemberSignature Language="C#" Value="public bool RecycleInstances { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecycleInstances" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
      <MemberSignature Language="VB.NET" Value="Public Property RecycleInstances As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecycleInstances { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia flagę wskazującą czy <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> zawsze spowoduje utworzenie nowego wystąpienia typu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> zwróci istniejącego wystąpienia; <see langword="false" /> Jeśli <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> utworzy nowe wystąpienie typu. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> właściwość jest `false`, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> metody zawsze spowoduje utworzenie nowego wystąpienia typu. Jeśli <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> jest `true`, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> zostanie najpierw wyszukać nazwę tabeli i kontener dla obiekt o tej samej nazwie. Jeśli taki obiekt istnieje i jest tego samego typu <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> zwróci istniejącego wystąpienia. Ta druga jest przydatne w przypadku implementowania serializatora stosowanym serializacji stanu do istniejącego zestawu obiektów, a nie zawsze Tworzenie nowego drzewa. **Cofnij** polecenie często używa tego typu serializatora.  
  
 W przypadku gdy <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> właściwość jest `true`, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> właściwości będzie dalsze modyfikowanie <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> w zależności od typów obiektów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tego menedżera serializacji ma już aktywna sesja serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName="SessionCreated">
      <MemberSignature Language="C#" Value="public event EventHandler SessionCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SessionCreated" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SessionCreated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy jest tworzony sesji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionDisposed">
      <MemberSignature Language="C#" Value="public event EventHandler SessionDisposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SessionDisposed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionDisposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionDisposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SessionDisposed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy sesja zostanie usunięty.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.AddSerializationProvider (System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider(class System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      <MemberSignature Language="VB.NET" Value="Sub AddSerializationProvider (provider As IDesignerSerializationProvider) Implements IDesignerSerializationManager.AddSerializationProvider" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider(System::ComponentModel::Design::Serialization::IDesignerSerializationProvider ^ provider) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::AddSerializationProvider;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dostawca serializacji do dodania.</param>
        <summary>Dodaje dostawcę niestandardowej serializacji tego menedżera serializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer%2A> metoda służy do żądania dostawca serializacji, dostawców niestandardowych serializacji najpierw przed wyszukiwanie w metadanych typu odpowiedni serializator wysyła zapytanie do tego menedżera serializacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context">
      <MemberSignature Language="C#" Value="System.ComponentModel.Design.Serialization.ContextStack System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.Serialization.ContextStack System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#Context" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Context As ContextStack Implements IDesignerSerializationManager.Context" />
      <MemberSignature Language="C++ CLI" Value="property System::ComponentModel::Design::Serialization::ContextStack ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context { System::ComponentModel::Design::Serialization::ContextStack ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.Serialization.ContextStack</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Stos kontekstu dla tej sesji serializacji.</summary>
        <value>A <see cref="T:System.ComponentModel.Design.Serialization.ContextStack" /> która przechowuje dane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stos kontekstu zawiera obszar przechowywania zdefiniowane przez użytkownika, zaimplementowane jako stosu. Ten obszar pamięci jest wygodnym sposobem na zapewniają komunikację między serializatorów, serializacji jest zazwyczaj hierarchiczna procesu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość uzyskano poza sesji serializacji.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.ContextStack" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance">
      <MemberSignature Language="C#" Value="object IDesignerSerializationManager.CreateInstance (Type type, System.Collections.ICollection arguments, string name, bool addToContainer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(class System.Type type, class System.Collections.ICollection arguments, string name, bool addToContainer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(Type ^ type, System::Collections::ICollection ^ arguments, System::String ^ name, bool addToContainer) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::CreateInstance;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.ICollection" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="addToContainer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ danych do utworzenia.</param>
        <param name="arguments">Argumenty do przekazania do konstruktora dla tego typu.</param>
        <param name="name">Nazwa obiektu. Ta nazwa może być używana do dostępu do obiektu później za pomocą <see cref="M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(System.String)" />. Jeśli <see langword="null" /> jest przekazany, nadal jest tworzony obiekt ale nazwa nie może uzyskać dostępu do.</param>
        <param name="addToContainer">
          <see langword="true" /> Aby dodać ten obiekt do kontenera projektu. Obiekt musi implementować <see cref="T:System.ComponentModel.IComponent" /> w tym celu ma żadnego efektu.</param>
        <summary>Implementuje <see cref="M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> metody.</summary>
        <returns>Wystąpienie nowo utworzony obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance">
      <MemberSignature Language="C#" Value="object IDesignerSerializationManager.GetInstance (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function GetInstance (name As String) As Object Implements IDesignerSerializationManager.GetInstance" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(System::String ^ name) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetInstance;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu do pobrania.</param>
        <summary>Pobiera wystąpienie utworzonego obiektu o określonej nazwie.</summary>
        <returns>Wystąpienie obiektu o podanej nazwie lub <see langword="null" /> w przypadku nieodnalezienia nie obiektu o takiej nazwie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta właściwość uzyskano poza sesji serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName">
      <MemberSignature Language="C#" Value="string IDesignerSerializationManager.GetName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetName (value As Object) As String Implements IDesignerSerializationManager.GetName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName(System::Object ^ value) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetName;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, do których chcesz pobrać nazwy.</param>
        <summary>Pobiera nazwę określonego obiektu.</summary>
        <returns>Nazwa obiektu, lub <see langword="null" /> Jeśli obiekt jest bez nazwy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23GetName%2A> metoda nie może znaleźć odpowiedniego nazwę `value` parametru zgłasza <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName> zdarzeń przed zwraca `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta właściwość uzyskano poza sesji serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SetName(System.Object,System.String)" />
        <altmember cref="E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer">
      <MemberSignature Language="C#" Value="object IDesignerSerializationManager.GetSerializer (Type objectType, Type serializerType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer(class System.Type objectType, class System.Type serializerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetSerializer(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetSerializer (objectType As Type, serializerType As Type) As Object Implements IDesignerSerializationManager.GetSerializer" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer(Type ^ objectType, Type ^ serializerType) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetSerializer;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="serializerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Typ obiektu do pobrania elementu serializującego dla.</param>
        <param name="serializerType">Typ serializatora do pobrania.</param>
        <summary>Pobiera serializator żądanego typu dla określonego typu.</summary>
        <returns>Wystąpienia żądanego serializator lub <see langword="null" /> Jeśli nie odpowiedni serializator może znajdować się.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType">
      <MemberSignature Language="C#" Value="Type IDesignerSerializationManager.GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function GetType (typeName As String) As Type Implements IDesignerSerializationManager.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType(System::String ^ typeName) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetType;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Pełna nazwa typu w celu załadowania.</param>
        <summary>Pobiera typ określonej nazwy.</summary>
        <returns>Wystąpienie tego typu, lub <see langword="null" /> Jeśli typ nie może zostać załadowany.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość uzyskano poza sesji serializacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties">
      <MemberSignature Language="C#" Value="System.ComponentModel.PropertyDescriptorCollection System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptorCollection System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#Properties" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Properties As PropertyDescriptorCollection Implements IDesignerSerializationManager.Properties" />
      <MemberSignature Language="C++ CLI" Value="property System::ComponentModel::PropertyDescriptorCollection ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties { System::ComponentModel::PropertyDescriptorCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementuje <see cref="P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" /> właściwości.</summary>
        <value>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> zawierającego właściwości, aby można było serializować.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.RemoveSerializationProvider (System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider(class System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveSerializationProvider (provider As IDesignerSerializationProvider) Implements IDesignerSerializationManager.RemoveSerializationProvider" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider(System::ComponentModel::Design::Serialization::IDesignerSerializationProvider ^ provider) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::RemoveSerializationProvider;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationProvider" /> Do usunięcia.</param>
        <summary>Usuwa dostawcę uprzednio dodanych serializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23RemoveSerializationProvider%2A> Metoda usuwa dostawcy niestandardowej serializacji, która wcześniej została dodana przez wywołanie do <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23AddSerializationProvider%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.ReportError (object errorInformation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError(object errorInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#ReportError(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub ReportError (errorInformation As Object) Implements IDesignerSerializationManager.ReportError" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError(System::Object ^ errorInformation) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::ReportError;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInformation" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="errorInformation">Obiekt zawierający informacje o błędzie, zazwyczaj typu <see cref="T:System.String" /> lub <see cref="T:System.Exception" />.</param>
        <summary>Używane do zgłaszania nieodwracalny błąd w serializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można zapisać serializatorów bezpiecznie obsłużyć błędy nieodwracalny, wywołując <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23ReportError%2A> metody informacje o błędzie. Tego menedżera serializacji może obsługiwać raportowania listę błędów, po jego ukończeniu lub może zgłosić wyjątek od tej metody i przerwania procesu serializacji. Serializator powinno być kontynuowane po wywołaniu tej funkcji.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23ReportError%2A> dodaje `errorInformation` parametr <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors%2A> kolekcji. Jeśli `errorInformation` jest `null`, nie podjęto żadnej akcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość uzyskano poza sesji serializacji.</exception>
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.SetName (object instance, string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName(object instance, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SetName(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetName (instance As Object, name As String) Implements IDesignerSerializationManager.SetName" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName(System::Object ^ instance, System::String ^ name) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::SetName;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, który można ustawić nazwy.</param>
        <param name="name">A <see cref="T:System.String" /> używana jako nazwa obiektu.</param>
        <summary>Ustawia nazwę dla określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23SetName%2A> — Metoda umożliwia określenie nazwy obiektu. Dzięki temu tworzenia wystąpienia obiektu poprzez wywołanie <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23GetInstance%2A> metoda umożliwia uniknięcie przeciążenia <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Obiekt określony przez wystąpienie już ma nazwę, lub <paramref name="name" /> jest już używany przez inny obiekt o nazwie.</exception>
        <exception cref="T:System.InvalidOperationException">Ta właściwość uzyskano poza sesji serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (serviceType As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ serviceType) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Obiekt, który określa typ obiektu usługi do pobrania.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IServiceProvider.GetService(System.Type)" /> metody.</summary>
        <returns>Obiekt usługi typu <paramref name="serviceType" />.  
  
 —lub—  
  
 <see langword="null" /> Jeśli nie ma żadnego obiektu usługi typu <paramref name="serviceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> wystąpienia jest rzutowane na <xref:System.IServiceProvider> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRecycledTypes">
      <MemberSignature Language="C#" Value="public bool ValidateRecycledTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateRecycledTypes" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateRecycledTypes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateRecycledTypes { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia flagę wskazującą czy <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> metody zweryfikuje, że nazwy pasujące odnoszą się do tego samego typu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> sprawdza typy; w przeciwnym razie <see langword="false" /> jeśli jej nie ma. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> Właściwości modyfikację działania <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> metody podczas <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> właściwość jest `true`, jak wyjaśniono w poniższej tabeli.  
  
|`RecycleInstances`|`ValidateRecycledTypes`|Zachowanie `CreateInstance`|  
|------------------------|-----------------------------|----------------------------------|  
|`false`|`true` lub `false`|Zawsze twórz nowe wystąpienie określonego typu|  
|`true`|`false`|Jeśli znaleziono zgodnego wystąpienia, jest zwracany, niezależnie od jego typu.|  
|`true`|`true`|Jeśli zostanie znaleziony zgodnego wystąpienia, jest zwracany tylko wtedy, gdy jej typ jest taka sama jak określona w wywołaniu metody.|  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> jest przydatne w przypadku przekształcania właściwości jeden typ obiektu do innego, jeśli mają podobne właściwości, ale udostępniać nie Wspólnemu elementowi nadrzędnemu lub interfejs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tego menedżera serializacji ma już aktywna sesja serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="DesignerSerializationManager" FullName="System.ComponentModel.Design.Serialization.DesignerSerializationManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="14299a9028ea2091d2d4068901aa2b5ad729d50c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69350239" /></Metadata><TypeSignature Language="C#" Value="public class DesignerSerializationManager : IServiceProvider, System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DesignerSerializationManager extends System.Object implements class System.ComponentModel.Design.Serialization.IDesignerSerializationManager, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class DesignerSerializationManager&#xA;Implements IDesignerSerializationManager, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DesignerSerializationManager : IServiceProvider, System::ComponentModel::Design::Serialization::IDesignerSerializationManager" />
  <TypeSignature Language="F#" Value="type DesignerSerializationManager = class&#xA;    interface IDesignerSerializationManager&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms.Design</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.Design.Serialization.IDesignerSerializationManager</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia implementację <see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" /> interfejsu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager> Interfejs został zaprojektowany jako interfejs niezależny od formatu do obiektu, który kontroluje serializację. Zasadniczo zapewnia ona kontekst i usługi dla serializatorów, które faktycznie wykonują deserializacji. <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager>pomaga w procesie deserializacji przez śledzenie obiektów. Jest to podobna Metoda do <xref:System.ComponentModel.Design.IDesignerHost> interfejsu: projektanci w rzeczywistości udostępniają interfejs użytkownika i <xref:System.ComponentModel.Design.IDesignerHost> udostępniają klej, który umożliwia różnym projektantom współdziałanie ze sobą.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> Klasa implementuje<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager>. Został zaprojektowany w celu zapewnienia uniwersalnej formy deserializacji podobnej do serializatorów w czasie wykonywania, takich jak <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> Klasa osiąga trzy cele:  
  
-   Jest to prosty obiekt gotowe, który może służyć do deserializacji różnych formatów.  
  
-   Jest ona ogólna i nie jest powiązana z żadnym konkretnym formatem. Można go użyć równie do deserializacji CodeDOM, a także deserializacji znaczników.  
  
-   Jest rozszerzalny i obsługuje różne metody serializacji, które są używane w scenariuszach kopiowania/wklejania i cofania/ponawiania.  
  
 Serializacja czasu projektowania ma następujące różnice między serializacji obiektu czasu wykonywania:  
  
-   Obiekt wykonujący serializacji jest ogólnie oddzielony od obiektu czasu wykonywania, dzięki czemu logika czasu projektowania może zostać usunięta ze składnika.  
  
-   Schemat serializacji zakłada, że obiekt zostanie utworzony w pełni zainicjowany, a następnie zmodyfikowany przez wywołania właściwości i metod podczas deserializacji.  
  
-   Właściwości obiektu, który ma wartości, które nigdy nie zostały ustawione dla obiektu (właściwości zawierają wartości domyślne) nie są serializowane. Odwrotnie, strumień deserializacji może mieć otwory.  
  
-   Nacisk jest umieszczany na jakości zawartości w strumieniu serializacji, a nie w pełnej serializacji obiektu. Oznacza to, że jeśli nie ma zdefiniowanego sposobu serializacji obiektu, ten obiekt może zostać pominięty zamiast zgłaszać wyjątek. Aparat serializacji może zapewnić algorytmy heurystyczne w tym miejscu, aby zdecydować, które błędy mogą być ignorowane i które nie są nieodwracalne.  
  
-   Strumień serializacji może mieć więcej danych niż jest to konieczne w przypadku deserializacji. Serializacja kodu źródłowego, na przykład, zawiera kod użytkownika zmieszany z kodem wymaganym do deserializacji grafu obiektów. Ten kod użytkownika musi być ignorowany podczas deserializacji i zachowywany podczas serializacji.  
  
 Z powodu różnic między różnymi modelami serializacji stosuje się do serializacji czasu projektowania. Ten model wykorzystuje oddzielny obiekt serializatora dla każdego serializowanego typu danych. Każdy serializator zapewnia swój niewielki udział w tym problemie jako całość. Te serializatory są koordynowane za pomocą wspólnego menedżera serializacji. Menedżer serializacji jest odpowiedzialny za utrzymanie stanu między różnymi serializatorami. Rozważmy na przykład następujące klasy:  
  
 [!code-csharp[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/CS/Program.cs#2)]
 [!code-vb[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/VB/Program.vb#2)]  
  
 Wystąpienie tej klasy wykorzystuje trzy różne serializatory: jeden dla `SampleObject`, jeden dla ciągów i drugi dla liczb całkowitych. Serializator dla `SampleObject` jest nazywany serializatorem głównym, ponieważ `SampleObject` jest elementem głównym grafu serializacji. Można również utworzyć bardziej złożone wykresy obiektów. Rozważmy na przykład to, co się `SampleObject` stanie, jeśli zostały zmienione w następujący sposób:  
  
 [!code-csharp[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/CS/SampleObject.cs#11)]
 [!code-vb[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/VB/SampleObject.vb#11)]  
  
 Umożliwia `SampleObject` to posiadanie elementu podrzędnego, który jest innym wystąpieniem. Poniższy kod jest wypełniany na grafie obiektów:  
  
 [!code-csharp[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/CS/SampleObject.cs#12)]
 [!code-vb[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/VB/SampleObject.vb#12)]  
  
 Gdy `root` jest serializowany, zostaną użyte cztery serializatory: jeden główny Serializator, jeden serializator dla elementu podrzędnego `SampleObject`, jeden serializator dla `int`i jeden serializator dla `string`. Serializatory są buforowane na podstawie typu, dlatego nie ma potrzeby tworzenia serializatorów dla każdego wystąpienia `SampleObject`.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> Klasa jest oparta na koncepcji sesji serializacji. Sesja zachowuje stan, do którego mogą uzyskać dostęp różne serializatory. Gdy sesja zostanie usunięta, ten stan zostanie zniszczony. Pozwala to zagwarantować, że serializatory pozostaną w dużym stopniu bezstanowym i pomaga oczyścić serializatory, które zostały uszkodzone. W poniższych tabelach opisano sposób zarządzania stanem w sesjach i między nimi.  
  
## <a name="global-state"></a>Stan globalny  
 Ten stan należy do obiektu menedżera serializacji, ale jest niezależny od bieżącej sesji serializacji.  
  
|Obiekt|Użycie|  
|------------|-----------|  
|Dostawcy serializacji|Obiekty mogą być dodawane jako niestandardowi dostawcy serializacji. Ponieważ ci dostawcy są używani do lokalizowania serializatorów, prowadzą do nich sesję serializacji.|  
  
## <a name="session-owned-state"></a>Stan należący do sesji  
 Ten stan jest własnością sesji i jest niszczony, gdy sesja jest niszczona. W związku z tym dostęp do wszelkich właściwości lub metod, które mogłyby manipulować tym stanem, zgłosi wyjątek, jeśli Menedżer serializacji nie znajduje się w aktywnej sesji.  
  
|Obiekt|Użycie|  
|------------|-----------|  
|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName>wydarzen|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName> Zdarzenie jest dołączone przez serializator, aby zapewnić dodatkowe rozwiązanie nazw. Po zakończeniu sesji wszystkie programy obsługi są odłączone od tego zdarzenia.|  
|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete>wydarzen|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete> Zdarzenie jest wywoływane tuż przed usunięciem sesji. Następnie wszystkie programy obsługi są odłączone od tego zdarzenia.|  
|Tabela nazw|Menedżer serializacji utrzymuje tabelę, która mapuje między obiektami i ich nazwami. Serializatory mogą dać nazwy obiektów do łatwej identyfikacji. Ta tabela nazw jest czyszczona po zakończeniu sesji.|  
|Pamięć podręczna serializatorów|Menedżer serializacji przechowuje pamięć podręczną serializatorów, do których zażądano. Ta pamięć podręczna jest czyszczona po zakończeniu sesji. Metodę publiczną <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer%2A> można bezpiecznie wywołać w dowolnym momencie, ale jej wartość jest buforowana tylko wtedy, gdy jest wywoływana z poziomu sesji.|  
|Stos kontekstu|Menedżer serializacji utrzymuje obiekt nazywany stosem kontekstowym, do którego można uzyskać dostęp za pomocą <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context%2A> właściwości. Serializatory mogą używać tego stosu do przechowywania dodatkowych informacji dostępnych dla innych serializatorów. Na przykład Serializator, który serializacji wartości właściwości może wypchnąć nazwę właściwości na stosie serializacji przed zapytaniem do serializacji wartości. Ten stos jest czyszczony, gdy sesja zostanie przerwana.|  
|Lista błędów|Menedżer serializacji przechowuje listę błędów, które wystąpiły podczas serializacji. Ta lista, do której uzyskuje się <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors%2A> dostęp za pomocą właściwości, jest czyszczona po zakończeniu sesji. Uzyskanie dostępu do właściwości między sesjami spowoduje wyjątek. <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors%2A>|  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.ContextStack" />
    <altmember cref="T:System.IServiceProvider" />
    <altmember cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignerSerializationManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignerSerializationManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor ustawia <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> właściwości i <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> na. `true`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignerSerializationManager (IServiceProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (provider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignerSerializationManager(IServiceProvider ^ provider);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.Serialization.DesignerSerializationManager : IServiceProvider -&gt; System.ComponentModel.Design.Serialization.DesignerSerializationManager" Usage="new System.ComponentModel.Design.Serialization.DesignerSerializationManager provider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="provider">A <see cref="T:System.IServiceProvider" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> klasy dla danego dostawcy usług.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli serializator żąda usług, które nie mogą zostać spełnione przez menedżera serializacji, domyślna implementacja przekaże te żądania do `provider` parametru.  
  
 Ten konstruktor ustawia <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> właściwości i <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> na. `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="provider" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.IServiceProvider" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName="Container">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IContainer Container { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IContainer Container" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Container" />
      <MemberSignature Language="VB.NET" Value="Public Property Container As IContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IContainer ^ Container { System::ComponentModel::IContainer ^ get(); void set(System::ComponentModel::IContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Container : System.ComponentModel.IContainer with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.Container" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontener dla tego menedżera serializacji.</summary>
        <value>, <see cref="T:System.ComponentModel.IContainer" /> Do którego Menedżer serializacji doda składniki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kontener istnieje, wszystkie składniki, które są tworzone przez menedżera serializacji, zostaną dodane do kontenera. Domyślna implementacja tej właściwości przeszuka dostawcę <xref:System.ComponentModel.Design.IDesignerHost> usługi i użyje kontenera dostarczonego przez hosta projektanta. W przeciwnym razie ta właściwość zwróci `null` wartość i żadne składniki nie zostaną dodane do kontenera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Menedżer serializacji ma aktywną sesję serializacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual object CreateInstance (Type type, System.Collections.ICollection arguments, string name, bool addToContainer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateInstance(class System.Type type, class System.Collections.ICollection arguments, string name, bool addToContainer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateInstance(Type ^ type, System::Collections::ICollection ^ arguments, System::String ^ name, bool addToContainer);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : Type * System.Collections.ICollection * string * bool -&gt; obj&#xA;override this.CreateInstance : Type * System.Collections.ICollection * string * bool -&gt; obj" Usage="designerSerializationManager.CreateInstance (type, arguments, name, addToContainer)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.ICollection" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="addToContainer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ, dla którego ma zostać utworzone wystąpienie.</param>
        <param name="arguments">Parametry konstruktora typu. Może to być <see langword="null" /> lub pusta kolekcja do wywołania konstruktora bez parametrów.</param>
        <param name="name">Nazwa, aby nadać obiektowi. Jeśli <see langword="null" />obiekt nie zostanie podaną nazwą, chyba że obiekt zostanie dodany do kontenera, a kontener nadaje obiektowi nazwę.</param>
        <param name="addToContainer"><see langword="true" />Aby dodać obiekt do kontenera, jeśli obiekt jest zaimplementowany <see cref="T:System.ComponentModel.IComponent" />; w przeciwnym razie,. <see langword="false" /></param>
        <summary>Tworzy wystąpienie typu.</summary>
        <returns>Nowe wystąpienie typu określonego przez <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez serializatory podczas próby utworzenia wystąpienia typu. Domyślna implementacja tworzy nowe wystąpienie typu lub może zwrócić istniejące wystąpienie w zależności od wartości <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> właściwości i. <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> Metoda używa odbicia do tworzenia wystąpień i przeprowadza niektóre przekształcenia ogólne <xref:System.IConvertible> w parametrach, aby znaleźć pasujący Konstruktor. <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException"><paramref name="type" />nie ma konstruktora, który pobiera parametry zawarte w <paramref name="arguments" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName="CreateSession">
      <MemberSignature Language="C#" Value="public IDisposable CreateSession ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable CreateSession() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSession () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ CreateSession();" />
      <MemberSignature Language="F#" Value="member this.CreateSession : unit -&gt; IDisposable" Usage="designerSerializationManager.CreateSession " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową sesję serializacji.</summary>
        <returns><see cref="T:System.IDisposable" /> Reprezentuje nową sesję serializacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość danych w Menedżerze serializacji jest przejściowa i dotyczy tylko życia sesji serializacji. Po zlikwidowaniu sesji Serializacja jest uznawana za kompletną i ten stan przejściowy jest wyczyszczony. Dzięki temu pojedyncze wystąpienie menedżera serializacji może służyć do serializacji wielu drzew obiektów. Niektóre Stany, w tym dostawca usług i niestandardowi dostawcy serializacji, które zostały dodane do menedżera serializacji, obejmują sesje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Menedżer serializacji jest już w ramach sesji. Ta wersja programu <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> nie obsługuje równoczesnych sesji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Errors">
      <MemberSignature Language="C#" Value="public System.Collections.IList Errors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList Errors" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Errors As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ Errors { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Errors : System.Collections.IList" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę błędów, które wystąpiły podczas serializacji lub deserializacji.</summary>
        <value>Lista błędów, które wystąpiły podczas serializacji lub deserializacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listę błędów można odczytać tylko wtedy, gdy sesja serializacji jest aktywna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do tej właściwości poza sesją serializacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeType">
      <MemberSignature Language="C#" Value="public Type GetRuntimeType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetRuntimeType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetRuntimeType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRuntimeType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetRuntimeType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.GetRuntimeType : string -&gt; Type" Usage="designerSerializationManager.GetRuntimeType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu, który ma zostać pobrany.</param>
        <summary>Pobiera typ odpowiadający określonej nazwie typu.</summary>
        <returns>Określony typ.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializer">
      <MemberSignature Language="C#" Value="public object GetSerializer (Type objectType, Type serializerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSerializer(class System.Type objectType, class System.Type serializerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSerializer (objectType As Type, serializerType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSerializer(Type ^ objectType, Type ^ serializerType);" />
      <MemberSignature Language="F#" Value="member this.GetSerializer : Type * Type -&gt; obj" Usage="designerSerializationManager.GetSerializer (objectType, serializerType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer(System.Type,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="serializerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Typ obiektu, dla którego ma zostać pobrany serializator.</param>
        <param name="serializerType">Typ serializatora do pobrania.</param>
        <summary>Pobiera serializator dla danego typu obiektu.</summary>
        <returns>Serializator dla <paramref name="objectType" />lub <see langword="null" />, jeśli nie został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz zażądać typu serializatora, który chcesz. Ta metoda zwraca `null` , jeśli nie istnieje serializator żądanego typu dla określonego typu obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="objectType" />lub <paramref name="serializerType" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="protected virtual object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="abstract member GetService : Type -&gt; obj&#xA;override this.GetService : Type -&gt; obj" Usage="designerSerializationManager.GetService serviceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Typ usługi do pobrania.</param>
        <summary>Pobiera żądaną usługę.</summary>
        <returns>Żądana usługa lub <see langword="null" /> nie można rozpoznać usługi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetService%2A> Metoda zapewnia dostęp do źródłowego kontenera lub dostawcy usług, który został ustawiony w konstruktorze.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="protected virtual Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="designerSerializationManager.GetType typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu do pobrania.</param>
        <summary>Pobiera żądany typ.</summary>
        <returns>Żądany typ, lub <see langword="null" /> Jeśli nie można rozpoznać typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda przeszuka dostawcę usługi <xref:System.ComponentModel.Design.ITypeResolutionService> dla i, jeśli jest dostępna, zostanie delegowana do tej usługi w celu rozpoznania typu. <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetType%2A> Jeśli element <xref:System.ComponentModel.Design.ITypeResolutionService> nie jest dostępny, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetType%2A> wywoła <xref:System.Object.GetType%2A?displayProperty=nameWithType> metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveName">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveName (System.ComponentModel.Design.Serialization.ResolveNameEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveName(class System.ComponentModel.Design.Serialization.ResolveNameEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveName (e As ResolveNameEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveName(System::ComponentModel::Design::Serialization::ResolveNameEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveName : System.ComponentModel.Design.Serialization.ResolveNameEventArgs -&gt; unit&#xA;override this.OnResolveName : System.ComponentModel.Design.Serialization.ResolveNameEventArgs -&gt; unit" Usage="designerSerializationManager.OnResolveName e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.Serialization.ResolveNameEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.Design.Serialization.ResolveNameEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" /> metodę klasy bazowej, aby zarejestrowani pełnomocnicy otrzymywali zdarzenie.</para></block>
        <altmember cref="E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SetName(System.Object,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionCreated : EventArgs -&gt; unit&#xA;override this.OnSessionCreated : EventArgs -&gt; unit" Usage="designerSerializationManager.OnSessionCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionCreated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani pełnomocnicy otrzymywali zdarzenie.</para></block>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionDisposed">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionDisposed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionDisposed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionDisposed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionDisposed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionDisposed : EventArgs -&gt; unit&#xA;override this.OnSessionDisposed : EventArgs -&gt; unit" Usage="designerSerializationManager.OnSessionDisposed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionDisposed" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani pełnomocnicy otrzymywali zdarzenie.</para></block>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="PreserveNames">
      <MemberSignature Language="C#" Value="public bool PreserveNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveNames" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveNames As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveNames { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreserveNames : bool with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> Metoda powinna sprawdzać obecność danej nazwy w kontenerze.</summary>
        <value><see langword="true" />Jeśli <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> zostanie przekazana nazwa składnika; <see langword="false" /> Jeśli<see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> program sprawdzi obecność podaną nazwę w kontenerze. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość określa zachowanie <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A>metody. <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> Jeśli `true` ,<xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> nastąpi przekazanie nazwy danego składnika. Jeśli `false` program<xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> sprawdzi obecność podaną nazwę w kontenerze. Jeśli nazwa nie istnieje w kontenerze, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> program użyje podaną nazwę. Jeśli nazwa istnieje w kontenerze, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> program przekaże wartość null jako nazwę składnika podczas dodawania go do kontenera, co daje mu nową nazwę. Druga odmiana jest przydatna do implementowania serializatora, który zawsze duplikuje obiekty, zamiast zakładając, że te obiekty nie istnieją. Polecenia Wklej często używają tego typu serializatora.  
  
 Tę właściwość można zmienić tylko wtedy, gdy nie jesteś w sesji serializacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość została zmieniona z poziomu sesji serializacji.</exception>
        <altmember cref="Overload:System.ComponentModel.Design.Serialization.DesignerSerializationManager.#ctor" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PropertyProvider">
      <MemberSignature Language="C#" Value="public object PropertyProvider { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object PropertyProvider" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PropertyProvider" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyProvider As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ PropertyProvider { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyProvider : obj with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.PropertyProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który powinien być używany do dostarczania właściwości do <see cref="P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" /> właściwości menedżera serializacji.</summary>
        <value>Obiekt, który powinien być używany do podania właściwości <see cref="P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" /> właściwości menedżera serializacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PropertyProvider%2A> Właściwość umożliwia nadanie menedżerowi serializacji zestawu właściwości serializacji, które mogą być używane przez serializatory do obsługi ich zachowań.  
  
 Właściwości publiczne tego obiektu zostaną sprawdzone i opakowane w nowe deskryptory właściwości, które mają obiekt docelowy menedżera serializacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecycleInstances">
      <MemberSignature Language="C#" Value="public bool RecycleInstances { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecycleInstances" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
      <MemberSignature Language="VB.NET" Value="Public Property RecycleInstances As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecycleInstances { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RecycleInstances : bool with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> zawsze będzie tworzone nowe wystąpienie typu.</summary>
        <value><see langword="true" />Jeśli <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> zwróci istniejące wystąpienie; <see langword="false" /> Jeśli<see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> program utworzy nowe wystąpienie typu. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość ma `false`wartość, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> Metoda zawsze utworzy nowe wystąpienie typu. <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> Jeśli <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> jest `true` ,<xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> najpierw przeszukuje tabelę nazw i kontener dla obiektu o tej samej nazwie. Jeśli taki obiekt istnieje i ma ten sam typ, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> zwróci istniejące wystąpienie. Druga odmiana jest przydatna do implementowania serializatora, który stosuje stan serializacji do istniejącego zestawu obiektów, a nie zawsze tworzenia nowego drzewa. Polecenie **Cofnij** często używa tego typu serializatora.  
  
 W <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> przypadku, gdy właściwość ma `true`wartość, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> właściwość będzie dodatkowo modyfikować zachowanie <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> w zależności od typów dwóch obiektów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Menedżer serializacji ma aktywną sesję serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName="SessionCreated">
      <MemberSignature Language="C#" Value="public event EventHandler SessionCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SessionCreated" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SessionCreated;" />
      <MemberSignature Language="F#" Value="member this.SessionCreated : EventHandler " Usage="member this.SessionCreated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy sesja zostanie utworzona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionDisposed">
      <MemberSignature Language="C#" Value="public event EventHandler SessionDisposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SessionDisposed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionDisposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionDisposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SessionDisposed;" />
      <MemberSignature Language="F#" Value="member this.SessionDisposed : EventHandler " Usage="member this.SessionDisposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy sesja zostanie usunięta.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.AddSerializationProvider (System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider(class System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      <MemberSignature Language="VB.NET" Value="Sub AddSerializationProvider (provider As IDesignerSerializationProvider) Implements IDesignerSerializationManager.AddSerializationProvider" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider(System::ComponentModel::Design::Serialization::IDesignerSerializationProvider ^ provider) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::AddSerializationProvider;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dostawca serializacji do dodania.</param>
        <summary>Dodaje niestandardowego dostawcę serializacji do menedżera serializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer%2A> Gdy metoda jest używana do żądania dostawcy serializacji, Menedżer serializacji najpierw wysyła zapytanie do niestandardowych dostawców serializacji przed szukaniem metadanych typu dla odpowiedniego serializatora.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context">
      <MemberSignature Language="C#" Value="System.ComponentModel.Design.Serialization.ContextStack System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.Serialization.ContextStack System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#Context" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Context As ContextStack Implements IDesignerSerializationManager.Context" />
      <MemberSignature Language="C++ CLI" Value="property System::ComponentModel::Design::Serialization::ContextStack ^ System::ComponentModel::Design::Serialization::IDesignerSerializationManager::Context { System::ComponentModel::Design::Serialization::ContextStack ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.Serialization.ContextStack</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stos kontekstu dla tej sesji serializacji.</summary>
        <value>A <see cref="T:System.ComponentModel.Design.Serialization.ContextStack" /> , który przechowuje dane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stos kontekstu zapewnia zdefiniowany przez użytkownika obszar magazynu wdrożony jako stos. Ten obszar magazynowania jest przydatnym sposobem zapewnienia komunikacji między serializatorami, ponieważ Serializacja jest ogólnym procesem hierarchicznym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do tej właściwości poza sesją serializacji.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.ContextStack" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance">
      <MemberSignature Language="C#" Value="object IDesignerSerializationManager.CreateInstance (Type type, System.Collections.ICollection arguments, string name, bool addToContainer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(class System.Type type, class System.Collections.ICollection arguments, string name, bool addToContainer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(Type ^ type, System::Collections::ICollection ^ arguments, System::String ^ name, bool addToContainer) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::CreateInstance;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.ICollection" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="addToContainer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ danych do utworzenia.</param>
        <param name="arguments">Argumenty, które mają zostać przekazane do konstruktora dla tego typu.</param>
        <param name="name">Nazwa obiektu. Ta nazwa może służyć do późniejszego dostępu do obiektu za <see cref="M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(System.String)" />pomocą. Jeśli <see langword="null" /> jest zakończony, obiekt jest nadal tworzony, ale nie można uzyskać do niego dostępu według nazwy.</param>
        <param name="addToContainer"><see langword="true" />Aby dodać ten obiekt do kontenera projektu. Obiekt musi być zaimplementowany <see cref="T:System.ComponentModel.IComponent" /> dla tego elementu, aby miał efekt.</param>
        <summary><see cref="M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> Implementuje metodę.</summary>
        <returns>Nowo utworzony wystąpienie obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance">
      <MemberSignature Language="C#" Value="object IDesignerSerializationManager.GetInstance (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function GetInstance (name As String) As Object Implements IDesignerSerializationManager.GetInstance" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(System::String ^ name) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetInstance;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu do pobrania.</param>
        <summary>Pobiera wystąpienie utworzonego obiektu o określonej nazwie.</summary>
        <returns>Wystąpienie obiektu o podaną nazwę lub <see langword="null" /> Jeśli nie można odnaleźć obiektu o tej nazwie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do tej właściwości poza sesją serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName">
      <MemberSignature Language="C#" Value="string IDesignerSerializationManager.GetName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetName (value As Object) As String Implements IDesignerSerializationManager.GetName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName(System::Object ^ value) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetName;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, dla którego ma zostać pobrana nazwa.</param>
        <summary>Pobiera nazwę określonego obiektu.</summary>
        <returns>Nazwa obiektu lub <see langword="null" /> Jeśli obiekt jest bez nazwy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda nie może znaleźć odpowiedniej nazwy `value` dla <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName> parametru, wywołuje zdarzenie przed zwróceniem `null`. <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23GetName%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do tej właściwości poza sesją serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SetName(System.Object,System.String)" />
        <altmember cref="E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer">
      <MemberSignature Language="C#" Value="object IDesignerSerializationManager.GetSerializer (Type objectType, Type serializerType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer(class System.Type objectType, class System.Type serializerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetSerializer(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetSerializer (objectType As Type, serializerType As Type) As Object Implements IDesignerSerializationManager.GetSerializer" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer(Type ^ objectType, Type ^ serializerType) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetSerializer;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer(System.Type,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="serializerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Typ obiektu, dla którego ma zostać pobrany serializator.</param>
        <param name="serializerType">Typ serializatora do pobrania.</param>
        <summary>Pobiera serializator żądanego typu dla określonego typu obiektu.</summary>
        <returns>Wystąpienie żądanego serializatora lub <see langword="null" /> Jeśli nie można zlokalizować odpowiedniego serializatora.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType">
      <MemberSignature Language="C#" Value="Type IDesignerSerializationManager.GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function GetType (typeName As String) As Type Implements IDesignerSerializationManager.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType(System::String ^ typeName) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">W pełni kwalifikowana nazwa typu do załadowania.</param>
        <summary>Pobiera typ określonej nazwy.</summary>
        <returns>Wystąpienie typu lub <see langword="null" /> , jeśli nie można załadować typu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do tej właściwości poza sesją serializacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties">
      <MemberSignature Language="C#" Value="System.ComponentModel.PropertyDescriptorCollection System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptorCollection System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#Properties" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Properties As PropertyDescriptorCollection Implements IDesignerSerializationManager.Properties" />
      <MemberSignature Language="C++ CLI" Value="property System::ComponentModel::PropertyDescriptorCollection ^ System::ComponentModel::Design::Serialization::IDesignerSerializationManager::Properties { System::ComponentModel::PropertyDescriptorCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" /> Implementuje właściwość.</summary>
        <value><see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> Zawierający właściwości, które mają być serializowane.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.RemoveSerializationProvider (System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider(class System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveSerializationProvider (provider As IDesignerSerializationProvider) Implements IDesignerSerializationManager.RemoveSerializationProvider" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider(System::ComponentModel::Design::Serialization::IDesignerSerializationProvider ^ provider) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::RemoveSerializationProvider;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationProvider" /> Do usunięcia.</param>
        <summary>Usuwa wcześniej dodany dostawca serializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda usuwa niestandardowego dostawcę serializacji, który został wcześniej dodany przez wywołanie <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23AddSerializationProvider%2A> metody. <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23RemoveSerializationProvider%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.ReportError (object errorInformation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError(object errorInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#ReportError(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub ReportError (errorInformation As Object) Implements IDesignerSerializationManager.ReportError" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError(System::Object ^ errorInformation) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::ReportError;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInformation" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="errorInformation">Obiekt zawierający informacje o błędzie, zazwyczaj typu <see cref="T:System.String" /> lub. <see cref="T:System.Exception" /></param>
        <summary>Służy do zgłaszania odwracalnego błędu w serializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializatory mogą być zapisywane, aby bezpiecznie obsługiwać błędy odwracalne przez wywołanie <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23ReportError%2A> metody z informacjami o błędzie. Menedżer serializacji może obsługiwać raportowanie listy błędów po jej zakończeniu lub może zgłosić wyjątek z tej metody i przerwać proces serializacji. Serializator powinien być kontynuowany po wywołaniu tej funkcji.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23ReportError%2A>`errorInformation` dodaje parametr<xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors%2A> do kolekcji. Jeśli `errorInformation` jest`null`, nie jest podejmowana żadna akcja.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do tej właściwości poza sesją serializacji.</exception>
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName">
      <MemberSignature Language="C#" Value="event System.ComponentModel.Design.Serialization.ResolveNameEventHandler System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.Design.Serialization.ResolveNameEventHandler System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#ResolveName" />
      <MemberSignature Language="VB.NET" Value="Custom Event ResolveName As ResolveNameEventHandler Implements System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.Serialization.ResolveNameEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" /> gdy nie można zlokalizować określonej nazwy w tabeli nazw menedżera serializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Zdarzenie jest zgłaszane, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23GetName%2A> gdy wywoływana jest metoda, ale nie można odnaleźć określonej nazwy w tabeli nazw menedżera serializacji. `ResolveName`

To zdarzenie umożliwia serializatorowi zażądanie — utworzenie obiektu, aby serializator nie musiał zamówić tworzenia obiektów przez zależność. Ten delegat jest wyczyszczony natychmiast po zakończeniu serializacji lub deserializacji.

]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Menedżer serializacji nie ma aktywnej sesji serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete">
      <MemberSignature Language="C#" Value="event EventHandler System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SerializationComplete" />
      <MemberSignature Language="VB.NET" Value="Custom Event SerializationComplete As EventHandler Implements System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy Serializacja została ukończona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Zazwyczaj proces serializacji jest jednowątkowy i powinien być bezstanowy. Jeśli te cechy nie są prawdziwe, można <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete> użyć zdarzenia, aby pomóc w organizowaniu tego procesu. Serializator może śledzić to zdarzenie, aby wiedzieć, że proces serializacji został ukończony.

Na przykład czasami serializator musi zapisywać w innym pliku, takim jak plik zasobów. W takim przypadku byłoby niewydajne, aby zaprojektować Serializator, aby zamknąć plik po zakończeniu, ponieważ Serializacja grafu obiektów zwykle wymaga kilku serializatorów; w związku z tym plik zasobów zostałby otwarty i zamknięty wiele razy. Zamiast tego do pliku zasobów można uzyskać dostęp za pomocą obiektu, który przeprowadził śledzenie <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete> zdarzenia, a ten obiekt może zamknąć plik zasobów na końcu serializacji.

W powiązanym użyciu to zdarzenie służy do usuwania tymczasowej usługi zainstalowanej w Menedżerze serializacji.

]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Menedżer serializacji nie ma aktywnej sesji serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.SetName (object instance, string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName(object instance, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SetName(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetName (instance As Object, name As String) Implements IDesignerSerializationManager.SetName" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName(System::Object ^ instance, System::String ^ name) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::SetName;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName(System.Object,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, aby ustawić nazwę.</param>
        <param name="name"><see cref="T:System.String" /> Używana jako nazwa obiektu.</param>
        <summary>Ustawia nazwę określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23SetName%2A> Metoda umożliwia ustawienie nazwy istniejącego obiektu. Umożliwia to utworzenie wystąpienia obiektu za pomocą wywołania <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23GetInstance%2A> metody, unikając obciążenia <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Obiekt określony przez wystąpienie ma już nazwę lub <paramref name="name" /> jest już używany przez inny nazwany obiekt.</exception>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do tej właściwości poza sesją serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (serviceType As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ serviceType) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Obiekt, który określa typ obiektu usługi do pobrania.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IServiceProvider.GetService(System.Type)" /> metodę.</summary>
        <returns>Obiekt usługi typu <paramref name="serviceType" />.  
  
—lub— 
 <see langword="null" />Jeśli nie ma obiektu usługi typu <paramref name="serviceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> gdy wystąpienie jest rzutowane <xref:System.IServiceProvider> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRecycledTypes">
      <MemberSignature Language="C#" Value="public bool ValidateRecycledTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateRecycledTypes" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateRecycledTypes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateRecycledTypes { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRecycledTypes : bool with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> metoda sprawdzi, czy pasujące nazwy odwołują się do tego samego typu.</summary>
        <value><see langword="true" />w <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> przypadku weryfikacji typów; w przeciwnym <see langword="false" /> razie, jeśli nie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość modyfikuje zachowanie <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> metody, jeśli <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> właściwość jest `true`, zgodnie z opisem w poniższej tabeli. <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A>  
  
|`RecycleInstances`|`ValidateRecycledTypes`|Zachowanie`CreateInstance`|  
|------------------------|-----------------------------|----------------------------------|  
|`false`|`true` lub `false`|Zawsze twórz nowe wystąpienie określonego typu|  
|`true`|`false`|Jeśli zostanie znalezione pasujące wystąpienie, jest ono zwracane niezależnie od jego typu.|  
|`true`|`true`|Jeśli zostanie znalezione pasujące wystąpienie, jest ono zwracane tylko wtedy, gdy jego typ jest taki sam jak określony w wywołaniu metody.|  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A>przydaje się do przedzielenia jednego typu obiektu na inny, jeśli mają podobne właściwości, ale nie mają wspólnego elementu nadrzędnego lub interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Menedżer serializacji ma aktywną sesję serializacji.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
      </Docs>
    </Member>
  </Members>
</Type>

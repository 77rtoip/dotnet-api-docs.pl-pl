<Type Name="AppContext" FullName="System.AppContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="482d52e5b69288b9a8240a5a41deef259168aace" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36433578" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class AppContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit AppContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.AppContext" />
  <TypeSignature Language="VB.NET" Value="Public Class AppContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppContext abstract sealed" />
  <TypeSignature Language="F#" Value="type AppContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.AppContext</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia to członkom ustawiania i pobierania danych o kontekście aplikacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppContext> Klasa umożliwia autorom biblioteki na mechanizm uniform Wypisz dla nowych funkcji dla użytkowników. Definiuje on kontrakt luźno powiązane między składnikami, aby komunikować się rezygnacji z żądania. Ta możliwość jest zwykle ważny w przypadku zmian do istniejących funkcji. Z drugiej strony już istnieje niejawna zgody na nowych funkcji.  
  
## <a name="appcontext-for-library-developers"></a>AppContext dla deweloperów biblioteki  
 Użyj biblioteki <xref:System.AppContext> zmienia klasy do definiowania i ujawnia zgodności, podczas gdy użytkownicy biblioteki można ustawić tych przełączników wpłynąć na zachowanie biblioteki. Domyślnie udostępnia nowych funkcji w bibliotekach i zmieniają tylko (to znaczy zapewniają funkcje poprzednich) Jeśli jest ustawiona przełącznik.  Dzięki temu biblioteki, aby podać nowe zachowanie dla istniejącego interfejsu API, pozostawiając obsługuje wywołań, które są zależne od poprzednie.  
  
### <a name="defining-the-switch-name"></a>Definiowanie nazwy przełącznika  
 Najczęściej umożliwia konsumentów biblioteki rezygnacji z Zmiana zachowania, jest do definiowania nazwanego przełącznika.  Jego `value` element to pary nazwa/wartość, która składa się z nazwy przełącznika i jego <xref:System.Boolean> wartość.  Domyślnie jest zawsze niejawnie `false`, która udostępnia nowe zachowanie (i sprawia, że nowe zachowanie opcjonalnych domyślnie). Ustawienia przełącznika `true` umożliwia, co zapewnia zachowanie starszej wersji. Jawne ustawienie przełącznika `false` udostępnia również nowe zachowanie.  
  
 Jest na użytek formacie spójnej nazwy przełącznika, ponieważ są one formalnego kontraktu udostępnianych przez bibliotekę. Poniżej przedstawiono dwa formaty oczywiste.  
  
-   *Przełącznik*.* przestrzeń nazw*.* switchName*  
  
-   *Przełącznik*.* Biblioteka*.* switchName*  
  
 Po zdefiniowaniu i udokumentować przełącznika wywołań może być używany za pomocą rejestru, dodając [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) elementu do ich pliku konfiguracji aplikacji lub poprzez wywołanie <xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> Metoda programowo. Zobacz [AppContext dla konsumentów biblioteki](#ForConsumers) sekcji, aby uzyskać więcej informacji dotyczących sposobu wywoływania użycia i ustaw wartość <xref:System.AppContext> konfiguracji przełączników.  
  
 Po uruchomieniu aplikacji środowisko uruchomieniowe języka wspólnego automatycznie odczytuje ustawienia zgodności w rejestrze i ładuje plik konfiguracji aplikacji, aby wypełnić aplikacji <xref:System.AppContext> wystąpienia. Ponieważ <xref:System.AppContext> wystąpień jest wypełniana programowo przez obiekt wywołujący lub w czasie wykonywania, nie trzeba wykonywać żadnych czynności, takie jak wywołania <xref:System.AppContext.SetSwitch%2A> metody, aby skonfigurować <xref:System.AppContext> wystąpienia.  
  
### <a name="checking-the-setting"></a>Sprawdzanie ustawienie  
 Następnie można sprawdzić, jeśli klient został zadeklarowany wartość przełącznika i odpowiednio przez wywołanie act <xref:System.AppContext.TryGetSwitch%2A?displayProperty=nameWithType> metody. Metoda zwraca `true` Jeśli `switchName` argument zostanie znaleziony, a kiedy metoda zwraca, jego `isEnabled` argument wskazuje wartość przełącznika.  W przeciwnym razie metoda zwraca `false`.  
  
### <a name="an-example"></a>Przykład  
 Poniższy przykład przedstawia użycie <xref:System.AppContext> klasę, aby umożliwić klientowi wybrać zachowanie oryginalnej metody biblioteki.   Poniżej znajduje się w wersji 1.0 biblioteki o nazwie `StringLibrary`. Definiuje `SubstringStartsAt` metodę, która wykonuje porządkowej porównanie, aby określić indeks początkowy podciągu ciągu większy.  
  
 [!code-csharp[System.AppContext.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example4.cs#4)]
 [!code-vb[System.AppContext.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example4.vb#4)]  
  
 W poniższym przykładzie użyto następnie biblioteki można znaleźć indeks początkowy podciągu "archæ" w "archaeologist". Ponieważ metoda przeprowadza porównanie liczby porządkowej, nie można odnaleźć podciąg.  
  
 [!code-csharp[System.AppContext.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example4.cs#5)]
 [!code-vb[System.AppContext.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example4.vb#5)]  
  
 Zmiany w wersji 2 biblioteki, jednak `SubstringStartsAt` metodę porównania z uwzględnieniem kultury.  
  
 [!code-csharp[System.AppContext.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example6.cs#6)]
 [!code-vb[System.AppContext.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example6.vb#6)]  
  
 Gdy aplikacja jest ponownie kompilowana w celu uruchomienia nowej wersji biblioteki, teraz raporty czy podciągu "archæ" znajduje się pod indeksem 4 "archaeologist".  
  
 [!code-csharp[System.AppContext.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example6.cs#7)]
 [!code-vb[System.AppContext.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example6.vb#7)]  
  
 Ta zmiana może uniemożliwić krytyczne aplikacje, które są zależne od oryginalnego zachowanie, definiując [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) przełącznika. W takim przypadku nosi nazwę przełącznika `StringLibrary.DoNotUseCultureSensitiveComparison`. Wartość domyślną `false`, wskazuje, że biblioteki należy wykonać jego porównanie zależne od kultury w wersji 2.0. `true` Wskazuje, że biblioteki należy wykonać jego porównanie liczby porządkowej w wersji 1.0.  Niewielkie zmiany poprzedni kod umożliwia konsumenta biblioteki można ustawić przełącznika tak, aby określić typ porównania, które wykonuje metodę.  
  
 [!code-csharp[System.AppContext.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example8.cs#8)]
 [!code-vb[System.AppContext.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example8.vb#8)]  
  
 Jeśli aplikacja może następnie używać następującego pliku konfiguracji do przywrócenia zachowanie w wersji 1.0.  
  
```xml  
  
<configuration>  
   <runtime>  
      <AppContextSwitchOverrides value="StringLibrary.DoNotUseCultureSensitiveComparison=true" />   
   </runtime>  
</configuration>  
  
```  
  
 Gdy aplikacja jest uruchamiana z pliku konfiguracji istnieje, tworzy następujące dane wyjściowe:  
  
```  
'archæ' not found in 'The archaeologist'  
```  
  
<a name="ForConsumers"></a>   
## <a name="appcontext-for-library-consumers"></a>AppContext dla konsumentów biblioteki  
 Jeśli klient biblioteki, <xref:System.AppContext> klasy pozwala korzystać z biblioteki lub biblioteki metody Wypisz mechanizm dla nowych funkcji.   Poszczególne metody biblioteki klas, z którym nawiązywane jest definiowanie określonego przełączników, które włączyć lub wyłączyć nowe zachowanie. Wartość parametru jest wartością logiczną. Jeśli jest `false`, który zazwyczaj jest to wartość domyślna, nowe zachowanie jest włączone; jeśli jest `true`, nowe zachowanie jest wyłączona, a element członkowski zachowuje się tak jak poprzednio.  
  
 Wartość przełącznika można ustawić w jeden z trzech sposobów:  
  
-   Wywołując <xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> metody w kodzie.  `switchName` Argument definiuje nazwę przełącznika i `isEnabled` właściwość definiuje wartość przełącznika. Ponieważ <xref:System.AppContext> jest Klasa statyczna, jest ona dostępna na podstawie domeny dla poszczególnych aplikacji.  
  
     Wywoływanie <xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> ma zakres aplikacji; oznacza to, dotyczy tylko aplikacji.  
  
-   Dodając `<AppContextSwitchOverrides>` elementu [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcji w pliku app.config. Przełącznik ma jeden atrybut, `value`, którego wartość jest ciągiem, który reprezentuje parę klucza i wartości, zawierająca zarówno nazwę przełącznika i jego wartość.  
  
     Aby zdefiniować wiele przełączników, oddziel każdy przełącznik parę klucza i wartości w [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) elementu `value` atrybutu średnikiem. W takim przypadku `<AppContextSwitchOverrides>` element ma następujący format:  
  
    ```xml  
    <AppContextSwitchOverrides value="switchName1=value1;switchName2=value2" />  
    ```  
  
     Przy użyciu `<AppContextSwitchOverrides>` element, aby zdefiniować ustawienia konfiguracji, ma zakres aplikacji; oznacza to, dotyczy tylko aplikacji.  

    > [!NOTE]    
    > Aby uzyskać informacje na temat parametrów zdefiniowanych w programie .NET Framework, zobacz [ \<AppContextSwitchOverrides > elementu](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md).

-   Dodając wartość ciągu, której nazwa jest nazwą przełącznika do `HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext` klucza w rejestrze. Wartość musi być reprezentację ciągu <xref:System.Boolean> może zostać przeanalizowany przez <xref:System.Boolean.Parse%2A?displayProperty=nameWithType> metody; oznacza to, musi mieć wartość "Prawda", "prawda", "False" lub "false". Jeśli środowisko uruchomieniowe napotka wszelkie inne wartości, ignoruje przełącznika.  
  
     Aby zdefiniować za pomocą rejestru <xref:System.AppContext> przełącznika ma zasięg maszyny; oznacza to, że ma to wpływ na wszystkie aplikacje uruchomione na maszynie.  
  
 Jeśli ustawisz ten sam przełącznik w więcej niż jednym ze sposobów jest kolejność pierwszeństwa, określania, które zastępuje inne:  
  
1.  Ustawienie programowe.  
  
2.  Ustawienia w pliku konfiguracyjnym aplikacji.  
  
3.  Ustawienie rejestru.  
  
 Poniżej przedstawiono prostą aplikację, która przekazuje plik identyfikator URI do <xref:System.IO.Path.GetDirectoryName%2A?displayProperty=nameWithType> metody.  Podczas uruchamiania w .NET Framework 4.6, zgłasza <xref:System.ArgumentException> ponieważ `file://` nie jest już prawidłowy część ścieżki pliku.  
  
 [!code-csharp[System.AppContext.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/ForConsumers1.cs#10)]
 [!code-vb[System.AppContext.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/ForConsumers1.vb#10)]  
  
 Aby przywrócić poprzednich zachowanie metody i uniemożliwić wyjątku, można dodać `Switch.System.IO.UseLegacyPathHandling` przełączyć się do pliku konfiguracji aplikacji, na przykład:  
  
```xml  
<configuration>  
    <runtime>  
        <AppContextSwitchOverrides value="Switch.System.IO.UseLegacyPathHandling=true" />    
    </runtime>  
</configuration>  
```  
## <a name="see-also"></a>Zobacz także
[Przełącznik AppContext](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public static string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppContext.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppContext.BaseDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę ścieżki katalogu podstawowego, używaną do sondowania dla zestawów mechanizm rozpoznawania zestawów.</summary>
        <value>Nazwa ścieżki katalogu podstawowego, używaną do sondowania dla zestawów mechanizm rozpoznawania zestawów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to dla właściwości domeny aplikacji. Wartość odpowiada <xref:System.AppDomain.BaseDirectory%2A?displayProperty=nameWithType> właściwości bieżącej domeny aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppContext.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetData : string -&gt; obj" Usage="System.AppContext.GetData name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu danych.</param>
        <summary>Zwraca wartość elementu danych o podanej nazwie przypisane do bieżącej domeny aplikacji.</summary>
        <returns>Wartość <paramref name="name" />, jeśli <paramref name="name" /> identyfikuje nazwanej wartości; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSwitch">
      <MemberSignature Language="C#" Value="public static void SetSwitch (string switchName, bool isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetSwitch(string switchName, bool isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppContext.SetSwitch(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetSwitch (switchName As String, isEnabled As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetSwitch(System::String ^ switchName, bool isEnabled);" />
      <MemberSignature Language="F#" Value="static member SetSwitch : string * bool -&gt; unit" Usage="System.AppContext.SetSwitch (switchName, isEnabled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchName" Type="System.String" />
        <Parameter Name="isEnabled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="switchName">Nazwa przełącznika.</param>
        <param name="isEnabled">Wartość parametru.</param>
        <summary>Ustawia wartość przełącznika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppContext> Klasa umożliwia autorom biblioteki na mechanizm uniform Wypisz dla nowych funkcji dla użytkowników. Definiuje on kontrakt luźno powiązane między składnikami, aby komunikować się rezygnacji z żądania. Ta możliwość jest zwykle ważny w przypadku zmian do istniejących funkcji. Z drugiej strony już istnieje niejawna zgody na nowych funkcji.  
  
 <xref:System.AppContext.SetSwitch%2A> Metoda jest wywoływana przez aplikację (lub biblioteki), aby zadeklarować wartość przełącznika (która jest zawsze <xref:System.Boolean> wartość) definiujący zależnej biblioteki. Przełącznik jest zawsze niejawnie `false`, która oferuje nowe zachowanie. Ustawienia przełącznika `true` umożliwia, co zapewnia zachowanie starszej wersji. Jawne ustawienie przełącznika `false` udostępnia również nowe zachowanie. Zależnej biblioteki można następnie sprawdź wartość przełącznika przez wywołanie metody <xref:System.AppContext.TryGetSwitch%2A> metody.  
  
> [!NOTE]
>  Jest na użytek formacie spójnej nazwy przełącznika, ponieważ są one formalnego kontraktu udostępnianych przez bibliotekę. Poniżej przedstawiono dwa formaty oczywiste.  
>   
>  -   *Przełącznik*.* przestrzeń nazw*.* switchName*  
> -   *Przełącznik*.* Biblioteka*.* switchName*  
  
 Dla aplikacji działających w programie .NET Framework, oprócz programowo, ustawiając wartość przełącznika go można również ustawić:  
  
-   Przez dodanie nazwy przełącznika i wartość do [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) element [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcji pliku konfiguracji aplikacji. Na przykład poniższe definicje przełącznikiem o nazwie `Libraries.FPLibrary.UseExactFloatingPointComparison` o wartości `False`.  
  
    ```xml  
  
    <configuration>  
       <runtime>  
          <AppContextSwitchOverrides value="Libraries.FPLibrary.UseExactFloatingPointComparison=false" />   
       </runtime>  
    </configuration>  
  
    ```  
  
-   Dodając wartość ciągu, której nazwa jest nazwą przełącznika do `HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext` klucza w rejestrze. Wartość musi być reprezentację ciągu <xref:System.Boolean> może zostać przeanalizowany przez <xref:System.Boolean.Parse%2A?displayProperty=nameWithType> metody; oznacza to, musi mieć wartość "Prawda", "prawda", "False" lub "false".  
  
 Jeśli `switchName` już istnieje, jego wartość zostanie zastąpiona `isEnabled` argumentu.  Oznacza to, że najnowsze wywołanie <xref:System.AppContext.SetSwitch%2A> metoda zastępuje wartość zdefiniowana w rejestrze, w pliku konfiguracji aplikacji lub poprzednich wywołań <xref:System.AppContext.SetSwitch%2A> metody.  
 
 ### <a name="appcontextsetswitch-and-net-core"></a>AppContext.SetSwitch i .NET Core

Oprogramowanie .NET core obsługuje wywołaniom z <xref:System.AppContext.SetSwitch%2A> tylko metody. Obsługiwane są następujące parametry:

|Przełącznik|Wartości|Opis|
|--|--|--|
|`System.Net.Http.useSocketsHttpHandler` |`true`|`false`|Określa, czy wysokiego poziomu sieci interfejsów API, takich jak <xref:System.Net.Http.HttpClient> użyj <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType> (`true`) lub <xref:System.Net.Http.HttpClientHandler?displayProperty=nameWithType> (`false`).|   
  
## Examples  
 Następujący wiersz kodu ustawia przełącznik o nazwie `Switch.AmazingLib.ThrowOnException` do `true`, które umożliwia zachowanie starszej wersji. Biblioteki można następnie sprawdź, czy konsumenta biblioteka została ustawiona wartość przełącznika przez wywołanie metody <xref:System.AppContext.TryGetSwitch%2A> metody.  
  
 [!code-csharp[System.AppContext.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/TestValue1.cs#1)]
 [!code-vb[System.AppContext.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/TestValue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="switchName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="switchName" /> jest <see cref="F:System.String.Empty" />.</exception>
        <altmember cref="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public static string TargetFrameworkName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppContext.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ TargetFrameworkName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string" Usage="System.AppContext.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę docelowej bieżącej aplikacji wersji platformy.</summary>
        <value>Nazwa docelowej bieżącej aplikacji wersji platformy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa docelowej wersji struktury odpowiada wartości <xref:System.Runtime.Versioning.TargetFrameworkAttribute.FrameworkName%2A?displayProperty=nameWithType> właściwości. Listę nazw framework docelowej platformy .NET Framework, zobacz [ &lt;supportedRuntime&gt; Element](~/docs/framework/configure-apps/file-schema/startup/supportedruntime-element.md) elementu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Versioning.TargetFrameworkAttribute" />
        <altmember cref="P:System.Runtime.Versioning.TargetFrameworkAttribute.FrameworkName" />
      </Docs>
    </Member>
    <Member MemberName="TryGetSwitch">
      <MemberSignature Language="C#" Value="public static bool TryGetSwitch (string switchName, out bool isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSwitch(string switchName, [out] bool&amp; isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetSwitch (switchName As String, ByRef isEnabled As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetSwitch(System::String ^ switchName, [Runtime::InteropServices::Out] bool % isEnabled);" />
      <MemberSignature Language="F#" Value="static member TryGetSwitch : string *  -&gt; bool" Usage="System.AppContext.TryGetSwitch (switchName, isEnabled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchName" Type="System.String" />
        <Parameter Name="isEnabled" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="switchName">Nazwa przełącznika.</param>
        <param name="isEnabled">Po powrocie z tej metody zawiera wartość <c>switchName</c> Jeśli <c>switchName</c> został znaleziony, lub <see langword="false" /> Jeśli <c>switchName</c> nie został znaleziony. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Próbuje pobrać wartość przełącznika.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="switchName" /> została ustawiona i <paramref name="isEnabled" /> argument zawiera wartość przełącznika; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppContext> Klasa umożliwia autorom biblioteki na mechanizm uniform Wypisz dla nowych funkcji dla użytkowników. Definiuje on kontrakt luźno powiązane między składnikami, aby komunikować się rezygnacji z żądania. Ta możliwość jest zwykle ważny w przypadku zmian do istniejących funkcji. Z drugiej strony już istnieje niejawna zgody na nowych funkcji.  
  
 Środowisko uruchomieniowe języka wspólnego automatycznie wypełni przełączniki przypisane do <xref:System.AppContext> czytając rejestru i pliku konfiguracji aplikacji. Można zmienić wartości tych parametrów i nowych przełączników, dodawany przez wywołanie <xref:System.AppContext.SetSwitch%2A> metody.  
  
 Wywołuje biblioteki <xref:System.AppContext.TryGetSwitch%2A> metodę sprawdzania, czy jego konsumentów zadeklarowaniu wartość przełącznika i działa poprawnie na nim.  Jeśli przełącznik nie jest zdefiniowane, nowe funkcje jest domyślnie włączona. Jeśli zdefiniowano przełącznika i jego wartość wynosi `false`, nowych funkcji jest włączona. Jeśli jego wartość wynosi `true`, starsze zachowanie jest włączone.  
  
   
  
## Examples  
 Poniższy przykład określa, czy klient biblioteki została ustawiona przełącznik o nazwie `Switch.AmazingLib.ThrowOnException`.  
  
 [!code-csharp[System.AppContext.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/TestValue1.cs#2)]
 [!code-vb[System.AppContext.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/TestValue1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="switchName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="switchName" /> jest <see cref="F:System.String.Empty" />.</exception>
        <altmember cref="M:System.AppContext.SetSwitch(System.String,System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>
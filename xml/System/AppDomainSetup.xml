<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1e37f298a1fd97905ed7653efd2efcd1633f2ffc" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56401396" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Przedstawia informacje o powiązaniu zestawu, który można dodać do wystąpienia <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmiana właściwości <xref:System.AppDomainSetup> wystąpienia nie ma wpływu na istniejące <xref:System.AppDomain>. Może mieć wpływ na tworzenie nowej <xref:System.AppDomain>, gdy <xref:System.AppDomain.CreateDomain%2A> metoda jest wywoływana z <xref:System.AppDomainSetup> wystąpienia jako parametr.  
  
 Ta klasa implementuje <xref:System.IAppDomainSetup> interfejsu.  
  
> [!CAUTION]
>  Wartością domyślną dla <xref:System.AppDomainSetup.DisallowCodeDownload%2A> właściwość ma wartość false. To ustawienie jest niebezpieczne dla usług. Aby zapobiec usługi pobierania częściowo zaufany kod, należy ustawić tę właściwość na wartość true  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Instrukcje: Konfigurowanie domeny aplikacji</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Kontekst aktywacji, który ma być używany dla domeny aplikacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy w kontekście określonej aktywacji na potrzeby aktywacji opartej na manifest domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ActivationContext> Określony dla obiektu `activationContext` służy do generowania <xref:System.Runtime.Hosting.ActivationArguments> obiekt zawierający informacje wymagane do aktywowania nowej domeny aplikacji. To <xref:System.Runtime.Hosting.ActivationArguments> obiektu jest możliwy za pomocą <xref:System.AppDomainSetup.ActivationArguments%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationContext" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Obiekt, który określa informacje wymagane w przypadku aktywacji oparte na manifeście nowej domeny aplikacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy z argumentami określone uaktywnianie wymagany do aktywacji oparte na manifeście domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt określony dla `activationArguments` jest możliwy za pomocą <xref:System.AppDomainSetup.ActivationArguments%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationArguments" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dane dotyczące aktywacji domeny aplikacji.</summary>
        <value>Obiekt, który zawiera dane o aktywacji domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest zgłaszany żaden wyjątek, jeśli ta właściwość jest ustawiona `null`.  
  
 Informacje dostarczone przez <xref:System.Runtime.Hosting.ActivationArguments> obiekt obsługuje aktywację w oparciu o manifeście.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiona na <see cref="T:System.Runtime.Hosting.ActivationArguments" /> obiektu, którego tożsamość aplikacji jest niezgodna z tożsamością <see cref="T:System.Security.Policy.ApplicationTrust" /> obiektu zwróconego przez <see cref="P:System.AppDomainSetup.ApplicationTrust" /> właściwości. Jest zgłaszany żaden wyjątek, jeśli <see cref="P:System.AppDomainSetup.ApplicationTrust" /> właściwość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.AppDomainInitializer" /> delegować, który reprezentuje metodę wywołania zwrotnego, która jest wywoływana po zainicjowaniu domeny aplikacji.</summary>
        <value>Delegat, który reprezentuje metodę wywołania zwrotnego, która jest wywoływana po zainicjowaniu domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do przekazywania informacji do metody wywołania zwrotnego, przypisać tablicę ciągów, aby <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> właściwości. Tablica jest przekazywany do metody wywołania zwrotnego każdorazowo <xref:System.AppDomain> został zainicjowany.  
  
 Metoda wywołania zwrotnego jest wykonywana w kontekście nowo utworzona domena aplikacji.  
  
   
  
## Examples  
 Poniższy przykład tworzy domenę aplikacji podrzędną o nazwie `ChildDomain`przy użyciu <xref:System.AppDomainSetup> obiektu i dowody z domyślnej domeny aplikacji. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Właściwość jest ustawiona na metody wywołania zwrotnego `AppDomainInit`, która jest wywoływana po zainicjowaniu domeny podrzędnej. Argumenty dla metody wywołania zwrotnego są umieszczane w tablicy ciągów, które jest przypisane do <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> właściwości. Podczas tworzenia domeny podrzędnej metody wywołania zwrotnego po prostu wyświetla ciągi.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia Argumenty przekazane do metody wywołania zwrotnego, reprezentowane przez <see cref="T:System.AppDomainInitializer" /> delegować. Metoda wywołania zwrotnego jest wywoływane, gdy domena aplikacji jest zainicjowany.</summary>
        <value>Tablica ciągów, który jest przekazywany do metody wywołania zwrotnego, reprezentowane przez <see cref="T:System.AppDomainInitializer" /> delegata, po wywołaniu metody wywołania zwrotnego podczas <see cref="T:System.AppDomain" /> inicjowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.AppDomainSetup.AppDomainInitializer%2A> właściwości w celu określenia metody wywołania zwrotnego, która jest wywoływana podczas <xref:System.AppDomain> inicjowania. Jeśli <xref:System.AppDomainSetup.AppDomainInitializer%2A> właściwość nie jest ustawiona, macierz, przypisany do tej właściwości nie jest używany.  
  
 Metoda wywołania zwrotnego jest wykonywana w kontekście nowo utworzona domena aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy domenę aplikacji podrzędną o nazwie `ChildDomain`przy użyciu <xref:System.AppDomainSetup> obiektu i dowody z domyślnej domeny aplikacji. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Właściwość jest ustawiona na metody wywołania zwrotnego `AppDomainInit`, która jest wywoływana po zainicjowaniu domeny podrzędnej. Argumenty dla metody wywołania zwrotnego są umieszczane w tablicy ciągów, które jest przypisane do <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> właściwości. Podczas tworzenia domeny podrzędnej metody wywołania zwrotnego po prostu wyświetla ciągi.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę wyświetlaną zestawu, który zapewnia typ Menedżer domeny aplikacji domen aplikacji utworzonych za pomocą tego <see cref="T:System.AppDomainSetup" /> obiektu.</summary>
        <value>Nazwa wyświetlana zestawu, który zapewnia <see cref="T:System.Type" /> Menedżera domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić typ Menedżer domeny aplikacji, ustaw właściwość ta i <xref:System.AppDomainSetup.AppDomainManagerType%2A> właściwości. Jeśli nie ustawiono tych właściwości, druga jest ignorowana.  
  
 Jeśli nie podano żadnego typu, Menedżer domeny aplikacji jest utworzone na podstawie tego samego typu co nadrzędnej domeny aplikacji (czyli domeny aplikacji, z której <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> wywoływana jest metoda).  
  
 Gdy jest ładowany do domeny aplikacji, <xref:System.TypeLoadException> jest generowany, jeśli zestaw nie istnieje lub jeśli zestaw nie zawiera typu określonego przez <xref:System.AppDomainSetup.AppDomainManagerType%2A> właściwości. <xref:System.IO.FileLoadException> jest generowany, jeśli zestaw zostanie znaleziony, ale informacje o wersji jest niezgodny.  
  
 Aby ustawić Menedżer domeny aplikacji dla domyślnej domeny aplikacji, użyj [ \<appdomainmanagerassembly — >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) i [ \<appdomainmanagertype — >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) elementów w [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcję pliku konfiguracji aplikacji lub użycie zmiennych środowiskowych opisanych w <xref:System.AppDomainManager>.  
  
 Ta funkcja wymaga aplikacja miała pełne zaufanie. (Na przykład aplikację działającą na pulpicie ma pełne zaufanie). Jeśli aplikacja nie ma pełne zaufanie <xref:System.TypeLoadException> zgłaszany.  
  
 Format nazwy wyświetlanej zestawu jest nadawana przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pełną nazwę typu, który zawiera Menedżer domeny aplikacji domen aplikacji utworzonych za pomocą tego <see cref="T:System.AppDomainSetup" /> obiektu.</summary>
        <value>Pełna nazwa typu, włącznie z przestrzenią nazw.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić typ Menedżer domeny aplikacji, ustaw właściwość ta i <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> właściwości. Jeśli nie ustawiono tych właściwości, druga jest ignorowana.  
  
 Jeśli nie podano żadnego typu, Menedżer domeny aplikacji jest utworzone na podstawie tego samego typu co nadrzędnej domeny aplikacji (czyli domeny aplikacji, z której <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> wywoływana jest metoda).  
  
 Gdy jest ładowany do domeny aplikacji, <xref:System.TypeLoadException> jest generowany, jeśli zestaw określony przez <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> vlastnost Neobsahuje typ określony przez tę właściwość.  
  
 Aby ustawić Menedżer domeny aplikacji dla domyślnej domeny aplikacji, użyj [ \<appdomainmanagerassembly — >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) i [ \<appdomainmanagertype — >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) elementów w [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcję pliku konfiguracji aplikacji lub użycie zmiennych środowiskowych opisanych w <xref:System.AppDomainManager>.  
  
 Ta funkcja wymaga aplikacja miała pełne zaufanie. (Na przykład aplikację działającą na pulpicie ma pełne zaufanie). Jeśli aplikacja nie ma pełne zaufanie <xref:System.TypeLoadException> zgłaszany.  
  
 Format Pełna nazwa typu jest nadawana przez <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę katalogu zawierającego aplikację.</summary>
        <value>Nazwa podstawowego katalogu aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Katalog podstawowy aplikacji jest, gdy Menedżer zestawów rozpoczyna sondowanie zestawów.  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A> Właściwości mogą mieć wpływ na uprawnienia, które są przyznawane domeny aplikacji. Na przykład domeny aplikacji pochodzące z komputera lokalnego, zazwyczaj otrzymuje pełnego zaufania, na podstawie jego lokalizacji źródła. Jednak jeśli <xref:System.AppDomainSetup.ApplicationBase%2A> właściwość, która <xref:System.AppDomain> jest ustawiona na pełną nazwę katalogu intranet <xref:System.AppDomainSetup.ApplicationBase%2A> ustawienie ogranicza uprawnienia udzielone do domeny aplikacji, do przyznawania LocalIntranet mimo domeny aplikacji rzeczywiście pochodzi z komputera lokalnego.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.AppDomainSetup.ApplicationBase%2A> właściwość do ustawiania lokalizacji, gdzie program ładujący rozpoczyna sondowanie zestawów do załadowania do nowej domeny aplikacji.  
  
> [!NOTE]
>  Należy się upewnić, że istnieje folder, który określisz.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę aplikacji.</summary>
        <value>Nazwa aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić <xref:System.AppDomainSetup.ApplicationName%2A> właściwości podczas tworzenia nowej domeny aplikacji.  
  
 Przykład tworzy nową domenę aplikacji, a następnie wywołuje <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> metodę, aby załadować zestaw przykład do nowej domeny aplikacji i Utwórz wystąpienie obiektu `Worker` klasy. `Worker` Klasa dziedziczy <xref:System.MarshalByRefObject>, dlatego na przykład można użyć serwera proxy zwrócone przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> do wywołania `TestLoad` metody.  
  
 `TestLoad` Metoda ładuje zestaw, który określisz. Należy określić nazwę zestawu prawidłową, w pełni kwalifikowaną, lub komentarz <xref:System.Reflection.Assembly.Load%28System.String%29> metody. `TestLoad` Metoda Wyświetla listę zestawów, które są ładowane do nowej domeny aplikacji, wyświetlane są ładowane z określonego zestawu i zestawu przykładu.  
  
 W przykładzie użyto <xref:System.LoaderOptimizationAttribute> atrybutu, aby poinformować program ładujący, jak aplikacja będzie udostępnianie kodu w różnych domenach aplikacji.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt zawierający bezpieczeństwa i informacje zaufania.</summary>
        <value>Obiekt, który zawiera informacje o zabezpieczeniach i zaufania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest `null` podczas <xref:System.AppDomainSetup> zostanie utworzony. Po zmianie, nie można zresetować odwołanie o wartości null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiona na <see cref="T:System.Security.Policy.ApplicationTrust" /> obiektu, którego tożsamość aplikacji jest niezgodna z tożsamością <see cref="T:System.Runtime.Hosting.ActivationArguments" /> obiektu zwróconego przez <see cref="P:System.AppDomainSetup.ActivationArguments" /> właściwości. Jest zgłaszany żaden wyjątek, jeśli <see cref="P:System.AppDomainSetup.ActivationArguments" /> właściwość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę obszaru określonych aplikacji pliki, w którym znajdują się kopie w tle.</summary>
        <value>W pełni kwalifikowana nazwa katalogu ścieżka i nazwa pliku pliki, w którym znajdują się kopie w tle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ta właściwość ma wpływ <xref:System.AppDomainSetup.ApplicationName%2A> również musi być ustawiona właściwość. Jeśli <xref:System.AppDomainSetup.ApplicationName%2A> nie ustawiono właściwości <xref:System.AppDomainSetup.CachePath%2A> właściwość jest ignorowana, a lokalizację pamięci podręcznej kopię w tle domyślnie pamięci podręcznej pobierania.  
  
 Aby uzyskać więcej informacji dotyczących kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę pliku konfiguracji domeny aplikacji.</summary>
        <value>Nazwa pliku konfiguracji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik konfiguracji w tym artykule opisano reguły wyszukiwania i dane konfiguracji domeny aplikacji. Host, który tworzy domenę aplikacji jest odpowiedzialny za dostarczanie te dane ponieważ istotne wartości różnią się w sytuacji sytuacji.  
  
 Na przykład dla każdej aplikacji, lokacji i komputerze, są przechowywane dane konfiguracji dla aplikacji ASP.NET, podczas przechowywania danych konfiguracji dla pliku wykonywalnego dla każdej aplikacji, użytkowników i komputerów. Tylko hosta wie, szczegółowych danych o konfiguracji dla konkretnej sytuacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Schemat ustawień środowiska uruchomieniowego</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy podstawowa ścieżka aplikacji i ścieżka binarna prywatne są sondowany podczas wyszukiwania dla zestawów do załadowania.</summary>
        <value><see langword="true" /> w przypadku badania jest niedozwolony. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> właściwość `true`, wartość <xref:System.AppDomainSetup.ApplicationBase%2A> właściwość jest ignorowana. Oznacza to, że żadne zestawy nie są sondowany w katalogi określone przez <xref:System.AppDomainSetup.ApplicationBase%2A> właściwości. Ponadto, wartości <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości i <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> właściwości są ignorowane. Żadne zestawy nie są sondowany dla w katalogi określone przez <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości.  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Właściwości zapewnia dodatkową warstwę kontroli nad proces ładowania. W zestawie normalne, podczas ładowania sekwencji, podstawa aplikacji jest sondowany przed <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenie jest wywoływane. Jednak niektóre aplikacje mogą wymagać ładować zestawów z pliku złożonych OLE w dokumencie lub unikatowy znanej lokalizacji, która nie jest ani w globalnej pamięci podręcznej, ani w katalogi określone przez <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości. Takie aplikacje mogą używać <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> właściwości, aby uniknąć opóźnienia spowodowane przez zwykłego sondowania i pozwala uniknąć wczytywania kopie niezbędne zestawu, który może znajdować się w normalnym ścieżkach sondowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy domena aplikacji umożliwia przekierowywania powiązań zestawów.</summary>
        <value><see langword="true" /> Jeśli przekierowanie zestawów jest niedozwolony. <see langword="false" /> Jeśli jest to dozwolone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> Właściwość jest przeznaczone do użytku przez usługi i aplikacje serwera gdzie przekierowanie powiązań zestawów nie jest częścią scenariusza aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy HTTP pobieranie zestawów jest dozwolony dla domeny aplikacji.</summary>
        <value><see langword="true" /> HTTP, który pobiera zestawów jest niedozwolony. <see langword="false" /> Jeśli jest to dozwolone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Właściwość jest przeznaczone do użytku przez usługi i aplikacje serwera gdzie Pobieranie kodu z intranetu lub Internetu nie jest częścią scenariusza aplikacji.  
  
> [!CAUTION]
>  Wartością domyślną dla <xref:System.AppDomainSetup.DisallowCodeDownload%2A> właściwość `false`. To ustawienie jest niebezpieczne dla usług. Aby zapobiec usługi pobierania częściowo zaufany kod, należy ustawić tę właściwość na `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy [ &lt;publisherPolicy&gt; ](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) sekcję pliku konfiguracji jest stosowany do domeny aplikacji.</summary>
        <value><see langword="true" /> Jeśli <see langword="&lt;publisherPolicy&gt;" /> sekcję pliku konfiguracji domeny aplikacji jest ignorowana. <see langword="false" /> Jeśli zasad wydawcy zadeklarowane zostanie uznane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> Właściwość ma zastosowanie konkretnie do aplikacji sieci Web, który jest ładowany lokalnie. Aby zapobiec złośliwe próby wykonania niebezpiecznych aplikacji sieci Web w trybie awaryjnym, należy użyć tej właściwości.  
  
 Aby uzyskać więcej informacji na temat pomijanie zasad wydawcy, zobacz [Redirecting Assembly Versions](~/docs/framework/configure-apps/redirect-assembly-versions.md) tematu. Aby uzyskać więcej informacji na temat trybu awaryjnego, zobacz sekcję "Badanie plików konfiguracji" [jak środowisko uruchomieniowe lokalizuje zestawy](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) tematu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podstawowego katalogu, w którym znajduje się katalog dla dynamicznie generowanych plików.</summary>
        <value>Katalog gdzie <see cref="P:System.AppDomain.DynamicDirectory" /> znajduje się.  

 <block subset="none" type="note"><para>  
 Zwracana wartość tej właściwości jest inna niż wartość przypisana.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Użyj tej właściwości można ustawić podstawowego katalogu, w której zostaną umieszczone dynamiczne katalog dla nowej domeny aplikacji. Gdy kod w nowej domenie aplikacji ładuje zestaw, rozpoznawania zestawu wygląda pierwszy w normalnym ścieżkach sondowania. Jeśli zestaw nie zostanie znaleziona, szuka w katalogu dynamiczne, który jest zwracany przez <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> właściwości. Można umieścić dynamicznych zestawów, które będą ładowane i wykonywane przez nową domenę aplikacji.  
  
 Po przypisaniu ścieżkę do <xref:System.AppDomainSetup.DynamicBase%2A> właściwości dodaniu dodatkowych podkatalogu; nazywa to podkatalogu skrótu wartość przypisana do <xref:System.AppDomainSetup.ApplicationName%2A> właściwości. W związku z tym katalog podstawowy zwrócona przez tę właściwość zawsze różni się od przypisanej wartości.  
  
> [!IMPORTANT]
>  Przypisywanie wartości do tej właściwości nie tworzy żadnych katalogów. Katalogi zostały utworzone lub zweryfikowane przez kod, który korzysta z nich.  
  
 Dynamiczne katalog jest podkatalogiem <xref:System.AppDomainSetup.DynamicBase%2A>. Jego nazwa proste jest wartość zwrócona przez obiekt <xref:System.AppDomainSetup.ApplicationName%2A> właściwości, dzięki czemu jego format jest *oryginalnej ścieżce*\\*skrótu*\\*Nazwa aplikacji*.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.AppDomainSetup.DynamicBase%2A> sondy właściwości, aby ustawić ścieżkę domenę aplikacji, podczas ładowania zestawów dynamicznych.  
  
 W przykładzie jest tworzony <xref:System.AppDomainSetup> i ustawia jego <xref:System.AppDomainSetup.ApplicationName%2A> właściwość "Przykład" i jego <xref:System.AppDomainSetup.DynamicBase%2A> właściwość "C:\DynamicAssemblyDir". Przykład następnie wyświetla <xref:System.AppDomainSetup.DynamicBase%2A> właściwości, aby pokazać, że skrótu nazwę aplikacji ma zostały dołączane jako podkatalogu ścieżki, który pierwotnie został przypisany.  
  
> [!NOTE]
>  Katalog podstawowy, w tym przykładzie jest przeznaczona do przekraczających badania ścieżkę dla przykładowej aplikacji. Pamiętaj skompilować przykład w innej lokalizacji. Usuń katalog podstawowy i jego podkatalogach każdym uruchomieniu tego przykładu.  
  
 Przykład tworzy nową domenę aplikacji, za pomocą <xref:System.AppDomainSetup> obiektu. Ten przykład tworzy następnie dynamiczne katalogu, jeśli jeszcze nie istnieje. Chociaż w przykładzie użyto domeny aplikacji <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> właściwości można odczytać nazwy katalogu dynamicznym go może równie łatwo można utworzyć katalogu wcześniej przez złączenie Oryginalna ścieżka skrótu nazwę aplikacji i Nazwa aplikacji.  
  
 W przykładzie przedstawiono `GenerateDynamicAssembly` metodę, która generuje zestaw o nazwie `DynamicHelloWorld.dll` i zapisuje go w katalogu dynamicznym nowej domeny aplikacji. Zestaw dynamiczny zawiera jeden typ `HelloWorld`, który ma metodę statyczną (`Shared` w języku Visual Basic) o nazwie `HelloFromAD`. Wywołanie tej metody zawiera nazwę domeny aplikacji.  
  
 `Example` Klasa pochodzi od <xref:System.MarshalByRefObject>, dlatego na przykład można utworzyć wystąpienia klasy w nowej domeny aplikacji i wywołanie jego `Test` metody. `Test` Metoda ładuje zestaw dynamiczny poprzez jego nazwę wyświetlaną i wywołuje statyczną `HelloFromAD` metody.  
  
 Możesz pokazać, że dynamiczne katalog jest przeszukiwany po normalne ścieżkach sondowania przez napisanie kodu dla zestawu o nazwie `DynamicHelloWorld.dll` i kompilowanie go w tym samym katalogu co w tym przykładzie. Zestaw musi mieć klasę o nazwie `HelloWorld` ze statyczną metodę o nazwie `HelloFromAD`. Ta metoda musi mieć taką samą funkcjonalność jak w przykładzie; po prostu umożliwia wyświetlanie ciągu w konsoli. Zestaw musi mieć również <xref:System.Reflection.AssemblyVersionAttribute> atrybut, który ustawia jego wersję do numeru 1.0.0.0. Po uruchomieniu tego przykładu, zestawu, który jest skompilowany w bieżącym katalogu znajduje się przed dynamiczne katalog jest przeszukiwany.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Nie można ustawić tę właściwość, ponieważ nazwa aplikacji w domenie aplikacji jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca informacje o konfiguracji XML, które zostały ustawione przez <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> metody, która zastępuje informacje o konfiguracji XML w aplikacji.</summary>
        <returns>Tablica, która zawiera informacje o konfiguracji XML, która została ustawiona przez <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> metody lub <see langword="null" /> Jeśli <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> nie została wywołana metoda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metoda umożliwia zastąpienie informacji o aplikacji, która tworzy nową domenę aplikacji w konfiguracji. Informacje o pliku konfiguracji w `value` przesłania informacji o pliku konfiguracji aplikacji. Na przykład gdy aplikacja Example.exe tworzy nową domenę aplikacji, można zastąpić oryginalnie uzyskiwana z pliku Example.exe.config informacje o konfiguracji.  
  
> [!IMPORTANT]
>  Niektórych klientów informacji o pliku konfiguracji należy używać informacje zapisane przez <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metody. Środowisko wykonawcze nie wymusza to. Aby upewnić się, że wszystkie informacje o konfiguracji pliku zostanie zastąpiona w nowej domenie aplikacji, należy użyć <xref:System.AppDomainSetup.ConfigurationFile%2A> właściwości w celu określenia pliku konfiguracji. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metody mają wpływ na powiązania zestawu.  
  
 Kod XML w `value` jest taki sam jak kod XML w pliku konfiguracji normalne, z tą różnicą, że jest przechowywany jako <xref:System.Byte> tablicy.  
  
 Aby uzyskać dostęp do bajtów konfiguracji domeny aplikacji, należy użyć <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> właściwości do pobrania <xref:System.AppDomainSetup> dla domeny aplikacji obiektu, a następnie użyj <xref:System.AppDomainSetup.GetConfigurationBytes%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia lokalizację pliku licencji skojarzonych z tą domeną.</summary>
        <value>Lokalizacja i nazwa pliku licencji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa zasady optymalizacji można załadować pliku wykonywalnego.</summary>
        <value>Stała wyliczeniowa, który jest używany z <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy zestaw dynamiczny i zapisuje go na dysku, a następnie używa <xref:System.AppDomainSetup.LoaderOptimization%2A> właściwość umożliwiająca ustawienie zasady optymalizacji można załadować zestawu do domeny aplikacji.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia listę zestawów oznaczone <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> flagi, które są one widoczne dla częściowo zaufanemu kodowi uruchomiony w domenie aplikacji w trybie piaskownicy.</summary>
        <value>Tablica nazw zestawów częściowej, gdzie każda część nazwy składa się z nazwy prostego zestawu i klucz publiczny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Security.AllowPartiallyTrustedCallersAttribute> atrybutu (APTCA) może być uzależniony, ustawiając jego <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> właściwość <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>. Zestawie APTCA, która jest oznaczona za pomocą <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> nie może służyć przez częściowo zaufany kod, chyba że nie umożliwia aplikacji hosta.  
  
 Wiele domen aplikacji w trybie piaskownicy umożliwia kodu w domenie aplikacji za pomocą zestawów atrybuty warunkowe APTCA, tworząc tablicę zawierającą prostą nazwę i klucz publiczny dla każdego zestawu i przypisywanie tablicy do tej właściwości. Na przykład element tablicy może wyglądać następująco: "MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9 ".  
  
> [!IMPORTANT]
>  Jeśli używasz podklasą <xref:System.AppDomainManager>i zestawu, który go definiuje zależy od zestawów, które są oznaczone przez atrybut APTCA conditional, należy uwzględnić te zestawy na liście, który jest przekazywany do <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> właściwość <xref:System.AppDomainSetup>służy do tworzenia domen aplikacji. W przeciwnym razie, zestawy, które są oznaczone atrybutem APTCA warunkowego zostaną wyłączone.  
  
> [!NOTE]
>  Podczas debugowania aplikacji, która działa w domenie aplikacji w trybie piaskownicy, niektóre <xref:System.Security.SecurityException> komunikaty mogą być mylące. Na przykład wiadomość może zawierać informację, czy jeden z w pełni zaufane zestawy ma tylko ograniczoną uprawnienia po przyczyny rzeczywistego problemu, że żądanie zabezpieczeń, który przekracza zestaw uprawnień w domenie aplikacji w trybie piaskownicy ma przenoszone na granicy domeny aplikacji w trybie piaskownicy, jak i niepowodzeniem.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia listę katalogów w obszarze katalog podstawowy aplikacji, które są sondowany zestawy prywatne.</summary>
        <value>Lista nazw katalogów, oddzielając je średnikami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy prywatne są wdrażane w tej samej struktury katalogów aplikacji. Jeśli katalogi określone dla <xref:System.AppDomainSetup.PrivateBinPath%2A> nie są w obszarze <xref:System.AppDomainSetup.ApplicationBase%2A>, są ignorowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość ciągu, która obejmuje lub wyklucza <see cref="P:System.AppDomainSetup.ApplicationBase" /> ze ścieżki wyszukiwania dla aplikacji i wyszukiwanie tylko <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) do uwzględnienia ścieżki podstawowej aplikacji podczas wyszukiwania dla zestawów; dowolną wartość ciągu inną niż null, które mają zostać wykluczone ścieżki. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na dowolną wartość ciągu inną niż null, w tym <xref:System.String.Empty?displayProperty=nameWithType> (""), które mają zostać wykluczone ścieżki katalogu aplikacji — oznacza to, <xref:System.AppDomainSetup.ApplicationBase%2A> — od ścieżki wyszukiwania dla aplikacji, a także do przeszukania pod kątem zestawów tylko w <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy buforowanie interfejsu jest wyłączona w przypadku współdziałania wywołuje w domenie aplikacji, tak aby <c>QueryInterface</c> odbywa się przy każdym wywołaniu.</summary>
        <value><see langword="true" /> Jeśli buforowanie interfejsu jest wyłączona w przypadku współdziałania wywołuje w domenach aplikacji utworzonych za pomocą bieżącego <see cref="T:System.AppDomainSetup" /> obiektu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyłączanie buforowania interfejsu ma znaczący wpływ na wydajność wywołań międzyoperacyjnych.  
  
 Ta składowa została wprowadzona w systemie [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">Wyliczalny zestaw wartości ciągów, które określają przełączniki zgodności lub <see langword="null" /> wymazać zgodność istniejących przełączników.</param>
        <summary>Ustawia określoną przełączników, co zgodność z poprzednimi wersjami programu .NET Framework dla określonego problemy z domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Główne wersje programu .NET Framework czasami wprowadzić przełomowe zmiany względem poprzedniej wersji. Na przykład [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] wprowadza niewielką liczbę przełomowe zmiany z [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Użyj <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> metodę, aby określić, że co najmniej jeden z tych zmian niepowodujących należy go z powrotem obniżyć do domeny aplikacji, aby zapewnić zachowanie zgodność z poprzedniej wersji programu .NET Framework.  
  
 Każdorazowo, ta metoda jest wywoływana zastępuje istniejące ustawienia przełącznika. Aby usunąć ustawienia, należy określić `null` dla `switches` parametru.  
  
 Zestaw wartości ciągów, które możesz podać `switches` może być tablicą ciągów proste, ponieważ implementuje tablic <xref:System.Collections.IEnumerable> interfejsu.  
  
 Poniższa tabela zawiera przykłady przełączników zgodności, które można ustawić, aby przywrócić zachowanie wcześniejszych wersji programu .NET Framework.  
  
|Przełącznik|Znaczenie|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Code access security (CAS) dla [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączona w tej domenie aplikacji. See [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Ustawienia domyślne sortowania ciągów [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] są włączone w tej domenie aplikacji. Pomyślnie Przywracanie starsze zachowanie sortowania wymaga również dynamicznie biblioteka sort00001000.dll mają być dostępne w systemie lokalnym. Zobacz [ &lt;CompatSortNLSVersion&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Ustawienia domyślne sortowania ciągów [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] a standard Unicode 5.0 są włączone w tej domenie aplikacji. Pomyślnie Przywracanie starsze zachowanie sortowania wymaga również biblioteki dołączanej dynamicznie sort00060101.dll mają być dostępne w systemie lokalnym.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> Formatowanie zachowanie [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączona w tej domenie aplikacji. Zobacz [ &lt;TimeSpan_LegacyFormatMode&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) sekcji "Przywracanie starszej wersji TimeSpan formatowanie" i <xref:System.TimeSpan> tematu.|  
|"UseRandomizedStringHashAlgorithm"|Środowisko uruchomieniowe oblicza kody skrótów dla ciągów na podstawie domeny aplikacji zamiast pojedynczego algorytmu mieszania, który produkuje spójny kod mieszany w różnych domenach aplikacji. Zobacz [ &lt;userandomizedstringhashalgorithm —&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; Element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;CompatSortNLSVersion&gt; — Element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt; Element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;Userandomizedstringhashalgorithm —&gt; — Element</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica, która zawiera informacje o konfiguracji XML służący do domeny aplikacji.</param>
        <summary>Dostarcza informacje dotyczące domeny aplikacji, zastępując informacje o konfiguracji XML aplikacji w konfiguracji XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metoda zapewnia sposób Zastąp informacje o konfiguracji aplikacji, która tworzy nową domenę aplikacji. Informacje o pliku konfiguracji w `value` zastępuje informacje o pliku konfiguracji aplikacji. Na przykład gdy aplikacja Example.exe tworzy nową domenę aplikacji, można zastąpić oryginalnie uzyskiwana z pliku Example.exe.config informacje o konfiguracji.  
  
> [!IMPORTANT]
>  Niektórych klientów informacji o pliku konfiguracji należy używać informacje zapisane przez <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metody. Środowisko wykonawcze nie wymusza to. Aby upewnić się, że wszystkie informacje w pliku konfiguracji jest zastępowana w nowej domenie aplikacji, należy użyć <xref:System.AppDomainSetup.ConfigurationFile%2A> właściwości w celu określenia pliku konfiguracji. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metody mają wpływ na powiązania zestawu.  
  
 Kod XML w `value` jest taki sam jak kod XML w pliku konfiguracji normalne, z tą różnicą, że jest przechowywany jako <xref:System.Byte> tablicy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Schemat ustawień środowiska uruchomieniowego</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">Nazwa funkcji porównywania ciągów do zastąpienia.</param>
        <param name="functionVersion">Wersja funkcji. Aby uzyskać [!INCLUDE[net_v45](~/includes/net-v45-md.md)], jego wartość musi być mniejsze niż 1.</param>
        <param name="functionPointer">Wskaźnik do funkcji, która zastępuje <paramref name="functionName" />.</param>
        <summary>Zapewnia środowisko uruchomieniowe języka wspólnego alternatywnej implementacji funkcją porównywania ciągów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujące porównywania ciągów i sortowania metod, które mogą być zastąpione przez <xref:System.AppDomainSetup.SetNativeFunction%2A> metody:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Aby uzyskać informacje na temat tych funkcji, zobacz [National funkcji obsługi języka](https://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="functionName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="functionVersion" /> jest mniejsze niż 1.  
  
—lub— 
 <paramref name="functionPointer" /> jest <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwy katalogów, zawierającego zestawy do kopie w tle woluminów.</summary>
        <value>Lista nazw katalogów, oddzielając je średnikami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas kopiowania w tle jest włączona, domyślnie są wszystkie zestawy można ich odnaleźć poprzez badania; kopii w tle oznacza to, że w katalogi określone przez <xref:System.AppDomainSetup.PrivateBinPath%2A> i <xref:System.AppDomainSetup.ApplicationBase%2A> właściwości. <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> Właściwość ogranicza kopii w tle do zestawów w katalogi określone przez <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.  
  
 Jeśli nie przypiszesz ciąg <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> właściwości, lub jeśli ta właściwość jest ustawiona na `null`, wszystkie zestawy w katalogi określone przez <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości są kopie w tle.  
  
> [!IMPORTANT]
>  Ścieżek katalogów nie mogą zawierać średnikami, ponieważ znajduje się znak ogranicznika. Nie ma żadnych znak ucieczki dla średnikami.  
  
 Podczas kopiowania w tle jest włączone, pliki zestawu są kopiowane do innej lokalizacji przed zestawy są ładowane. Oryginalny plik zestawu nie jest zablokowany, dzięki czemu mogą być aktualizowane. Aby uzyskać więcej informacji dotyczących kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg, który wskazuje, czy kopiowanie w tle jest włączony lub wyłączony.</summary>
        <value>Wartość ciągu "true", aby wskazać, że kopiowania w tle jest włączona; lub "false", aby wskazać, że kopiowania w tle funkcja jest wyłączona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji dotyczących kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg, który określa wersja docelowa i profilu programu .NET Framework dla domeny aplikacji w formacie, który może być analizowane przez <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> konstruktora.</summary>
        <value>Wersja docelowa i profilu platformy .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość w bieżącej wersji programu .NET Framework stwierdzić, że domeny aplikacji będzie służyć do załadowania i uruchomienia zestawów, które zostały skompilowane dla wersji docelowej i profilu. Jeśli aktualnie uruchomionej wersji .NET Framework zawiera opcjonalne zachowania, które wpływają na zgodność kodu, który został skompilowany przy użyciu wersji docelowej, jej można włączać lub wyłączać tych zachowań, zgodnie z potrzebami zwiększyć zgodność. Może to być przydatne, gdy aplikacja obsługuje dodatków skompilowany przy użyciu wielu wersji programu .NET Framework, uruchamiając je w domenach oddzielną aplikację.  
  
 Dla aplikacji klienckich, wartość <xref:System.AppDomainSetup.TargetFrameworkName%2A> właściwość jest wnioskowany z <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atrybutu. W [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] a później, ten atrybut jest dodawany do zestawu automatycznie na podstawie ustawienia projektu **platformę docelową** właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b01f805ef110c375925a5ca5ffbb351875c265af" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36433363" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje informacje o powiązaniu zestawu do dodania do wystąpienia <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmiana właściwości <xref:System.AppDomainSetup> wystąpienia nie wpływa na istniejące <xref:System.AppDomain>. Może mieć wpływ na tworzenie nowej <xref:System.AppDomain>, gdy <xref:System.AppDomain.CreateDomain%2A> metoda jest wywoływana z <xref:System.AppDomainSetup> wystąpienia jako parametr.  
  
 Ta klasa implementuje <xref:System.IAppDomainSetup> interfejsu.  
  
> [!CAUTION]
>  Wartość domyślna dla <xref:System.AppDomainSetup.DisallowCodeDownload%2A> właściwość ma wartość false. To ustawienie jest niebezpieczne dla usług. Aby zapobiec usług pobierania częściowo zaufany kod, należy ustawić tę właściwość na wartość true  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Kontekst aktywacji używanego do domeny aplikacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy z kontekstem określony na potrzeby aktywacji opartej na manifest domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ActivationContext> Określony dla obiekt `activationContext` służy do generowania <xref:System.Runtime.Hosting.ActivationArguments> obiekt zawierający informacje wymagane do aktywowania nowej domeny aplikacji. To <xref:System.Runtime.Hosting.ActivationArguments> obiektu jest możliwy za pomocą <xref:System.AppDomainSetup.ActivationArguments%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationContext" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Obiekt, który określa informacje wymagane do przeprowadzenia aktywacji opartej na manifest nowej domeny aplikacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy z argumentami określone uaktywnianie wymagane do aktywacji opartej na manifest domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określony dla obiekt `activationArguments` jest możliwy za pomocą <xref:System.AppDomainSetup.ActivationArguments%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationArguments" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dane o aktywacji domeny aplikacji.</summary>
        <value>Obiekt zawierający dane dotyczące aktywacji domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żaden wyjątek jest zgłaszany, jeśli ta właściwość jest ustawiona na `null`.  
  
 Informacje dostarczane przez <xref:System.Runtime.Hosting.ActivationArguments> obiekt obsługuje aktywację w oparciu o manifeście.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiona na <see cref="T:System.Runtime.Hosting.ActivationArguments" /> obiektu, którego tożsamość aplikacji jest niezgodna z tożsamością <see cref="T:System.Security.Policy.ApplicationTrust" /> obiektu zwróconego przez <see cref="P:System.AppDomainSetup.ApplicationTrust" /> właściwości. Żaden wyjątek jest zgłaszany, jeśli <see cref="P:System.AppDomainSetup.ApplicationTrust" /> jest właściwość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.AppDomainInitializer" /> delegata, który reprezentuje metody wywołania zwrotnego, które jest wywoływane, gdy domena aplikacji została zainicjowana.</summary>
        <value>Delegat, który reprezentuje metodę wywołania zwrotnego, które jest wywoływane, gdy domena aplikacji została zainicjowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do przekazywania informacji do metody wywołania zwrotnego, przypisywania tablicą ciągów <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> właściwości. Tablica jest przekazywany do metody wywołania zwrotnego zawsze <xref:System.AppDomain> został zainicjowany.  
  
 Metoda wywołania zwrotnego jest wykonywany w kontekście domeny nowo utworzonej aplikacji.  
  
   
  
## Examples  
 Poniższy przykład tworzy domenę aplikacji podrzędną o nazwie `ChildDomain`za pomocą <xref:System.AppDomainSetup> obiekt i dowód od domyślnej domeny aplikacji. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Właściwość jest ustawiona na metodę wywołania zwrotnego `AppDomainInit`, która jest wywoływana po zainicjowaniu domeny podrzędnej. Argumenty dla metody wywołania zwrotnego są umieszczane w tablicy ciągów, które jest przypisane do <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> właściwości. Podczas tworzenia domeny podrzędnej, metody wywołania zwrotnego po prostu drukuje ciągi.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia Argumenty przekazane do metody wywołania zwrotnego reprezentowany przez <see cref="T:System.AppDomainInitializer" /> delegowanie. Metoda wywołania zwrotnego jest wywoływane, gdy domena aplikacji została zainicjowana.</summary>
        <value>Tablica ciągów jest przekazywany do metody wywołania zwrotnego reprezentowany przez <see cref="T:System.AppDomainInitializer" /> delegata, po wywołaniu metody wywołania zwrotnego podczas <see cref="T:System.AppDomain" /> inicjowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.AppDomainSetup.AppDomainInitializer%2A> właściwości w celu określenia metody wywołania zwrotnego, które jest wywoływane podczas <xref:System.AppDomain> inicjowania. Jeśli <xref:System.AppDomainSetup.AppDomainInitializer%2A> nie ustawiono właściwości, przypisane do tej właściwości tablicy nie jest używany.  
  
 Metoda wywołania zwrotnego jest wykonywany w kontekście domeny nowo utworzonej aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy domenę aplikacji podrzędną o nazwie `ChildDomain`za pomocą <xref:System.AppDomainSetup> obiekt i dowód od domyślnej domeny aplikacji. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Właściwość jest ustawiona na metodę wywołania zwrotnego `AppDomainInit`, która jest wywoływana po zainicjowaniu domeny podrzędnej. Argumenty dla metody wywołania zwrotnego są umieszczane w tablicy ciągów, które jest przypisane do <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> właściwości. Podczas tworzenia domeny podrzędnej, metody wywołania zwrotnego po prostu drukuje ciągi.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wyświetlaną nazwę zestawu, który zawiera typ Menedżer domeny aplikacji domen aplikacji utworzony za pomocą tej <see cref="T:System.AppDomainSetup" /> obiektu.</summary>
        <value>Wyświetlana nazwa zestawu, który zawiera <see cref="T:System.Type" /> Menedżera domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić typ Menedżer domeny aplikacji, należy ustawić właściwość ta i <xref:System.AppDomainSetup.AppDomainManagerType%2A> właściwości. Jeśli nie ustawiono tych właściwości, druga jest ignorowana.  
  
 Jeśli żaden typ nie zostanie podany, Menedżer domeny aplikacji jest tworzona na podstawie tego samego typu co domeny nadrzędnej aplikacji (czyli domeny aplikacji z którego <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> metoda jest wywoływana).  
  
 Po załadowaniu domeny aplikacji <xref:System.TypeLoadException> jest generowany, jeśli zestaw nie istnieje lub zestaw nie zawiera typu określonego przez <xref:System.AppDomainSetup.AppDomainManagerType%2A> właściwości. <xref:System.IO.FileLoadException> jest generowany, jeśli zostanie znaleziony w zestawie, ale informacje o wersji jest niezgodny.  
  
 Aby ustawić Menedżer domeny aplikacji dla domyślnej domeny aplikacji, użyj [ \<appdomainmanagerassembly — >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) i [ \<appdomainmanagertype — >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) elementów w [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcję pliku konfiguracji aplikacji lub użycie zmiennych środowiskowych opisanych w <xref:System.AppDomainManager>.  
  
 Ta funkcja wymaga aplikacja miała pełne zaufanie. (Na przykład aplikacja uruchomiona na komputerze ma pełnego zaufania). Jeśli aplikacja jest w pełni zaufany <xref:System.TypeLoadException> jest generowany.  
  
 Format nazwy wyświetlanej zestawu jest określany przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pełną nazwę typu, który zapewnia Menedżer domeny aplikacji utworzony za pomocą tej domeny aplikacji <see cref="T:System.AppDomainSetup" /> obiektu.</summary>
        <value>Pełna nazwa typu, łącznie z przestrzenią nazw.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić typ Menedżer domeny aplikacji, należy ustawić właściwość ta i <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> właściwości. Jeśli nie ustawiono tych właściwości, druga jest ignorowana.  
  
 Jeśli żaden typ nie zostanie podany, Menedżer domeny aplikacji jest tworzona na podstawie tego samego typu co domeny nadrzędnej aplikacji (czyli domeny aplikacji z którego <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> metoda jest wywoływana).  
  
 Po załadowaniu domeny aplikacji <xref:System.TypeLoadException> jest generowany, jeśli określony zestaw przez <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> właściwość nie zawiera typu określonej przez tę właściwość.  
  
 Aby ustawić Menedżer domeny aplikacji dla domyślnej domeny aplikacji, użyj [ \<appdomainmanagerassembly — >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) i [ \<appdomainmanagertype — >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) elementów w [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcję pliku konfiguracji aplikacji lub użycie zmiennych środowiskowych opisanych w <xref:System.AppDomainManager>.  
  
 Ta funkcja wymaga aplikacja miała pełne zaufanie. (Na przykład aplikacja uruchomiona na komputerze ma pełnego zaufania). Jeśli aplikacja jest w pełni zaufany <xref:System.TypeLoadException> jest generowany.  
  
 Format Pełna nazwa typu jest określany przez <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę katalog zawierający aplikację.</summary>
        <value>Nazwa podstawowego katalogu aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowego katalogu aplikacji jest, gdzie Menedżer zestawów rozpoczyna się sondowanie dla zestawów.  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A> Właściwości mogą mieć wpływ, które uprawnienia są przyznawane domeny aplikacji. Na przykład domeny aplikacji pochodzące z komputera lokalnego zazwyczaj otrzymuje pełnego zaufania, na podstawie jej lokalizacji źródła. Jednak jeśli <xref:System.AppDomainSetup.ApplicationBase%2A> właściwości tego <xref:System.AppDomain> ustawiono pełną nazwę katalogu intranet <xref:System.AppDomainSetup.ApplicationBase%2A> ustawienie ogranicza uprawnienia przyznane do domeny aplikacji, aby LocalIntranet grant mimo że domeny aplikacji faktycznie pochodzi z komputera lokalnego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.AppDomainSetup.ApplicationBase%2A> właściwość do ustawiania lokalizacji, w którym program ładujący zestawu rozpoczyna się sondowanie dla zestawów załadować do nowej domeny aplikacji.  
  
> [!NOTE]
>  Należy się upewnić, że istnieje folder, który określisz.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę aplikacji.</summary>
        <value>Nazwa aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób ustawiania <xref:System.AppDomainSetup.ApplicationName%2A> właściwości podczas tworzenia nowej domeny aplikacji.  
  
 Przykład tworzy nową domenę aplikacji, a następnie wywołuje <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> metodę, aby załadować zestawu przykład do nowej domeny aplikacji i Utwórz wystąpienie `Worker` klasy. `Worker` Klasa dziedziczy <xref:System.MarshalByRefObject>, więc przykładu można użyć zwrócony przez serwer proxy <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> do wywołania `TestLoad` metody.  
  
 `TestLoad` Metody ładuje zestaw, który określisz. Należy określić nazwę zestawu prawidłową, w pełni kwalifikowana, lub komentarz <xref:System.Reflection.Assembly.Load%28System.String%29> metody. `TestLoad` Metoda Wyświetla listę zestawów załadowanych do nowej domeny aplikacji wyświetlane są ładowane z określonego zestawu i zestawu przykład.  
  
 W przykładzie użyto <xref:System.LoaderOptimizationAttribute> atrybutu, sprawdzić modułu ładującego zestawu, jak aplikacja udostępnianie kodu w domenach aplikacji.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt zawierający zabezpieczeń i poufnych informacji.</summary>
        <value>Obiekt zawierający informacje o bezpieczeństwie i zaufania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest `null` podczas <xref:System.AppDomainSetup> jest tworzony. Po zmianie, nie można zresetować odwołanie o wartości null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiona na <see cref="T:System.Security.Policy.ApplicationTrust" /> obiektu, którego tożsamość aplikacji jest niezgodna z tożsamością <see cref="T:System.Runtime.Hosting.ActivationArguments" /> obiektu zwróconego przez <see cref="P:System.AppDomainSetup.ActivationArguments" /> właściwości. Żaden wyjątek jest zgłaszany, jeśli <see cref="P:System.AppDomainSetup.ActivationArguments" /> jest właściwość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę obszaru określonych aplikacji pliki, w którym znajdują się kopie w tle.</summary>
        <value>Pełna nazwa katalogu ścieżka i nazwa pliku pliki, w którym znajdują się kopie w tle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ta właściwość ma wpływ <xref:System.AppDomainSetup.ApplicationName%2A> również musi być ustawiona właściwość. Jeśli <xref:System.AppDomainSetup.ApplicationName%2A> nie ustawiono właściwości <xref:System.AppDomainSetup.CachePath%2A> właściwość jest ignorowana i lokalizację pamięci podręcznej kopii w tle domyślnie ustawiany na pamięć podręczną pobierania.  
  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę pliku konfiguracyjnego dla domeny aplikacji.</summary>
        <value>Nazwa pliku konfiguracji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik konfiguracji opisano reguły wyszukiwania i dane konfiguracji domeny aplikacji. Hosta, który tworzy domeny aplikacji jest odpowiedzialny za dostarczanie tych danych, ponieważ istotnych wartości różnią się od sytuacji sytuacji.  
  
 Na przykład dane konfiguracyjne dla aplikacji ASP.NET jest przechowywane dla każdej aplikacji, lokacji i komputerze, podczas przechowywania danych konfiguracji do pliku wykonywalnego dla każdej aplikacji, użytkownika i komputera. Szczegółowe informacje na temat danych konfiguracji dla określonego okoliczności wie, tylko hosta.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy aplikacja ścieżki podstawowej i prywatnych ścieżka binarna sondowania podczas wyszukiwania zestawów do załadowania.</summary>
        <value>
          <see langword="true" /> Jeśli sondowanie jest niedozwolony. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> właściwość jest `true`, wartość <xref:System.AppDomainSetup.ApplicationBase%2A> właściwość jest ignorowana. Oznacza to, że żadnych zestawów są sondowany w katalogach określonych przez <xref:System.AppDomainSetup.ApplicationBase%2A> właściwości. Ponadto wartości <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości i <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> właściwości są ignorowane. Zestawy nie są sondowany dla w określonym przez <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości.  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Właściwość zapewnia dodatkową warstwę kontroli nad procesem ładowania. W zestawie normalne ładowania sekwencji baza aplikacji jest sondowany przed <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenia. Jednak niektóre aplikacje może być konieczne ładować zestawów z pliku złożonego OLE w dokumencie lub unikatowy znane lokalizacji w pamięci podręcznej GAC ani w katalogach określonych przez <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości. Takie aplikacje mogą używać <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> właściwości, aby uniknąć opóźnienia spowodowane przez zwykłego sondowania i uniknąć obciążania kopie niezbędne zestawu, który może być dostępna w zwykłych sondowania ścieżek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy domena aplikacji umożliwia przekierowywania powiązań zestawów.</summary>
        <value>
          <see langword="true" /> Jeśli przekierowanie zestawów jest niedozwolony. <see langword="false" /> czy jest dozwolony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> Właściwości jest przeznaczony do użytku przez usługi i aplikacje serwera gdzie przekierowanie powiązań zestawów nie jest częścią scenariusza aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pobieranie zestawów przy HTTP jest dozwolony dla domeny aplikacji.</summary>
        <value>
          <see langword="true" /> Jeśli HTTP pobrać zestawów jest niedozwolony. <see langword="false" /> czy jest dozwolony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Właściwości jest przeznaczony do użytku przez usługi i aplikacje serwera gdy pobieranie kod z intranetu lub Internetu nie jest częścią scenariusza aplikacji.  
  
> [!CAUTION]
>  Wartość domyślna dla <xref:System.AppDomainSetup.DisallowCodeDownload%2A> jest właściwość `false`. To ustawienie jest niebezpieczne dla usług. Aby zapobiec usług pobierania częściowo zaufany kod, należy ustawić tę właściwość na `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) sekcji pliku konfiguracji jest stosowany do domeny aplikacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see langword="&lt;publisherPolicy&gt;" /> sekcji pliku konfiguracji dla domeny aplikacji jest ignorowana. <see langword="false" /> Jeśli zasad wydawcy zadeklarowane jest przestrzegana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> Właściwość w szczególności dotyczy aplikacji sieci Web, który jest ładowany lokalnie. Tej właściwości należy użyć, aby zapobiec złośliwego próba wykonania niebezpiecznych aplikacji sieci Web w trybie awaryjnym.  
  
 Aby uzyskać więcej informacji na temat obchodzenia zasad wydawcy, zobacz [przekierowywanie wersji zestawu](~/docs/framework/configure-apps/redirect-assembly-versions.md) tematu. Aby uzyskać więcej informacji dotyczących trybu awaryjnego, zobacz sekcję "Badanie pliki konfiguracji" [jak zestawy środowiska wykonawczego lokalizuje](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) tematu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podstawowego katalogu, w którym znajduje się katalog dla plików dynamicznie generowanym.</summary>
        <value>Katalog gdzie <see cref="P:System.AppDomain.DynamicDirectory" /> znajduje się.  
 <block subset="none" type="note"><para> Zwracane wartości tej właściwości różni się od przypisanej wartości. </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Użyj tej właściwości można ustawić katalogu podstawowego, w której zostaną umieszczone na dynamiczne katalog dla nowej domeny aplikacji. Załadowanie kod w nowej domenie aplikacji zestawu, rozpoznawania zestawu wygląda pierwszy w zwykłych sondowania ścieżek. Jeśli nie zostanie znaleziona w zestawie, wygląda w katalogu dynamicznych, który jest zwracany przez <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> właściwości. Można umieścić zestawów dynamicznych, które zostanie załadowana i wykonywane przez nową domenę aplikacji.  
  
 Po przypisaniu ścieżki do <xref:System.AppDomainSetup.DynamicBase%2A> właściwości, dodaniu dodatkowych podkatalogu; nazwa tego podkatalogu jest wartość skrótu wartość przypisana do <xref:System.AppDomainSetup.ApplicationName%2A> właściwości. W związku z tym podstawowego katalogu zwrócona przez tę właściwość zawsze różni się od przypisanej wartości.  
  
> [!IMPORTANT]
>  Przypisywanie wartości do tej właściwości nie tworzy żadnych katalogów. Zostały utworzone lub zweryfikowane przez kod, który używa tych katalogów.  
  
 Dynamiczne katalog jest podkatalogiem katalogu <xref:System.AppDomainSetup.DynamicBase%2A>. Jego prostą nazwą jest wartość zwrócona przez <xref:System.AppDomainSetup.ApplicationName%2A> właściwości, więc jego format jest *oryginalnej ścieżce*\\*skrótu*\\*Nazwa aplikacji*.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.AppDomainSetup.DynamicBase%2A> sondy właściwości, aby ustawić ścieżkę domeny aplikacji podczas ładowania zestawów dynamicznych.  
  
 W przykładzie jest tworzony <xref:System.AppDomainSetup> obiekt i ustawia jej <xref:System.AppDomainSetup.ApplicationName%2A> dla właściwości "Example" i jego <xref:System.AppDomainSetup.DynamicBase%2A> dla właściwości "C:\DynamicAssemblyDir". W przykładzie następnie przedstawiono <xref:System.AppDomainSetup.DynamicBase%2A> właściwości, aby pokazać, że skrótu nazwy aplikacji zostały dołączone jako podkatalogu ścieżki, która pierwotnie była przypisana.  
  
> [!NOTE]
>  Podstawowego katalogu, w tym przykładzie jest przeznaczony na zewnątrz ścieżki próbkowania dla przykładowej aplikacji. Należy się upewnić, że w przykładzie w innej lokalizacji. Usuń podstawowego katalogu i jego podkatalogach zawsze należy uruchomić przykład.  
  
 W przykładzie jest tworzony nowy domeny aplikacji, przy użyciu <xref:System.AppDomainSetup> obiektu. Przykład następnie tworzy dynamiczne katalogu, jeśli jeszcze nie istnieje. Mimo że w przykładzie użyto domeny aplikacji <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> właściwości nazwy katalogu dynamicznej można równie łatwo utworzyć katalog wcześniej przez łączenie w oryginalnej ścieżce skrótu nazwę aplikacji i Nazwa aplikacji.  
  
 W przykładzie przedstawiono `GenerateDynamicAssembly` metodę, która emituje zestawu o nazwie `DynamicHelloWorld.dll` i zapisuje go w katalogu dynamicznym nowej domeny aplikacji. Zestaw dynamiczny zawiera jeden typ `HelloWorld`, która ma statycznej metody (`Shared` metody w języku Visual Basic) o nazwie `HelloFromAD`. Wywołanie tej metody Wyświetla nazwę domeny aplikacji.  
  
 `Example` Pochodną klasy <xref:System.MarshalByRefObject>, więc przykładzie można utworzyć wystąpienia klasy w nowej domenie aplikacji i wywołanie jego `Test` metody. `Test` Metody ładuje według jego nazwy wyświetlanej zestawu dynamicznego i wywołuje statycznych `HelloFromAD` metody.  
  
 Można wyświetlić, że dynamiczne katalogu przeszukuje po zwykłych sondowania ścieżek pisanie kodu dla zestawu o nazwie `DynamicHelloWorld.dll` i kompilowanie go w tym samym katalogu co w tym przykładzie. Zestaw musi mieć klasę o nazwie `HelloWorld` za pomocą metody statycznej o nazwie `HelloFromAD`. Ta metoda muszą mieć te same funkcje co w przykładzie; po prostu umożliwia wyświetlanie ciąg do konsoli. Zestaw musi mieć również <xref:System.Reflection.AssemblyVersionAttribute> atrybut, który ustawia swoją wersję 1.0.0.0. Po uruchomieniu przykładzie zestawu, w którym skompilowany w bieżącym katalogu znajduje się przed dynamiczne katalogu jest przeszukiwany.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Nie można ustawić tej właściwości, ponieważ nazwa aplikacji w domenie aplikacji jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca informacje o konfiguracji XML, które zostały ustawione przez <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> metodę, która zastępuje informacje o konfiguracji XML aplikacji.</summary>
        <returns>Tablica zawierająca informacje o konfiguracji XML, która została ustawiona przez <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> metody, lub <see langword="null" /> Jeśli <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> nie zostanie wywołana metoda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metoda pozwala zastąpić informacje o konfiguracji aplikacji, która tworzy nową domenę aplikacji. Informacje o pliku konfiguracji w `value` zastępuje informacje o pliku konfiguracji aplikacji. Na przykład gdy aplikacja Example.exe tworzy nową domenę aplikacji, można zastąpić informacje o konfiguracji, które pierwotnie uzyskiwane z pliku Example.exe.config.  
  
> [!IMPORTANT]
>  Niektóre konsumentów informacji o pliku konfiguracji należy używać informacje przechowywane w <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metody. Środowisko uruchomieniowe nie obsługuje wymuszania to. Aby upewnić się, że wszystkie informacje o konfiguracji pliku zostanie zastąpiona w nowej domenie aplikacji, należy użyć <xref:System.AppDomainSetup.ConfigurationFile%2A> właściwości, aby określić plik konfiguracji. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> — Metoda ma wpływu na powiązań zestawów.  
  
 Kod XML w `value` jest taka sama jak kodu XML w pliku konfiguracji normalne, z wyjątkiem tego, że są przechowywane jako <xref:System.Byte> tablicy.  
  
 Aby uzyskać dostęp do bajtów konfiguracji dla domeny aplikacji, należy użyć <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> właściwości do pobrania <xref:System.AppDomainSetup> obiektu domeny aplikacji, a następnie użyj <xref:System.AppDomainSetup.GetConfigurationBytes%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia lokalizację pliku licencji skojarzone z tą domeną.</summary>
        <value>Lokalizacja i nazwa pliku licencji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa zasady optymalizacji można załadować pliku wykonywalnego.</summary>
        <value>Wyliczany stała, który jest używany z <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy zestawie dynamicznym i zapisuje go na dysku, a następnie używa <xref:System.AppDomainSetup.LoaderOptimization%2A> właściwości można ustawić zasady Optymalizacja ładowania zestawu do domeny aplikacji.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia listę zestawów oznaczonych <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> flagi, które są widoczne kod częściowego zaufania działający w domenie aplikacji piaskownicy.</summary>
        <value>Tablica nazw zestawów częściowe, gdzie każda część nazwy składa się z nazwy prostego zestawu i klucz publiczny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Security.AllowPartiallyTrustedCallersAttribute> atrybutu (APTCA) może się warunkowe przez ustawienie jej <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> właściwości <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>. Zestaw APTCA, który jest oznaczony atrybutem <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> nie można użyć przez kod częściowo zaufany, chyba że pozwala aplikacji hosta.  
  
 Host domenie aplikacji piaskownicy umożliwia kodu w domenie aplikacji używanie zestawów o atrybuty warunkowe APTCA, tworząc tablicę zawierającą prostą nazwą, a klucz publiczny każdego zestawu i przypisywanie tablicy do tej właściwości. Na przykład element tablicy może wyglądać następująco: "MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9 ".  
  
> [!IMPORTANT]
>  Jeśli używasz podklasą <xref:System.AppDomainManager>i zestawy, które są oznaczone atrybutem APTCA warunkowego zależy od zestawu, który definiuje ona, musi zawierać te zestawy są przekazywane do listy <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> właściwości <xref:System.AppDomainSetup>służy do tworzenia domeny aplikacji. W przeciwnym razie zostanie wyłączone zestawy, które są oznaczone atrybutem APTCA warunkowego.  
  
> [!NOTE]
>  Podczas debugowania aplikacji, która działa w domenie aplikacji piaskownicy niektóre <xref:System.Security.SecurityException> komunikaty mogą być mylące. Na przykład komunikat może zawierać informację, że jedną z całkowicie zaufanych zestawów ma tylko ograniczoną uprawnienia, gdy rzeczywistą przyczyną problemu jest czy żądania zabezpieczeń większy zestaw grant domenie aplikacji piaskownicy ma propagowane do granicy domeny aplikacji w trybie piaskownicy, a nie powiodło się.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia listę katalogi w ramach podstawowego katalogu aplikacji, które są sondowany zestawy prywatne.</summary>
        <value>Lista nazw katalogów, oddzielając je średnikami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy prywatne są wdrażane w tej samej struktury katalogów, co aplikacja. Jeśli katalogi określone dla <xref:System.AppDomainSetup.PrivateBinPath%2A> nie są w obszarze <xref:System.AppDomainSetup.ApplicationBase%2A>, są ignorowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość ciągu, która obejmuje lub wyklucza <see cref="P:System.AppDomainSetup.ApplicationBase" /> ze ścieżki wyszukiwania dla aplikacji, a wyszukiwanie tylko <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) do uwzględnienia podstawowa ścieżka aplikacji podczas wyszukiwania zestawów; dowolną wartością ciągu inną niż null, aby wykluczyć ścieżkę. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawić tę właściwość na dowolną wartość ciągu inną niż null, w tym <xref:System.String.Empty?displayProperty=nameWithType> (""), aby wykluczyć ścieżkę katalogu aplikacji — to znaczy <xref:System.AppDomainSetup.ApplicationBase%2A> — ze ścieżki wyszukiwania dla aplikacji, a także do wyszukiwania zestawów tylko w <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy interfejs jest wyłączone buforowanie dla międzyoperacyjności wywołuje w domenie aplikacji, dzięki czemu <c>QueryInterface</c> jest wykonywane przy każdym wywołaniu.</summary>
        <value>
          <see langword="true" /> Jeśli interfejs jest wyłączone buforowanie dla międzyoperacyjności wywołuje w domenach aplikacji utworzonych za pomocą bieżącego <see cref="T:System.AppDomainSetup" /> obiektu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyłączanie buforowania interfejs ma znaczący wpływ na wydajność międzyoperacyjnego wywołań.  
  
 Ten element członkowski jest wprowadzony w [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">Wyliczalny zestaw wartości ciągu, które określają przełączniki zgodności lub <see langword="null" /> przełącza się na usunięcie istniejącej zgodności.</param>
        <summary>Ustawia określony przełączników, Tworzenie domeny aplikacji zgodność z poprzednimi wersjami programu .NET Framework dla określonych problemów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Główne wersje programu .NET Framework czasami wprowadzenia zmian, które psuły z poprzedniej wersji. Na przykład [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] wprowadza niewielkiej liczby zmian, które psuły z [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Użyj <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> metodę, aby określić, że co najmniej jeden z tych zmian, które psuły konieczność wycofania dla domeny aplikacji, aby zapewnić zachowanie zgodność z poprzedniej wersji programu .NET Framework.  
  
 Każdym wywołaniu tej metody, zastępuje on istniejące ustawienia przełącznika. Aby usunąć ustawienia, należy określić `null` dla `switches` parametru.  
  
 Zbiór wartości ciągu, należy przewidzieć `switches` może być tablicą prostego ciągu, ponieważ implementuje tablice <xref:System.Collections.IEnumerable> interfejsu.  
  
 Poniższa tabela zawiera przykłady przełączniki zgodności, które można ustawić, aby przywrócić zachowanie wcześniejszych wersji programu .NET Framework.  
  
|Przełącznik|Znaczenie|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Kod zabezpieczeń dostępu (CAS) [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączona w tej domenie aplikacji. Zobacz [ &lt;NetFx40_LegacySecurityPolicy&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Ciąg sortowania wartości domyślne dla [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] są włączone w tej domenie aplikacji. Pomyślnie przywracania starszej wersji sortowania wymaga także biblioteki dołączanej dynamicznie sort00001000.dll mają być dostępne w systemie lokalnym. Zobacz [ &lt;compatsortnlsversion —&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Ciąg sortowania wartości domyślne dla [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] i Unicode 5.0 są włączone w tej domenie aplikacji. Pomyślnie przywracania starszej wersji sortowania wymaga także biblioteki dołączanej dynamicznie sort00060101.dll mają być dostępne w systemie lokalnym.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> Formatowanie zachowanie [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączona w tej domenie aplikacji. Zobacz [ &lt;timespan_legacyformatmode —&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) sekcji "Przywracanie starszych TimeSpan formatowanie" i <xref:System.TimeSpan> tematu.|  
|"UseRandomizedStringHashAlgorithm"|Środowisko uruchomieniowe oblicza skrótu dla ciągów na poszczególnych domen aplikacji zamiast przy użyciu pojedynczego algorytmu wyznaczania wartości skrótu, który tworzy spójne skrótu w domenach aplikacji. Zobacz [ &lt;userandomizedstringhashalgorithm —&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica, która zawiera informacje o konfiguracji XML do użycia dla domeny aplikacji.</param>
        <summary>Dostarcza informacje dotyczące domeny aplikacji, zastępując informacje o konfiguracji XML aplikacji konfiguracji XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metoda pozwala zastąpić informacje o konfiguracji aplikacji, która tworzy nową domenę aplikacji. Informacje o pliku konfiguracji w `value` zastępuje informacje o pliku konfiguracji aplikacji. Na przykład gdy aplikacja Example.exe tworzy nową domenę aplikacji, można zastąpić informacje o konfiguracji, które pierwotnie uzyskane z pliku Example.exe.config.  
  
> [!IMPORTANT]
>  Niektóre konsumentów informacji o pliku konfiguracji należy używać informacje przechowywane w <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metody. Środowisko uruchomieniowe nie obsługuje wymuszania to. Aby upewnić się, że wszystkie informacje w pliku konfiguracji jest zastępowana w nowej domenie aplikacji, należy użyć <xref:System.AppDomainSetup.ConfigurationFile%2A> właściwości, aby określić plik konfiguracji. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> — Metoda ma wpływu na powiązań zestawów.  
  
 Kod XML w `value` jest taka sama jak kodu XML w pliku konfiguracji normalne, z wyjątkiem tego, że są przechowywane jako <xref:System.Byte> tablicy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">Nazwa funkcji porównanie ciągu do zastąpienia.</param>
        <param name="functionVersion">Wersja funkcji. Dla [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], jego wartość musi wynosić 1 lub większą.</param>
        <param name="functionPointer">Wskaźnik do funkcji, która zastępuje <c>functionName</c>.</param>
        <summary>Udostępnia środowisko uruchomieniowe języka wspólnego z alternatywnych implementacji funkcji porównanie ciągu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższe porównanie ciągu i sortowanie metody może zostać przesłonięta przez <xref:System.AppDomainSetup.SetNativeFunction%2A> metody:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Aby uzyskać informacje na temat tych funkcji, zobacz [National funkcji obsługi języka](http://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" /> nie jest mniejsza od 1.  - lub - <paramref name="functionPointer" /> jest <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwy katalogów zawierający zestawy się kopie w tle.</summary>
        <value>Lista nazw katalogów, oddzielając je średnikami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kopiowanie w tle jest włączona, domyślnie nie jest kopia w tle wszystkich zestawów znaleziono przez sondowanie; oznacza to, że w katalogach określonych przez <xref:System.AppDomainSetup.PrivateBinPath%2A> i <xref:System.AppDomainSetup.ApplicationBase%2A> właściwości. <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> Właściwość ogranicza kopii w tle do zestawów w określonym przez <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.  
  
 Jeśli nie przypisuj ciąg <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> właściwości, lub jeśli ta właściwość jest ustawiona na `null`, wszystkie zestawy w katalogach określonych przez <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości są kopie w tle.  
  
> [!IMPORTANT]
>  Ponieważ średnik jest znak ogranicznika średnikami, nie może zawierać ścieżki katalogu. Brak nie znak ucieczki dla średnikami.  
  
 Kopiowanie w tle jest włączona, pliki zestawu są kopiowane do innej lokalizacji, przed załadowaniem zestawy. Oryginalny plik zestawu nie jest zablokowany, dlatego może być aktualizowana. Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg, który wskazuje, czy kopiowanie w tle jest włączony czy wyłączony.</summary>
        <value>Wartość ciągu "true", aby wskazać, że kopiowanie w tle jest włączona; lub "false", aby wskazać, że kopiowanie w tle funkcja jest wyłączona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg określający profil platformy .NET dla domeny aplikacji i wersji docelowej w formacie, który może zostać przeanalizowany przez <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> konstruktora.</summary>
        <value>Wersja docelowa i profilu platformy .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość w bieżącej wersji programu .NET Framework stwierdzić, czy domena aplikacji będzie służyć do załadowania i uruchomienia zestawy, które zostały skompilowane dla wersji docelowej i profilu. Jeśli aktualnie uruchomionej wersji programu .NET Framework ma zachowania opcjonalne, które mają wpływ na zgodność kod, który został skompilowany z wersji docelowej, go włączać lub wyłączać tych zachowań, zgodnie z potrzebami zwiększyć zgodność. Może to być przydatne, gdy aplikacja obsługuje dodatki skompilowana z wieloma wersjami programu .NET Framework uruchamiając w domenach innej aplikacji.  
  
 Dla aplikacji klienckich, wartość <xref:System.AppDomainSetup.TargetFrameworkName%2A> właściwości jest wywnioskowany na podstawie <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atrybutu. W [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] i później, ten atrybut jest dodawane do zestawu automatycznie na podstawie ustawienia projektu **platformy docelowej** właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aaabb3e2c80a8f502ecaefbb58d9f4d492be7c81" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69421677" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje informacje o powiązaniu zestawu, które można dodać do wystąpienia <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmiana właściwości <xref:System.AppDomainSetup> wystąpienia nie ma wpływu na istniejące <xref:System.AppDomain>. Może wpływać tylko na tworzenie nowego <xref:System.AppDomain>, <xref:System.AppDomain.CreateDomain%2A> gdy <xref:System.AppDomainSetup> Metoda jest wywoływana z wystąpieniem jako parametr.  
  
 Ta klasa implementuje <xref:System.IAppDomainSetup> interfejs.  
  
> [!CAUTION]
>  Wartość domyślna dla <xref:System.AppDomainSetup.DisallowCodeDownload%2A> właściwości jest równa false. To ustawienie jest niebezpieczne dla usług. Aby zapobiec pobieraniu częściowo zaufanego kodu przez usługi, ustaw dla tej właściwości wartość true.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Instrukcje: Konfigurowanie domeny aplikacji</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AppDomainSetup" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationContext">Kontekst aktywacji, który ma być używany dla domeny aplikacji.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.AppDomainSetup" /> klasy z określonym kontekstem aktywacji do użycia w przypadku aktywacji opartej na manifeście domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt określony `activationContext` dla<xref:System.Runtime.Hosting.ActivationArguments> jest używany do generowania obiektu zawierającego informacje wymagane do aktywowania nowej domeny aplikacji. <xref:System.ActivationContext> Dostęp <xref:System.Runtime.Hosting.ActivationArguments> do tego obiektu można uzyskać za <xref:System.AppDomainSetup.ActivationArguments%2A> pomocą właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationContext" />jest <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Obiekt, który określa informacje wymagane dla aktywacji opartej na manifeście dla nowej domeny aplikacji.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.AppDomainSetup" /> klasy z określonymi argumentami aktywacji wymaganymi dla aktywacji opartej na manifeście domeny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obiektu określonego dla `activationArguments` elementu można uzyskać dostęp za <xref:System.AppDomainSetup.ActivationArguments%2A> pomocą właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationArguments" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dane dotyczące aktywacji domeny aplikacji.</summary>
        <value>Obiekt, który zawiera dane o aktywacji domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zgłaszany żaden wyjątek, jeśli ta właściwość `null`jest ustawiona na.  
  
 Informacje dostarczone przez <xref:System.Runtime.Hosting.ActivationArguments> obiekt obsługują aktywację opartą na manifeście.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiona na obiekt, <see cref="T:System.Runtime.Hosting.ActivationArguments" /> którego tożsamość aplikacji nie jest zgodna z tożsamością <see cref="T:System.Security.Policy.ApplicationTrust" /> aplikacji obiektu zwróconego przez <see cref="P:System.AppDomainSetup.ApplicationTrust" /> właściwość. Nie jest zgłaszany żaden wyjątek <see cref="P:System.AppDomainSetup.ApplicationTrust" /> , jeśli <see langword="null" />właściwość jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.AppDomainInitializer" /> delegata, który reprezentuje metodę wywołania zwrotnego, która jest wywoływana po zainicjowaniu domeny aplikacji.</summary>
        <value>Delegat reprezentujący metodę wywołania zwrotnego, która jest wywoływana po zainicjowaniu domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby przekazać informacje do metody wywołania zwrotnego, przypisz tablicę ciągów do <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> właściwości. Tablica jest przenoszona do metody wywołania zwrotnego za każdym <xref:System.AppDomain> razem, gdy jest inicjowana.  
  
 Metoda wywołania zwrotnego jest wykonywana w kontekście nowo utworzonej domeny aplikacji.  
  
   
  
## Examples  
 Poniższy przykład tworzy podrzędną domenę aplikacji o nazwie `ChildDomain`, <xref:System.AppDomainSetup> używając obiektu i dowodów z domyślnej domeny aplikacji. Właściwość jest ustawiona na metodę `AppDomainInit`wywołania zwrotnego, która jest wywoływana po zainicjowaniu domeny podrzędnej. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Argumenty metody wywołania zwrotnego są umieszczane w tablicy ciągów, która jest przypisana do <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> właściwości. Po utworzeniu domeny podrzędnej Metoda wywołania zwrotnego po prostu drukuje ciągi.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia argumenty przekazane do metody wywołania zwrotnego reprezentowanej przez <see cref="T:System.AppDomainInitializer" /> delegata. Metoda wywołania zwrotnego jest wywoływana po zainicjowaniu domeny aplikacji.</summary>
        <value>Tablica ciągów, która jest przesyłana do metody wywołania zwrotnego reprezentowanej <see cref="T:System.AppDomainInitializer" /> przez delegata, gdy wywoływana jest metoda wywołania <see cref="T:System.AppDomain" /> zwrotnego podczas inicjacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości, aby określić metodę wywołania zwrotnego, która jest <xref:System.AppDomain> wywoływana podczas inicjacji. <xref:System.AppDomainSetup.AppDomainInitializer%2A> <xref:System.AppDomainSetup.AppDomainInitializer%2A> Jeśli właściwość nie jest ustawiona, tablica przypisana do tej właściwości nie jest używana.  
  
 Metoda wywołania zwrotnego jest wykonywana w kontekście nowo utworzonej domeny aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy podrzędną domenę aplikacji o nazwie `ChildDomain`, <xref:System.AppDomainSetup> używając obiektu i dowodów z domyślnej domeny aplikacji. Właściwość jest ustawiona na metodę `AppDomainInit`wywołania zwrotnego, która jest wywoływana po zainicjowaniu domeny podrzędnej. <xref:System.AppDomainSetup.AppDomainInitializer%2A> Argumenty metody wywołania zwrotnego są umieszczane w tablicy ciągów, która jest przypisana do <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> właściwości. Po utworzeniu domeny podrzędnej Metoda wywołania zwrotnego po prostu drukuje ciągi.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę wyświetlaną zestawu, który udostępnia typ Menedżera domeny aplikacji dla domen aplikacji utworzonych przy użyciu tego <see cref="T:System.AppDomainSetup" /> obiektu.</summary>
        <value>Nazwa wyświetlana zestawu, który udostępnia <see cref="T:System.Type" /> Menedżera domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić typ Menedżera domeny aplikacji, ustaw tę właściwość i <xref:System.AppDomainSetup.AppDomainManagerType%2A> właściwość. Jeśli nie ustawiono żadnej z tych właściwości, drugi zostanie zignorowany.  
  
 Jeśli nie podano żadnego typu, Menedżer domeny aplikacji jest tworzony na podstawie tego samego typu co domena nadrzędnej domeny aplikacji (czyli domeny aplikacji, z której <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> wywoływana jest metoda).  
  
 Gdy domena aplikacji zostanie załadowana, <xref:System.TypeLoadException> jest zgłaszany, jeśli zestaw nie istnieje, lub jeśli zestaw nie zawiera typu określonego <xref:System.AppDomainSetup.AppDomainManagerType%2A> przez właściwość. <xref:System.IO.FileLoadException>jest zgłaszany, jeśli zestaw zostanie znaleziony, ale informacje o wersji nie są zgodne.  
  
 Aby ustawić Menedżera domeny aplikacji dla domyślnej domeny aplikacji, należy użyć [ \<elementów appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) i [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) w [ \<sekcji > środowiska uruchomieniowego](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) pliku konfiguracyjnego aplikacji lub użyć zmiennych środowiskowych opisanych w <xref:System.AppDomainManager>temacie.  
  
 Ta funkcja wymaga, aby aplikacja miała pełne zaufanie. (Na przykład aplikacja uruchomiona na pulpicie ma pełne zaufanie). Jeśli aplikacja nie ma pełnego zaufania, <xref:System.TypeLoadException> jest zgłaszany.  
  
 Format nazwy wyświetlanej zestawu jest określony przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pełną nazwę typu, który zapewnia Menedżera domeny aplikacji dla domen aplikacji utworzonych przy użyciu tego <see cref="T:System.AppDomainSetup" /> obiektu.</summary>
        <value>Pełna nazwa typu, łącznie z przestrzenią nazw.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić typ Menedżera domeny aplikacji, ustaw tę właściwość i <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> właściwość. Jeśli nie ustawiono żadnej z tych właściwości, drugi zostanie zignorowany.  
  
 Jeśli nie podano żadnego typu, Menedżer domeny aplikacji jest tworzony na podstawie tego samego typu co domena nadrzędnej domeny aplikacji (czyli domeny aplikacji, z której <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> wywoływana jest metoda).  
  
 Gdy domena aplikacji zostanie załadowana, <xref:System.TypeLoadException> jest zgłaszany, jeśli zestaw określony <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> przez właściwość nie zawiera typu określonego przez tę właściwość.  
  
 Aby ustawić Menedżera domeny aplikacji dla domyślnej domeny aplikacji, należy użyć [ \<elementów appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) i [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) w [ \<sekcji > środowiska uruchomieniowego](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) pliku konfiguracyjnego aplikacji lub użyć zmiennych środowiskowych opisanych w <xref:System.AppDomainManager>temacie.  
  
 Ta funkcja wymaga, aby aplikacja miała pełne zaufanie. (Na przykład aplikacja uruchomiona na pulpicie ma pełne zaufanie). Jeśli aplikacja nie ma pełnego zaufania, <xref:System.TypeLoadException> jest zgłaszany.  
  
 Format pełnej nazwy typu jest określony przez <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę katalogu zawierającego aplikację.</summary>
        <value>Nazwa katalogu podstawowego aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Katalog podstawowy aplikacji to miejsce, w którym Menedżer zestawów rozpoczyna sondowanie dla zestawów.  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A> Właściwość może mieć wpływ na uprawnienia przyznawane domenie aplikacji. Na przykład domena aplikacji pochodząca z komputera lokalnego zazwyczaj otrzymuje pełne zaufanie na podstawie jego lokalizacji pochodzenia. Jeśli <xref:System.AppDomainSetup.ApplicationBase%2A> jednak właściwość, która <xref:System.AppDomain> jest ustawiona na pełną nazwę katalogu intranetowego, <xref:System.AppDomainSetup.ApplicationBase%2A> ustawienie ogranicza uprawnienia przyznawane domenie aplikacji do LocalIntranet, nawet jeśli domena aplikacji faktycznie pochodzi z komputera lokalnego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak użyć <xref:System.AppDomainSetup.ApplicationBase%2A> właściwości, aby ustawić lokalizację, w której moduł ładujący zestawy rozpoczyna sondowanie zestawów do załadowania do nowej domeny aplikacji.  
  
> [!NOTE]
>  Musisz się upewnić, że określony folder istnieje.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę aplikacji.</summary>
        <value>Nazwa aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.AppDomainSetup.ApplicationName%2A> jak ustawić właściwość podczas tworzenia nowej domeny aplikacji.  
  
 Przykład tworzy nową domenę aplikacji, a następnie wywołuje <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> metodę w celu załadowania przykładowego zestawu do domeny nowej aplikacji i tworzenia wystąpienia `Worker` klasy. Klasa dziedziczy <xref:System.MarshalByRefObject>, więc przykład może używać serwera proxy `TestLoad` zwróconego przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> , aby wywołać metodę. `Worker`  
  
 `TestLoad` Metoda ładuje zestaw, który określisz. Należy określić prawidłową, w pełni kwalifikowaną nazwę zestawu lub dodać komentarz do <xref:System.Reflection.Assembly.Load%28System.String%29> metody. `TestLoad` Metoda zawiera listę zestawów, które są ładowane do domeny nowej aplikacji, pokazując, że określony zestaw i przykładowy zestaw są załadowane.  
  
 W przykładzie używa <xref:System.LoaderOptimizationAttribute> atrybutu do informowania modułu ładującego zestawy, jak aplikacja będzie współużytkować kod w domenach aplikacji.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt zawierający informacje o zabezpieczeniach i zaufaniu.</summary>
        <value>Obiekt, który zawiera informacje o zabezpieczeniach i zaufania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest `null` tworzona <xref:System.AppDomainSetup> po utworzeniu. Po zmianie nie można resetować do odwołania o wartości null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiona na obiekt, <see cref="T:System.Security.Policy.ApplicationTrust" /> którego tożsamość aplikacji nie jest zgodna z tożsamością <see cref="T:System.Runtime.Hosting.ActivationArguments" /> aplikacji obiektu zwróconego przez <see cref="P:System.AppDomainSetup.ActivationArguments" /> właściwość. Nie jest zgłaszany żaden wyjątek <see cref="P:System.AppDomainSetup.ActivationArguments" /> , jeśli <see langword="null" />właściwość jest.</exception>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę obszaru określonego dla aplikacji, w której pliki są kopiowane w tle.</summary>
        <value>W pełni kwalifikowana nazwa ścieżki katalogu i nazwy pliku, w którym pliki są kopiowane w tle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ta właściwość miała efekt, <xref:System.AppDomainSetup.ApplicationName%2A> należy również ustawić właściwość. Jeśli właściwość nie jest ustawiona <xref:System.AppDomainSetup.CachePath%2A> , właściwość jest ignorowana, a lokalizacja pamięci podręcznej kopii w tle jest domyślna dla pamięci podręcznej pobierania. <xref:System.AppDomainSetup.ApplicationName%2A>  
  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę pliku konfiguracji dla domeny aplikacji.</summary>
        <value>Nazwa pliku konfiguracji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik konfiguracji zawiera opis reguł wyszukiwania i danych konfiguracyjnych dla domeny aplikacji. Host tworzący domenę aplikacji jest odpowiedzialny za dostarczanie tych danych, ponieważ istotne wartości różnią się w zależności od sytuacji.  
  
 Na przykład dane konfiguracji dla aplikacji ASP.NET są przechowywane dla każdej aplikacji, lokacji i komputera, podczas gdy dane konfiguracji dla pliku wykonywalnego są przechowywane dla każdej aplikacji, użytkownika i komputera. Tylko Host zna szczegółowe dane konfiguracyjne dla konkretnej sytuacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Schemat ustawień środowiska uruchomieniowego</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy podczas wyszukiwania zestawów do załadowania mają być badane ścieżki podstawowe aplikacji i prywatna ścieżka binarna.</summary>
        <value><see langword="true" />Jeśli badanie nie jest dozwolone; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest `true`, wartość właściwościjestignorowana.<xref:System.AppDomainSetup.ApplicationBase%2A> <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Oznacza to, że żadne zestawy nie są badane dla w katalogach określonych przez <xref:System.AppDomainSetup.ApplicationBase%2A> właściwość. Ponadto wartości <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> i właściwości są ignorowane. W katalogach określonych przez <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwość nie są badane żadne zestawy.  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Właściwość zapewnia dodatkową warstwę kontroli nad procesem ładowania. W normalnej sekwencji ładowania zestawu baza aplikacji jest sondowana przed <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> wywołaniem zdarzenia. Niektóre aplikacje mogą jednak wymagać załadowania zestawów z pliku złożonego OLE w dokumencie lub z unikatowej znanej lokalizacji, która nie znajduje się w globalnej pamięci podręcznej zestawów ani w katalogach określonych przez <xref:System.AppDomainSetup.ApplicationBase%2A> właściwości <xref:System.AppDomainSetup.PrivateBinPath%2A> i. Takie aplikacje mogą używać <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> właściwości, aby uniknąć opóźnień spowodowanych przez normalną sondę i aby uniknąć ładowania kopii niezbędnego zestawu, które mogą znajdować się w normalnej ścieżce sondowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy domena aplikacji zezwala na przekierowywanie powiązań zestawu.</summary>
        <value><see langword="true" />Jeśli przekierowanie zestawów nie jest dozwolone; <see langword="false" /> jeśli jest to dozwolone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> Właściwość jest przeznaczona do użycia przez usługi i aplikacje serwera, w których przekierowanie powiązania zestawu nie jest częścią scenariusza aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pobieranie zestawów przez protokół HTTP jest dozwolone dla domeny aplikacji.</summary>
        <value><see langword="true" />Jeśli pobieranie zestawów za pośrednictwem protokołu HTTP nie jest dozwolone; <see langword="false" /> jeśli jest to dozwolone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Właściwość jest przeznaczona do użycia przez usługi i aplikacje serwera, gdzie pobieranie kodu z intranetu lub Internetu nie jest częścią scenariusza aplikacji.  
  
> [!CAUTION]
>  Wartość <xref:System.AppDomainSetup.DisallowCodeDownload%2A> domyślna właściwości to `false`. To ustawienie jest niebezpieczne dla usług. Aby zapobiec pobieraniu częściowo zaufanego kodu przez usługi, należy ustawić tę `true`właściwość na.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy [ &lt;sekcja publisherPolicy Apply&gt; ](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) pliku konfiguracji jest zastosowana do domeny aplikacji.</summary>
        <value><see langword="true" /><see langword="&lt;publisherPolicy&gt;" /> Jeśli sekcja pliku konfiguracji dla domeny aplikacji jest ignorowana; <see langword="false" /> jeśli zadeklarowane zasady wydawcy są honorowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> ma zastosowanie w odróżnieniu od aplikacji sieci Web, która jest ładowana lokalnie. Użyj tej właściwości, aby zapobiec złośliwej próbie wykonania niebezpiecznej aplikacji sieci Web w trybie awaryjnym.  
  
 Więcej informacji na temat pomijania zasad wydawcy znajduje się w temacie [przekierowywanie wersji zestawu](~/docs/framework/configure-apps/redirect-assembly-versions.md) . Aby uzyskać więcej informacji na temat trybu awaryjnego, zobacz sekcję "Badanie plików konfiguracji" w temacie [how](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) The runtimeing refiless.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia katalog podstawowy, w którym znajduje się katalog dla dynamicznie generowanych plików.</summary>
        <value>Katalog, w <see cref="P:System.AppDomain.DynamicDirectory" /> którym znajduje się folder.  

 <block subset="none" type="note"><para>  
 Wartość zwracana przez tę właściwość różni się od przypisanej wartości.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Ta właściwość służy do ustawiania katalogu podstawowego, w którym będzie zlokalizowany katalog dynamiczny nowej domeny aplikacji. Gdy kod w nowej domenie aplikacji ładuje zestaw, rozdzielczość zestawu jest najpierw sprawdzana w normalnych ścieżkach sondowania. Jeśli zestaw nie zostanie znaleziony, szuka w katalogu dynamicznym, który jest zwracany przez <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> właściwość. Zestawy dynamiczne, które będą ładowane i wykonywane przez nową domenę aplikacji, można tam umieścić.  
  
 Po przypisaniu ścieżki do <xref:System.AppDomainSetup.DynamicBase%2A> właściwości zostanie dodany dodatkowy podkatalog; nazwa tego podkatalogu jest kodem skrótu wartości przypisanej <xref:System.AppDomainSetup.ApplicationName%2A> do właściwości. W związku z tym, katalog podstawowy zwracany przez tę właściwość jest zawsze różny od przypisanej wartości.  
  
> [!IMPORTANT]
>  Przypisanie wartości do tej właściwości nie powoduje utworzenia żadnych katalogów. Katalogi muszą zostać utworzone lub zweryfikowane przez kod, który z nich korzysta.  
  
 Katalog dynamiczny jest podkatalogiem <xref:System.AppDomainSetup.DynamicBase%2A>. Jego prosta nazwa jest wartością zwracaną <xref:System.AppDomainSetup.ApplicationName%2A> przez właściwość, więc jego format jest oryginalną ścieżką do*kodu*\\skrótu *ścieżki*\\.**  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.AppDomainSetup.DynamicBase%2A> właściwości, aby ustawić ścieżkę do sond domeny aplikacji podczas ładowania zestawów dynamicznych.  
  
 Przykład tworzy <xref:System.AppDomainSetup> obiekt i ustawia jego <xref:System.AppDomainSetup.ApplicationName%2A> właściwość na "przykład" i jego <xref:System.AppDomainSetup.DynamicBase%2A> właściwość na "C:\DynamicAssemblyDir". W przykładzie zostanie wyświetlona <xref:System.AppDomainSetup.DynamicBase%2A> właściwość, aby pokazać, że kod skrótu nazwy aplikacji został dołączony jako podkatalog ścieżki, która została pierwotnie przypisana.  
  
> [!NOTE]
>  Katalog podstawowy w tym przykładzie ma być poza ścieżką do sondowania przykładowej aplikacji. Zadbaj o skompilowanie przykładu w innej lokalizacji. Usuń katalog podstawowy i wszystkie jego podkatalogi przy każdym uruchomieniu przykładu.  
  
 Przykład tworzy nową domenę aplikacji przy użyciu <xref:System.AppDomainSetup> obiektu. W przykładzie tworzony jest katalog dynamiczny, jeśli jeszcze nie istnieje. Chociaż w przykładzie używa się <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> właściwości domeny aplikacji w celu uzyskania nazwy katalogu dynamicznego, można tak jak łatwo utworzyć katalog wcześniej, łącząc oryginalną ścieżkę, kod skrótu nazwy aplikacji i Nazwa aplikacji.  
  
 Przykład ma `GenerateDynamicAssembly` metodę, która emituje zestaw o nazwie `DynamicHelloWorld.dll` i zapisuje je w katalogu dynamicznym nowej domeny aplikacji. Zestaw dynamiczny zawiera jeden typ, `HelloWorld`który ma metodę statyczną (`Shared` Metoda w Visual Basic) o nazwie `HelloFromAD`. Wywołanie tej metody powoduje wyświetlenie nazwy domeny aplikacji.  
  
 Klasa pochodzi od <xref:System.MarshalByRefObject>, więc przykład może utworzyć wystąpienie klasy w nowej domenie `Test` aplikacji i wywołać metodę. `Example` Metoda ładuje dynamiczny zestaw według jego nazwy wyświetlanej i wywołuje metodę statyczną `HelloFromAD`. `Test`  
  
 Możesz pokazać, że katalog dynamiczny jest przeszukiwany po normalnej ścieżce sondowania, pisząc kod dla zestawu o `DynamicHelloWorld.dll` nazwie i kompilując go w tym samym katalogu, co w tym przykładzie. Zestaw musi mieć klasę o nazwie `HelloWorld` z metodą statyczną o nazwie. `HelloFromAD` Ta metoda nie musi mieć takich samych funkcji jak w przykładzie; może po prostu wyświetlić ciąg w konsoli programu. Zestaw musi mieć <xref:System.Reflection.AssemblyVersionAttribute> również atrybut, który ustawia jego wersję na 1.0.0.0. Po uruchomieniu przykładu zestaw skompilowany w bieżącym katalogu zostanie znaleziony przed przeszukaniem katalogu dynamicznego.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Nie można ustawić tej właściwości, ponieważ nazwa aplikacji w domenie aplikacji to <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca informacje o konfiguracji XML ustawione przez <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> metodę, która zastępuje informacje o konfiguracji XML aplikacji.</summary>
        <returns>Tablica zawierająca informacje o konfiguracji XML, które zostały ustawione przez <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> metodę lub <see langword="null" /> Jeśli <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> Metoda nie została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metoda zapewnia sposób przesłania informacji o konfiguracji aplikacji, która tworzy nową domenę aplikacji. Informacje o pliku konfiguracji w `value` programie zastępują informacje o pliku konfiguracyjnym aplikacji. Na przykład, gdy aplikacja example. exe tworzy nową domenę aplikacji, może zastąpić informacje o konfiguracji pierwotnie uzyskane z przykładowego pliku exe. config.  
  
> [!IMPORTANT]
>  Niektórzy odbiorcy informacji o pliku konfiguracyjnym nie używają informacji przechowywanych przez <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metodę. Środowisko uruchomieniowe nie wymusza tego działania. Aby upewnić się, że wszystkie informacje o pliku konfiguracyjnym zostały zastąpione w nowej <xref:System.AppDomainSetup.ConfigurationFile%2A> domenie aplikacji, użyj właściwości, aby określić plik konfiguracji. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metoda ma wpływ na powiązanie zestawu.  
  
 Kod XML w `value` jest taki sam jak kod XML w normalnym pliku konfiguracji, z tą różnicą, że jest <xref:System.Byte> przechowywany jako tablica.  
  
 Aby uzyskać dostęp do bajtów konfiguracji dla domeny aplikacji, użyj <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> właściwości, aby <xref:System.AppDomainSetup> pobrać obiekt dla <xref:System.AppDomainSetup.GetConfigurationBytes%2A> domeny aplikacji, a następnie użyj metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia lokalizację pliku licencji skojarzonego z tą domeną.</summary>
        <value>Lokalizacja i nazwa pliku licencji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa zasady optymalizacji używane do ładowania pliku wykonywalnego.</summary>
        <value>Stała wyliczana, która jest używana z <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy zestaw dynamiczny i zapisuje go na dysku, a następnie używa <xref:System.AppDomainSetup.LoaderOptimization%2A> właściwości, aby ustawić zasady optymalizacji używane do ładowania zestawu do domeny aplikacji.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia listę zestawów oznaczonych za pomocą <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> flagi, które są widoczne dla kodu częściowego zaufania działającego w domenie aplikacji w trybie piaskownicy.</summary>
        <value>Tablica częściowych nazw zestawów, gdzie każda nazwa częściowa składa się z prostej nazwy zestawu i klucza publicznego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], atrybut (APTCA) może być spowodowany przez ustawienie jego właściwości na. <xref:System.Security.AllowPartiallyTrustedCallersAttribute> Zestaw APTCA, który jest oznaczony za <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> pomocą, nie może być używany przez częściowo zaufany kod, chyba że aplikacja hosta go zezwala.  
  
 Host domeny aplikacji w trybie piaskownicy umożliwia kodowi w domenie aplikacji używanie zestawów z warunkowymi atrybutami APTCA przez utworzenie tablicy zawierającej prostą nazwę i klucz publiczny każdego zestawu oraz przypisanie tablicy do tej właściwości. Na przykład element tablicy może wyglądać następująco: "PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".  
  
> [!IMPORTANT]
>  Jeśli używasz podklasy <xref:System.AppDomainManager>, a zestaw, który definiuje go, zależy od zestawów, które są oznaczone atrybutem Conditional APTCA, należy dołączyć te zestawy do listy, które są przekazywane <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> do właściwości <xref:System.AppDomainSetup>służy do tworzenia domen aplikacji. W przeciwnym razie zestawy, które są oznaczone za pomocą warunkowego atrybutu APTCA, zostaną wyłączone.  
  
> [!NOTE]
>  Podczas debugowania aplikacji, która jest uruchomiona w domenie aplikacji w trybie piaskownicy, niektóre <xref:System.Security.SecurityException> komunikaty mogą być mylące. Na przykład komunikat może być spowodowany tym, że jeden z w pełni zaufanych zestawów ma tylko ograniczone uprawnienia, gdy rzeczywista przyczyna problemu polega na tym, że żądanie zabezpieczeń, które przekracza zestaw uprawnień domeny aplikacji w trybie piaskownicy, zostało propagowane do granicy domena aplikacji w trybie piaskownicy i nie powiodła się.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia listę katalogów w katalogu podstawowym aplikacji, które są badane dla zestawów prywatnych.</summary>
        <value>Lista nazw katalogów rozdzielonych średnikami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy prywatne są wdrażane w tej samej strukturze katalogów co aplikacja. Jeśli katalogi określone dla programu <xref:System.AppDomainSetup.PrivateBinPath%2A> nie są objęte <xref:System.AppDomainSetup.ApplicationBase%2A>, są one ignorowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość ciągu, która zawiera lub wyklucza <see cref="P:System.AppDomainSetup.ApplicationBase" /> ze ścieżki wyszukiwania dla aplikacji, i przeszukuje tylko. <see cref="P:System.AppDomainSetup.PrivateBinPath" /></summary>
        <value>Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic) do uwzględnienia ścieżki bazowej aplikacji podczas wyszukiwania zestawów; dowolna wartość ciągu o wartości innej niż null, która wyklucza ścieżkę. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na dowolną wartość ciągu o wartości innej niż null <xref:System.String.Empty?displayProperty=nameWithType> , w tym (""), aby wykluczyć ścieżkę katalogu aplikacji — czyli <xref:System.AppDomainSetup.ApplicationBase%2A> z ścieżki wyszukiwania dla aplikacji, a także wyszukiwać zestawy tylko w <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy buforowanie interfejsów jest wyłączone dla wywołań międzyoperacyjnych w domenie aplikacji, tak aby funkcja <c>QueryInterface</c> była wykonywana dla każdego wywołania.</summary>
        <value><see langword="true" />Jeśli buforowanie interfejsu jest wyłączone dla wywołań międzyoperacyjnych w domenach aplikacji utworzonych <see cref="T:System.AppDomainSetup" /> przy użyciu bieżącego obiektu <see langword="false" />; w przeciwnym razie,.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyłączenie buforowania interfejsu ma znaczny wpływ na wydajność wywołań międzyoperacyjnych.  
  
 Ten element członkowski jest wprowadzany [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]w.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switches">Wyliczalny zestaw wartości ciągu określający przełączniki zgodności lub <see langword="null" /> do wymazywania istniejących przełączników zgodności.</param>
        <summary>Ustawia określone przełączniki, ustawiając domenę aplikacji zgodną z poprzednimi wersjami .NET Framework dla określonych problemów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Główne wersje .NET Framework czasami wprowadzają istotne zmiany z poprzedniej wersji. Na przykład [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] wprowadza niewielką liczbę istotnych zmian [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]z. <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> Użyj metody, aby określić, że co najmniej jedna z tych istotnych zmian powinna zostać wycofana dla domeny aplikacji, aby zachowanie było zgodne z poprzednią wersją .NET Framework.  
  
 Za każdym razem, gdy wywoływana jest metoda, zastępuje istniejące ustawienia przełącznika. Aby wymazać ustawienia, określ `null` `switches` dla parametru.  
  
 Zestaw wartości ciągów, które zapewniasz `switches` , może być prostą tablicą ciągów, ponieważ tablice <xref:System.Collections.IEnumerable> implementują interfejs.  
  
 W poniższej tabeli przedstawiono przykłady przełączników zgodności, które można ustawić w celu przywrócenia zachowania wcześniejszych wersji .NET Framework.  
  
|Przełącznik|Znaczenie|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Zabezpieczenia dostępu kodu (CAS) dla programu [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] są włączone w tej domenie aplikacji. [ Zobacz&lt;elementNetFx40_LegacySecurityPolicy&gt; ](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Wartości domyślne sortowania ciągu dla [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] programu są włączone w tej domenie aplikacji. Pomyślnie przywrócono starsze zachowanie podczas sortowania, wymagane jest również, aby biblioteka dołączana dynamicznie sort00001000. dll była dostępna w systemie lokalnym. [ Zobacz&lt;elementCompatSortNLSVersion&gt; ](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Wartości domyślne sortowania ciągów dla [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] i Unicode 5,0 są włączone w tej domenie aplikacji. Pomyślnie przywrócono starsze zachowanie podczas sortowania, wymagane jest również, aby biblioteka dołączana dynamicznie sort00060101. dll była dostępna w systemie lokalnym.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan>zachowanie formatowania dla programu [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] jest włączone w tej domenie aplikacji. <xref:System.TimeSpan> Zobacz [ &lt;elementTimeSpan_LegacyFormatMode&gt; ](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) oraz sekcję "Przywracanie starszego formatowania TimeSpan" w temacie.|  
|"UseRandomizedStringHashAlgorithm"|Środowisko uruchomieniowe oblicza kody skrótów dla ciągów na podstawie poszczególnych domen aplikacji zamiast używać jednego algorytmu skrótu, który tworzy spójny kod skrótu w domenach aplikacji. [ Zobacz&lt;elementUseRandomizedStringHashAlgorithm&gt; ](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; Element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;CompatSortNLSVersion&gt; , element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt; , element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; , element</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Tablica zawierająca informacje o konfiguracji XML, które mają być używane dla domeny aplikacji.</param>
        <summary>Zawiera informacje o konfiguracji XML dla domeny aplikacji, zastępując informacje o konfiguracji XML aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metoda umożliwia zamianę informacji konfiguracyjnych aplikacji tworzącej nową domenę aplikacji. Informacje o pliku konfiguracji w `value` programie zamieniają informacje o pliku konfiguracyjnym aplikacji. Na przykład, gdy aplikacja example. exe tworzy nową domenę aplikacji, może zastąpić informacje o konfiguracji, które zostały pierwotnie uzyskane z pliku example. exe. config.  
  
> [!IMPORTANT]
>  Niektórzy odbiorcy informacji o pliku konfiguracyjnym nie używają informacji przechowywanych przez <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metodę. Środowisko uruchomieniowe nie wymusza tego działania. Aby upewnić się, że wszystkie informacje o pliku konfiguracyjnym zostały zastąpione w nowej <xref:System.AppDomainSetup.ConfigurationFile%2A> domenie aplikacji, użyj właściwości, aby określić plik konfiguracji. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Metoda ma wpływ na powiązanie zestawu.  
  
 Kod XML w `value` jest taki sam jak kod XML w normalnym pliku konfiguracji, z tą różnicą, że jest <xref:System.Byte> przechowywany jako tablica.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Schemat ustawień środowiska uruchomieniowego</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionVersion" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionPointer" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="functionName">Nazwa funkcji porównywania ciągów, która ma zostać przesłonięta.</param>
        <param name="functionVersion">Wersja funkcji. Dla [!INCLUDE[net_v45](~/includes/net-v45-md.md)], jego wartość musi być równa 1 lub większa.</param>
        <param name="functionPointer">Wskaźnik do funkcji, która zastępuje <paramref name="functionName" />.</param>
        <summary>Udostępnia środowisko uruchomieniowe języka wspólnego z alternatywną implementacją funkcji porównywania ciągów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujące metody porównywania i sortowania ciągów mogą zostać zastąpione przez <xref:System.AppDomainSetup.SetNativeFunction%2A> metodę:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Aby uzyskać informacje o tych funkcjach, zobacz [National Language Support Functions](https://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="functionName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="functionVersion" />nie jest 1 lub większa.  
  
—lub— 
 <paramref name="functionPointer" />jest <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwy katalogów zawierających zestawy przeznaczone do kopiowania w tle.</summary>
        <value>Lista nazw katalogów rozdzielonych średnikami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy kopiowanie w tle jest włączone, domyślnym ustawieniem jest kopiowanie w tle wszystkich zestawów znalezionych za pomocą sondowania; oznacza to, że w katalogach określonych przez <xref:System.AppDomainSetup.PrivateBinPath%2A> i <xref:System.AppDomainSetup.ApplicationBase%2A> właściwości. Właściwość ogranicza kopię w tle do zestawów w katalogach określonych przez <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>. <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>  
  
 Jeśli nie przypiszesz ciągu <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> do właściwości lub jeśli ustawisz tę właściwość na `null`, wszystkie zestawy w katalogach określonych przez <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> właściwości są skopiowane w tle.  
  
> [!IMPORTANT]
>  Ścieżki katalogów nie mogą zawierać średników, ponieważ średnik jest znakiem ogranicznika. Brak znaku ucieczki dla średników.  
  
 Po przystąpieniu do kopiowania w tle pliki zestawów są kopiowane do innej lokalizacji przed załadowaniem zestawów. Oryginalny plik zestawu nie jest zablokowany, więc można go zaktualizować. Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg, który wskazuje, czy kopiowanie w tle jest włączone, czy wyłączone.</summary>
        <value>Wartość ciągu "true" wskazująca, że kopiowanie w tle jest włączone; lub wartość "false", aby wskazać, że kopiowanie w tle jest wyłączone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg określający wersję docelową i profil .NET Framework domeny aplikacji w formacie, który może być analizowany przez <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> Konstruktor.</summary>
        <value>Docelowa wersja i profil .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość, aby określić aktualnie działającą wersję .NET Framework, do której zostanie użyta domena aplikacji do załadowania i uruchomienia zestawów, które zostały skompilowane dla docelowej wersji i profilu. Jeśli aktualnie uruchomiona wersja .NET Framework ma zachowania opcjonalne, które mają wpływ na zgodność kodu skompilowanego z wersją docelową, można włączyć lub wyłączyć te zachowania odpowiednio do potrzeb, aby zwiększyć zgodność. Może to być przydatne, gdy aplikacja obsługuje dodatki skompilowane z wieloma wersjami .NET Framework przez uruchomienie ich w oddzielnych domenach aplikacji.  
  
 W przypadku aplikacji klienckich wartość <xref:System.AppDomainSetup.TargetFrameworkName%2A> właściwości jest wywnioskowana <xref:System.Runtime.Versioning.TargetFrameworkAttribute> z atrybutu. W [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] systemach i nowszych ten atrybut jest dodawany do zestawu automatycznie na podstawie ustawienia właściwości **platformy docelowej** projektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Func&lt;T,TResult&gt;" FullName="System.Func&lt;T,TResult&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="376675baf8e14d5ae81bf0b102d6017fb220e31b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431602" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate TResult Func&lt;in T,out TResult&gt;(T arg);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Func`2&lt;- T, + TResult&gt; extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Func`2" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function Func(Of In T, Out TResult)(arg As T) As TResult " />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T, typename TResult&gt;&#xA;public delegate TResult Func(T arg);" />
  <TypeSignature Language="F#" Value="type Func&lt;'T, 'Result&gt; = delegate of 'T -&gt; 'Result" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T">
      <Constraints>
        <ParameterAttribute>Contravariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TResult">
      <Constraints>
        <ParameterAttribute>Covariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")</AttributeName>
    </Attribute>
  </Attributes>
  <Parameters>
    <Parameter Name="arg" Type="T" />
  </Parameters>
  <ReturnValue>
    <ReturnType>TResult</ReturnType>
  </ReturnValue>
  <Docs>
    <typeparam name="T">Typ parametru metody, która hermetyzuje tego delegata.</typeparam>
    <typeparam name="TResult">Typ zwracanej wartości metody, która hermetyzuje tego delegata.</typeparam>
    <param name="arg">Parametr metody, która hermetyzuje tego delegata.</param>
    <summary>Hermetyzuje metodę, która ma jeden parametr i zwraca wartość typu określonego przez <typeparamref name="TResult" /> parametru.</summary>
    <returns>Wartość zwracaną metody, która hermetyzuje tego delegata.</returns>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten delegat umożliwia reprezentuje metodę, która można przekazać jako parametru bez jawnie deklarowanie niestandardowego obiektu delegowanego. Metoda hermetyzowany musi odpowiadać podpis metody jest definiowana za pomocą tego delegata. Oznacza to, że metoda hermetyzowany musi mieć jeden parametr, który jest przekazywany do niej przez wartość, a aplikacja musi zwracać wartość.  
  
> [!NOTE]
>  Metody, która ma jeden parametr i zwraca odwołanie do `void` (lub w języku Visual Basic, który jest zadeklarowany jako `Sub` , a nie jako `Function`), używać ogólnych <xref:System.Action%601> zamiast tego delegata.  
  
 Jeśli używasz <xref:System.Func%602> delegata, nie trzeba jawnie definiować delegata, który hermetyzuje metody z pojedynczym parametrem. Na przykład następujący kod jawnie deklaruje delegata o nazwie `ConvertMethod` i odwołanie do `UppercaseString` metodę, aby jego wystąpienie obiektu delegowanego.  
  
 [!code-csharp[System.Func~2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~2/cs/Delegate.cs#1)]
 [!code-vb[System.Func~2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~2/vb/Delegate.vb#1)]  
  
 Poniższy przykład ułatwiają ten kod przy uruchamianiu <xref:System.Func%602> delegata zamiast jawnie nowe delegowanie definiowanie i przypisywanie metodę o nazwie.  
  
 [!code-csharp[System.Func~2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~2/cs/Func2_1.cs#2)]
 [!code-vb[System.Func~2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~2/vb/Func2_1.vb#2)]  
  
 Można również użyć <xref:System.Func%602> delegata z metody anonimowe w języku C#, jak pokazano w poniższym przykładzie. (Wprowadzenie do metod anonimowych, zobacz [metod anonimowych](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md).)  
  
 [!code-csharp[System.Func~2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~2/cs/Anon.cs#3)]  
  
 Można także przypisać wyrażenia lambda do <xref:System.Func%602> delegować, jak pokazano w poniższym przykładzie. (Wprowadzenie do wyrażenia lambda, zobacz [wyrażenia Lambda](~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md) i [wyrażenia Lambda](~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).)  
  
 [!code-csharp[System.Func~2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~2/cs/Lambda.cs#4)]
 [!code-vb[System.Func~2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~2/vb/Lambda.vb#4)]  
  
 Podstawowy typ wyrażenia lambda jest jednym z ogólnego `Func` delegatów. Dzięki temu można przekazać wyrażenia lambda jako parametr bez jawnie przypisywania go do delegata. W szczególności ponieważ wiele metod typów w <xref:System.Linq> ma przestrzeń nazw <xref:System.Func%602> parametry, można przekazać te metody wyrażenia lambda bez jawnego tworzenia wystąpienia <xref:System.Func%602> delegowanie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób deklarowanie i użycie <xref:System.Func%602> delegowanie. W tym przykładzie deklaruje <xref:System.Func%602> zmiennej i przypisuje go wyrażenia lambda, który konwertuje znaki w ciągu na wielkie litery. Delegata, który hermetyzuje tej metody są następnie przekazywane do <xref:System.Linq.Enumerable.Select%2A?displayProperty=nameWithType> metodę, aby zmienić ciągi w tablicy ciągów na wielkie litery.  
  
 [!code-csharp[System.Func~2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~2/cs/Example.cs#5)]
 [!code-vb[System.Func~2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~2/vb/Example.vb#5)]  
  
 ]]></format>
    </remarks>
  </Docs>
</Type>
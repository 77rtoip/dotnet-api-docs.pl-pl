<Type Name="Enum" FullName="System.Enum">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b368eaa5eb272694f75de1cc458159e009de037c" />
    <Meta Name="ms.sourcegitcommit" Value="81d387351cc43c342755705908f4a5eb8af153d3" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/05/2018" />
    <Meta Name="ms.locfileid" Value="34758970" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Enum extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Enum" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Enum&#xA;Inherits ValueType&#xA;Implements IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Enum abstract : ValueType, IComparable, IConvertible, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia klasę podstawową dla wyliczenia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczenie to zbiór stałe nazwane, którego typ podstawowy jest dowolnego typu całkowitego. Jeśli żaden typ podstawowy jest jawnie zadeklarowana, <xref:System.Int32> jest używany. <xref:System.Enum> jest klasą bazową dla wszystkich wyliczenia w programie .NET Framework. Typy wyliczeniowe są definiowane przez `enum` — słowo kluczowe języka C# i `Enum`... `End Enum` utworzyć w języku Visual Basic.  
  
 <xref:System.Enum> udostępnia metody porównanie wystąpienia tej klasy, konwertowania wartości wystąpienia na jej reprezentację konwertowanie reprezentację liczby na wystąpienie tej klasy i tworzenia wystąpienia określonego wyliczenie i wartości.  
  
 Wyliczenie można również traktować jako pole bitowe. Aby uzyskać więcej informacji, zobacz [Non-wyłącznie elementy członkowskie i atrybut Flags](#Flags) sekcji i <xref:System.FlagsAttribute> tematu.  
  
 W tym temacie:  
  
 [Tworzenie typu wyliczenia](#Creating)   
 [Utworzenie wystąpienia typu wyliczenia](#Instantiating)   
 [Najlepsze rozwiązania w zakresie — wyliczenie](#BestPractices)   
 [Wykonywanie operacji z wyliczenia](#Operations)   
 [Wykonywania konwersji](#conversions)  
 [Podczas analizowania wartości wyliczenia](#parsing)  
 [Formatowanie wartości wyliczenia](#formatting)  
[Iteracja elementy członkowskie wyliczenia](#iterating)  
[Elementy Członkowskie inne niż na wyłączność i atrybut Flags](#Flags)  
[Dodawanie metod — wyliczenie](#methods)  
  
<a name="Creating"></a>   
## <a name="creating-an-enumeration-type"></a>Tworzenie typu wyliczenia  
 Języki programowania zwykle zawierają składni, aby zadeklarować wyliczenie zawiera zestaw stałe nazwane i ich wartości. Poniższy przykład przedstawia składnię wykorzystywaną przez C# i Visual Basic zdefiniowanie wyliczenia. Tworzy wyliczenie o nazwie `ArrivalStatus` mający trzech elementów członkowskich: `ArrivalStatus.Early`, `ArrivalStatus.OnTime`, i `ArrivalStatus.Late`. Należy pamiętać, że w obu przypadkach wyliczenia nie jawnie dziedziczy <xref:System.Enum>; relacji dziedziczenia jest niejawnie obsługiwane przez kompilator.  
  
 [!code-csharp[System.Enum.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#1)]
 [!code-vb[System.Enum.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#1)]  
  
> [!WARNING]
>  Nigdy nie należy utworzyć których typ podstawowy jest niecałkowity typ wyliczeniowy lub <xref:System.Char>. Chociaż typem wyliczenia można tworzyć przy użyciu odbicia, wywołania metody, które używają wynikowy typ są zawodne i może także zgłaszać dodatkowe wyjątki.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-an-enumeration-type"></a>Utworzenie wystąpienia typu wyliczenia  
 Można utworzyć wystąpienie typu wyliczenia tak samo, jak wystąpienia dowolnego typu wartości: deklarowanie zmiennej i przypisując jedną z wyliczenia do niego. Poniższy przykład tworzy `ArrivalStatus` o wartości `ArrivalStatus.OnTime`.  
  
 [!code-csharp[System.Enum.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#2)]
 [!code-vb[System.Enum.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#2)]  
  
 Można również utworzyć wystąpienie wartością wyliczenia w następujący sposób:  
  
-   Za pomocą funkcji określonym programowania w języku rzutowania (jak C#) lub przekonwertować (tak jak w języku Visual Basic) wartość całkowitą wartością wyliczenia. Poniższy przykład tworzy `ArrivalStatus` obiektu, którego wartość jest `ArrivalStatus.Early` w ten sposób.  
  
     [!code-csharp[System.Enum.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#4)]
     [!code-vb[System.Enum.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#4)]  
  
-   Przez wywołanie jego niejawne domyślnego konstruktora. Jak w poniższym przykładzie pokazano, w tym przypadku odpowiednia wartość wyliczenia wystąpienia jest 0. Jednak to nie jest zawsze wartość prawidłowej stałej w wyliczeniu.  
  
     [!code-csharp[System.Enum.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#3)]
     [!code-vb[System.Enum.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#3)]  
  
-   Wywołując <xref:System.Enum.Parse%2A> lub <xref:System.Enum.TryParse%2A> metodę, aby przeanalizować ciągu zawierającego nazwę stała w wyliczeniu. Aby uzyskać więcej informacji, zobacz [podczas analizowania wartości wyliczenia](#parsing) sekcji.  
  
-   Wywołując <xref:System.Enum.ToObject%2A> do przekonwertowania na typ wyliczeniowy wartością całkowitą. Aby uzyskać więcej informacji, zobacz [wykonywania konwersji](#conversions) sekcji.  
  
<a name="BestPractices"></a>   
## <a name="enumeration-best-practices"></a>Najlepsze rozwiązania w zakresie — wyliczenie  
 Zaleca się stosować następujące najlepsze rozwiązania, podczas definiowania Typy wyliczeniowe:  
  
-   Jeśli nie zdefiniowano elementu członkowskiego wyliczenia, którego wartość wynosi 0, należy rozważyć utworzenie `None` stała wyliczenia. Domyślnie pamięć używana na potrzeby wyliczenia jest ustawiana na wartość zero przez środowisko uruchomieniowe języka wspólnego. W związku z tym jeśli nie zostanie zdefiniowana stałą, którego wartość wynosi zero, wyliczenia będzie zawierać niedozwoloną wartość, po jego utworzeniu.  
  
-   W przypadku oczywiste domyślne działanie case, aby reprezentować, rozważ użycie wyliczany aplikacji stałej którego wartość wynosi zero do reprezentowania go. Jeśli nie ma żadnych domyślne działanie case, rozważ użycie Stała wyliczeniowa którego wartość wynosi zero, aby określić przypadek, który nie jest reprezentowany przez żadną wyliczone stałe.  
  
-   Nie określaj wyliczone stałe, które są zarezerwowane do użytku w przyszłości.  
  
-   Podczas definiowania metody lub właściwości, która ma stałą wyliczone jako wartość, należy wziąć pod uwagę sprawdzania poprawności wartości. Dzieje się tak można rzutować wartość liczbową na typ wyliczeniowy nawet, jeśli nie zdefiniowano wartości numerycznych w wyliczeniu.  
  
 Dodatkowe wskazówki na typy wyliczeniowe pola bitowe są stałe, których są wyświetlane w [Non-wyłącznie elementy członkowskie i atrybut Flags](#Flags) sekcji.  
  
<a name="Operations"></a>   
## <a name="performing-operations-with-enumerations"></a>Wykonywanie operacji z wyliczenia  
 Nie można definiować nowych metod tworzenia wyliczenia. Jednak typem wyliczenia dziedziczy kompletny zestaw statyczne i metody wystąpienia z <xref:System.Enum> klasy. Poniższe sekcje przeglądu większość tych metod, oprócz kilka metod, które są często używane podczas pracy z wartości wyliczenia.  
  
<a name="conversions"></a>   
### <a name="performing-conversions"></a>Wykonywania konwersji  
 Można konwertować między elementu członkowskiego wyliczenia i jego typem podstawowym za pomocą rzutowanie (w języku C#) lub operatora konwersji (w języku Visual Basic). W poniższym przykładzie użyto operatory rzutowania lub konwersji do wykonywania konwersji zarówno z liczby całkowitej w celu wartością wyliczenia i z wartością wyliczenia na liczbę całkowitą.  
  
 [!code-csharp[System.Enum.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#5)]
 [!code-vb[System.Enum.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#5)]  
  
 <xref:System.Enum> Zawiera również klasy <xref:System.Enum.ToObject%2A> metodę, która konwertuje wartość typu całkowitego na wartość wyliczenia. W poniższym przykładzie użyto <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29> metodę, aby przekonwertować <xref:System.Int32> do `ArrivalStatus` wartości. Należy zauważyć, że ponieważ <xref:System.Enum.ToObject%2A> zwraca wartość typu <xref:System.Object>, użyj operatora rzutowania lub konwersji nadal może być konieczne można rzutować obiektu na typ wyliczeniowy.  
  
 [!code-csharp[System.Enum.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#6)]
 [!code-vb[System.Enum.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#6)]  
  
 Podczas konwersji całkowitą wartością wyliczenia, jest można przypisać wartość, która nie jest rzeczywiście członkiem wyliczenia. Aby tego uniknąć, można przekazać liczby całkowitej w celu <xref:System.Enum.IsDefined%2A> metoda przed przeprowadzeniem konwersji. W poniższym przykładzie użyto tej metody, aby określić, czy elementy w tablicy wartości będące liczbami całkowitymi można przekonwertować na `ArrivalStatus` wartości.  
  
 [!code-csharp[System.Enum.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion1.cs#7)]
 [!code-vb[System.Enum.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion1.vb#7)]  
  
 Mimo że <xref:System.Enum> klasa zawiera jawne implementacje interfejsu z <xref:System.IConvertible> interfejs dla konwersji z wartości wyliczenia na typ całkowity, należy użyć metody <xref:System.Convert> klas, takich jak <xref:System.Convert.ToInt32%2A>, do Wykonaj te konwersji. Poniższy przykład przedstawia, jak używasz <xref:System.Enum.GetUnderlyingType%2A> metody wraz z programem <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> metodę, aby przekonwertować wartość wyliczenia na jego typ podstawowy. Należy pamiętać, że w tym przykładzie nie wymaga z typem podstawowym typu wyliczania znane w czasie kompilacji.  
  
 [!code-csharp[System.Enum.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion2.cs#8)]
 [!code-vb[System.Enum.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion2.vb#8)]  
  
<a name="parsing"></a>   
### <a name="parsing-enumeration-values"></a>Podczas analizowania wartości wyliczenia  
 <xref:System.Enum.Parse%2A> i <xref:System.Enum.TryParse%2A> metody umożliwiają konwertowanie reprezentacja ciągu wartości wyliczenia z tą wartością. Reprezentacja ciągu może być nazwa lub odpowiednia wartość stałej wyliczenia. Należy zwrócić uwagę, metody analizy pomyślnie przekonwertuje reprezentacje ciąg liczb, które nie są członkami określonej wyliczenia, jeśli ciągi można konwertować na wartość typ podstawowy wyliczenia. Aby temu zapobiec, <xref:System.Enum.IsDefined%2A> można wywołać metody w celu zapewnienia wartość wyliczenia nieprawidłowy wynik metody analizy. W przykładzie pokazano tego podejścia i przedstawiono oba wywołania <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> i <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29?displayProperty=nameWithType> metody. Należy pamiętać, że nieogólną metodę analizowania zwraca obiekt, który może być konieczne rzutowanie (C#) lub przekonwertować (w języku Visual Basic) na typ wyliczeniowy odpowiednie.  
  
 [!code-csharp[System.Enum.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classparse1.cs#9)]
 [!code-vb[System.Enum.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classparse1.vb#9)]  
  
<a name="formatting"></a>   
### <a name="formatting-enumeration-values"></a>Formatowanie wartości wyliczenia  
 Można przekonwertować wartości wyliczenia ich oświadczenia ciąg przez wywołanie metody statycznych <xref:System.Enum.Format%2A> metody, a także przeciążenia wystąpienia <xref:System.Enum.ToString%2A> metody. Ciąg formatu służy do kontrolowania sposobu dokładne, w którym wartość wyliczenia jest reprezentowany jako ciąg. Aby uzyskać więcej informacji, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md). W poniższym przykładzie użyto każdej z obsługiwanych wyliczanie ciągów formatujących ("G" lub "g", "D" lub "d", "X" lub "x" i "F" lub "f") można przekonwertować członkiem `ArrivalStatus` wyliczeniu, aby jej reprezentacji ciągu.  
  
 [!code-csharp[System.Enum.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classformat1.cs#10)]
 [!code-vb[System.Enum.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classformat1.vb#10)]  
  
<a name="iterating"></a>   
### <a name="iterating-enumeration-members"></a>Iteracja elementy członkowskie wyliczenia  
 <xref:System.Enum> Typ nie implementuje <xref:System.Collections.IEnumerable> lub <xref:System.Collections.Generic.IEnumerable%601> interfejsu, które umożliwią przejść elementów członkowskich kolekcji za pomocą `foreach` (w języku C#) lub `For Each` (w języku Visual Basic) należy utworzyć. Jednak można wyliczyć elementów członkowskich na dwa sposoby.  
  
-   Możesz wywołać <xref:System.Enum.GetNames%2A> metoda pobierania tablica ciągów zawierająca nazwy elementy członkowskie wyliczenia. Następnie dla każdego elementu w tablicy ciągów, należy wywołać <xref:System.Enum.Parse%2A> metodę, aby przekonwertować ciągu na wartość wyliczenia równoważne. To podejście pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Enum.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#11)]
     [!code-vb[System.Enum.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#11)]  
  
-   Możesz wywołać <xref:System.Enum.GetValues%2A> metoda pobierania tablicę zawierającą podstawową wartości w wyliczeniu. Następnie dla każdego elementu tablicy, należy wywołać <xref:System.Enum.ToObject%2A> metodę, aby przekonwertować na wartość wyliczenia równoważne do liczby całkowitej. To podejście pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Enum.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#12)]
     [!code-vb[System.Enum.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#12)]  
  
<a name="Flags"></a>   
## <a name="non-exclusive-members-and-the-flags-attribute"></a>Elementy Członkowskie inne niż na wyłączność i atrybut Flags  
 Jeden zazwyczaj wyliczenie jest używane do reprezentowania zestaw wartości wykluczają się wzajemnie. Na przykład `ArrivalStatus` wystąpienie może mieć wartość `Early`, `OnTime`, lub `Late`. Nie ma sensu dla wartości `ArrivalStatus` wystąpienia, aby odzwierciedlić więcej niż jeden stała wyliczenia.  
  
 W innych przypadkach należy jednak wartość obiektu wyliczenia może zawierać wiele elementy członkowskie wyliczenia i każdy element członkowski reprezentuje pole bitowe wartości wyliczenia. <xref:System.FlagsAttribute> Atrybut może służyć do wskazują, że wyliczenia składa się z bitowego pól. Na przykład wyliczeń o nazwie `Pets` może używać do określenia rodzaje zwierząt domowych w gospodarstwo domowe. Mogą być zdefiniowane w następujący sposób.  
  
 [!code-csharp[System.Enum.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#13)]
 [!code-vb[System.Enum.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#13)]  
  
 `Pets` Wyliczenia mogą być następnie używane jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Enum.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#14)]
 [!code-vb[System.Enum.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#14)]  
  
 Następujące najlepsze rozwiązania stosuje się podczas definiowania bitowej wyliczenie i stosowanie <xref:System.FlagsAttribute> atrybutu.  
  
-   Użyj <xref:System.FlagsAttribute> atrybutu niestandardowego wyliczania tylko wtedy, gdy operacja bitowa (AND, OR wyłączne lub) ma zostać wykonane na wartość liczbową.  
  
-   Zdefiniuj wyliczenie stałe w potęgami liczby dwa, oznacza to, 1, 2, 4, 8 i tak dalej. Oznacza to, że indywidualne flagi w stałych Scalonej wyliczenia nie mogą się pokrywać.  
  
-   Należy rozważyć utworzenie wyliczany stała dla często używanych flagi kombinacji. Na przykład, jeśli masz wyliczenie używane dla operacji We/Wy pliku zawierającego stałych wyliczeniowych `Read = 1` i `Write = 2`, należy rozważyć utworzenie Stała wyliczeniowa `ReadWrite = Read OR Write`, który łączy `Read` i `Write` flagi. Ponadto używane do łączenia z flagami operacji lub może zostać uznane za zaawansowane koncepcji w pewnych okolicznościach, które nie powinny być wymagane dla prostych zadań.  
  
-   Należy zachować ostrożność, jeśli zdefiniować liczbą ujemną jako stała wyliczenia flag, ponieważ wielu pozycji flagi może być ustawiony na 1, co może zwiększyć mylące kodu i zachęca błędy kodowania.  
  
-   Jest to wygodny sposób sprawdzić, czy ustawiono flagę w wartość liczbową wywołać wystąpienie <xref:System.Enum.HasFlag%2A> metody, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Enum.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#15)]
     [!code-vb[System.Enum.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#15)]  
  
     Odpowiada to wykonywanie operacji i między wartość liczbową i stała wyliczenia flagi, ustawiająca wszystkie bity w wartość liczbową na zero, które nie odpowiadają flagi, a następnie sprawdzenie, czy wynik tej operacji jest równa Flaga wyliczyć stała. Jest to zilustrowane w poniższym przykładzie.  
  
     [!code-csharp[System.Enum.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#16)]
     [!code-vb[System.Enum.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#16)]  
  
-   Użyj `None` jako nazwa flagi wyliczyć stała, którego wartość wynosi zero. Nie można użyć `None` stała wyliczenia w operacji i do testowania dla flagi, ponieważ wynik to zawsze zero. Jednak można wykonać operatorów logicznych, nie bitowe, porównania wartości liczbowych i `None` stała wyliczany można określić, czy wszystkie bity w wartość liczbową zostały ustawione. Jest to zilustrowane w poniższym przykładzie.  
  
     [!code-csharp[System.Enum.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#17)]
     [!code-vb[System.Enum.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#17)]  
  
-   Definiuje wartości wyliczenia wyłącznie w celu utworzenia duplikatów stan wyliczenia sam. Na przykład nie definiują wyliczany stałą, której jedynie oznacza koniec wyliczenia. Jeśli trzeba określić ostatniej wartości wyliczenia, sprawdź jawnie dla tej wartości. Ponadto można wykonać sprawdzania zakresu stała wyliczenia imię i nazwisko, jeśli wszystkie wartości w zakresie są prawidłowe.  
  
<a name="methods"></a>   
## <a name="adding-enumeration-methods"></a>Dodawanie metod — wyliczenie  
 Ponieważ Typy wyliczeniowe są zdefiniowane przez struktury języka, takich jak `enum` (C#) i `Enum` (Visual Basic), nie można definiować niestandardowe metody dla typu wyliczenia innych niż te dziedziczone z metody <xref:System.Enum> klasy.  Jednak można użyć metody rozszerzenia Dodawanie funkcji do typu konkretnego wyliczenia.  
  
 W poniższym przykładzie `Grades` wyliczenie reprezentuje klas możliwych list, które student może pojawić się w klasie. Metody rozszerzenia o nazwie `Passing` jest dodawany do `Grades` wpisz, aby każde wystąpienie tego typu teraz "wie" czy reprezentuje klasy przekazywanie, czy nie.       `Extensions` Klasa zawiera także statyczne zmiennej odczytu i zapisu, która definiuje klasy minimalna przekazywanie. Wartość zwracana `Passing` — metoda rozszerzenia odzwierciedla bieżącą wartość tej zmiennej.  
  
 [!code-csharp[System.Enum.Class#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/Extensions.cs#18)]
 [!code-vb[System.Enum.Class#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/Extensions.vb#18)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, do reprezentowania nazwanych wartości i innym wyliczenie do reprezentowania pola bitowe o nazwie przy użyciu wyliczania.  
  
 [!code-cpp[enummain#1](~/samples/snippets/cpp/VS_Snippets_CLR/enummain/CPP/EnumMain.cpp#1)]
 [!code-csharp[enummain#1](~/samples/snippets/csharp/VS_Snippets_CLR/enummain/CS/EnumMain.cs#1)]
 [!code-vb[enummain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enummain/VB/EnumMain.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.ValueType" />
    <altmember cref="T:System.FlagsAttribute" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Enum ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Enum();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Enum" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (target As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ target);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt do porównania, lub <see langword="null" />.</param>
        <summary>Porównuje to wystąpienie z określonym obiektem i zwraca wskazanie ich względnych wartości.</summary>
        <returns>Podpisem liczba, która określa względne wartości tego wystąpienia i <paramref name="target" />.  
  
 <list type="table"><listheader><term> Wartość </term><description> znaczenie </description></listheader><item><term> mniejsza od zera </term><description> wartość tego wystąpienia jest mniejsza niż wartość <paramref name="target" />.  </description></item><item><term> Zero </term><description> wartość tego wystąpienia jest równa wartości <paramref name="target" />.  </description></item><item><term> Większa od zera </term><description> wartość tego wystąpienia jest większa niż wartość <paramref name="target" />.  - lub - <paramref name="target" /> jest <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia użycie `CompareTo` w kontekście `Enum`.  
  
 [!code-cpp[enumcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumcompareto/CPP/EnumCompareTo.cpp#1)]
 [!code-csharp[enumcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumcompareto/CS/EnumCompareTo.cs#1)]
 [!code-vb[enumcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumcompareto/VB/EnumCompareTo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> i to wystąpienie nie są tego samego typu.</exception>
        <exception cref="T:System.InvalidOperationException">To wystąpienie nie jest typem <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" />, lub <see cref="T:System.UInt64" />.</exception>
        <altmember cref="M:System.Enum.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest wartością wyliczenia tego samego typu i o tej samej wartości podstawowej jako tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.Equals%28System.Object%29?displayProperty=nameWithType> Przesłonięcia metody <xref:System.ValueType.Equals%28System.Object%29?displayProperty=nameWithType> Aby zdefiniować sposób elementy członkowskie wyliczenia są oceniane pod kątem równości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Enum.Equals%2A> metody.  
  
 [!code-cpp[enumequals#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumequals/CPP/EnumEquals.cpp#1)]
 [!code-csharp[enumequals#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumequals/CS/EnumEquals.cs#1)]
 [!code-vb[enumequals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumequals/VB/EnumEquals.vb#1)]  
  
 W poniższym przykładzie zdefiniowano dwa typy wyliczeniowe, `SledDog` i `WorkDog`. `SledDog` Wyliczenie ma dwa elementy członkowskie, `SledDog.AlaskanMalamute` i `SledDog.Malamute`, które mają taką samą wartość podstawowej. Wywołanie <xref:System.Enum.Equals%2A> — metoda wskazuje, że te wartości są takie same, ponieważ ich wartości bazowe są takie same. `SledDog.Malamute` i `WorkDog.Newfoundland` elementów członkowskich mają taką samą wartość podstawowej, mimo że reprezentują wyliczenie różnych typów. Wywołanie <xref:System.Enum.Equals%2A> — metoda wskazuje, że te wartości nie są takie same.  
  
 [!code-csharp[System.Enum.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.equals/cs/enumequals.cs#1)]
 [!code-vb[System.Enum.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.equals/vb/enumequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Enum.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (Type enumType, object value, string format);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.Type enumType, object value, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Format(System.Type,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (enumType As Type, value As Object, format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(Type ^ enumType, System::Object ^ value, System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczenia wartości do konwersji.</param>
        <param name="value">Wartość do konwersji.</param>
        <param name="format">Format danych wyjściowych do użycia.</param>
        <summary>Konwertuje określoną wartość określonego typu wyliczeniowego do reprezentacji ciągu równoważne zgodnie z określonym formacie.</summary>
        <returns>Reprezentacja ciągu <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono prawidłowe wartości dla `format` parametru.  
  
|Format|Opis|  
|------------|-----------------|  
|„G” lub „g”|Jeśli `value` jest równy nazwanej stałej wyliczenia, nazwa tej stałej jest zwracane; w przeciwnym razie wartość dziesiętną z `value` jest zwracany.<br /><br /> Na przykład załóżmy, że tylko stała wyliczenia nosi nazwę czerwony, a jego wartość wynosi 1. Jeśli `value` jest określony jako 1, ten format zwraca "Red". Jednak jeśli `value` jest określony jako 2, ten format zwraca "2".<br /><br /> —lub—<br /><br /> Jeśli <xref:System.FlagsAttribute> niestandardowy atrybut jest stosowany do wyliczenia, `value` jest traktowany jako pola bitowego, która zawiera jedną lub więcej flag, które składają się z jednego lub więcej bitów.<br /><br /> Jeśli `value` jest równe kombinację o nazwie wyliczone stałe, listę nazw tych stałych rozdzielonych ogranicznik jest zwracany. `value` jest wyszukiwany flagi zamierza najmniejszą wartość z flagą o największej wartości. Dla każdego Flaga, która odnosi się do pola bitowego w `value`, nazwa stałej jest połączony do listy rozdzielonych ogranicznika. Wartość tej flagi jest wykluczany z dalszych brany pod uwagę, a wyszukiwanie jest kontynuowane flagę dalej.<br /><br /> Jeśli `value` nie jest równa kombinację stałych wyliczeniowych dziesiętną o nazwie `value` jest zwracany.|  
|„X” lub „x”|Reprezentuje `value` w formacie szesnastkowym bez znaków "0 x".|  
|„D” lub „d”|Reprezentuje `value` w formie dziesiętnej.|  
|„F” lub „f”|Zachowuje się tak samo "G" lub "g", z wyjątkiem <xref:System.FlagsAttribute> nie musi znajdować się na <xref:System.Enum> deklaracji.|  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Format` w kontekście `Enum`.  
  
 [!code-cpp[enumformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumformat/CPP/EnumFormat.cpp#1)]
 [!code-csharp[enumformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumformat/CS/EnumFormat.cs#1)]
 [!code-vb[enumformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumformat/VB/EnumFormat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" />, <paramref name="value" />, Lub <paramref name="format" /> parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Parametr nie jest <see cref="T:System.Enum" /> typu.  - lub - <paramref name="value" /> jest z poziomu wyliczenia, która różni się w typie z <paramref name="enumType" />.  - lub - typ <paramref name="value" /> nie jest typem podstawowym typu <paramref name="enumType" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> Parametrów zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> równa się "X", ale typ wyliczeniowy jest nieznany.</exception>
        <altmember cref="M:System.Enum.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla wartości tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetName(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetName(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (enumType As Type, value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(Type ^ enumType, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczenia.</param>
        <param name="value">Wartość określonej stałej wyliczenia pod względem jego typem podstawowym.</param>
        <summary>Pobiera nazwę stała w wyliczeniu określony, która ma określoną wartość.</summary>
        <returns>Ciąg zawierający nazwę stała wyliczenia w <paramref name="enumType" /> o wartości <paramref name="value" />; lub <see langword="null" /> przypadku nieznalezienia takie stałej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wiele elementy członkowskie wyliczenia mają taką samą wartość podstawowej, <xref:System.Enum.GetName%2A> metoda gwarantuje, że zwróci nazwę jednego z tych elementy członkowskie wyliczenia. Jednak go nie gwarantuje, że zawsze zwróci nazwę elementu członkowskiego wyliczenia. W związku z tym po wielu elementy członkowskie wyliczenia mają taką samą wartość, kod aplikacji powinno nigdy nie zależą od metody zwraca nazwę określonego elementu członkowskiego.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `GetName`.  
  
 [!code-cpp[enumgetname#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetname/CPP/EnumGetName.cpp#1)]
 [!code-csharp[enumgetname#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetname/CS/EnumGetName.cs#1)]
 [!code-vb[enumgetname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetname/VB/EnumGetName.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> lub <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.  - lub - <paramref name="value" /> nie jest ani typu <paramref name="enumType" /> ani nie ma ten sam typ podstawowy jako <paramref name="enumType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNames">
      <MemberSignature Language="C#" Value="public static string[] GetNames (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetNames(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetNames(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNames (enumType As Type) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetNames(Type ^ enumType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczenia.</param>
        <summary>Pobiera tablicę nazw stałych w określonym wyliczenia.</summary>
        <returns>Tablica ciągów nazw stałe <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy tablicy zwracanej wartości są sortowane według wartości binarne dla stałych wyliczeniowych (to znaczy przez ich wielkość bez znaku). W poniższym przykładzie przedstawiono Wyświetla informacje o tablica zwrócona przez <xref:System.Enum.GetNames%2A> — metoda wyliczania zawierające ujemny, zero oraz wartość dodatnią.  
  
 [!code-csharp[System.Enum.GetNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getnames/cs/getnames1.cs#1)]
 [!code-vb[System.Enum.GetNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getnames/vb/getnames1.vb#1)]  
  
 W przypadku stałych wyliczeniowych o tej samej wartości kolejności odpowiadających im nazw jest nieokreślony.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Enum.GetNames%2A> metody.  
  
 [!code-cpp[enumgetnames#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetnames/CPP/EnumGetNames.cpp#1)]
 [!code-csharp[enumgetnames#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetnames/CS/EnumGetNames.cs#1)]
 [!code-vb[enumgetnames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetnames/VB/EnumGetNames.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Parametr nie jest <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod typu typ bazowy tego typu wyliczeniowego.</summary>
        <returns>Kod typu typu bazowego dla tego wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Typ wyliczeniowy jest nieznany.</exception>
        <altmember cref="M:System.Enum.GetUnderlyingType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnderlyingType">
      <MemberSignature Language="C#" Value="public static Type GetUnderlyingType (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetUnderlyingType(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetUnderlyingType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnderlyingType (enumType As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetUnderlyingType(Type ^ enumType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Wyliczenie, którego typem podstawowym zostaną pobrane.</param>
        <summary>Zwraca typ podstawowy wyliczenia określony.</summary>
        <returns>Typ podstawowy elementu <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum> Struktury umożliwia wartości może być reprezentowana jako stałe nazwane. Typ danych wartości wyliczenia nosi nazwę jego typem podstawowym. Na przykład typ bazowy <xref:System.DayOfWeek> wyliczenia, która składa się z stałe, które reprezentują każdego dnia tygodnia (<xref:System.DayOfWeek.Monday?displayProperty=nameWithType>, <xref:System.DayOfWeek.Tuesday?displayProperty=nameWithType>i tak dalej), jest <xref:System.Int32>.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Enum.GetUnderlyingType%2A> metodę, aby wyświetlić podstawowy typ niektóre elementy członkowskie wyliczenia.  
  
 [!code-csharp[System.Enum.GetUnderlyingType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getunderlyingtype/cs/getunderlyingtype1.cs#1)]
 [!code-vb[System.Enum.GetUnderlyingType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getunderlyingtype/vb/getunderlyingtype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.GetTypeCode" />
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public static Array GetValues (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array GetValues(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetValues(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValues (enumType As Type) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ GetValues(Type ^ enumType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczenia.</param>
        <summary>Pobiera tablicę wartości stałe w określonym wyliczenia.</summary>
        <returns>Tablica zawierająca wartości stałe w <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy tablicy są sortowane według wartości binarne stałych — wyliczenie (to znaczy przez ich wielkość bez znaku). W poniższym przykładzie przedstawiono informacje o tablica zwrócona przez <xref:System.Enum.GetValues%2A> — metoda wyliczania zawierające wartości ujemnej, zero oraz wartość dodatnią.  
  
 [!code-csharp[System.Enum.GetValues#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues1.cs#1)]
 [!code-vb[System.Enum.GetValues#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues1.vb#1)]  
  
 <xref:System.Enum.GetValues%2A> Metoda zwraca tablicę, która zawiera wartość dla każdego członka `enumType` wyliczenia. Jeśli wiele elementów członkowskich mają taką samą wartość, zwracana tablica zawiera zduplikowane wartości. W takim przypadku wywoływania <xref:System.Enum.GetName%2A> metody z każdej wartości w tablicy zwracane nie przywraca unikatowych nazw przypisane do elementów członkowskich, które mają zduplikowane wartości. Aby pomyślnie pobrać wszystkie elementy członkowskie wyliczenia nazw, należy wywołać <xref:System.Enum.GetNames%2A> metody.  
  
 <xref:System.Enum.GetValues%2A> Nie można wywołać metody przy użyciu odbicia w kontekstu reflection-only. Zamiast tego można pobrać wartość wszystkie elementy członkowskie wyliczenia za pomocą <xref:System.Type.GetFields%2A?displayProperty=nameWithType> metody, aby uzyskać tablicę <xref:System.Reflection.FieldInfo> obiektów, które reprezentują elementy członkowskie wyliczenia, a następnie wywołać <xref:System.Reflection.FieldInfo.GetRawConstantValue%2A?displayProperty=nameWithType> metody na każdy element tablicy. Poniższy przykład przedstawia tej metody. Zdefiniuj wyliczenie następujące w zestawie o nazwie Enumerations.dll wymaga:  
  
 [!code-csharp[System.Enum.GetValues#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#2)]
 [!code-vb[System.Enum.GetValues#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#2)]  
  
 Zestaw został załadowany w kontekście tylko odbicie <xref:System.Type> obiekt, który reprezentuje `Pets` wystąpienia wyliczenie tablicę <xref:System.Reflection.FieldInfo> obiekty są pobierane i wartości pól są wyświetlane w konsoli.  
  
 [!code-csharp[System.Enum.GetValues#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#3)]
 [!code-vb[System.Enum.GetValues#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#3)]  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Enum.GetValues%2A>.  
  
 [!code-cpp[enumgetvalues#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetvalues/CPP/EnumGetValues.cpp#1)]
 [!code-csharp[enumgetvalues#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetvalues/CS/EnumGetValues.cs#1)]
 [!code-vb[enumgetvalues#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetvalues/VB/EnumGetValues.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda jest wywoływana przez odbicie w kontekstu reflection-only - lub - <paramref name="enumType" /> załadowaniu typu z zestawu w kontekstu reflection-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasFlag">
      <MemberSignature Language="C#" Value="public bool HasFlag (Enum flag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasFlag(class System.Enum flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.HasFlag(System.Enum)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasFlag (flag As Enum) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasFlag(Enum ^ flag);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Enum" />
      </Parameters>
      <Docs>
        <param name="flag">Wartość wyliczenia.</param>
        <summary>Określa, czy co najmniej jedno pole bitowe są ustawione w bieżącego wystąpienia.</summary>
        <returns>
          <see langword="true" /> Jeśli pole bitowe lub bitowego pola, które są ustawiane w <paramref name="flag" /> również są ustawione w bieżącym wystąpieniu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.HasFlag%2A> Metoda zwraca wynik następujące wyrażenie warunkowe.  
  
```  
thisInstance And flag = flag   
```  
  
 Jeśli podstawową wartość `flag` wynosi zero, metoda zwraca `true`. Jeśli to zachowanie nie jest pożądane, możesz użyć <xref:System.Enum.Equals%2A> metody do testowania pod kątem równości zero i wywołanie <xref:System.Enum.HasFlag%2A> tylko wtedy, gdy podstawowa wartość `flag` jest równa zero, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Enum.HasFlag#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag0.cs#1)]
 [!code-vb[System.Enum.HasFlag#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag0.vb#1)]  
  
 <xref:System.Enum.HasFlag%2A> Metoda jest przeznaczona do użycia z typów wyliczenia, które są oznaczone ikoną z <xref:System.FlagsAttribute> atrybutu i może służyć do określenia, czy ustawiono wiele pól bitowych. Dla typów wyliczenia, które nie są oznaczone ikoną z <xref:System.FlagsAttribute> atrybutu, albo wywoływać <xref:System.Enum.Equals%2A> metody lub <xref:System.Enum.CompareTo%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `ItemsOrdered` wyliczenie odzwierciedlający kategorii elementy, które klient można uporządkować w restauracji. Przykład sprawdza, czy klient ma uporządkowane zarówno entrée, jak i napój.  
  
 [!code-csharp[System.Enum.HasFlag#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag1.cs#2)]
 [!code-vb[System.Enum.HasFlag#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="flag" /> jest innego typu niż bieżące wystąpienie.</exception>
        <altmember cref="T:System.FlagsAttribute" />
        <altmember cref="M:System.Enum.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public static bool IsDefined (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefined(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.IsDefined(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefined (enumType As Type, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefined(Type ^ enumType, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczenia.</param>
        <param name="value">Wartość lub nazwa stałej w <c>enumType</c>.</param>
        <summary>Zwraca wartość typu Boolean określającą czy podanej wartości całkowitych lub jego nazwę w postaci ciągu, istnieje w wyliczeniu określony.</summary>
        <returns>
          <see langword="true" /> Jeśli stała w <paramref name="enumType" /> ma wartość równą <paramref name="value" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr może być jedną z następujących czynności:  
  
-   Dowolny element członkowski typu `enumType`.  
  
-   Zmienna, którego wartość jest elementu członkowskiego wyliczenia typu `enumType`.  
  
-   Reprezentacja ciągu nazwy elementu członkowskiego wyliczenia. Znaki w ciągu musi mieć tej samej litery jako nazwa elementu członkowskiego wyliczenia.  
  
-   Wartość typu bazowego dla `enumType`.  
  
 Jeśli stałe `enumType` zdefiniować zestaw pól bitowych i `value` zawiera wartości nazwy i wartości podstawowych wielu pól bitowych, <xref:System.Enum.IsDefined%2A> metoda zwraca `false`. Innymi słowy, w przypadku wyliczenia, które definiują zestaw pól bitowych, Metoda określa tylko czy pola bitowego pojedynczego należy do wyliczenia. Aby ustalić, czy wiele pól bitowych są ustawione w typem wyliczenia, które są oznaczone <xref:System.FlagsAttribute> atrybutu, należy wywołać <xref:System.Enum.HasFlag%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyliczenie o nazwie `PetType` składający się z bitowego poszczególnych pól. Następnie wywołuje <xref:System.Enum.IsDefined%2A> metody z wartości wyliczenia, ciąg nazwy i wartości złożonego wynikających z wielu pól bitowych ustawienie to możliwe.  
  
 [!code-csharp[System.Enum.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.IsDefined/cs/isdefined1.cs#1)]
 [!code-vb[System.Enum.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.IsDefined/vb/IsDefined1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> lub <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see langword="Enum" />.  - lub - typ <paramref name="value" /> jest wyliczeniem, ale nie jest wyliczenia typu <paramref name="enumType" />.  - lub - typ <paramref name="value" /> nie jest typem podstawowym typu <paramref name="enumType" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> nie jest typem <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" />, lub <see cref="T:System.UInt64" />, lub <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Jeśli <paramref name="enumType" /> jest wyliczeniem, która jest zdefiniowana za pomocą <see cref="T:System.FlagsAttribute" /> atrybutu, metoda zwraca <see langword="false" /> Jeśli bit wiele pól w <paramref name="value" /> są ustawione, ale <paramref name="value" /> nie odpowiada wartość wyliczenia złożonego lub, jeśli <paramref name="value" /> jest ciągów nazw wiele flag bitowych. W poniższym przykładzie <c>zwierząt domowych</c> wyliczenie zdefiniowano z <see cref="T:System.FlagsAttribute" /> atrybutu. <see cref="M:System.Enum.IsDefined(System.Type,System.Object)" /> Metoda zwraca <see langword="false" /> gdy przekazujesz ją wartością wyliczenia z bitowego dwa pola (<c>Pets.Dog</c> i <c>Pets.Cat</c>) ustawiona, i gdy przekazujesz ją reprezentację ciągu, który Wartość wyliczenia ("Dog, Cat").  [! kodu csharp [System.Enum.IsDefined#2] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. Enum.IsDefined/cs/isdefined2.cs#2)] [! kodu vb [System.Enum.IsDefined#2] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. Enum.IsDefined/vb/isdefined2.vb#2)] można określić, czy wiele pól bitowych są ustawiane przez wywołanie metody <see cref="M:System.Enum.HasFlag(System.Enum)" /> metody.</para>
        </block>
        <altmember cref="M:System.Enum.GetName(System.Type,System.Object)" />
        <altmember cref="M:System.Enum.GetNames(System.Type)" />
        <altmember cref="M:System.Enum.GetValues(System.Type)" />
        <altmember cref="M:System.Enum.HasFlag(System.Enum)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje ciąg znaków reprezentujący nazwę lub wartość liczbową jednej lub więcej stałych wyliczeniowych dla równoważnego obiektu wyliczanego.</summary>
        <altmember cref="M:System.Enum.TryParse``1(System.String,``0@)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (enumType As Type, value As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(Type ^ enumType, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczenia.</param>
        <param name="value">Ciąg zawierający nazwę lub wartość do przekonwertowania.</param>
        <summary>Konwertuje ciąg znaków reprezentujący nazwę lub wartość liczbową jednej lub więcej stałych wyliczeniowych dla równoważnego obiektu wyliczanego.</summary>
        <returns>Obiekt typu <paramref name="enumType" /> którego wartość jest reprezentowana przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr zawierający reprezentację ciągu odpowiednia wartość elementu członkowskiego wyliczenia lub nazwanej stałej lub listę o nazwie stałe rozdzielonych przecinkami (,). Co najmniej jeden spacje można przed lub po każdej wartości, nazwa lub przecinkami w `value`. Jeśli `value` listę, jest zwracana wartość jest wartością określonej nazwy połączeniu z bitowego `OR` operacji.  
  
 Jeśli `value` jest nazwą, która nie odpowiada nazwanej stałej z `enumType`, metoda wygeneruje <xref:System.ArgumentException>. Jeśli `value` jest liczba całkowita, która nie stanowi podstawową wartość reprezentację ciągu `enumType` wyliczenia, metoda zwraca wartość elementu członkowskiego wyliczenia, których wartości podstawowej jest `value` przekonwertować na typ całkowity. Jeśli to zachowanie jest niepożądane, wywołanie <xref:System.Enum.IsDefined%2A> metody w celu zapewnienia reprezentację ciągu określonego typu integer faktycznie członkiem `enumType`. W poniższym przykładzie zdefiniowano `Colors` wyliczenia, wywołania <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> Konwertowanie ciągów na odpowiadające im wartości wyliczenia i wywołania metody <xref:System.Enum.IsDefined%2A> metody, aby upewnić się, że określonej wartości całkowitych na wartości są bazowy wartości w `Colors` wyliczenia.  
  
 [!code-csharp[System.Enum.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample1.cs#1)]
 [!code-vb[System.Enum.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample1.vb#1)]  
  
 Ta operacja jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> metodę, aby przeanalizować tablicą ciągów, które są tworzone przez wywołanie metody <xref:System.Enum.GetNames%2A> metody. Ponadto użyto <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> metody, można przeanalizować wartości wyliczenia, która składa się z polem bitowym.  
  
 [!code-cpp[enumparse#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumparse/CPP/EnumParse.cpp#1)]
 [!code-csharp[enumparse#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumparse/CS/EnumParse.cs#1)]
 [!code-vb[enumparse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumparse/VB/EnumParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> lub <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.  - lub - <paramref name="value" /> jest ciągiem pustym lub zawiera tylko biały znak.  - lub - <paramref name="value" /> nazwę, ale nie jest elementem stałe nazwane zdefiniowane dla wyliczenia.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> znajduje się poza zakresem typu bazowego dla <paramref name="enumType" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (enumType As Type, value As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(Type ^ enumType, System::String ^ value, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczenia.</param>
        <param name="value">Ciąg zawierający nazwę lub wartość do przekonwertowania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter; <see langword="false" /> uznanie case.</param>
        <summary>Konwertuje ciąg znaków reprezentujący nazwę lub wartość liczbową jednej lub więcej stałych wyliczeniowych dla równoważnego obiektu wyliczanego. Parametr określa, czy operacja jest rozróżniana wielkość liter.</summary>
        <returns>Obiekt typu <paramref name="enumType" /> którego wartość jest reprezentowana przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr zawierający reprezentację ciągu odpowiednia wartość elementu członkowskiego wyliczenia lub nazwanej stałej lub listę o nazwie stałe rozdzielonych przecinkami (,). Co najmniej jeden spacje można przed lub po każdej wartości, nazwa lub przecinkami w `value`. Jeśli `value` listę, jest zwracana wartość jest wartością określonej nazwy połączeniu z bitowego `OR` operacji.  
  
 Jeśli `value` jest nazwą, która nie odpowiada nazwanej stałej z `enumType`, metoda wygeneruje <xref:System.ArgumentException>. Jeśli `value` jest liczba całkowita, która nie stanowi podstawową wartość reprezentację ciągu `enumType` wyliczenia, metoda zwraca wartość elementu członkowskiego wyliczenia, których wartości podstawowej jest `value` przekonwertować na typ całkowity. Jeśli to zachowanie jest niepożądane, wywołanie <xref:System.Enum.IsDefined%2A> metody w celu zapewnienia reprezentację ciągu określonego typu integer faktycznie członkiem `enumType`. W poniższym przykładzie zdefiniowano `Colors` wyliczenia, wywołania <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> Konwertowanie ciągów na odpowiadające im wartości wyliczenia i wywołania metody <xref:System.Enum.IsDefined%2A> metody, aby upewnić się, że określonej wartości całkowitych na wartości są bazowy wartości w `Colors` wyliczenia.  
  
 [!code-csharp[System.Enum.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 `ignoreCase` Parametr określa, czy ta operacja jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> metodę, aby przeanalizować tablicą ciągów, które są tworzone przez wywołanie metody <xref:System.Enum.GetNames%2A> metody. Ponadto użyto <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> metody, można przeanalizować wartości wyliczenia, która składa się z polem bitowym.  
  
 [!code-csharp[System.Enum.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> lub <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.  - lub - <paramref name="value" /> jest pustym ciągiem ("") lub zawiera tylko biały znak.  - lub - <paramref name="value" /> nazwę, ale nie jest elementem stałe nazwane zdefiniowane dla wyliczenia.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> znajduje się poza zakresem typu bazowego dla <paramref name="enumType" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse(Of TEnum As Structure) (value As String) As TEnum" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static TEnum Parse(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value, bool ignoreCase) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse(Of TEnum As Structure) (value As String, ignoreCase As Boolean) As TEnum" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static TEnum Parse(System::String ^ value, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącą wartość logiczną na podstawie typu podstawowego.</summary>
        <returns>Ten element członkowski zawsze zgłasza wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie nie zaimplementowana. Zawsze zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącą wartość całkowitą bez znaku 8-bitowych na podstawie typu podstawowego.</summary>
        <returns>Przekonwertowana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa <xref:System.Convert> do wykonania konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżący znak Unicode, w zależności od typu podstawowego.</summary>
        <returns>Ten element członkowski zawsze zgłasza wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie nie zaimplementowana. Zawsze zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącą wartość <see cref="T:System.DateTime" /> na podstawie typu podstawowego.</summary>
        <returns>Ten element członkowski zawsze zgłasza wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie nie zaimplementowana. Zawsze zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącą wartość <see cref="T:System.Decimal" /> na podstawie typu podstawowego.</summary>
        <returns>Ten element członkowski zawsze zgłasza wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie nie zaimplementowana. Zawsze zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącą wartość zmiennoprzecinkową podwójnej precyzji punktu numer na podstawie typu podstawowego.</summary>
        <returns>Ten element członkowski zawsze zgłasza wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie nie zaimplementowana. Zawsze zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącej wartości 16-bitową liczbę całkowitą ze znakiem na podstawie typu podstawowego.</summary>
        <returns>Przekonwertowana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa <xref:System.Convert> do wykonania konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącą wartość całkowita 32-bitowy oparty na typie podstawowym.</summary>
        <returns>Przekonwertowana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa <xref:System.Convert> do wykonania konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącą wartość całkowita 64-bitowy oparty na typie podstawowym.</summary>
        <returns>Przekonwertowana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa <xref:System.Convert> do wykonania konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącej wartości 8-bitową liczbę całkowitą ze znakiem na podstawie typu podstawowego.</summary>
        <returns>Przekonwertowana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa <xref:System.Convert> do wykonania konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącą liczbie zmiennoprzecinkowej pojedynczej precyzji, na podstawie typu podstawowego.</summary>
        <returns>Ten element członkowski zawsze zgłasza wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie nie zaimplementowana. Zawsze zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Typ docelowy konwersji.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącą wartość na określony typ na podstawie typu podstawowego.</summary>
        <returns>Przekonwertowana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa <xref:System.Convert> do wykonania konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącej wartości 16-bitową liczbę całkowitą bez znaku na podstawie typu podstawowego.</summary>
        <returns>Przekonwertowana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa <xref:System.Convert> do wykonania konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącą 32-bitowej liczby całkowitej bez znaku na podstawie typu podstawowego.</summary>
        <returns>Przekonwertowana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa <xref:System.Convert> do wykonania konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje bieżącą wartość 64-bitowej liczby całkowitej bez znaku na podstawie typu podstawowego.</summary>
        <returns>Przekonwertowana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa <xref:System.Convert> do wykonania konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość całkowitą określonego elementu członkowskiego wyliczenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Byte) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczeniowy, który będzie zwracany.</param>
        <param name="value">Wartość do konwersji do elementu członkowskiego wyliczenia.</param>
        <summary>Konwertuje określony 8-bitową liczbę całkowitą bez znaku do elementu członkowskiego wyliczenia.</summary>
        <returns>Wystąpienie wyliczenie ustawioną <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Byte%29> Metoda konwertuje `value` do elementu członkowskiego wyliczenia, których wartości podstawowej jest `value`. Należy pamiętać, że konwersji zakończy się powodzeniem, nawet jeśli wartość jest poza granicami `enumType` elementów członkowskich. Aby upewnić się, że `value` jest prawidłową wartością podstawowej `enumType` wyliczenia, przekaż go do <xref:System.Enum.IsDefined%2A> metody.  
  
 Ta metoda konwersji zwraca wartość typu <xref:System.Object>. Następnie można rzutować go lub przekonwertować go na obiekt typu `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Short) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczeniowy, który będzie zwracany.</param>
        <param name="value">Wartość do konwersji do elementu członkowskiego wyliczenia.</param>
        <summary>Konwertuje określony 16-bitową liczbę całkowitą ze znakiem do elementu członkowskiego wyliczenia.</summary>
        <returns>Wystąpienie wyliczenie ustawioną <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Int16%29> Metoda konwertuje `value` do elementu członkowskiego wyliczenia, których wartości podstawowej jest `value`. Należy pamiętać, że konwersji zakończy się powodzeniem, nawet jeśli wartość jest poza granicami `enumType` elementów członkowskich. Aby upewnić się, że `value` jest prawidłową wartością podstawowej `enumType` wyliczenia, przekaż go do <xref:System.Enum.IsDefined%2A> metody.  
  
 Ta metoda konwersji zwraca wartość typu <xref:System.Object>. Następnie można rzutować go lub przekonwertować go na obiekt typu `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczeniowy, który będzie zwracany.</param>
        <param name="value">Wartość do konwersji do elementu członkowskiego wyliczenia.</param>
        <summary>Konwertuje określony całkowita 32-bitowej do elementu członkowskiego wyliczenia.</summary>
        <returns>Wystąpienie wyliczenie ustawioną <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29> Metoda konwertuje `value` do elementu członkowskiego wyliczenia, których wartości podstawowej jest `value`. Należy pamiętać, że konwersji zakończy się powodzeniem, nawet jeśli wartość jest poza granicami `enumType` elementów członkowskich. Aby upewnić się, że `value` jest prawidłową wartością podstawowej `enumType` wyliczenia, przekaż go do <xref:System.Enum.IsDefined%2A> metody.  
  
 Ta metoda konwersji zwraca wartość typu <xref:System.Object>. Następnie można rzutować go lub przekonwertować go na obiekt typu `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczeniowy, który będzie zwracany.</param>
        <param name="value">Wartość do konwersji do elementu członkowskiego wyliczenia.</param>
        <summary>Konwertuje określony całkowita 64-bitowej do elementu członkowskiego wyliczenia.</summary>
        <returns>Wystąpienie wyliczenie ustawioną <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Int64%29> Metoda konwertuje `value` do elementu członkowskiego wyliczenia, których wartości podstawowej jest `value`. Należy pamiętać, że konwersji zakończy się powodzeniem, nawet jeśli wartość jest poza granicami `enumType` elementów członkowskich. Aby upewnić się, że `value` jest prawidłową wartością podstawowej `enumType` wyliczenia, przekaż go do <xref:System.Enum.IsDefined%2A> metody.  
  
 Ta metoda konwersji zwraca wartość typu <xref:System.Object>. Następnie można rzutować go lub przekonwertować go na obiekt typu `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczeniowy, który będzie zwracany.</param>
        <param name="value">Konwertuj wartości do elementu członkowskiego wyliczenia.</param>
        <summary>Konwertuje określony obiekt z wartością całkowitą do elementu członkowskiego wyliczenia.</summary>
        <returns>Obiekt wyliczenia, którego wartość jest <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.Object%29> Metoda konwertuje wartości całkowite `value` do elementu członkowskiego wyliczenia, których wartości podstawowej jest `value`. Należy pamiętać, że konwersji zakończy się powodzeniem, nawet jeśli wartość jest poza granicami `enumType` elementów członkowskich. Aby upewnić się, że `value` jest prawidłową wartością podstawowej `enumType` wyliczenia, przekaż go do <xref:System.Enum.IsDefined%2A> metody.  
  
 Ta metoda konwersji zwraca wartość typu <xref:System.Object>. Następnie można rzutować go lub przekonwertować go na obiekt typu `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> lub <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.  - lub - <paramref name="value" /> nie jest typem <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" />, lub <see cref="T:System.UInt64" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As SByte) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczeniowy, który będzie zwracany.</param>
        <param name="value">Wartość do konwersji do elementu członkowskiego wyliczenia.</param>
        <summary>Konwertuje wartość określonego 8-bitową liczbę całkowitą ze znakiem do elementu członkowskiego wyliczenia.</summary>
        <returns>Wystąpienie wyliczenie ustawioną <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.SByte%29> Metoda konwertuje `value` do elementu członkowskiego wyliczenia, których wartości podstawowej jest `value`. Należy pamiętać, że konwersji zakończy się powodzeniem, nawet jeśli wartość jest poza granicami `enumType` elementów członkowskich. Aby upewnić się, że `value` jest prawidłową wartością podstawowej `enumType` wyliczenia, przekaż go do <xref:System.Enum.IsDefined%2A> metody.  
  
 Ta metoda konwersji zwraca wartość typu <xref:System.Object>. Następnie można rzutować go lub przekonwertować go na obiekt typu `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As UShort) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczeniowy, który będzie zwracany.</param>
        <param name="value">Wartość do konwersji do elementu członkowskiego wyliczenia.</param>
        <summary>Konwertuje wartość określonej liczby całkowitej bez znaku 16-bitowych do elementu członkowskiego wyliczenia.</summary>
        <returns>Wystąpienie wyliczenie ustawioną <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt16%29> Metoda konwertuje `value` do elementu członkowskiego wyliczenia, których wartości podstawowej jest `value`. Należy pamiętać, że konwersji zakończy się powodzeniem, nawet jeśli wartość jest poza granicami `enumType` elementów członkowskich. Aby upewnić się, że `value` jest prawidłową wartością podstawowej `enumType` wyliczenia, przekaż go do <xref:System.Enum.IsDefined%2A> metody.  
  
 Ta metoda konwersji zwraca wartość typu <xref:System.Object>. Następnie można rzutować go lub przekonwertować go na obiekt typu `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As UInteger) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczeniowy, który będzie zwracany.</param>
        <param name="value">Wartość do konwersji do elementu członkowskiego wyliczenia.</param>
        <summary>Konwertuje wartość określonej liczby całkowitej bez znaku 32-bitowej do elementu członkowskiego wyliczenia.</summary>
        <returns>Wystąpienie wyliczenie ustawioną <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt32%29> Metoda konwertuje `value` do elementu członkowskiego wyliczenia, których wartości podstawowej jest `value`. Należy pamiętać, że konwersji zakończy się powodzeniem, nawet jeśli wartość jest poza granicami `enumType` elementów członkowskich. Aby upewnić się, że `value` jest prawidłową wartością podstawowej `enumType` wyliczenia, przekaż go do <xref:System.Enum.IsDefined%2A> metody.  
  
 Ta metoda konwersji zwraca wartość typu <xref:System.Object>. Następnie można rzutować go lub przekonwertować go na obiekt typu `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As ULong) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="enumType">Typ wyliczeniowy, który będzie zwracany.</param>
        <param name="value">Wartość do konwersji do elementu członkowskiego wyliczenia.</param>
        <summary>Konwertuje wartość określonej liczby całkowitej bez znaku 64-bitowej do elementu członkowskiego wyliczenia.</summary>
        <returns>Wystąpienie wyliczenie ustawioną <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt64%29> Metoda konwertuje `value` do elementu członkowskiego wyliczenia, których wartości podstawowej jest `value`. Należy pamiętać, że konwersji zakończy się powodzeniem, nawet jeśli wartość jest poza granicami `enumType` elementów członkowskich. Aby upewnić się, że `value` jest prawidłową wartością podstawowej `enumType` wyliczenia, przekaż go do <xref:System.Enum.IsDefined%2A> metody.  
  
 Ta metoda konwersji zwraca wartość typu <xref:System.Object>. Następnie można rzutować go lub przekonwertować go na obiekt typu `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> Nie jest <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia na jego równoważną reprezentację w postaci ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia na jego równoważną reprezentację w postaci ciągu.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana jest formatowana przy specyfikator formatu Ogólne ("G"). Oznacza to, że jeśli <xref:System.FlagsAttribute> nie dotyczy to typ wyliczeniowy i jest nazwane równe stałą wartość tego wystąpienia, a następnie ciąg zawierający nazwę stałej jest zwracana wartość. Jeśli <xref:System.FlagsAttribute> są stosowane i wartość tego wystąpienia jest kombinacją co najmniej jeden stałe nazwane, a następnie wartość zwracana jest ciąg zawierający listę nazw stałe rozdzielonych ogranicznika. W przeciwnym razie wartość zwracana jest reprezentację ciągu tego wystąpienia wartość liczbową. Aby uzyskać więcej informacji dotyczących formatowania wartości wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md). Aby uzyskać więcej informacji na temat formatowania ogólnie rzecz biorąc, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano konwertowania wartości wyliczane na ciąg.  
  
 [!code-cpp[Classic Enum.ToString2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Enum.ToString2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CS/source.cs#1)]
 [!code-vb[Classic Enum.ToString2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Wiele elementy członkowskie wyliczenia mają taką samą wartość podstawowego próba pobrania reprezentację ciągu w nazwie elementu członkowskiego wyliczenia na podstawie jego wartości podstawowej, kodu nie upewnić żadnym założeniu o nazwie, który zwróci metoda. Na przykład następujące wyliczenie definiuje dwa elementy członkowskie, <c>Shade.Gray</c> i <c>Shade.Grey</c>, które mają taką samą wartość podstawowej.  [! code-csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)] [! code-vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)]  Następujące wywołanie metody próbuje pobrać nazwy elementu członkowskiego <c>cień</c> wyliczenie których odpowiednia wartość to 1. Metoda może zwracać "Szarym" lub "Wyjście", a kod, nie należy wprowadzać żadnych założeń, o których zostanie zwrócony ciąg.  [! code-csharp[System.Enum.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#2)] [! code-vb[System.Enum.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#2)]</para>
        </block>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(przestarzałe)</param>
        <summary>Przeciążenie tej metody jest przestarzały; Użyj <see cref="M:System.Enum.ToString" />.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu.</param>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji równoważne ciągu w określonym formacie.</summary>
        <returns>Reprezentacja ciągu wartość tego wystąpienia, określony przez <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format` Parametr może zawierać "G" lub "g", "D" lub "d", "X" lub "x" i "F" lub "f" ciągi formatów (ciąg formatu nie jest rozróżniana wielkość liter). Jeśli `format` jest `null` lub ciąg pusty (""), specyfikator formatu Ogólne ("G") jest używany. Aby uzyskać więcej informacji na temat wyliczanie ciągów formatujących i formatowania wartości wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md). Aby uzyskać więcej informacji na temat formatowania ogólnie rzecz biorąc, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak przekonwertować wyliczenia wartości na ciąg.  
  
 [!code-cpp[enum.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/enum.tostring/CPP/tostr.cpp#1)]
 [!code-csharp[enum.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/enum.tostring/CS/tostr.cs#1)]
 [!code-vb[enum.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enum.tostring/VB/tostr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> zawiera nieprawidłową specyfikację.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> równa się "X", ale typ wyliczeniowy jest nieznany.</exception>
        <block subset="none" type="usage">
          <para>Wiele elementy członkowskie wyliczenia mają taką samą wartość podstawowego próba pobrania reprezentację ciągu w nazwie elementu członkowskiego wyliczenia na podstawie jego wartości podstawowej, kodu nie upewnić żadnym założeniu o nazwie, który zwróci metoda. Na przykład następujące wyliczenie definiuje dwa elementy członkowskie, <c>Shade.Gray</c> i <c>Shade.Grey</c>, które mają taką samą wartość podstawowej.  [! code-csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)] [! code-vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)]  Następujące wywołanie metody próbuje pobrać nazwy elementu członkowskiego <c>cień</c> wyliczenie których odpowiednia wartość to 1. Metoda może zwracać "Szarym" lub "Wyjście", a kod, nie należy wprowadzać żadnych założeń, o których zostanie zwrócony ciąg.  [! code-csharp[System.Enum.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#3)] [! code-vb[System.Enum.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#3)]</para>
        </block>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
        <altmember cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Definicja formatu.</param>
        <param name="provider">(Przestarzałe).</param>
        <summary>Przeciążenie tej metody jest przestarzały; Użyj <see cref="M:System.Enum.ToString(System.String)" />.</summary>
        <returns>Reprezentacja ciągu wartość tego wystąpienia, określony przez <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format` Parametr może zawierać "G" lub "g", "D" lub "d", "X" lub "x" i "F" lub "f" ciągi formatów (ciąg formatu nie jest rozróżniana wielkość liter). Jeśli `format` jest `null` lub ciąg pusty (""), specyfikator formatu Ogólne ("G") jest używany. Aby uzyskać więcej informacji na temat wyliczanie ciągów formatujących i formatowania wartości wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md). Aby uzyskać więcej informacji na temat formatowania ogólnie rzecz biorąc, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Należy określić tylko `format`; `provider` parametru jest przestarzała.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie zawiera specyfikację prawidłowy format.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> równa się "X", ale typ wyliczeniowy jest nieznany.</exception>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje ciąg znaków reprezentujący nazwę lub wartość liczbową jednej lub więcej stałych wyliczeniowych dla równoważnego obiektu wyliczanego. Zwracana wartość wskazuje, czy konwersja powiodła się.</summary>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (enumType As Type, value As String, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(Type ^ enumType, System::String ^ value, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, bool ignoreCase, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, bool ignoreCase, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Boolean,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (enumType As Type, value As String, ignoreCase As Boolean, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(Type ^ enumType, System::String ^ value, bool ignoreCase, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, [out] !!TEnum&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse(Of TEnum As Structure) (value As String, ByRef result As TEnum) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] TEnum % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="TEnum&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">Typ wyliczenia, do którego można przekonwertować <c>wartość</c>.</typeparam>
        <param name="value">Reprezentacja ciągu z uwzględnieniem wielkości liter nazwę wyliczenia lub odpowiednia wartość do przekonwertowania.</param>
        <param name="result">Gdy metoda zwróci wartość, <c>wynik</c> zawiera obiekt typu <c>element TEnum</c> którego wartość jest reprezentowana przez <c>wartość</c> Jeśli operacji analizowania zakończy się powodzeniem. W przypadku niepowodzenia operacji analizowania <c>wynik</c> zawiera domyślną wartość typu bazowego dla <c>element TEnum</c>. Należy pamiętać, że ta wartość nie musi być członkiem <c>element TEnum</c> wyliczenia. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje ciąg znaków reprezentujący nazwę lub wartość liczbową jednej lub więcej stałych wyliczeniowych dla równoważnego obiektu wyliczanego. Zwracana wartość wskazuje, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29> jest taka sama jak <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> metody, z wyjątkiem zamiast generowania wyjątku, zwraca `false` Jeśli konwersji nie powiedzie się. Eliminuje potrzebę obsługi podczas analizowania reprezentacja ciągu wartości wyliczenia wyjątków.  
  
 `value` Parametr zawierający reprezentację ciągu odpowiednia wartość elementu członkowskiego wyliczenia lub nazwanej stałej lub lista stałe nazwane podstawowej wartości rozdzielane przecinkami (,). Jeśli `value` zawiera wiele o nazwie stałe lub wartości, co najmniej jeden spacje można przed lub po każdej wartości, nazwa lub przecinkami w `value`. Jeśli `value` jest listą, `result` odzwierciedla wartość określonej nazwy i wartości, w połączeniu z bitowego podstawowe `OR` operacji. Jeśli `value` jest reprezentację ciągu nazwy wartości wyliczenia, porównanie `value` z wyliczenia nazw jest rozróżniana wielkość liter.  
  
 Jeśli `value` jest nazwą, która nie odpowiada nazwanej stałej z `TEnum`, metoda zwraca `false`. Jeśli `value` jest liczba całkowita, która nie stanowi podstawową wartość reprezentację ciągu `TEnum` wyliczenia, metoda zwraca wartość elementu członkowskiego wyliczenia, których wartości podstawowej jest `value` przekonwertować na typ całkowity. Jeśli to zachowanie jest niepożądane, wywołanie <xref:System.Enum.IsDefined%2A> metody w celu zapewnienia reprezentację ciągu określonego typu integer faktycznie członkiem `TEnum`.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Colors` wyliczenia, wywołania <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29> Konwertowanie ciągów na odpowiadające im wartości wyliczenia i wywołania metody <xref:System.Enum.IsDefined%2A> metody, aby upewnić się, że określonej wartości całkowitych na wartości są bazowy wartości w `Colors` wyliczenia.  
  
 [!code-csharp[System.Enum.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Enum.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TEnum" /> nie jest typem wyliczenia.</exception>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, bool ignoreCase, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase, [out] !!TEnum&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,System.Boolean,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse(Of TEnum As Structure) (value As String, ignoreCase As Boolean, ByRef result As TEnum) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static bool TryParse(System::String ^ value, bool ignoreCase, [Runtime::InteropServices::Out] TEnum % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="TEnum&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">Typ wyliczenia, do którego można przekonwertować <c>wartość</c>.</typeparam>
        <param name="value">Reprezentacja ciągu nazwę wyliczenia lub odpowiednia wartość do przekonwertowania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter; <see langword="false" /> wziąć pod uwagę w przypadku.</param>
        <param name="result">Gdy metoda zwróci wartość, <c>wynik</c> zawiera obiekt typu <c>element TEnum</c> którego wartość jest reprezentowana przez <c>wartość</c> Jeśli operacji analizowania zakończy się powodzeniem. W przypadku niepowodzenia operacji analizowania <c>wynik</c> zawiera domyślną wartość typu bazowego dla <c>element TEnum</c>. Należy pamiętać, że ta wartość nie musi być członkiem <c>element TEnum</c> wyliczenia. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje ciąg znaków reprezentujący nazwę lub wartość liczbową jednej lub więcej stałych wyliczeniowych dla równoważnego obiektu wyliczanego. Parametr określa, czy operacja jest rozróżniana wielkość liter. Zwracana wartość wskazuje, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> jest taka sama jak <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> metody, z wyjątkiem zamiast generowania wyjątku, zwraca `false` Jeśli konwersji nie powiedzie się. Eliminuje potrzebę obsługi podczas analizowania reprezentacja ciągu wartości wyliczenia wyjątków.  
  
 `value` Parametr zawierający reprezentację ciągu odpowiednia wartość elementu członkowskiego wyliczenia lub nazwanej stałej lub lista stałe nazwane podstawowej wartości rozdzielane przecinkami (,). Jeśli `value` zawiera wiele o nazwie stałe lub wartości, co najmniej jeden spacje można przed lub po każdej wartości, nazwa lub przecinkami w `value`. Jeśli `value` jest listą, `result` odzwierciedla wartość określonej nazwy i wartości, w połączeniu z bitowego podstawowe `OR` operacji. Jeśli `value` jest reprezentację ciągu nazwy wartości wyliczenia, porównanie `value` z wyliczenia nazw zależy od `ignoreCase` parametru. Jeśli `true`, wynik porównania ma bez uwzględniania wielkości liter; w wypadku `false`, jest rozróżniana wielkość liter.  
  
 Jeśli `value` jest nazwą, która nie odpowiada nazwanej stałej z `TEnum`, metoda zwraca `false`. Jeśli `value` jest liczba całkowita, która nie stanowi podstawową wartość reprezentację ciągu `TEnum` wyliczenia, metoda zwraca wartość elementu członkowskiego wyliczenia, których wartości podstawowej jest `value` przekonwertować na typ całkowity. Jeśli to zachowanie jest niepożądane, wywołanie <xref:System.Enum.IsDefined%2A> metody w celu zapewnienia reprezentację ciągu określonego typu integer faktycznie członkiem `TEnum`.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Colors` wyliczenia, wywołania <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> Konwertowanie ciągów na odpowiadające im wartości wyliczenia i wywołania metody <xref:System.Enum.IsDefined%2A> metody, aby upewnić się, że określonej wartości całkowitych na wartości są bazowy wartości w `Colors` wyliczenia. <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> Metoda używa porównania bez uwzględniania wielkości liter podczas próby skonwertowania reprezentacji ciągu o nazwie stałe wartości wyliczenia równoważne.  
  
 [!code-csharp[System.Enum.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse2.cs#2)]
 [!code-vb[System.Enum.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TEnum" /> nie jest typem wyliczenia.</exception>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String,System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>
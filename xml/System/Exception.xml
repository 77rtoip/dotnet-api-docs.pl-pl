<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="982c48cb4df4baf1eb52eafe07c62c028e3863a6" /><Meta Name="ms.sourcegitcommit" Value="5c332e8417c001736f7e2f33a84791feebba2cd7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/30/2019" /><Meta Name="ms.locfileid" Value="68632591" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje błędy występujące podczas wykonywania aplikacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest klasą bazową dla wszystkich wyjątków. Gdy wystąpi błąd, system lub aktualnie wykonywana aplikacja zgłosi go, zgłaszając wyjątek zawierający informacje o błędzie. Gdy wyjątek jest zgłaszany, jest obsługiwany przez aplikację lub przez domyślną procedurę obsługi wyjątków.  
  
 W tej sekcji:  
  
 [Błędy i wyjątki](#Errors)   
 [Bloki try/catch](#TryCatch)   
 [Funkcje typu wyjątku](#Features)   
 [Właściwości klasy wyjątku](#Properties)   
 [Zagadnienia dotyczące wydajności](#Performance)   
 [Ponowne zgłaszanie wyjątku](#Rethrow)   
 [Wybieranie standardowych wyjątków](#Standard)   
 [Implementowanie wyjątków niestandardowych](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>Błędy i wyjątki  
 Błędy w czasie wykonywania mogą wystąpić z różnych powodów. Nie wszystkie błędy powinny jednak być obsługiwane jako wyjątki w kodzie. Poniżej wymieniono niektóre kategorie błędów, które mogą wystąpić w czasie wykonywania, oraz odpowiednie sposoby reagowania na nie.  
  
-   **Błędy użycia.** Błąd użycia reprezentuje błąd w logice programu, który może spowodować wyjątek. Jednak błąd powinien zostać rozkierowany do obsługi wyjątków, ale przez modyfikację błędnego kodu. Na przykład przesłonięcie <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody w poniższym przykładzie zakłada `obj` , że argument musi być zawsze inny niż null.  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     Wyjątek, który `obj` powoduje <xref:System.Object.Equals%2A?displayProperty=nameWithType> , że można wyeliminować, modyfikując kod źródłowy do jawnego testowania dla wartości null przed wywołaniem zastąpienia, a następnie ponownie skompilować. `null` <xref:System.NullReferenceException> Poniższy przykład zawiera poprawiony kod źródłowy, który obsługuje `null` argument.  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     Zamiast korzystać z obsługi wyjątków w przypadku błędów użycia, można użyć <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metody do identyfikowania błędów użycia w kompilacjach debugowania, a także <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metody identyfikowania błędów użycia w kompilacjach i wersjach. Aby uzyskać więcej informacji, zobacz [potwierdzenia w kodzie zarządzanym](/visualstudio/debugger/assertions-in-managed-code).  
  
-   **Błędy programu.** Błąd programu to błąd czasu wykonywania, którego nie można koniecznie uniknąć, pisząc kod bez błędów.  
  
     W niektórych przypadkach błąd programu może odzwierciedlać oczekiwany lub rutynowy warunek błędu. W takim przypadku można uniknąć korzystania z obsługi wyjątków w celu postępowania z błędem programu, a zamiast tego ponownie wykonać operację. Na przykład, jeśli użytkownik chce wprowadzić datę w określonym formacie, można przeanalizować ciąg daty przez wywołanie <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> metody, która <xref:System.Boolean> zwraca wartość wskazującą, czy operacja analizy zakończyła się powodzeniem, zamiast używać <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>Metoda, która zgłasza <xref:System.FormatException> wyjątek, jeśli nie można <xref:System.DateTime> przekonwertować ciągu daty na wartość. Podobnie, jeśli użytkownik próbuje otworzyć plik, który nie istnieje, można najpierw wywołać <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> metodę, aby sprawdzić, czy plik istnieje i, jeśli nie, monitować użytkownika, czy chce go utworzyć.  
  
     W innych przypadkach błąd programu odzwierciedla Nieoczekiwany warunek błędu, który można obsłużyć w kodzie. Na przykład, nawet jeśli sprawdzono, że plik istnieje, można go usunąć, aby można było go otworzyć, lub może być uszkodzony. W takim przypadku próba otwarcia pliku przez utworzenie wystąpienia <xref:System.IO.StreamReader> obiektu lub <xref:System.IO.File.Open%2A> wywołanie metody może zgłosić <xref:System.IO.FileNotFoundException> wyjątek. W takich przypadkach należy użyć obsługi wyjątków, aby odzyskać sprawność po błędzie.  
  
-   **Awarie systemu.** Awaria systemu to błąd czasu wykonywania, którego nie można programowo obsługiwać w zrozumiały sposób. Na przykład każda metoda może zgłosić <xref:System.OutOfMemoryException> wyjątek, jeśli środowisko uruchomieniowe języka wspólnego nie może przydzielić dodatkowej pamięci. Zwykle błędy systemu nie są obsługiwane przy użyciu obsługi wyjątków. Zamiast tego można użyć zdarzenia, takiego jak <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> i <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> wywołać metodę, aby zarejestrować informacje o wyjątku i powiadomić użytkownika o awarii przed zakończeniem działania aplikacji.  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Bloki try/catch  
 Środowisko uruchomieniowe języka wspólnego udostępnia model obsługi wyjątków, który jest oparty na reprezentacji wyjątków jako obiektów i oddziela kod programu i kod obsługi wyjątków do `try` bloków i `catch` bloków. Może istnieć jeden lub więcej `catch` bloków, z których każdy jest przeznaczony do obsługi określonego typu wyjątku lub jeden blok zaprojektowany w celu przechwycenia bardziej szczegółowego wyjątku niż inny blok.  
  
 Jeśli aplikacja obsługuje wyjątki, które występują podczas wykonywania bloku kodu aplikacji, kod musi być umieszczony wewnątrz `try` instrukcji i nosi `try` nazwę bloku. Kod aplikacji obsługujący wyjątki zgłoszone przez `try` blok jest umieszczany `catch` w `catch` instrukcji i jest nazywany blokiem. Co najmniej `catch` zero bloków jest skojarzonych `try` z blokiem, a każdy `catch` blok zawiera filtr typu, który określa typy wyjątków, które obsługuje.  
  
 Gdy w `try` bloku występuje wyjątek, system przeszukuje skojarzone `catch` bloki w kolejności, w jakiej występują w kodzie aplikacji, `catch` dopóki nie zostanie znaleziony blok obsługujący wyjątek. Blok obsługuje wyjątek typu `T` , jeśli filtr typu bloku catch `T` określa `T` lub dowolny typ pochodzący z. `catch` System przestaje wyszukiwać po znalezieniu pierwszego `catch` bloku, który obsługuje wyjątek. Z tego powodu w kodzie `catch` aplikacji blok obsługujący typ musi być określony `catch` przed blokiem, który obsługuje jego typy podstawowe, jak pokazano w przykładzie opisanym w tej sekcji. Blok catch, który obsługuje `System.Exception` , jest określany jako ostatni.  
  
 Jeśli `catch` żaden z bloków skojarzonych z bieżącym `try` `try` blokiem nie obsługuje wyjątku, a bieżący blok jest zagnieżdżony w `catch` innych `try` blokach w bieżącym wywołaniu, bloki skojarzone z następnym przeszukiwany jest otaczający blok. `try` Jeśli nie `catch` zostanie znaleziony żaden blok dla wyjątku, system przeszuka poprzednie poziomy zagnieżdżenia w bieżącym wywołaniu. Jeśli żaden `catch` blok dla wyjątku nie zostanie znaleziony w bieżącym wywołaniu, zostanie przeszukany stos wywołań, a w poprzedniej klatce stosu jest wyszukiwany `catch` blok obsługujący wyjątek. Wyszukiwanie stosu wywołań jest kontynuowane do momentu obsługi wyjątku lub do momentu, gdy w stosie wywołań nie ma więcej ramek. Jeśli Góra stosu wywołań zostanie osiągnięta bez znajdowania `catch` bloku, który obsługuje wyjątek, zostanie ona prześwietlona przez domyślny program obsługi wyjątków, a aplikacja zostanie przerwana.  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>Funkcje typu wyjątku  
 Typy wyjątków obsługują następujące funkcje:  
  
-   Czytelny dla człowieka tekst opisujący błąd. Gdy wystąpi wyjątek, środowisko uruchomieniowe udostępnia wiadomość tekstową, aby poinformować użytkownika o charakterze błędu i zasugerować akcję w celu rozwiązania problemu. Ten komunikat tekstowy jest przechowywany we <xref:System.Exception.Message%2A> właściwości obiektu wyjątku. Podczas tworzenia obiektu wyjątku można przekazać ciąg tekstowy do konstruktora, aby opisać szczegóły tego wyjątku. Jeśli do konstruktora nie zostanie dostarczony argument komunikatu o błędzie, zostanie użyty domyślny komunikat o błędzie. Aby uzyskać więcej informacji, zobacz <xref:System.Exception.Message%2A> właściwość.  
  
-   Stan stosu wywołań, gdy wystąpił wyjątek. <xref:System.Exception.StackTrace%2A> Właściwość przenosi ślad stosu, którego można użyć do określenia miejsca wystąpienia błędu w kodzie. Ślad stosu wyświetla wszystkie wywoływane metody i numery wierszy w pliku źródłowym, w którym są wykonywane wywołania.  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>Właściwości klasy wyjątku  
 <xref:System.Exception.Message%2A> <xref:System.Exception.Source%2A> <xref:System.Exception.HResult%2A> <xref:System.Exception.StackTrace%2A> <xref:System.Exception.HelpLink%2A> <xref:System.Exception.InnerException%2A>Klasa zawiera wiele właściwości, które ułatwiają identyfikację lokalizacji kodu, typu, pliku pomocy i przyczyny wyjątku:,,,,,, <xref:System.Exception> <xref:System.Exception.TargetSite%2A>i .<xref:System.Exception.Data%2A>  
  
 Gdy istnieje związek przyczynowy między dwoma lub więcej wyjątkami, <xref:System.Exception.InnerException%2A> Właściwość utrzymuje te informacje. Wyjątek zewnętrzny jest zgłaszany w odpowiedzi na ten wyjątek wewnętrzny. Kod, który obsługuje wyjątek zewnętrzny, może użyć informacji z wcześniejszego wyjątku wewnętrznego, aby bardziej odpowiednio obsłużyć błąd. Dodatkowe informacje o wyjątku mogą być przechowywane jako kolekcja par klucz/wartość we <xref:System.Exception.Data%2A> właściwości.  
  
 Ciąg komunikatu o błędzie, który jest przekazywany do konstruktora podczas tworzenia obiektu wyjątku powinien być zlokalizowany i może być dostarczony z pliku zasobów przy użyciu <xref:System.Resources.ResourceManager> klasy. Aby uzyskać więcej informacji o zlokalizowanych zasobach, zobacz temat [Tworzenie zestawów satelickich](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) i [pakowanie i wdrażanie zasobów](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) .  
  
 Aby zapewnić użytkownikowi wyczerpujące informacje na temat przyczyny wystąpienia wyjątku, <xref:System.Exception.HelpLink%2A> właściwość może zawierać adres URL (lub nazwę URN) do pliku pomocy.  
  
 <xref:System.Exception> Klasa używa HRESULT COR_E_EXCEPTION, która ma wartość 0x80131500.  
  
 Aby uzyskać listę początkowych wartości właściwości dla wystąpienia <xref:System.Exception> klasy, <xref:System.Exception.%23ctor%2A> Zobacz konstruktory.  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Wyrzucanie lub obsługa wyjątku zużywa znaczną ilość zasobów systemowych i czasu wykonywania. Zgłaszaj wyjątki tylko w celu obsługi prawdziwie nieprawidłowych warunków, nie obsługują przewidywalnych zdarzeń lub sterowanie przepływem. Na przykład w niektórych przypadkach, na przykład podczas tworzenia biblioteki klas, należy zgłosić wyjątek, jeśli argument metody jest nieprawidłowy, ponieważ oczekuje się, że metoda zostanie wywołana z prawidłowymi parametrami. Nieprawidłowy argument metody, jeśli nie jest wynikiem błędu użycia, oznacza to, że wystąpił coś nadzwyczajowego. Z drugiej strony nie należy zgłaszać wyjątku, jeśli dane wejściowe użytkownika są nieprawidłowe, ponieważ można oczekiwać, że użytkownicy sporadycznie wprowadzają nieprawidłowe dane. Zamiast tego należy zapewnić mechanizm ponawiania prób, aby umożliwić użytkownikom wprowadzanie prawidłowych danych wejściowych. Nie należy używać wyjątków do obsługi błędów użycia. Zamiast tego należy [](/visualstudio/debugger/assertions-in-managed-code) użyć potwierdzeń, aby identyfikować i poprawiać błędy użycia.  
  
 Ponadto nie należy zgłaszać wyjątku, gdy kod powrotny jest wystarczający; nie Konwertuj kodu powrotu na wyjątek; i nie przeprowadzaj rutynowo przechwytywania wyjątku, zignoruj go, a następnie kontynuuj przetwarzanie.  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>Ponowne zgłaszanie wyjątku  
 W wielu przypadkach procedura obsługi wyjątków po prostu chce przekazać wyjątek do obiektu wywołującego. Najczęściej występuje w programie:  
  
-   Biblioteka klas, która z kolei zawija wywołania metod w bibliotece klas .NET Framework lub innych bibliotekach klas.  
  
-   Aplikacja lub biblioteka, która napotyka wyjątek krytyczny. Procedura obsługi wyjątków może rejestrować wyjątek, a następnie ponownie zgłosić wyjątek.  
  
 Zalecanym sposobem ponownego wygenerowania wyjątku jest po prostu użycie instrukcji [throw](~/docs/csharp/language-reference/keywords/throw.md) w C# i instrukcji [throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) w Visual Basic bez uwzględnienia wyrażenia. Dzięki temu wszystkie informacje stosu wywołań są zachowywane, gdy wyjątek jest propagowany do obiektu wywołującego. Ilustruje to poniższy przykład. Metoda `FindOccurrences`rozszerzenia ciągu, zawija jedno lub więcej wywołań do <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> bez weryfikowania wcześniej argumentów.  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 Wywołujący następnie wywołuje `FindOccurrences` dwa razy. W drugim wywołaniu `FindOccurrences`, obiekt wywołujący `null` przekazuje jako <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> ciąg wyszukiwania, w którym występują metody <xref:System.ArgumentNullException> zgłaszania wyjątku. Ten wyjątek jest obsługiwany przez `FindOccurrences` metodę i przeszedł z powrotem do obiektu wywołującego. Ponieważ Instrukcja throw jest używana bez wyrażenia, dane wyjściowe z przykładu pokazują, że stos wywołań jest zachowywany.  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 Z drugiej strony, jeśli wyjątek jest ponownie zgłaszany przy użyciu  
  
```csharp
throw e;
```  
  
```vb  
Throw e  
```  
  
 instrukcji, pełny stos wywołań nie jest zachowywany, a przykład generuje następujące dane wyjściowe:  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 Nieco bardziej nieskomplikowaną alternatywą jest wygenerowanie nowego wyjątku i zachowanie informacji o stosie wywołań oryginalnego wyjątku w wyjątku wewnętrznym. Obiekt wywołujący może następnie użyć <xref:System.Exception.InnerException%2A> właściwości nowego wyjątku, aby pobrać ramkę stosu i inne informacje na temat oryginalnego wyjątku. W tym przypadku Instrukcja throw jest:  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 Kod użytkownika, który obsługuje wyjątek, musi wiedzieć, że <xref:System.Exception.InnerException%2A> Właściwość zawiera informacje o oryginalnym wyjątku, ponieważ ilustruje poniższy program obsługi wyjątków.  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>Wybieranie standardowych wyjątków  
 Jeśli trzeba zgłosić wyjątek, często można użyć istniejącego typu wyjątku w .NET Framework zamiast implementowania niestandardowego wyjątku. Należy używać standardowego typu wyjątku w następujących dwóch warunkach:  
  
-   Zgłaszasz wyjątek, który jest spowodowany przez błąd użycia (to oznacza, że wystąpił błąd w logice programu wykonany przez dewelopera, który wywołuje metodę). <xref:System.ArgumentException>Zazwyczaj należy zgłosić wyjątek <xref:System.ArgumentNullException> <xref:System.NotSupportedException>, taki jak,, ,lub.<xref:System.InvalidOperationException> Ciąg, który jest dostarczany do konstruktora obiektu wyjątku podczas tworzenia wystąpienia obiektu wyjątku powinien opisać błąd, aby umożliwić deweloperowi rozwiązanie tego problemu. Aby uzyskać więcej informacji, zobacz <xref:System.Exception.Message%2A> właściwość.  
  
-   Obsłużysz błąd, który może być przekazywany do obiektu wywołującego z istniejącym wyjątkiem .NET Framework. Należy zgłosić najbardziej pochodny wyjątek. Na przykład jeśli metoda wymaga, aby argument był prawidłowym elementem członkowskim typu wyliczenia, należy zgłosić <xref:System.ComponentModel.InvalidEnumArgumentException> (najbardziej pochodną klasę), a nie. <xref:System.ArgumentException>  
  
 W poniższej tabeli wymieniono typowe typy wyjątków i warunki, w których zostałyby one wyrzucane.  
  
|Wyjątek|Warunek|  
|---------------|---------------|  
|<xref:System.ArgumentException>|Argument o wartości innej niż null, który jest przesyłany do metody jest nieprawidłowy.|  
|<xref:System.ArgumentNullException>|Argument, który jest przekazaniem do metody `null`, to.|  
|<xref:System.ArgumentOutOfRangeException>|Argument znajduje się poza zakresem prawidłowych wartości.|  
|<xref:System.IO.DirectoryNotFoundException>|Część ścieżki katalogu jest nieprawidłowa.|  
|<xref:System.DivideByZeroException>|Mianownik w operacji typu Integer lub <xref:System.Decimal> dzielenie ma wartość zero.|  
|<xref:System.IO.DriveNotFoundException>|Dysk jest niedostępny lub nie istnieje.|  
|<xref:System.IO.FileNotFoundException>|Plik nie istnieje.|  
|<xref:System.FormatException>|Wartość nie jest w odpowiednim formacie do przekonwertowania z ciągu przez metodę konwersji taką jak `Parse`.|  
|<xref:System.IndexOutOfRangeException>|Indeks znajduje się poza granicami tablicy lub kolekcji.|  
|<xref:System.InvalidOperationException>|Wywołanie metody jest nieprawidłowe w bieżącym stanie obiektu.|  
|<xref:System.Collections.Generic.KeyNotFoundException>|Nie można znaleźć określonego klucza do uzyskania dostępu do elementu członkowskiego w kolekcji.|  
|<xref:System.NotImplementedException>|Metoda lub operacja nie jest zaimplementowana.|  
|<xref:System.NotSupportedException>|Metoda lub operacja nie jest obsługiwana.|  
|<xref:System.ObjectDisposedException>|Operacja jest wykonywana na obiekcie, który został usunięty.|  
|<xref:System.OverflowException>|Operacja arytmetyczna, rzutowania lub konwersji powoduje przepełnienie.|  
|<xref:System.IO.PathTooLongException>|Ścieżka lub nazwa pliku przekracza maksymalną długość zdefiniowaną przez system.|  
|<xref:System.PlatformNotSupportedException>|Operacja nie jest obsługiwana na bieżącej platformie.|  
|<xref:System.RankException>|Tablica o nieprawidłowej liczbie wymiarów jest przenoszona do metody.|  
|<xref:System.TimeoutException>|Przedział czasu przypisany do operacji wygasł.|  
|<xref:System.UriFormatException>|Użyto nieprawidłowego Uniform Resource Identifier (URI).|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>Implementowanie wyjątków niestandardowych  
 W następujących przypadkach użycie istniejącego wyjątku .NET Framework w celu obsłużenia warunku błędu nie jest wystarczające:  
  
-   Gdy wyjątek odzwierciedla unikatowy błąd programu, którego nie można zamapować na istniejący wyjątek .NET Framework.  
  
-   Gdy wyjątek wymaga obsługi, która różni się od obsługi, która jest odpowiednia dla istniejącego wyjątku .NET Framework, lub wyjątek należy odróżnić od podobnego wyjątku. Na przykład jeśli <xref:System.ArgumentOutOfRangeException> zgłaszasz wyjątek podczas analizowania liczbowej reprezentacji ciągu, który jest poza zakresem docelowego typu całkowitego, nie chcesz używać tego samego wyjątku w przypadku błędu, który wynika z wywołującego niedostarczającego odpowiednie ograniczone wartości podczas wywoływania metody.  
  
 <xref:System.Exception> Klasa jest klasą bazową wszystkich wyjątków w .NET Framework. Wiele klas pochodnych opiera się na dziedziczonym zachowaniu elementów członkowskich <xref:System.Exception> klasy; nie przesłaniają oni <xref:System.Exception>elementów członkowskich ani nie definiują żadnych unikatowych elementów członkowskich.  
  
 Aby zdefiniować własną klasę wyjątku:  
  
1.  Zdefiniuj klasę, która dziedziczy z <xref:System.Exception>. W razie potrzeby Zdefiniuj wszelkich unikatowych członków wymaganych przez klasę, aby podać dodatkowe informacje o wyjątku. Na przykład <xref:System.ArgumentException> Klasa <xref:System.ArgumentException.ParamName%2A> zawiera właściwość, która określa nazwę parametru, którego argument spowodował wyjątek, <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Właściwość zawiera właściwość, która wskazuje interwał limitu czasu.  
  
2.  W razie potrzeby Zastąp wszystkie Odziedziczone elementy członkowskie, których funkcjonalność chcesz zmienić lub zmodyfikować. Należy zauważyć, że większość istniejących klas <xref:System.Exception> pochodnych nie przesłania zachowania dziedziczonych elementów członkowskich.  
  
3.  Ustal, czy obiekt wyjątku niestandardowego jest możliwy do serializacji. Serializacja umożliwia zapisywanie informacji o wyjątku i Zezwalanie na udostępnianie informacji o wyjątku przez serwer i serwer proxy klienta w kontekście komunikacji zdalnej. Aby można było serializować obiekt wyjątku, oznacz go <xref:System.SerializableAttribute> atrybutem.  
  
4.  Zdefiniuj konstruktory klasy wyjątków. Zazwyczaj klasy wyjątków mają jeden lub więcej z następujących konstruktorów:  
  
    -   <xref:System.Exception.%23ctor>, który używa wartości domyślnych do inicjowania właściwości nowego obiektu wyjątku.  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>, który inicjuje nowy obiekt wyjątku z określonym komunikatem o błędzie.  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, który inicjuje nowy obiekt wyjątku z określonym komunikatem o błędzie i wyjątkiem wewnętrznym.  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, który jest `protected` konstruktorem, który inicjuje nowy obiekt wyjątku z danych serializowanych. Należy zaimplementować ten Konstruktor, jeśli wybrano opcję, aby obiekt wyjątku był możliwy do serializacji.  
  
 Poniższy przykład ilustruje użycie niestandardowej klasy wyjątków. Definiuje `NotPrimeException` wyjątek, który jest generowany, gdy klient próbuje pobrać sekwencję numerów początkowych przez określenie początkowego numeru, który nie jest podstawowy. Wyjątek definiuje nową właściwość `NonPrime`, która zwraca liczbę niewskazującą, która spowodowała wyjątek. Oprócz implementacji <xref:System.Runtime.Serialization.SerializationInfo> chronionego konstruktora bez parametrów i konstruktora z <xref:System.Runtime.Serialization.StreamingContext> `NotPrimeException` parametrami dla serializacji, `NonPrime` Klasa definiuje trzy dodatkowe konstruktory do obsługi właściwości.  Każdy Konstruktor wywołuje konstruktora klasy bazowej oprócz zachowania wartości numeru niebędącego znakiem. Klasa jest również oznaczona <xref:System.SerializableAttribute> przy użyciu atrybutu. `NotPrimeException`  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator` Klasa pokazana w poniższym przykładzie używa sita Eratostenesa, aby obliczyć sekwencję liczb pierwszych z 2 do limitu określonego przez klienta w wywołaniu jego konstruktora klasy. Metoda zwraca wszystkie liczby podstawowe, które są większe niż lub równe określonemu dolnemu limitowi, ale `NotPrimeException` zgłasza, jeśli ten dolny limit nie jest liczbą najmniejszą. `GetPrimesFrom`  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 Poniższy przykład tworzy dwa wywołania `GetPrimesFrom` metody z liczbami niepodstawowymi, z których jedna przecina granice domeny aplikacji. W obu przypadkach wyjątek jest zgłaszany i pomyślnie obsłużony w kodzie klienta.  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>środowisko wykonawcze systemu Windows i[!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 W [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] przypadku [!INCLUDE[win8](~/includes/win8-md.md)]programu niektóre informacje o wyjątkach są zazwyczaj tracone, gdy wyjątek jest propagowany przez ramki stosu non-.NET Framework. Począwszy od [!INCLUDE[win81](~/includes/win81-md.md)] <xref:System.Exception> i, środowisko uruchomieniowe języka wspólnego nadal używa oryginalnego obiektu, który został wygenerowany, chyba że ten wyjątek został zmodyfikowany w ramce stosu non-.NET Framework. [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje `catch` blok, który jest zdefiniowany do obsługi <xref:System.ArithmeticException> błędów. Ten `catch` blok również <xref:System.DivideByZeroException> przechwytuje błędy, <xref:System.DivideByZeroException> ponieważ pochodzi <xref:System.ArithmeticException> od i nie `catch` istnieje blok jawnie zdefiniowany dla <xref:System.DivideByZeroException> błędów.  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">Obsługa i zgłaszanie wyjątków</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów w aplikacjach klasycznych</related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">Potwierdzenia w zarządzanym kodzie</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwość nowego wystąpienia do komunikatu dostarczonego przez system, który opisuje błąd i bierze pod uwagę bieżącą kulturę systemu.  
  
 Wszystkie klasy pochodne powinny udostępniać ten konstruktor bez parametrów. W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Exception>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Zlokalizowany opis dostarczany przez system.|  
  
   
  
## Examples  
 Poniższy przykład kodu pochodzi `Exception` , który używa wstępnie zdefiniowanego komunikatu. Kod demonstruje użycie konstruktora bez parametrów dla klasy pochodnej i klasy bazowej `Exception` .  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który opisuje błąd.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy przy użyciu określonego komunikatu o błędzie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwość nowego wystąpienia przy `message` użyciu parametru. Jeśli parametr ma `null`wartość, jest to taka sama jak wywołanie <xref:System.Exception.%23ctor%2A> konstruktora. `message`  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Exception>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
   
  
## Examples  
 Poniższy przykład kodu dziedziczy `Exception` dla określonego warunku. Kod demonstruje użycie konstruktora, który przyjmuje komunikat określony przez obiekt wywołujący jako parametr, dla klasy pochodnej i klasy bazowej `Exception` .  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Przechowujący dane serializowanego obiektu o generowanym wyjątku.</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> Zawiera informacje kontekstowe o źródle lub miejscu docelowym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy z serializowanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana podczas deserializacji do odtworzenia obiektu wyjątku przesyłanego za pomocą strumienia. Aby uzyskać więcej informacji, zobacz [XML oraz serializacji protokołu SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
   
  
## Examples  
 Poniższy przykład kodu definiuje pochodną klasę, `Exception` której można serializować. Kod wymusza błąd dzielenia przez 0, a następnie tworzy wystąpienie wyjątku pochodnego przy użyciu konstruktora (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>). Kod serializować wystąpienie do pliku, deserializacji pliku do nowego wyjątku, który zgłasza, a następnie przechwytuje i wyświetla dane wyjątku.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Nazwa klasy ma <see langword="null" /> wartość lub <see cref="P:System.Exception.HResult" /> jest równa zero (0).</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serializacja XML i SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat o błędzie wyjaśniający przyczynę wyjątku.</param>
        <param name="innerException">Wyjątek, który jest przyczyną bieżącego wyjątku lub odwołaniem null (<see langword="Nothing" /> w Visual Basic), jeśli nie określono wyjątku wewnętrznego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy przy użyciu określonego komunikatu o błędzie i odwołania do wewnętrznego wyjątku, który jest przyczyną tego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek generowany jako bezpośredni wynik poprzedniego wyjątku powinien zawierać odwołanie do poprzedniego wyjątku we <xref:System.Exception.InnerException%2A> właściwości. Właściwość zwraca tę samą wartość, która jest przenoszona do konstruktora lub odwołanie o wartości null (`Nothing` <xref:System.Exception.InnerException%2A> w Visual Basic), jeśli właściwość nie poda wewnętrznej wartości wyjątku do konstruktora. <xref:System.Exception.InnerException%2A>  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Exception>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie do wewnętrznego wyjątku.|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
   
  
## Examples  
 Poniższy przykład kodu dziedziczy `Exception` dla określonego warunku. Kod demonstruje użycie konstruktora, który przyjmuje komunikat i wyjątek wewnętrzny jako parametry, dla klasy pochodnej i klasy bazowej `Exception` .  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję par klucz/wartość, które zawierają dodatkowe informacje zdefiniowane przez użytkownika dotyczące wyjątku.</summary>
        <value>Obiekt, który implementuje <see cref="T:System.Collections.IDictionary" /> interfejs i zawiera kolekcję par klucz/wartość zdefiniowanych przez użytkownika. Wartością domyślną jest pusta kolekcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj obiektu zwróconego przez właściwość w celu przechowywania i pobierania informacji dodatkowych dotyczących wyjątku. <xref:System.Exception.Data%2A> <xref:System.Collections.IDictionary?displayProperty=nameWithType> Informacje są w postaci dowolnej liczby par klucz-wartość zdefiniowanych przez użytkownika. Najważniejszym składnikiem pary klucz/wartość jest zazwyczaj ciąg identyfikacyjny, natomiast składnik wartości pary może być dowolnym typem obiektu.  
  
## <a name="keyvalue-pair-security"></a>Zabezpieczenia pary klucz/wartość  
 Pary klucz/wartość przechowywane w kolekcji zwróconej przez <xref:System.Exception.Data%2A> właściwość nie są bezpieczne. Jeśli aplikacja wywołuje zagnieżdżoną serię procedur, a każda procedura zawiera obsługę wyjątków, powstaje stos wywołań zawiera hierarchię programów obsługi wyjątków. Jeśli procedura niższego poziomu zgłasza wyjątek, każdy program obsługi wyjątków najwyższego poziomu w hierarchii stosu wywołań może odczytać i/lub zmodyfikować pary klucz/wartość przechowywane w kolekcji przez dowolną inną procedurę obsługi wyjątków. Oznacza to, że należy zagwarantować, że informacje w parach klucz/wartość nie są poufne i że aplikacja będzie działać prawidłowo, jeśli informacje w parach klucz/wartość są uszkodzone.  
  
## <a name="key-conflicts"></a>Konflikty klucza  
 Konflikt klucza występuje, gdy różne programy obsługi wyjątków określają ten sam klucz, aby uzyskać dostęp do pary klucz/wartość. Należy zachować ostrożność podczas opracowywania aplikacji, ponieważ występuje konflikt klucza, że programy obsługi wyjątków niższego poziomu mogą przypadkowo komunikować się z obsługą wyjątków wyższego poziomu, a ta komunikacja może spowodować drobne błędy programu. Jednak jeśli jest to ostrożne, można użyć konfliktów kluczy do udoskonalenia aplikacji.  
  
## <a name="avoiding-key-conflicts"></a>Unikanie konfliktów klucza  
 Unikaj konfliktów kluczowych przez przyjęcie konwencji nazewnictwa w celu wygenerowania unikatowych kluczy dla par klucz/wartość. Na przykład Konwencja nazewnictwa może dać klucz, który składa się z rozdzielanej kropką nazwy aplikacji, metody, która zawiera dodatkowe informacje dla pary i unikatowy identyfikator.  
  
 Załóżmy, że dwie aplikacje, nazwane produkty i dostawcy, mają metodę o nazwie Sales. Metoda Sales w aplikacji Products zawiera numer identyfikacyjny (jednostka magazynowa lub SKU) produktu. Metoda Sales w aplikacji dostawcy udostępnia numer identyfikacyjny lub identyfikator SID dostawcy. W związku z tym, Konwencja nazewnictwa dla tego przykładu daje klucze "Products. Sales. SKU" i "dostawcy. Sales. SID".  
  
## <a name="exploiting-key-conflicts"></a>Wykorzystanie konfliktów klucza  
 Luki w zabezpieczeniach z wykorzystaniem klucza wykorzystującego jeden lub więcej specjalnych, nastawianych kluczy do sterowania przetwarzaniem. Załóżmy, że w jednym scenariuszu program obsługi wyjątków najwyższego poziomu w hierarchii stosu wywołań przechwytuje wszystkie wyjątki zgłoszone przez programy obsługi wyjątków niższego poziomu. Jeśli istnieje para klucz/wartość z kluczem specjalnym, program obsługi wyjątków wysokiego poziomu formatuje pozostałe pary klucz/wartość w <xref:System.Collections.IDictionary> obiekcie w niestandardowym trybie; w przeciwnym razie pozostałe pary klucz/wartość są sformatowane w zwykły sposób.  
  
 Teraz Załóżmy, że w innym scenariuszu program obsługi wyjątków na każdym poziomie hierarchii stosu wywołań przechwytuje wyjątek zgłoszony przez następną procedurę obsługi wyjątków niższego poziomu. Ponadto każdy program obsługi wyjątków wie, że Kolekcja zwracana przez <xref:System.Exception.Data%2A> Właściwość zawiera zestaw par klucz/wartość, do których można uzyskać dostęp przy użyciu premieszczonego zestawu kluczy.  
  
 Każdy program obsługi wyjątków używa wstępnie utworzonego zestawu kluczy, aby zaktualizować składnik wartości odpowiedniej pary klucz/wartość z informacjami unikatowymi dla tego programu obsługi wyjątków. Po zakończeniu procesu aktualizacji procedura obsługi wyjątków zgłasza wyjątek do następnego programu obsługi wyjątków wyższego poziomu. Na koniec program obsługi wyjątków najwyższego poziomu uzyskuje dostęp do par klucz/wartość i wyświetla skonsolidowane informacje o aktualizacji ze wszystkich programów obsługi wyjątków niższego poziomu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób dodawania i pobierania informacji przy użyciu <xref:System.Exception.Data%2A> właściwości.  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca <see cref="T:System.Exception" /> wartość będącą główną przyczyną jednego lub kilku kolejnych wyjątków.</summary>
        <returns>Pierwszy wyjątek zgłoszony w łańcuchu wyjątków. Jeśli właściwość bieżącego wyjątku jest odwołaniem null (<see langword="Nothing" /> w Visual Basic), ta właściwość zwraca bieżący wyjątek. <see cref="P:System.Exception.InnerException" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Łańcuch wyjątków składa się z zestawu wyjątków, w taki sposób, że każdy wyjątek w łańcuchu został zgłoszony jako bezpośredni wynik wyjątku, do którego istnieje `InnerException` odwołanie w jego właściwości. Dla danego łańcucha może istnieć tylko jeden wyjątek, który jest główną przyczyną wszystkich innych wyjątków w łańcuchu. Ten wyjątek nosi nazwę wyjątku podstawowego, a jego `InnerException` Właściwość zawsze zawiera odwołanie o wartości null.  
  
 Dla wszystkich wyjątków w łańcuchu wyjątków `GetBaseException` Metoda musi zwracać ten sam obiekt (wyjątek podstawowy).  
  
 Użyj metody `GetBaseException` , jeśli chcesz znaleźć główną przyczynę wyjątku, ale nie potrzebujesz informacji o wyjątkach, które mogły wystąpić między bieżącym wyjątkiem a pierwszym wyjątkiem.  
  
   
  
## Examples  
 Poniższy przykład kodu definiuje dwie klasy pochodne `Exception` . Wymusza wyjątek, a następnie generuje go ponownie z każdą klasą pochodną. Kod pokazuje użycie `GetBaseException` metody do pobrania oryginalnego wyjątku.  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="GetBaseException" /> Metoda jest zastępowana w klasach, które wymagają kontroli nad zawartością lub formatem wyjątku.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Przechowujący dane serializowanego obiektu o generowanym wyjątku.</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> Zawiera informacje kontekstowe o źródle lub miejscu docelowym.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, ustawia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> informacje o wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData`<xref:System.Runtime.Serialization.SerializationInfo> ustawia wszystkie dane obiektu wyjątku przeznaczone do serializacji. Podczas deserializacji wyjątek zostaje odtworzony od `SerializationInfo` przekazanego strumienia.  
  
   
  
## Examples  
 Poniższy przykład kodu definiuje pochodną klasę do `Exception` serializacji, która `GetObjectData`implementuje, która wprowadza drobne zmiany do dwóch właściwości, a następnie wywołuje klasę bazową w celu wykonania serializacji. Przykład wymusza błąd dzielenia przez 0, a następnie tworzy wystąpienie wyjątku pochodnego. Kod serializować wystąpienie do pliku, deserializacji pliku do nowego wyjątku, który zgłasza, a następnie przechwytuje i wyświetla dane wyjątku.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr jest odwołaniem o wartości null<see langword="Nothing" /> (w Visual Basic). <paramref name="info" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ środowiska uruchomieniowego bieżącego wystąpienia.</summary>
        <returns><see cref="T:System.Type" /> Obiekt, który reprezentuje dokładny typ środowiska uruchomieniowego bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda istnieje do obsługi infrastruktury .NET Framework i wewnętrznie wywołuje metodę podstawową, <xref:System.Object.GetType%2A?displayProperty=nameWithType>. <xref:System.Exception.GetType%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia link do pliku pomocy skojarzonego z tym wyjątkiem.</summary>
        <value>Jednolita nazwa zasobu (URN) lub adres URL (Uniform Resource Locator).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana, która reprezentuje plik pomocy, jest URN lub adresem URL. Na przykład może to `HelpLink` być:  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 Poniższy przykład kodu zgłasza `Exception` , że `HelpLink` właściwość w jego konstruktorze, a następnie przechwytuje wyjątek i wyświetla `HelpLink`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość HRESULT, kodowane wartości liczbowe przypisane do określonego wyjątku.</summary>
        <value>Wartość HRESULT.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT jest wartością 32-bitową podzieloną na trzy różne pola: kod ważności, kod obiektu i kod błędu. Kod ważności wskazuje, czy wartość zwracana reprezentuje informacje, ostrzeżenie lub błąd. Kod obiektu służy do identyfikowania obszaru systemu odpowiedzialnego za błąd. Kod błędu jest unikatowym numerem, który jest przypisywany do reprezentowania wyjątku. Każdy wyjątek jest mapowany na oddzielny wynik HRESULT. Gdy kod zarządzany zgłasza wyjątek, środowisko uruchomieniowe przekazuje wynik HRESULT do klienta COM. Gdy kod niezarządzany zwraca błąd, wynik HRESULT jest konwertowany na wyjątek, który jest następnie generowany przez środowisko uruchomieniowe. Aby uzyskać informacje na temat wartości HRESULT i ich odpowiednich wyjątków .NET Framework [, zobacz How to: Mapuj HRESULTs i Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md). Zobacz [typowe wartości HRESULT](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) w dokumentacji systemu Windows, aby zapoznać się z listą wartości, które najprawdopodobniej napotkasz.  
  
 Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)] <xref:System.Exception.HResult%2A> , Metoda ustawiająca właściwości jest chroniona, podczas gdy jej metoda pobierająca jest publiczna.  W poprzednich wersjach .NET Framework są chronione metody pobierające i setter.  
  
   
  
## Examples  
 Poniższy przykład kodu definiuje klasę pochodną `Exception` , która `HResult` ustawia właściwość na wartość niestandardową w konstruktorze.  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">Instrukcje: Mapowanie wyników HRESULT i wyjątków</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">Typowe wartości HRESULT</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Exception" /> Pobiera wystąpienie, które spowodowało bieżący wyjątek.</summary>
        <value>Obiekt, który opisuje błąd, który spowodował bieżący wyjątek. Właściwość zwraca tę samą wartość, która została przekazana <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> do konstruktora, lub <see langword="null" /> Jeśli wewnętrzna wartość wyjątku nie została dostarczona do konstruktora. <see cref="P:System.Exception.InnerException" /> Ta właściwość jest tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `X` wyjątek jest zgłaszany jako bezpośredni wynik poprzedniego wyjątku <xref:System.Exception.InnerException%2A> `Y`, właściwość `X` powinna zawierać odwołanie do `Y`.  
  
 <xref:System.Exception.InnerException%2A> Użyj właściwości, aby uzyskać zestaw wyjątków, które doprowadziły do bieżącego wyjątku.  
  
 Można utworzyć nowy wyjątek, który przechwytuje wcześniejszy wyjątek. Kod, który obsługuje drugi wyjątek, może używać dodatkowych informacji z wcześniejszego wyjątku, aby bardziej odpowiednio obsłużyć błąd.  
  
 Załóżmy, że istnieje funkcja, która odczytuje plik i formatuje dane z tego pliku. W tym przykładzie, ponieważ kod próbuje odczytać plik, <xref:System.IO.IOException> zostanie zgłoszony. Funkcja przechwytuje <xref:System.IO.IOException> i <xref:System.IO.FileNotFoundException>zgłasza. Może być zapisany <xref:System.Exception.InnerException%2A> we właściwości <xref:System.IO.FileNotFoundException>, co umożliwia kod, który przechwytuje, <xref:System.IO.FileNotFoundException> aby poznać przyczynę błędu początkowego. <xref:System.IO.IOException>  
  
 <xref:System.Exception.InnerException%2A> Właściwość, która przechowuje odwołanie do wewnętrznego wyjątku, jest ustawiana podczas inicjowania obiektu Exception.  
  
   
  
## Examples  
 Poniższy przykład demonstruje generowanie i przechwytywanie wyjątku, który odwołuje się do wyjątku wewnętrznego.  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera komunikat, który opisuje bieżący wyjątek.</summary>
        <value>Komunikat o błędzie objaśniający przyczynę wyjątku lub pusty ciąg ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikaty o błędach są przeznaczone dla deweloperów, którzy obsługują wyjątek. Tekst <xref:System.Exception.Message%2A> właściwości powinien całkowicie opisać błąd i, jeśli to możliwe, powinien również wyjaśnić, jak naprawić błąd. Programy obsługi wyjątków najwyższego poziomu mogą wyświetlać komunikat dla użytkowników końcowych, dlatego należy upewnić się, że jest on poprawny gramatycznie i że każde zdanie komunikatu kończy się kropką. Nie należy używać znaków zapytania ani wykrzykników. Jeśli aplikacja używa zlokalizowanych komunikatów o wyjątkach, należy się upewnić, że są one dokładnie tłumaczone.  
  
> [!IMPORTANT]
>  Nie ujawniaj poufnych informacji w komunikatach o wyjątku bez sprawdzania odpowiednich uprawnień.  
  
 Wartość <xref:System.Exception.Message%2A> właściwości jest uwzględniona w informacjach zwracanych przez <xref:System.Exception.ToString%2A>. Właściwość jest ustawiana tylko podczas <xref:System.Exception>tworzenia. <xref:System.Exception.Message%2A> Jeśli żaden komunikat nie został dostarczony do konstruktora dla bieżącego wystąpienia, system poda komunikat domyślny sformatowany przy użyciu bieżącej kultury systemowej.  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>środowisko wykonawcze systemu Windows i[!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 Poczynając od [!INCLUDE[net_v451](~/includes/net-v451-md.md)] programu [!INCLUDE[win81](~/includes/win81-md.md)]i, wierność komunikatów o błędach z wyjątków, które są propagowane z typów środowisko wykonawcze systemu Windows i elementów członkowskich, które nie są częścią .NET Framework, jest ulepszona. W szczególności komunikaty o wyjątkach z C++ rozszerzeń składników wizualnych (C++/CX) są teraz propagowane z <xref:System.Exception> powrotem do .NET Framework obiektów.  
  
   
  
## Examples  
 Poniższy przykład kodu zgłasza, a następnie przechwytuje <xref:System.Exception> wyjątek i wyświetla komunikat tekstowy wyjątku <xref:System.Exception.Message%2A> przy użyciu właściwości.
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli zgłaszasz wyjątek z właściwości i musisz odwołać się w tekście <see cref="P:System.Exception.Message" /> do argumentu właściwości, który został ustawiony lub pobrany, użyj "value" jako nazwy argumentu właściwości.</para></block>
        <block subset="none" type="overrides"><para><see cref="P:System.Exception.Message" /> Właściwość jest zastępowana w klasach, które wymagają kontroli nad zawartością lub formatem wiadomości. Kod aplikacji zwykle uzyskuje dostęp do tej właściwości, gdy musi wyświetlić informacje o wychwyconym wyjątku.  
  
Komunikat o błędzie powinien być zlokalizowany.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek jest serializowany w celu utworzenia obiektu stanu wyjątku, który zawiera serializowane dane dotyczące wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt stanu wyjątku implementuje <xref:System.Runtime.Serialization.ISafeSerializationData> interfejs.  
  
 Po zasubskrybowaniu <xref:System.Exception.SerializeObjectState> zdarzenia wyjątek jest deserializowany i tworzony jako pusty wyjątek. Konstruktor wyjątku nie jest uruchomiony, a stan wyjątku jest również deserializowany. Metoda <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> wywołania zwrotnego obiektu stanu wyjątku jest następnie powiadamiana, aby można było wypchnąć deserializowane dane do pustego wyjątku.  
  
 <xref:System.Exception.SerializeObjectState> Zdarzenie włącza przezroczyste typy wyjątków do serializacji i deserializacji danych wyjątków. Kod przezroczysty może wykonywać polecenia w granicach zestawu uprawnień, który działa w ramach, ale nie może wykonać wywołania, wywołać, pochodzić z lub zawierać kod krytyczny.  
  
 Jeśli zdarzenie nie jest subskrybowane, deserializacja odbywa się w zwykły sposób <xref:System.Exception.%23ctor%2A> przy użyciu konstruktora. <xref:System.Exception.SerializeObjectState>  
  
 Zazwyczaj procedura obsługi <xref:System.Exception.SerializeObjectState> zdarzenia jest dodawana w konstruktorze wyjątku w celu zapewnienia serializacji. Jednak, ponieważ Konstruktor nie jest wykonywany, gdy <xref:System.Exception.SerializeObjectState> program obsługi zdarzeń jest wykonywany, Serializowanie wyjątku deserializowanego może <xref:System.Runtime.Serialization.SerializationException> zgłosić wyjątek podczas próby deserializacji wyjątku. Aby tego uniknąć, należy również dodać procedurę obsługi dla <xref:System.Exception.SerializeObjectState> zdarzenia <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> w metodzie. Zobacz sekcję przykłady, aby zapoznać się z ilustracją.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `BadDivisionException` , który <xref:System.Exception.SerializeObjectState> obsługuje zdarzenie. Zawiera również obiekt stanu, który jest zagnieżdżoną strukturą o nazwie `BadDivisionExceptionState` <xref:System.Runtime.Serialization.ISafeSerializationData> implementującej interfejs.  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException` Wyjątek jest zgłaszany, gdy występuje dzielenie zmiennoprzecinkowe przez zero. Podczas pierwszego dzielenia przez zero, przykład tworzy `BadDivisionException` obiekt, serializować go i zgłasza wyjątek. Gdy występują kolejne podziały przez zero, przykład deserializacji poprzednio serializowanego obiektu, deserializacji go i zgłasza wyjątek. W celu zapewnienia serializacji obiektu, deserializacji, deserializacji i deserializacji, przykład dodaje <xref:System.Exception.SerializeObjectState> procedurę obsługi zdarzeń zarówno `BadDivisionException` w konstruktorze <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> klasy, jak i w implementacji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jeśli to zdarzenie jest subskrybowane i używane, wszystkie typy pochodne, które są zgodne w hierarchii dziedziczenia, muszą implementować ten sam mechanizm serializacji.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę aplikacji lub obiekt, który powoduje błąd.</summary>
        <value>Nazwa aplikacji lub obiektu, który powoduje błąd.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.Source%2A> Jeśli właściwość nie zostanie ustawiona jawnie, środowisko uruchomieniowe automatycznie ustawi ją na nazwę zestawu, z którego pochodzi wyjątek.  
  
   
  
## Examples  
 Poniższy przykład zgłasza `Exception` , że `Source` ustawia właściwość w jego konstruktorze, a następnie przechwytuje wyjątek i wyświetla `Source`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Obiekt musi być obiektem środowiska <see cref="N:System.Reflection" /> uruchomieniowego.</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg reprezentujący bezpośrednie ramki w stosie wywołań.</summary>
        <value>Ciąg, który opisuje bezpośrednie klatki stosu wywołań.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stos wykonywania śledzi wszystkie metody, które są wykonywane w danym momencie. Śledzenie wywołań metod jest nazywane śladem stosu. Lista śladów stosu zapewnia sposób, aby postępować zgodnie ze stosem wywołań do numeru wiersza w metodzie, w której występuje wyjątek.  
  
 <xref:System.Exception.StackTrace%2A> Właściwość zwraca ramki stosu wywołań, które pochodzą z lokalizacji, w której został zgłoszony wyjątek. Możesz uzyskać informacje o dodatkowych klatkach w stosie wywołań, tworząc nowe wystąpienie <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> klasy i używając jej <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> metody.  
  
 Środowisko uruchomieniowe języka wspólnego (CLR) aktualizuje ślad stosu za każdym razem, gdy wyjątek jest zgłaszany w kodzie aplikacji `throw` (za pomocą słowa kluczowego). Jeśli wyjątek został ponownie zgłoszony w metodzie, która jest inna niż metoda, w której został pierwotnie zgłoszony, ślad stosu zawiera zarówno lokalizację w metodzie, w której został wygenerowany wyjątek, jak i lokalizację w metodzie, w której wystąpił wyjątek zgłaszany ponownie. Jeśli wyjątek jest zgłaszany, a później ponownie zgłaszany, w tej samej metodzie ślad stosu zawiera tylko lokalizację, w której wyjątek został ponownie zgłoszony i nie zawiera lokalizacji, w której pierwotnie został zgłoszony wyjątek.  
  
 <xref:System.Exception.StackTrace%2A> Właściwość może nie raportować tylu wywołań metod zgodnie z oczekiwaniami, ponieważ przekształcenia kodu, takie jak derysowanie, występują podczas optymalizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu zgłasza `Exception` , a następnie przechwytuje i wyświetla ślad stosu `StackTrace` przy użyciu właściwości.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="StackTrace" /> Właściwość jest zastępowana w klasach, które wymagają kontroli nad zawartością lub formatem śladu stosu.  
  
Domyślnie ślad stosu jest przechwytywany bezpośrednio przed zgłoszeniem obiektu wyjątku. Użyj <see cref="P:System.Environment.StackTrace" /> , aby uzyskać informacje o śledzeniu stosu, gdy żaden wyjątek nie jest zgłaszany.</para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę, która zgłasza bieżący wyjątek.</summary>
        <value><see cref="T:System.Reflection.MethodBase" /> , Który wywołał bieżący wyjątek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda zwracająca ten wyjątek jest niedostępna, a ślad stosu nie jest odwołaniem null (`Nothing` w Visual Basic), <xref:System.Exception.TargetSite%2A> uzyskuje metodę z śladu stosu. Jeśli ślad stosu jest odwołaniem o wartości null <xref:System.Exception.TargetSite%2A> , zwraca również odwołanie o wartości null.  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A> Właściwość może nieprawidłowo zgłosić nazwę metody, w której wystąpił wyjątek, jeśli procedura obsługi wyjątków obsługuje wyjątek między domeną aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu zgłasza `Exception` , a następnie przechwytuje i wyświetla metodę źródłową `TargetSite` przy użyciu właściwości.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca reprezentację ciągu bieżącego wyjątku.</summary>
        <returns>Ciąg reprezentujący bieżący wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A>Zwraca reprezentację bieżącego wyjątku, która ma być zrozumiała dla ludzi. W przypadku, gdy wyjątek zawiera dane zależne od kultury, reprezentacja `ToString` ciągu zwracanego przez jest wymagana do uwzględnienia bieżącej kultury systemowej. Chociaż nie ma dokładnych wymagań dotyczących formatu zwracanego ciągu, powinien on próbować odzwierciedlić wartość obiektu, tak jak zostało to postrzegane przez użytkownika.  
  
 Domyślna implementacja programu <xref:System.Exception.ToString%2A> uzyskuje nazwę klasy, która wywołała bieżący wyjątek, komunikat, wynik wywołania <xref:System.Exception.ToString%2A> wyjątku wewnętrznego i wynik wywołania <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>. Jeśli którykolwiek z tych elementów członkowskich `null`jest, jego wartość nie jest uwzględniona w zwracanym ciągu.  
  
 Jeśli nie ma komunikatu o błędzie lub jeśli jest to ciąg pusty (""), nie zostanie zwrócony żaden komunikat o błędzie. Nazwa wewnętrznego wyjątku i ślad stosu są zwracane tylko wtedy, gdy nie `null`są.  
  
 Ta metoda przesłania <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład powoduje wystąpienie wyjątku i wyświetla wynik wywołania <xref:System.Exception.ToString%2A> tego wyjątku. Należy zauważyć, <xref:System.Exception.ToString%2A?displayProperty=nameWithType> że metoda jest wywoływana niejawnie, gdy wystąpienie klasy wyjątku pojawia się na liście <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> argumentów metody.  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

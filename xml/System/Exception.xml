<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Exception.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86c3e876a1482a23c73451498e9a529b706c17f38a0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e876a1482a23c73451498e9a529b706c17f38a0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Exception">
          <source>Represents errors that occur during application execution.</source>
          <target state="translated">Reprezentuje błędów występujących podczas wykonywania aplikacji.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This class is the base class for all exceptions.</source>
          <target state="translated">Ta klasa jest klasą bazową dla wszystkich wyjątków.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When an error occurs, either the system or the currently executing application reports it by throwing an exception that contains information about the error.</source>
          <target state="translated">Gdy wystąpi błąd, system lub aktualnie realizowanej aplikacji zgłasza przez Zgłaszanie wyjątku, który zawiera informacje o tym błędzie.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>After an exception is thrown, it is handled by the application or by the default exception handler.</source>
          <target state="translated">Po jest zgłaszany wyjątek, jest to obsługiwane przez aplikację lub przez domyślną procedurę obsługi wyjątków.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In this section:</source>
          <target state="translated">W tej sekcji:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Errors and exceptions<ept id="p1">](#Errors)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Błędy i wyjątki<ept id="p1">](#Errors)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Try/catch blocks<ept id="p1">](#TryCatch)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Bloki try/catch<ept id="p1">](#TryCatch)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Exception type features<ept id="p1">](#Features)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Wyjątek typu funkcji<ept id="p1">](#Features)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Exception class properties<ept id="p1">](#Properties)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Właściwości klasy wyjątków<ept id="p1">](#Properties)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Performance considerations<ept id="p1">](#Performance)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Zagadnienia dotyczące wydajności<ept id="p1">](#Performance)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Re-throwing an exception<ept id="p1">](#Rethrow)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Ponownego generowania wyjątku<ept id="p1">](#Rethrow)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Choosing standard exceptions<ept id="p1">](#Standard)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Wybieranie standardowe wyjątków<ept id="p1">](#Standard)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Implementing custom exceptions<ept id="p1">](#Custom)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Implementowanie niestandardowymi wyjątkami<ept id="p1">](#Custom)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Errors and exceptions</source>
          <target state="translated">Błędy i wyjątki</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Run-time errors can occur for a variety of reasons.</source>
          <target state="translated">Z różnych powodów, mogą wystąpić błędy czasu wykonywania.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>However, not all errors should be handled as exceptions in your code.</source>
          <target state="translated">Jednak nie wszystkie błędy powinny być traktowane jako wyjątki w kodzie.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Here are some categories of errors that can occur at run time and the appropriate ways to respond to them.</source>
          <target state="translated">Poniżej przedstawiono niektóre kategorie błędy, które mogą wystąpić w czasie wykonywania i odpowiednie sposoby nie odpowiadają.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">**</bpt>Usage errors.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Błędy użycia.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A usage error represents an error in program logic that can result in an exception.</source>
          <target state="translated">Błąd użycia reprezentuje błąd w logice programu, który może spowodować wyjątek.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>However, the error should be addressed not through exception handling but by modifying the faulty code.</source>
          <target state="translated">Jednak powinny być kierowane błąd, nie za pomocą obsługi wyjątków, ale modyfikując nieprawidłowy kod.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, the override of the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method in the following example assumes that the <ph id="ph2">`obj`</ph> argument must always be non-null.</source>
          <target state="translated">Na przykład zastępowania <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> metody w następującym przykładzie zakłada się, że <ph id="ph2">`obj`</ph> argumentu musi zawsze mieć wartości null.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> exception that results when <ph id="ph2">`obj`</ph> is <ph id="ph3">`null`</ph> can be eliminated by modifying the source code to explicitly test for null before calling the <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> override and then re-compiling.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> Wyjątek, który powoduje podczas <ph id="ph2">`obj`</ph> jest <ph id="ph3">`null`</ph> mogą zostać usunięte przez zmodyfikowanie kodu źródłowego próba jawnie na wartość null przed wywołaniem <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> zastępowania i ponowną kompilację.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example contains the corrected source code that handles a <ph id="ph1">`null`</ph> argument.</source>
          <target state="translated">Poniżej przedstawiono przykład zawierający kod źródłowy poprawiony, który obsługuje <ph id="ph1">`null`</ph> argumentu.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead of using exception handling for usage errors, you can use the <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType&gt;</ph> method to identify usage errors in debug builds, and the <ph id="ph2">&lt;xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType&gt;</ph> method to identify usage errors in both debug and release builds.</source>
          <target state="translated">Zamiast korzystać z obsługi błędów użycia wyjątków, można użyć <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType&gt;</ph> metodę identyfikowania błędów użycia w kompilacjach do debugowania i <ph id="ph2">&lt;xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType&gt;</ph> kompilacje metoda do użycia w wykrywaniu błędów zarówno debug i release.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information, see <bpt id="p1">[</bpt>Assertions in Managed Code<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>potwierdzenia w kod zarządzany<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">**</bpt>Program errors.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Błędy programu.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A program error is a run-time error that cannot necessarily be avoided by writing bug-free code.</source>
          <target state="translated">Błąd programu jest błąd w czasie wykonywania, którego nie można uniknąć niekoniecznie pisanie kodu bez błędów.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In some cases, a program error may reflect an expected or routine error condition.</source>
          <target state="translated">W niektórych przypadkach błąd programu mogą uwzględniać warunek błędu oczekiwanych lub procedury.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In this case, you may want to avoid using exception handling to deal with the program error and instead retry the operation.</source>
          <target state="translated">W takim przypadku można uniknąć, za pomocą obsługi wyjątków biznesowych w radzeniu sobie z powodu błędu programu, a zamiast tego spróbuj ponownie wykonać operację.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, if the user is expected to input a date in a particular format, you can parse the date string by calling the <ph id="ph1">&lt;xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> value that indicates whether the parse operation succeeded, instead of using the <ph id="ph3">&lt;xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType&gt;</ph> method, which throws a <ph id="ph4">&lt;xref:System.FormatException&gt;</ph> exception if the date string cannot be converted to a <ph id="ph5">&lt;xref:System.DateTime&gt;</ph> value.</source>
          <target state="translated">Na przykład, jeśli użytkownik ma wprowadź datę w określonym formacie, można przeanalizować ciągu daty wywołując <ph id="ph1">&lt;xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType&gt;</ph> metody, która zwraca <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> wartość, która wskazuje, czy operacja analizy zakończyło się pomyślnie, zamiast <ph id="ph3">&lt;xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType&gt;</ph>— metoda, która zgłasza <ph id="ph4">&lt;xref:System.FormatException&gt;</ph> wyjątek, jeśli nie można przekonwertować ciągu daty <ph id="ph5">&lt;xref:System.DateTime&gt;</ph> wartość.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Similarly, if a user tries to open a file that does not exist, you can first call the <ph id="ph1">&lt;xref:System.IO.File.Exists%2A?displayProperty=nameWithType&gt;</ph> method to check whether the file exists and, if it does not, prompt the user whether he or she wants to create it.</source>
          <target state="translated">Podobnie, jeśli użytkownik podejmuje próbę otwarcia pliku, który nie istnieje, można wywołać <ph id="ph1">&lt;xref:System.IO.File.Exists%2A?displayProperty=nameWithType&gt;</ph> , aby sprawdzić, czy plik istnieje i, jeśli nie, Monituj użytkownika, czy użytkownik chce go utworzyć.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In other cases, a program error reflects an unexpected error condition that can be handled in your code.</source>
          <target state="translated">W pozostałych przypadkach błąd programu odzwierciedla nieoczekiwany błąd, które mogą być obsługiwane w kodzie.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, even if you've checked to ensure that a file exists, it may be deleted before you can open it, or it may be corrupted.</source>
          <target state="translated">Na przykład nawet jeśli została sprawdzona, aby upewnić się, że plik istnieje, jej mogą zostać usunięte przed, możesz otworzyć go lub jest uszkodzony.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In that case, trying to open the file by instantiating a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object or calling the <ph id="ph2">&lt;xref:System.IO.File.Open%2A&gt;</ph> method may throw a <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph> exception.</source>
          <target state="translated">W takim przypadku próby otwarcia pliku przez utworzenie wystąpienia <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> obiektu lub wywoływania <ph id="ph2">&lt;xref:System.IO.File.Open%2A&gt;</ph> metoda może generować <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph> wyjątku.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In these cases, you should use exception handling to recover from the error.</source>
          <target state="translated">W takich sytuacjach należy użyć obsługi wyjątków, aby odzyskać sprawność po błędzie.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">**</bpt>System failures.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Awarie systemu.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A system failure is a run-time error that cannot be handled programmatically in a meaningful way.</source>
          <target state="translated">Awarii systemu jest błąd w czasie wykonywania, które nie mogą być obsługiwane programowo w znaczący sposób.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, any method can throw an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception if the common language runtime is unable to allocate additional memory.</source>
          <target state="translated">Na przykład może zgłosić dowolnej metody <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> wyjątek, jeśli nie można przydzielić pamięć jest środowisko uruchomieniowe języka wspólnego.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Ordinarily, system failures are not handled by using exception handling.</source>
          <target state="translated">Zwykle awarii systemu nie są obsługiwane przy użyciu obsługi wyjątków.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead, you may be able to use an event such as <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> and call the <ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph> method to log exception information and notify the user of the failure before the application terminates.</source>
          <target state="translated">Zamiast tego można użyć zdarzenia, takie jak <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> i Wywołaj <ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph> metody do rejestrowania informacji o wyjątku i powiadamia użytkownika o awarii, zanim aplikacja zakończy.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Try/catch blocks</source>
          <target state="translated">Bloki try/catch</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The common language runtime provides an exception handling model that is based on the representation of exceptions as objects, and the separation of program code and exception handling code into <ph id="ph1">`try`</ph> blocks and <ph id="ph2">`catch`</ph> blocks.</source>
          <target state="translated">Środowisko uruchomieniowe języka wspólnego udostępnia model obsługi wyjątku, który jest oparta na reprezentację wyjątki jako obiekty i oddzielenie kodu programu i kodu do obsługi wyjątków <ph id="ph1">`try`</ph> bloków i <ph id="ph2">`catch`</ph> bloków.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>There can be one or more <ph id="ph1">`catch`</ph> blocks, each designed to handle a particular type of exception, or one block designed to catch a more specific exception than another block.</source>
          <target state="translated">Może istnieć co najmniej jeden <ph id="ph1">`catch`</ph> blokuje każdego przeznaczone do obsługi określonego typu wyjątku lub jeden blok wychwytywania bardziej konkretny wyjątek niż inny blok.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If an application handles exceptions that occur during the execution of a block of application code, the code must be placed within a <ph id="ph1">`try`</ph> statement and is called a <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">Jeśli aplikacja obsługuje wyjątków występujących podczas wykonywania blok kodu aplikacji, kodu musi zostać umieszczony w <ph id="ph1">`try`</ph> instrukcji i nosi nazwę <ph id="ph2">`try`</ph> bloku.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Application code that handles exceptions thrown by a <ph id="ph1">`try`</ph> block is placed within a <ph id="ph2">`catch`</ph> statement and is called a <ph id="ph3">`catch`</ph> block.</source>
          <target state="translated">Kod aplikacji, które obsługuje wyjątków zgłaszanych przez <ph id="ph1">`try`</ph> blok jest umieszczony w obrębie <ph id="ph2">`catch`</ph> instrukcji i nosi nazwę <ph id="ph3">`catch`</ph> bloku.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Zero or more <ph id="ph1">`catch`</ph> blocks are associated with a <ph id="ph2">`try`</ph> block, and each <ph id="ph3">`catch`</ph> block includes a type filter that determines the types of exceptions it handles.</source>
          <target state="translated">Zero lub więcej <ph id="ph1">`catch`</ph> bloki są skojarzone z <ph id="ph2">`try`</ph> bloku oraz każdy <ph id="ph3">`catch`</ph> bloku obejmuje filtr typu, który określa typy obsługi wyjątków.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When an exception occurs in a <ph id="ph1">`try`</ph> block, the system searches the associated <ph id="ph2">`catch`</ph> blocks in the order they appear in application code, until it locates a <ph id="ph3">`catch`</ph> block that handles the exception.</source>
          <target state="translated">Gdy wystąpi wyjątek w <ph id="ph1">`try`</ph> bloku, system wyszukuje skojarzony <ph id="ph2">`catch`</ph> blokuje w kolejności ich występowania w kodzie aplikacji, lokalizując <ph id="ph3">`catch`</ph> bloku, który obsługuje wyjątek.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A <ph id="ph1">`catch`</ph> block handles an exception of type <ph id="ph2">`T`</ph> if the type filter of the catch block specifies <ph id="ph3">`T`</ph> or any type that <ph id="ph4">`T`</ph> derives from.</source>
          <target state="translated">A <ph id="ph1">`catch`</ph> blok obsługuje wyjątek typu <ph id="ph2">`T`</ph> Jeśli Określa filtr typu bloku catch <ph id="ph3">`T`</ph> lub dowolny typ <ph id="ph4">`T`</ph> pochodną.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The system stops searching after it finds the first <ph id="ph1">`catch`</ph> block that handles the exception.</source>
          <target state="translated">Wyszukiwanie po znalezieniu pierwszy zatrzymania systemu <ph id="ph1">`catch`</ph> bloku, który obsługuje wyjątek.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For this reason, in application code, a <ph id="ph1">`catch`</ph> block that handles a type must be specified before a <ph id="ph2">`catch`</ph> block that handles its base types, as demonstrated in the example that follows this section.</source>
          <target state="translated">Z tego powodu w kodzie aplikacji <ph id="ph1">`catch`</ph> bloku, który obsługuje typ muszą zostać określone przed <ph id="ph2">`catch`</ph> bloku obsługująca jego typów podstawowych, jak pokazano w następującym przykładzie w tej sekcji.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A catch block that handles <ph id="ph1">`System.Exception`</ph> is specified last.</source>
          <target state="translated">Blok catch, która obsługuje <ph id="ph1">`System.Exception`</ph> jest określony jako ostatni.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If none of the <ph id="ph1">`catch`</ph> blocks associated with the current <ph id="ph2">`try`</ph> block handle the exception, and the current <ph id="ph3">`try`</ph> block is nested within other <ph id="ph4">`try`</ph> blocks in the current call, the <ph id="ph5">`catch`</ph> blocks associated with the next enclosing <ph id="ph6">`try`</ph> block are searched.</source>
          <target state="translated">Jeśli żadna z <ph id="ph1">`catch`</ph> bloki skojarzone z bieżącym <ph id="ph2">`try`</ph> bloku obsługi wyjątków, a bieżący <ph id="ph3">`try`</ph> bloku jest zagnieżdżone w innych <ph id="ph4">`try`</ph> blokuje w bieżącym wywołaniu <ph id="ph5">`catch`</ph> bloki skojarzone z następnej otaczającej <ph id="ph6">`try`</ph> bloku są przeszukiwane.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If no <ph id="ph1">`catch`</ph> block for the exception is found, the system searches previous nesting levels in the current call.</source>
          <target state="translated">Jeśli nie <ph id="ph1">`catch`</ph> bloku wyjątek zostanie znaleziony, system wyszukuje poprzednie poziomów zagnieżdżenia w bieżącym wywołaniu.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If no <ph id="ph1">`catch`</ph> block for the exception is found in the current call, the exception is passed up the call stack, and the previous stack frame is searched for a <ph id="ph2">`catch`</ph> block that handles the exception.</source>
          <target state="translated">Jeśli nie <ph id="ph1">`catch`</ph> zablokować dla wyjątek znajduje się w bieżącym wywołaniu wyjątek jest przekazywany w górę stosu wywołań i poprzedniej ramki stosu jest wyszukiwany <ph id="ph2">`catch`</ph> bloku, który obsługuje wyjątek.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The search of the call stack continues until the exception is handled or until no more frames exist on the call stack.</source>
          <target state="translated">Wyszukiwanie stos wywołań będzie kontynuowane aż do obsługi wyjątku lub istnieje ma więcej ramek na stosie wywołań.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If the top of the call stack is reached without finding a <ph id="ph1">`catch`</ph> block that handles the exception, the default exception handler handles it and the application terminates.</source>
          <target state="translated">Po osiągnięciu górnej części stosu wywołań nie <ph id="ph1">`catch`</ph> blok, który obsługuje wyjątek domyślny program obsługi wyjątku obsługuje go i zakończy aplikacji.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception type features</source>
          <target state="translated">Funkcje typu wyjątku</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception types support the following features:</source>
          <target state="translated">Typy wyjątków obsługuje następujące funkcje:</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Human-readable text that describes the error.</source>
          <target state="translated">Czytelny dla człowieka tekst, który opisuje błąd.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When an exception occurs, the runtime makes a text message available to inform the user of the nature of the error and to suggest action to resolve the problem.</source>
          <target state="translated">Po wystąpieniu wyjątku, środowisko uruchomieniowe sprawia, że wiadomość SMS poinformować użytkownika charakteru błędu i zasugerować akcji do rozwiązania problemu.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This text message is held in the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the exception object.</source>
          <target state="translated">Ta wiadomość tekstowa jest przechowywana w <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> właściwości obiekt wyjątku.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>During the creation of the exception object, you can pass a text string to the constructor to describe the details of that particular exception.</source>
          <target state="translated">Podczas tworzenia obiektu wyjątku można przekazać ciąg tekstowy do konstruktora opisujący szczegóły tego określonego wyjątku.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If no error message argument is supplied to the constructor, the default error message is used.</source>
          <target state="translated">Jeśli nie błąd komunikat podano argumentu do konstruktora, używany jest domyślny komunikat o błędzie.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The state of the call stack when the exception was thrown.</source>
          <target state="translated">Stan stos wywołań, gdy wyjątek został zgłoszony.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> property carries a stack trace that can be used to determine where the error occurs in the code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> Właściwość niesie ślad stosu, który może służyć do określenia, gdzie występuje błąd w kodzie.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The stack trace lists all the called methods and the line numbers in the source file where the calls are made.</source>
          <target state="translated">Ślad stosu wymieniono wywoływane metody i numery wierszy w pliku źródłowym, w którym wywołań.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception class properties</source>
          <target state="translated">Właściwości klasy wyjątku</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class includes a number of properties that help identify the code location, the type, the help file, and the reason for the exception: <ph id="ph2">&lt;xref:System.Exception.StackTrace%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Exception.Message%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Exception.HelpLink%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Exception.HResult%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Exception.Source%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Exception.TargetSite%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Exception.Data%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception&gt;</ph> Klasy zawiera wiele właściwości, które ułatwia identyfikację lokalizacji kodu, typ pliku pomocy i przyczynę wyjątek: <ph id="ph2">&lt;xref:System.Exception.StackTrace%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Exception.Message%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Exception.HelpLink%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Exception.HResult%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Exception.Source%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Exception.TargetSite%2A&gt;</ph>, i <ph id="ph9">&lt;xref:System.Exception.Data%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When a causal relationship exists between two or more exceptions, the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property maintains this information.</source>
          <target state="translated">Gdy istnieje przyczynowego między co najmniej dwa wyjątki, <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> właściwość przechowuje te informacje.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The outer exception is thrown in response to this inner exception.</source>
          <target state="translated">Wyjątek zewnętrzny jest generowany w odpowiedzi na ten wyjątek wewnętrzny.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The code that handles the outer exception can use the information from the earlier inner exception to handle the error more appropriately.</source>
          <target state="translated">Kod obsługujący Wyjątek zewnętrzny umożliwia bardziej odpowiednią obsługę błąd informacji z wcześniej wyjątek wewnętrzny.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Supplementary information about the exception can be stored as a collection of key/value pairs in the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property.</source>
          <target state="translated">Dodatkowe informacje o wyjątku mogą być przechowywane jako kolekcja par klucz/wartość w <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The error message string that is passed to the constructor during the creation of the exception object should be localized and can be supplied from a resource file by using the <ph id="ph1">&lt;xref:System.Resources.ResourceManager&gt;</ph> class.</source>
          <target state="translated">Ciąg z komunikatem o przekazywany do konstruktora podczas tworzenia obiektu wyjątku powinien być zlokalizowany i plik zasobów mogą być dostarczane za pomocą <ph id="ph1">&lt;xref:System.Resources.ResourceManager&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information about localized resources, see the <bpt id="p1">[</bpt>Creating Satellite Assemblies<ept id="p1">](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)</ept> and <bpt id="p2">[</bpt>Packaging and Deploying Resources<ept id="p2">](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)</ept> topics.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat zlokalizowanych zasobów, zobacz <bpt id="p1">[</bpt>tworzenie zestawów satelickich<ept id="p1">](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)</ept> i <bpt id="p2">[</bpt>pakowanie i wdrażanie zasobów<ept id="p2">](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)</ept> tematów.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>To provide the user with extensive information about why the exception occurred, the <ph id="ph1">&lt;xref:System.Exception.HelpLink%2A&gt;</ph> property can hold a URL (or URN) to a help file.</source>
          <target state="translated">Aby przyznać użytkownikowi o dodatkowe informacje o dlaczego wystąpił wyjątek <ph id="ph1">&lt;xref:System.Exception.HelpLink%2A&gt;</ph> właściwości może zawierać adres URL (lub URN) do pliku pomocy.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class uses the HRESULT COR_E_EXCEPTION, which has the value 0x80131500.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception&gt;</ph> COR_E_EXCEPTION HRESULT, która ma wartość 0x80131500 używa klasy.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For a list of initial property values for an instance of the <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class, see the <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> constructors.</source>
          <target state="translated">Aby uzyskać listę początkowe wartości właściwości dla wystąpienia <ph id="ph1">&lt;xref:System.Exception&gt;</ph> , zobacz <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> konstruktorów.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Performance considerations</source>
          <target state="translated">Zagadnienia dotyczące wydajności</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Throwing or handling an exception consumes a significant amount of system resources and execution time.</source>
          <target state="translated">Wyrzucanie lub Obsługa wyjątku zużywa znaczną ilość zasobów systemowych i czasu wykonywania.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Throw exceptions only to handle truly extraordinary conditions, not to handle predictable events or flow control.</source>
          <target state="translated">Zgłaszanie wyjątków tylko do obsługi naprawdę nadzwyczajne warunki, nie obsługi zdarzeń przewidywalne lub Sterowanie przepływem.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, in some cases, such as when you're developing a class library, it's reasonable to throw an exception if a method argument is invalid, because you expect your method to be called with valid parameters.</source>
          <target state="translated">Na przykład w niektórych przypadkach, takich jak Jeśli projektujesz biblioteki klas, jest uzasadnione zgłosić wyjątek, jeśli argument metody jest nieprawidłowy, ponieważ oczekuje metodę można wywołać z prawidłowe parametry.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An invalid method argument, if it is not the result of a usage error, means that something extraordinary has occurred.</source>
          <target state="translated">Argument nieprawidłową metodę, jeśli nie jest wynikiem błędu użycia oznacza, że coś nadzwyczajne wystąpił.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Conversely, do not throw an exception if user input is invalid, because you can expect users to occasionally enter invalid data.</source>
          <target state="translated">Z drugiej strony nie zgłosić wyjątek, jeśli dane wejściowe użytkownika jest nieprawidłowy, ponieważ można oczekiwać, że od czasu do czasu wprowadzenia nieprawidłowe dane.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead, provide a retry mechanism so users can enter valid input.</source>
          <target state="translated">Zamiast tego udostępniają mechanizm ponawiania, więc użytkownik może wprowadzić prawidłowe wartości wejściowe.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Nor should you use exceptions to handle usage errors.</source>
          <target state="translated">Nie należy używać wyjątków do obsługi błędów użycia.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead, use <bpt id="p1">[</bpt>assertions<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept> to identify and correct usage errors.</source>
          <target state="translated">Zamiast tego należy użyć <bpt id="p1">[</bpt>potwierdzenia<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept> Aby zidentyfikować i poprawić błędy użycia.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In addition, do not throw an exception when a return code is sufficient; do not convert a return code to an exception; and do not routinely catch an exception, ignore it, and then continue processing.</source>
          <target state="translated">Ponadto nie zgłosić wyjątek, gdy kod powrotu jest wystarczające; Nie można konwertować kod powrotny wyjątek; czy nie rutynowo catch wyjątku, ją zignorować i następnie kontynuować przetwarzanie.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Re-throwing an exception</source>
          <target state="translated">Ponownego generowania wyjątku</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In many cases, an exception handler simply wants to pass the exception on to the caller.</source>
          <target state="translated">W wielu przypadkach program obsługi wyjątku po prostu chce przekazać wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This most often occurs in:</source>
          <target state="translated">Najczęstszą przyczyną tego błędu w:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A class library that in turn wraps calls to methods in the .NET Framework class library or other class libraries.</source>
          <target state="translated">Biblioteka klas, który z kolei powoduje błąd wywołania metody w bibliotece klas programu .NET Framework lub innych bibliotek klas.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An application or library that encounters a fatal exception.</source>
          <target state="translated">Aplikacja lub biblioteki, który napotkał wyjątek krytyczny.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The exception handler can log the exception and then re-throw the exception.</source>
          <target state="translated">Obsługa wyjątków zalogować wyjątek i ponowne zgłoszenie wyjątku.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The recommended way to re-throw an exception is to simply use the <bpt id="p1">[</bpt>throw<ept id="p1">](~/docs/csharp/language-reference/keywords/throw.md)</ept> statement in C# and the <bpt id="p2">[</bpt>Throw<ept id="p2">](~/docs/visual-basic/language-reference/statements/throw-statement.md)</ept> statement in Visual Basic without including an expression.</source>
          <target state="translated">Zalecanym sposobem do ponownego zgłoszenia wyjątku jest po prostu użyć <bpt id="p1">[</bpt>throw<ept id="p1">](~/docs/csharp/language-reference/keywords/throw.md)</ept> instrukcji w języku C# i <bpt id="p2">[</bpt>Throw<ept id="p2">](~/docs/visual-basic/language-reference/statements/throw-statement.md)</ept> instrukcji w języku Visual Basic bez uwzględniania wyrażenia.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This ensures that all call stack information is preserved when the exception is propagated to the caller.</source>
          <target state="translated">Dzięki temu zachowywanie wszystkie informacje stosu wywołań, jeśli wyjątek jest propagowana do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example illustrates this.</source>
          <target state="translated">Ilustruje to poniższy przykład.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A string extension method, <ph id="ph1">`FindOccurrences`</ph>, wraps one or more calls to <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> without validating its arguments beforehand.</source>
          <target state="translated">Metodę rozszerzenie ciąg <ph id="ph1">`FindOccurrences`</ph>, opakowuje co najmniej jednego wywołania <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> bez weryfikowania jej argumenty wcześniej.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A caller then calls <ph id="ph1">`FindOccurrences`</ph> twice.</source>
          <target state="translated">Obiekt wywołujący wywołuje <ph id="ph1">`FindOccurrences`</ph> dwa razy.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In the second call to <ph id="ph1">`FindOccurrences`</ph>, the caller passes a <ph id="ph2">`null`</ph> as the search string, which cases the <ph id="ph3">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to throw an <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> exception.</source>
          <target state="translated">W wywołaniu drugi <ph id="ph1">`FindOccurrences`</ph>, przekazuje obiekt wywołujący <ph id="ph2">`null`</ph> jako ciąg wyszukiwania, które przypadków <ph id="ph3">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> metodę, aby zgłosić <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> wyjątku.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This exception is handled by the <ph id="ph1">`FindOccurrences`</ph> method and passed back to the caller.</source>
          <target state="translated">Ten wyjątek jest obsługiwany przez <ph id="ph1">`FindOccurrences`</ph> — metoda i z powrotem przekazany do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Because the throw statement is used with no expression, the output from the example shows that the call stack is preserved.</source>
          <target state="translated">Ponieważ instrukcji throw jest używana z Brak wyrażenia, dane wyjściowe w przykładzie przedstawiono zachowywanie stosu wywołań.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In contrast, if the exception is re-thrown by using the</source>
          <target state="translated">Natomiast jeśli ponownie wyjątku używając</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>statement, the full call stack is not preserved, and the example would generate the following output:</source>
          <target state="translated">Instrukcja, stos wywołań pełne nie są zachowywane i przykładzie powoduje wygenerowanie następujących danych wyjściowych:</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A slightly more cumbersome alternative is to throw a new exception, and to preserve the original exception's call stack information in an inner exception.</source>
          <target state="translated">Nieco bardziej skomplikowane alternatywą jest zgłoszenie wyjątku nowy i zachować informacje stosu wywołań pierwotny wyjątek w wyjątku wewnętrznym.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The caller can then use the new exception's <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property to retrieve stack frame and other information about the original exception.</source>
          <target state="translated">Obiekt wywołujący można użyć nowego wyjątek <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> właściwości do pobrania ramki stosu i inne informacje o pierwotny wyjątek.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In this case, the throw statement is:</source>
          <target state="translated">W takim przypadku instrukcji throw jest:</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The user code that handles the exception has to know that the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property contains information about the original exception, as the following exception handler illustrates.</source>
          <target state="translated">Kod użytkownika, który obsługuje wyjątek ma pamiętać, że <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> właściwość zawiera informacje o pierwotny wyjątek, jak pokazano w poniższych obsługi wyjątków.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Choosing standard exceptions</source>
          <target state="translated">Wybieranie standardowych wyjątków</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When you have to throw an exception, you can often use an existing exception type in the .NET Framework instead of implementing a custom exception.</source>
          <target state="translated">Jeśli ma zostać zgłoszony wyjątek, można jej użyć istniejącego typu wyjątku w programie .NET Framework zamiast Implementowanie niestandardowego wyjątku.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You should use a standard exception type under these two conditions:</source>
          <target state="translated">Należy używać typu wyjątku standardowe tych dwóch warunkach:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You are throwing an exception that is caused by a usage error (that is, by an error in program logic made by the developer who is calling your method).</source>
          <target state="translated">Są Zgłaszanie wyjątku, który jest spowodowany przez błąd użycia (oznacza to błąd w logice programu wprowadzone przez projektanta, który wywołuje metodę).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Typically, you would throw an exception such as <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>, <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>, or <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Zazwyczaj należy spowoduje zgłoszenie wyjątku takich jak <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>, <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>, lub <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The string you supply to the exception object's constructor when instantiating the exception object should describe the error so that the developer can fix it.</source>
          <target state="translated">Ciąg, który podasz do konstruktora obiektu wyjątek podczas tworzenia wystąpienia obiektu wyjątek powinien opisano błąd, dzięki czemu deweloper może go rozwiązać.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You are handling an error that can be communicated to the caller with an existing .NET Framework exception.</source>
          <target state="translated">Czy obsługa błędu, który można przekazane do elementu wywołującego z istniejących wyjątek .NET Framework.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You should throw the most derived exception possible.</source>
          <target state="translated">Powinien zgłosić wyjątek najdalszych pochodnych możliwe.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, if a method requires an argument to be a valid member of an enumeration type, you should throw an <ph id="ph1">&lt;xref:System.ComponentModel.InvalidEnumArgumentException&gt;</ph> (the most derived class) rather than an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Na przykład, jeśli metoda wymaga argumentu być prawidłowym elementem członkowskim typu wyliczeniowego, powinien zgłosić <ph id="ph1">&lt;xref:System.ComponentModel.InvalidEnumArgumentException&gt;</ph> (najbardziej pochodnej klasy) zamiast <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following table lists common exception types and the conditions under which you would throw them.</source>
          <target state="translated">W poniższej tabeli wymieniono typowe typów wyjątków i warunków, w których spowoduje zgłoszenie je.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception</source>
          <target state="translated">Wyjątek</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Condition</source>
          <target state="translated">Warunek</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A non-null argument that is passed to a method is invalid.</source>
          <target state="translated">Argument inną niż null, która została przekazana do metody jest nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An argument that is passed to a method is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Argument przekazywany do metody jest <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An argument is outside the range of valid values.</source>
          <target state="translated">Argument jest spoza zakresu prawidłowych wartości.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Part of a directory path is not valid.</source>
          <target state="translated">Część ścieżki katalogu jest nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The denominator in an integer or <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> division operation is zero.</source>
          <target state="translated">Mianownik w całkowitą lub <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> operacji dzielenia wynosi zero.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A drive is unavailable or does not exist.</source>
          <target state="translated">Dysk jest niedostępny lub nie istnieje.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A file does not exist.</source>
          <target state="translated">Plik nie istnieje.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A value is not in an appropriate format to be converted from a string by a conversion method such as <ph id="ph1">`Parse`</ph>.</source>
          <target state="translated">Wartość nie jest w odpowiednim formacie, który ma zostać przekonwertowany z ciągu za pomocą metody konwersji, takich jak <ph id="ph1">`Parse`</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An index is outside the bounds of an array or collection.</source>
          <target state="translated">Indeks jest poza granicami tablicą lub kolekcją.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A method call is invalid in an object's current state.</source>
          <target state="translated">Wywołanie metody jest nieprawidłowy w bieżącym stanie obiektu.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The specified key for accessing a member in a collection cannot be found.</source>
          <target state="translated">Nie można odnaleźć określonego klucza do uzyskiwania dostępu do elementu członkowskiego w kolekcji.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A method or operation is not implemented.</source>
          <target state="translated">Metoda lub operacja nie jest zaimplementowana.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A method or operation is not supported.</source>
          <target state="translated">Metoda lub operacja nie jest obsługiwana.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An operation is performed on an object that has been disposed.</source>
          <target state="translated">Operacja jest wykonywana na obiekcie, który został usunięty.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An arithmetic, casting, or conversion operation results in an overflow.</source>
          <target state="translated">Działania arytmetyczne, rzutowania lub konwersji spowodowało przepełnienie.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A path or file name exceeds the maximum system-defined length.</source>
          <target state="translated">Ścieżka lub nazwa pliku przekracza maksymalną długość zdefiniowana w systemie.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The operation is not supported on the current platform.</source>
          <target state="translated">Operacja nie jest obsługiwana na bieżącej platformie.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An array with the wrong number of dimensions is passed to a method.</source>
          <target state="translated">Ze złą liczbę wymiarów tablicy jest przekazywany do metody.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The time interval allotted to an operation has expired.</source>
          <target state="translated">Upłynął czas przydzielony na wykonanie operacji.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An invalid Uniform Resource Identifier (URI) is used.</source>
          <target state="translated">Nieprawidłowy identyfikator URI (Uniform Resource) jest używany.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Implementing custom exceptions</source>
          <target state="translated">Implementowanie wyjątków niestandardowych</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In the following cases, using an existing .NET Framework exception to handle an error condition is not adequate:</source>
          <target state="translated">Używanie istniejącej wyjątek .NET Framework do obsługi warunek błędu nie jest w następujących przypadkach odpowiednie:</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When the exception reflects a unique program error that cannot be mapped to an existing .NET Framework exception.</source>
          <target state="translated">Jeśli wyjątek odzwierciedla błąd unikatowy programu, które nie może być mapowane na istniejące wyjątek .NET Framework.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When the exception requires handling that is different from the handling that is appropriate for an existing .NET Framework exception, or the exception must be disambiguated from a similar exception.</source>
          <target state="translated">Jeśli wyjątek wymaga obsługi, który różni się od obsługi, który jest odpowiedni dla istniejącego wyjątek .NET Framework lub wyjątek musi rozróżniane z podobnych wyjątku.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, if you throw an <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> exception when parsing the numeric representation of a string that is out of range of the target integral type, you would not want to use the same exception for an error that results from the caller not supplying the appropriate constrained values when calling the method.</source>
          <target state="translated">Na przykład, jeśli Generowanie <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> wyjątek podczas analizowania reprezentację liczbową ciąg, który jest poza zakresem typu całkowitego docelowej, czy nie ma być używany ten sam wyjątek dla błędu, który powoduje wywołujący nie podano odpowiednie wartości ograniczeniami podczas wywoływania metody.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class is the base class of all exceptions in the .NET Framework.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception&gt;</ph> Klasa jest klasą bazową dla wszystkich wyjątków w programie .NET Framework.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Many derived classes rely on the inherited behavior of the members of the <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class; they do not override the members of <ph id="ph2">&lt;xref:System.Exception&gt;</ph>, nor do they define any unique members.</source>
          <target state="translated">Wiele klas pochodnych polegać na zachowanie dziedziczone elementy członkowskie <ph id="ph1">&lt;xref:System.Exception&gt;</ph> klasy; nie zastępuj członków <ph id="ph2">&lt;xref:System.Exception&gt;</ph>, ani czy definiują żadnych unikatowych elementów członkowskich.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>To define your own exception class:</source>
          <target state="translated">Aby zdefiniować klasy wyjątku:</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Define a class that inherits from <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">Definiowanie klasy, która dziedziczy <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If necessary, define any unique members needed by your class to provide additional information about the exception.</source>
          <target state="translated">Jeśli to konieczne, zdefiniuj żadnych unikatowych elementów członkowskich klasy potrzebne dodatkowe informacje o wyjątku.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, the <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> class includes a <ph id="ph2">&lt;xref:System.ArgumentException.ParamName%2A&gt;</ph> property that specifies the name of the parameter whose argument caused the exception, and the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> property includes a <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A&gt;</ph> property that indicates the time-out interval.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> klasa zawiera <ph id="ph2">&lt;xref:System.ArgumentException.ParamName%2A&gt;</ph> właściwość, która określa nazwę parametru, którego argument spowodował wyjątek, i <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> zawiera właściwość <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A&gt;</ph> właściwość, która wskazuje interwał limitu czasu.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If necessary, override any inherited members whose functionality you want to change or modify.</source>
          <target state="translated">W razie potrzeby należy zastąpić wszystkie dziedziczone elementy członkowskie funkcje, których chcesz zmieniać ani modyfikować.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Note that most existing derived classes of <ph id="ph1">&lt;xref:System.Exception&gt;</ph> do not override the behavior of inherited members.</source>
          <target state="translated">Należy pamiętać, że większość istniejących pochodnej klasy <ph id="ph1">&lt;xref:System.Exception&gt;</ph> nie zastępują zachowanie dziedziczone elementy członkowskie.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Determine whether your custom exception object is serializable.</source>
          <target state="translated">Określić, czy obiekt niestandardowego wyjątku jest możliwy do serializacji.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Serialization enables you to save information about the exception and permits exception information to be shared by a server and a client proxy in a remoting context.</source>
          <target state="translated">Serializacja umożliwia zapisanie informacji o wyjątku i pozwala na informacje o wyjątku być współużytkowane przez serwer i klienta serwera proxy w kontekście usług zdalnych.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>To make the exception object serializable, mark it with the <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph> attribute.</source>
          <target state="translated">Aby obiekt wyjątku do serializacji, oznacz go z <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph> atrybutu.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Define the constructors of your exception class.</source>
          <target state="translated">Definiowanie konstruktora klasy wyjątku.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Typically, exception classes have one or more of the following constructors:</source>
          <target state="translated">Zazwyczaj klasy wyjątków mają co najmniej jeden z następujących konstruktorów:</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor&gt;</ph>, which uses default values to initialize the properties of a new exception object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor&gt;</ph>, które są używane wartości domyślne można zainicjować właściwości nowy obiekt wyjątku.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%29&gt;</ph>, which initializes a new exception object with a specified error message.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%29&gt;</ph>, która inicjuje nowy obiekt wyjątku z powodu określonego błędu.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29&gt;</ph>, which initializes a new exception object with a specified error message and inner exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29&gt;</ph>, która inicjuje nowy obiekt wyjątku z komunikatu i wewnętrzny wyjątek określonego błędu.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29&gt;</ph>, which is a <ph id="ph2">`protected`</ph> constructor that initializes a new exception object from serialized data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29&gt;</ph>, która jest <ph id="ph2">`protected`</ph> Konstruktor, który inicjuje nowy obiekt wyjątku z serializacji danych.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You should implement this constructor if you've chosen to make your exception object serializable.</source>
          <target state="translated">Ten konstruktor powinien implementować Jeśli wybrano możliwy do serializacji obiektu wyjątku.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example illustrates the use of a custom exception class.</source>
          <target state="translated">Poniższy przykład przedstawia użycie klasy niestandardowej wyjątku.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>It defines a <ph id="ph1">`NotPrimeException`</ph> exception that is thrown when a client tries to retrieve a sequence of prime numbers by specifying a starting number that is not prime.</source>
          <target state="translated">Definiuje <ph id="ph1">`NotPrimeException`</ph> wyjątek zgłaszany, gdy klient próbuje pobrać sekwencji liczb pierwszych określając początkowy numer, który nie jest podstawowym.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The exception defines a new property, <ph id="ph1">`NonPrime`</ph>, that returns the non-prime number that caused the exception.</source>
          <target state="translated">Wyjątek definiuje nową właściwość <ph id="ph1">`NonPrime`</ph>, która zwraca z systemem innym niż — pierwsze numer, który spowodował wyjątek.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Besides implementing a protected parameterless constructor and a constructor with <ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph> parameters for serialization, the <ph id="ph3">`NotPrimeException`</ph> class defines three additional constructors to support the <ph id="ph4">`NonPrime`</ph> property.</source>
          <target state="translated">Oprócz wykonania chronionych konstruktora ani konstruktora z <ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph> i <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph> parametry w celu serializacji, <ph id="ph3">`NotPrimeException`</ph> klasa definiuje trzy dodatkowe konstruktorów do obsługi <ph id="ph4">`NonPrime`</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Each constructor calls a base class constructor in addition to preserving the value of the non-prime number.</source>
          <target state="translated">Każdy Konstruktor wywołuje konstruktor klasy podstawowej, oprócz zachowania programu liczba firmy z systemem innym niż pierwsza wartość.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">`NotPrimeException`</ph> class is also marked with the <ph id="ph2">&lt;xref:System.SerializableAttribute&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">`NotPrimeException`</ph> Klasy również jest oznaczony atrybutem <ph id="ph2">&lt;xref:System.SerializableAttribute&gt;</ph> atrybutu.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">`PrimeNumberGenerator`</ph> class shown in the following example uses the Sieve of Eratosthenes to calculate the sequence of prime numbers from 2 to a limit specified by the client in the call to its class constructor.</source>
          <target state="translated"><ph id="ph1">`PrimeNumberGenerator`</ph> Pokazano w poniższym przykładzie klasa używa sito Eratosthenes do obliczenia sekwencji liczb pierwszych od 2 do limitu określonego przez klienta w wywołaniu dla jego konstruktora klasy.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">`GetPrimesFrom`</ph> method returns all prime numbers that are greater than or equal to a specified lower limit, but throws a <ph id="ph2">`NotPrimeException`</ph> if that lower limit is not a prime number.</source>
          <target state="translated"><ph id="ph1">`GetPrimesFrom`</ph> Metoda zwraca wszystkie liczb pierwszych, które są większe niż lub równa określonej dolną granicę, ale zgłasza <ph id="ph2">`NotPrimeException`</ph> jeśli że dolna granica nie jest liczba pierwsza.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example makes two calls to the <ph id="ph1">`GetPrimesFrom`</ph> method with non-prime numbers, one of which crosses application domain boundaries.</source>
          <target state="translated">Poniższy przykład powoduje, że dwa wywołań <ph id="ph1">`GetPrimesFrom`</ph> metody z nie liczby pierwsze, z których jedna przecina granice domeny aplikacji.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In both cases, the exception is thrown and successfully handled in client code.</source>
          <target state="translated">W obu przypadkach wyjątek jest generowany i pomyślnie obsługiwane kodu klienta.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Windows Runtime and <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></source>
          <target state="translated">Środowisko wykonawcze systemu Windows i <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> for <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph>, some exception information is typically lost when an exception is propagated through non-.NET Framework stack frames.</source>
          <target state="translated">W <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> dla <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph>, niektóre informacje o wyjątku jest zwykle utracone w przypadku, gdy wyjątek zostanie przekazane za pomocą ramki stosu platformy .NET.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> and <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the common language runtime continues to use the original <ph id="ph3">&lt;xref:System.Exception&gt;</ph> object that was thrown unless that exception was modified in a non-.NET Framework stack frame.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> i <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, środowisko uruchomieniowe języka wspólnego w dalszym ciągu używa oryginalnej <ph id="ph3">&lt;xref:System.Exception&gt;</ph> obiekt, który został zgłoszony, chyba że ten wyjątek został zmodyfikowany w ramce stosu platformy .NET.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example demonstrates a <ph id="ph1">`catch`</ph> block that is defined to handle <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> errors.</source>
          <target state="translated">W poniższym przykładzie pokazano <ph id="ph1">`catch`</ph> bloku, który jest zdefiniowany w celu obsługi <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> błędy.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This <ph id="ph1">`catch`</ph> block also catches <ph id="ph2">&lt;xref:System.DivideByZeroException&gt;</ph> errors, because <ph id="ph3">&lt;xref:System.DivideByZeroException&gt;</ph> derives from <ph id="ph4">&lt;xref:System.ArithmeticException&gt;</ph> and there is no <ph id="ph5">`catch`</ph> block explicitly defined for <ph id="ph6">&lt;xref:System.DivideByZeroException&gt;</ph> errors.</source>
          <target state="translated">To <ph id="ph1">`catch`</ph> również zablokować połowy <ph id="ph2">&lt;xref:System.DivideByZeroException&gt;</ph> błędy, ponieważ <ph id="ph3">&lt;xref:System.DivideByZeroException&gt;</ph> pochodzi z <ph id="ph4">&lt;xref:System.ArithmeticException&gt;</ph> i ma nie <ph id="ph5">`catch`</ph> bloku jawnie zdefiniowany dla <ph id="ph6">&lt;xref:System.DivideByZeroException&gt;</ph> błędy.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="T:System.Exception">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the new instance to a system-supplied message that describes the error and takes into account the current system culture.</source>
          <target state="translated">Ten konstruktor inicjuje <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> właściwość nowego wystąpienia dostarczony przez system komunikatu opisem błędu bierze pod uwagę bieżące ustawienia kulturowe systemu.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>All the derived classes should provide this default constructor.</source>
          <target state="translated">Klasy pochodne powinien zapewnić tym domyślnego konstruktora.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>Property</source>
          <target state="translated">Właściwość</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>Value</source>
          <target state="translated">Wartość</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">Odwołanie o wartości null (<ph id="ph1">`Nothing`</ph> w języku Visual Basic).</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>A system-supplied localized description.</source>
          <target state="translated">Zlokalizowany opis dostarczany przez system.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>The following code example derives an <ph id="ph1">`Exception`</ph> that uses a predefined message.</source>
          <target state="translated">Poniższy przykład kodu pochodzi <ph id="ph1">`Exception`</ph> używającą wstępnie zdefiniowanych wiadomości.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>The code demonstrates the use of the parameterless constructor for the derived class and the base <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">Kod przedstawia użycie konstruktora bez parametrów dla klasy pochodnej i podstawowym <ph id="ph1">`Exception`</ph> klasy.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String)">
          <source>The message that describes the error.</source>
          <target state="translated">Komunikat, który opisuje błąd.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class with a specified error message.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> klasy z powodu określonego błędu.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the new instance by using the <ph id="ph2">`message`</ph> parameter.</source>
          <target state="translated">Ten konstruktor inicjuje <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> właściwość nowego wystąpienia przy użyciu <ph id="ph2">`message`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>If the <ph id="ph1">`message`</ph> parameter is <ph id="ph2">`null`</ph>, this is the same as calling the <ph id="ph3">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Jeśli <ph id="ph1">`message`</ph> parametr jest <ph id="ph2">`null`</ph>, jest taka sama jak wywołanie <ph id="ph3">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> konstruktora.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>Property</source>
          <target state="translated">Właściwość</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>Value</source>
          <target state="translated">Wartość</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">Odwołanie o wartości null (<ph id="ph1">`Nothing`</ph> w języku Visual Basic).</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The error message string.</source>
          <target state="translated">Ciąg komunikatu o błędzie.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The following code example derives an <ph id="ph1">`Exception`</ph> for a specific condition.</source>
          <target state="translated">Poniższy przykład kodu pochodzi <ph id="ph1">`Exception`</ph> dla określonego warunku.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The code demonstrates the use of the constructor that takes a caller-specified message as a parameter, for both the derived class and the base <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">Kod przedstawia użycie Konstruktor, który pobiera komunikat określonym funkcję wywołującą jako parametr, dla klasy pochodnej i podstawowym <ph id="ph1">`Exception`</ph> klasy.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that holds the serialized object data about the exception being thrown.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> Zawierający dane zserializowanego obiektu dotyczące zgłaszanego wyjątku.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that contains contextual information about the source or destination.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> Zawierający informacje kontekstowe dotyczące źródła lub miejsca docelowego.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class with serialized data.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> z zserializowanymi danymi.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</source>
          <target state="translated">Ten konstruktor jest wywoływana podczas deserializacji do odtworzenia obiektu wyjątku przesyłanego za pomocą strumienia.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>For more information, see <bpt id="p1">[</bpt>XML and SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>XML i serializacji SOAP<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The following code example defines a derived serializable <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">Poniższy przykładowy kod definiuje pochodnego serializacji <ph id="ph1">`Exception`</ph> klasy.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The code forces a divide-by-0 error and then creates an instance of the derived exception using the (<ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph>) constructor.</source>
          <target state="translated">Kod wymusza błąd dzielenia przez 0, a następnie tworzy wystąpienie klasy pochodnej wyjątków za pomocą (<ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph>) konstruktora.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</source>
          <target state="translated">Kod serializuje wystąpienie do pliku, deserializuje plik do nowego wyjątek, który zgłasza, a następnie przechwytuje i wyświetla dane wyjątku.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;paramref name="info" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> Parametr jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The class name is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Exception.HResult" /&gt;</ph> is zero (0).</source>
          <target state="translated">Nazwa klasy jest <ph id="ph1">&lt;see langword="null" /&gt;</ph> lub <ph id="ph2">&lt;see cref="P:System.Exception.HResult" /&gt;</ph> wynosi zero (0).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The error message that explains the reason for the exception.</source>
          <target state="translated">Komunikat o błędzie wyjaśniający przyczynę wyjątku.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The exception that is the cause of the current exception, or a null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) if no inner exception is specified.</source>
          <target state="translated">Wyjątek będący przyczyną bieżącego wyjątku lub odwołanie o wartości null (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> w języku Visual Basic), jeśli jest określony żaden wyjątek wewnętrzny.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class with a specified error message and a reference to the inner exception that is the cause of this exception.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> z określonego komunikatu o błędzie i odwołania do wyjątek wewnętrzny będący przyczyną tego wyjątku.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>An exception that is thrown as a direct result of a previous exception should include a reference to the previous exception in the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property.</source>
          <target state="translated">Wyjątek zgłaszany bezpośrednio w wyniku poprzedniego wyjątku powinien zawierać odwołanie do poprzedniego wyjątku we <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property returns the same value that is passed into the constructor, or a null reference (<ph id="ph2">`Nothing`</ph> in Visual Basic) if the <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property does not supply the inner exception value to the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> Właściwość zwraca tę samą wartość, która została przekazana do konstruktora lub odwołanie o wartości null (<ph id="ph2">`Nothing`</ph> w języku Visual Basic) Jeśli <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> właściwości nie dostarcza do konstruktora wartości wyjątku wewnętrznego.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>Property</source>
          <target state="translated">Właściwość</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>Value</source>
          <target state="translated">Wartość</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The inner exception reference.</source>
          <target state="translated">Odwołanie do wewnętrznego wyjątku.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The error message string.</source>
          <target state="translated">Ciąg komunikatu o błędzie.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The following code example derives an <ph id="ph1">`Exception`</ph> for a specific condition.</source>
          <target state="translated">Poniższy przykład kodu pochodzi <ph id="ph1">`Exception`</ph> dla określonego warunku.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The code demonstrates the use of the constructor that takes a message and an inner exception as parameters, for both the derived class and the base <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">Kod przedstawia użycie konstruktora, który przyjmuje wiadomości i wyjątek wewnętrzny jako parametry dla klasy pochodnej i podstawowym <ph id="ph1">`Exception`</ph> klasy.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="P:System.Exception.Data">
          <source>Gets a collection of key/value pairs that provide additional user-defined information about the exception.</source>
          <target state="translated">Pobiera kolekcję par klucz/wartość, które znajdują się dodatkowe zdefiniowane przez użytkownika informacje o wyjątku.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>An object that implements the <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> interface and contains a collection of user-defined key/value pairs.</source>
          <target state="translated">Obiekt, który implementuje <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> interfejsu i zawiera kolekcję par klucz/wartość zdefiniowane przez użytkownika.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The default is an empty collection.</source>
          <target state="translated">Wartością domyślną jest pusta kolekcja.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Use the <ph id="ph1">&lt;xref:System.Collections.IDictionary?displayProperty=nameWithType&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Exception.Data%2A&gt;</ph> property to store and retrieve supplementary information relevant to the exception.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.Collections.IDictionary?displayProperty=nameWithType&gt;</ph> obiektu zwróconego przez <ph id="ph2">&lt;xref:System.Exception.Data%2A&gt;</ph> właściwości do przechowywania i pobierania dodatkowe informacje dotyczące wyjątku.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The information is in the form of an arbitrary number of user-defined key/value pairs.</source>
          <target state="translated">Informacje znajdują się w formie dowolnej liczby pary klucz wartość zdefiniowana przez użytkownika.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The key component of each key/value pair is typically an identifying string, whereas the value component of the pair can be any type of object.</source>
          <target state="translated">Najważniejszym aspektem każdego pary klucza/wartości jest zwykle ciąg identyfikujący część wartości pary mogą być obiekty dowolnego typu.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Key/Value Pair Security</source>
          <target state="translated">Zabezpieczenia pary klucz/wartość</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The key/value pairs stored in the collection returned by the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property are not secure.</source>
          <target state="translated">Pary klucz/wartość przechowywanych w kolekcji zwróconej przez <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> właściwości nie są bezpieczne.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>If your application calls a nested series of routines, and each routine contains exception handlers, the resulting call stack contains a hierarchy of those exception handlers.</source>
          <target state="translated">Jeśli aplikacja wywołuje szereg zagnieżdżonych procedury, a każda procedura zawiera programy obsługi wyjątków, wynikowy stosu wywołań zawiera hierarchię te programy obsługi wyjątków.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>If a lower-level routine throws an exception, any upper-level exception handler in the call stack hierarchy can read and/or modify the key/value pairs stored in the collection by any other exception handler.</source>
          <target state="translated">Jeśli procedura niższego poziomu zgłasza wyjątek, wszelkie obsługi wyjątków wyższego poziomu w hierarchii stosu wywołań można odczytać i/lub zmodyfikować pary klucz/wartość przechowywanych w kolekcji przez inne obsługi wyjątków.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>This means you must guarantee that the information in the key/value pairs is not confidential and that your application will operate correctly if the information in the key/value pairs is corrupted.</source>
          <target state="translated">Oznacza to, że należy zagwarantować dane w pary klucz wartość nie jest poufne i że aplikacja będzie działać prawidłowo, jeśli informacje w pary klucz wartość są uszkodzone.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Key Conflicts</source>
          <target state="translated">Konflikty klucza</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>A key conflict occurs when different exception handlers specify the same key to access a key/value pair.</source>
          <target state="translated">Konflikt klucza występuje, gdy programy obsługi wyjątków różnych określić ten sam klucz dostępu parę klucza i wartości do.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Use caution when developing your application because the consequence of a key conflict is that lower-level exception handlers can inadvertently communicate with higher-level exception handlers, and this communication might cause subtle program errors.</source>
          <target state="translated">Tworzenie aplikacji, ponieważ konsekwencją konflikt klucza jest programy obsługi wyjątków niższego poziomu mogą przypadkowo może komunikować się z wyższego poziomu obsługi wyjątków, czy ta komunikacja może spowodować błędy niewielkie program, należy zachować ostrożność.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>However, if you are cautious you can use key conflicts to enhance your application.</source>
          <target state="translated">Jednak w przypadku ostrożność służy konfliktów kluczy w celu zwiększenia aplikacji.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Avoiding Key Conflicts</source>
          <target state="translated">Unikanie konfliktów klucza</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Avoid key conflicts by adopting a naming convention to generate unique keys for key/value pairs.</source>
          <target state="translated">Aby uniknąć konfliktów kluczy przyjmowanie konwencji nazewnictwa do wygenerowania unikatowy kluczy dla pary klucz wartość.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>For example, a naming convention might yield a key that consists of the period-delimited name of your application, the method that provides supplementary information for the pair, and a unique identifier.</source>
          <target state="translated">Na przykład konwencji nazewnictwa może dać klucz, który składa się z nazwy rozdzielonym aplikacji, metody, która zawiera dodatkowe informacje dotyczące pary i unikatowy identyfikator.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Suppose two applications, named Products and Suppliers, each has a method named Sales.</source>
          <target state="translated">Załóżmy, że dwóch aplikacji o nazwie produktów i dostawców, każda ma metodę o nazwie sprzedaży.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The Sales method in the Products application provides the identification number (the stock keeping unit or SKU) of a product.</source>
          <target state="translated">Metoda sprzedaży w aplikacji produktów zawiera numeru identyfikacyjnego (magazynową jednostki lub jednostki SKU) produktu.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The Sales method in the Suppliers application provides the identification number, or SID, of a supplier.</source>
          <target state="translated">Metoda sprzedaży w aplikacji dostawcy udostępnia numer identyfikacyjny lub identyfikator SID dostawcy.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Consequently, the naming convention for this example yields the keys, "Products.Sales.SKU" and "Suppliers.Sales.SID".</source>
          <target state="translated">W rezultacie konwencji nazewnictwa w tym przykładzie daje klucze, "Products.Sales.SKU" i "Suppliers.Sales.SID".</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Exploiting Key Conflicts</source>
          <target state="translated">Wykorzystanie konfliktów klucza</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Exploit key conflicts by using the presence of one or more special, prearranged keys to control processing.</source>
          <target state="translated">Wykorzystać konfliktów kluczy przy użyciu obecności co najmniej jeden klucz specjalnych, wstępnie ustalane do kontrolowania przetwarzania.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Suppose, in one scenario, the highest level exception handler in the call stack hierarchy catches all exceptions thrown by lower-level exception handlers.</source>
          <target state="translated">Załóżmy scenariusz, najwyższy program obsługi wyjątku poziomu w hierarchii stosu wywołań przechwytuje wszystkie wyjątki zgłaszane przez programy obsługi wyjątków niższego poziomu.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>If a key/value pair with a special key exists, the high-level exception handler formats the remaining key/value pairs in the <ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph> object in some nonstandard way; otherwise, the remaining key/value pairs are formatted in some normal manner.</source>
          <target state="translated">Jeśli para klucza i wartości, przy użyciu specjalnego klucza istnieje, obsługa wyjątków ogólnych formatuje pozostałych pary klucz wartość w <ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph> obiektu w jakiś sposób niestandardowych; w przeciwnym razie pozostałych pary klucz wartość są sformatowane w normalnym sposób.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Now suppose, in another scenario, the exception handler at each level of the call stack hierarchy catches the exception thrown by the next lower-level exception handler.</source>
          <target state="translated">Teraz załóżmy, w innym scenariuszu obsługi wyjątków na każdym poziomie hierarchii stosu wywołań przechwytuje wyjątków zgłaszanych przez dalej obsługi wyjątków niższego poziomu.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>In addition, each exception handler knows the collection returned by the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property contains a set of key/value pairs that can be accessed with a prearranged set of keys.</source>
          <target state="translated">Ponadto każdy program obsługi wyjątku zna kolekcji zwróconej przez <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> właściwość zawiera zbiór pary klucz wartość, które są dostępne z wstępnie ustalane zestawu kluczy.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Each exception handler uses the prearranged set of keys to update the value component of the corresponding key/value pair with information unique to that exception handler.</source>
          <target state="translated">Każdy program obsługi wyjątku używa wstępnie ustalane zestaw kluczy zaktualizować składnik wartości odpowiednich pary klucz wartość z użyciem informacji specyficznych dla programu obsługi wyjątków.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>After the update process is complete, the exception handler throws the exception to the next higher-level exception handler.</source>
          <target state="translated">Po zakończeniu procesu aktualizacji program obsługi wyjątku zgłasza wyjątek do następnego wyższego poziomu obsługi wyjątków.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Finally, the highest level exception handler accesses the key/value pairs and displays the consolidated update information from all the lower-level exception handlers.</source>
          <target state="translated">Ponadto obsługa najwyższego poziomu wyjątków uzyskuje dostęp do pary klucz wartość i wyświetla informacje skonsolidowanych aktualizacji z obsługi wyjątków niższego poziomu.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The following example demonstrates how to add and retrieve information using the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property.</source>
          <target state="translated">W poniższym przykładzie pokazano, jak dodać i pobrać za pomocą informacji <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Exception.GetBaseException">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> that is the root cause of one or more subsequent exceptions.</source>
          <target state="translated">Po przesłonięciu w klasie pochodnej zwraca <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> czyli przyczynę jeden lub więcej kolejnych wyjątków.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Exception.GetBaseException">
          <source>The first exception thrown in a chain of exceptions.</source>
          <target state="translated">Pierwszy wyjątek w łańcuchu wyjątków.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Exception.GetBaseException">
          <source>If the <ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> property of the current exception is a null reference (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), this property returns the current exception.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> właściwości bieżącego wyjątku jest odwołanie o wartości null (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph> w języku Visual Basic), ta właściwość zwraca bieżącego wyjątku.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>A chain of exceptions consists of a set of exceptions such that each exception in the chain was thrown as a direct result of the exception referenced in its <ph id="ph1">`InnerException`</ph> property.</source>
          <target state="translated">Łańcuch wyjątków zawiera zestaw wyjątków tak, aby każdy w łańcuchu wyjątek bezpośrednio z powodu wyjątku, do którego odwołuje się jego <ph id="ph1">`InnerException`</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>For a given chain, there can be exactly one exception that is the root cause of all other exceptions in the chain.</source>
          <target state="translated">Dla danego łańcucha może istnieć dokładnie jeden wyjątek, który jest główną przyczynę wszystkie wyjątki w łańcuchu.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>This exception is called the base exception and its <ph id="ph1">`InnerException`</ph> property always contains a null reference.</source>
          <target state="translated">Ten wyjątek nosi nazwę podstawową wyjątek i jego <ph id="ph1">`InnerException`</ph> właściwość zawsze zawiera odwołanie o wartości null.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>For all exceptions in a chain of exceptions, the <ph id="ph1">`GetBaseException`</ph> method must return the same object (the base exception).</source>
          <target state="translated">Wszystkie wyjątki w łańcuchu wyjątków <ph id="ph1">`GetBaseException`</ph> metoda musi zwracać ten sam obiekt (wyjątek podstawowej).</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>Use the <ph id="ph1">`GetBaseException`</ph> method when you want to find the root cause of an exception but do not need information about exceptions that may have occurred between the current exception and the first exception.</source>
          <target state="translated">Użyj <ph id="ph1">`GetBaseException`</ph> metody, aby znaleźć przyczynę wyjątek, ale nie są informacje dotyczące wyjątków, które mogły wystąpić między bieżący wyjątek i pierwszy wyjątek.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>The following code example defines two derived <ph id="ph1">`Exception`</ph> classes.</source>
          <target state="translated">Poniższy przykład kodu definiuje dwie pochodnych <ph id="ph1">`Exception`</ph> klasy.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>It forces an exception and then throws it again with each of the derived classes.</source>
          <target state="translated">Wymusza wyjątek, a następnie generuje go ponownie z każdym z klasy pochodnej.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>The code shows the use of the <ph id="ph1">`GetBaseException`</ph> method to retrieve the original exception.</source>
          <target state="translated">Kod pokazano sposób użycia <ph id="ph1">`GetBaseException`</ph> metoda pobierania pierwotny wyjątek.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>The <ph id="ph1">&lt;see langword="GetBaseException" /&gt;</ph> method is overridden in classes that require control over the exception content or format.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="GetBaseException" /&gt;</ph> Metoda zostanie przesłonięta w klasach, które wymagają kontrolę nad zawartością wyjątku lub format.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that holds the serialized object data about the exception being thrown.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> Zawierający dane zserializowanego obiektu dotyczące zgłaszanego wyjątku.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that contains contextual information about the source or destination.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> Zawierający informacje kontekstowe dotyczące źródła lub miejsca docelowego.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>When overridden in a derived class, sets the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> with information about the exception.</source>
          <target state="translated">W przypadku przesłonięcia w klasie pochodnej, ustawia <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> informacje o wyjątku.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">`GetObjectData`</ph> sets a <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph> with all the exception object data targeted for serialization.</source>
          <target state="translated"><ph id="ph1">`GetObjectData`</ph> Ustawia <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph> ze wszystkimi danymi obiektu wyjątków przeznaczone do serializacji.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>During deserialization, the exception is reconstituted from the <ph id="ph1">`SerializationInfo`</ph> transmitted over the stream.</source>
          <target state="translated">Podczas deserializacji, wyjątek jest odtworzonych z <ph id="ph1">`SerializationInfo`</ph> przesyłane przez strumień.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The following code example defines a derived serializable <ph id="ph1">`Exception`</ph> class that implements <ph id="ph2">`GetObjectData`</ph>, which makes minor changes to two properties and then calls the base class to perform the serialization.</source>
          <target state="translated">Poniższy przykładowy kod definiuje pochodnego serializacji <ph id="ph1">`Exception`</ph> klasa implementująca <ph id="ph2">`GetObjectData`</ph>, co czyni drobne zmiany do dwóch właściwości i następnie wywołania podstawowym klasy do wykonywania serializacji.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The example forces a divide-by-0 error and then creates an instance of the derived exception.</source>
          <target state="translated">Przykład wymusza błąd dzielenia przez 0, a następnie tworzy wystąpienia pochodne wyjątku.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</source>
          <target state="translated">Kod serializuje wystąpienie do pliku, deserializuje plik do nowego wyjątek, który zgłasza, a następnie przechwytuje i wyświetla dane wyjątku.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;paramref name="info" /&gt;</ph> parameter is a null reference (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> Parametr jest odwołanie o wartości null (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph> w języku Visual Basic).</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Exception.GetType">
          <source>Gets the runtime type of the current instance.</source>
          <target state="translated">Pobiera typ środowiska uruchomieniowego bieżącego wystąpienia.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Exception.GetType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the exact runtime type of the current instance.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> obiekt, który reprezentuje typ środowiska uruchomieniowego dokładne bieżącego wystąpienia.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Exception.GetType%2A&gt;</ph> method exists to support the .NET Framework infrastructure, and internally invokes the fundamental method, <ph id="ph2">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.GetType%2A&gt;</ph> Metoda istnieje obsługuje infrastrukturę programu .NET Framework i wewnętrznie wywołuje metodę podstawową, <ph id="ph2">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="P:System.Exception.HelpLink">
          <source>Gets or sets a link to the help file associated with this exception.</source>
          <target state="translated">Pobiera lub ustawia łącze do pliku Pomocy skojarzonych z tym wyjątkiem.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>The Uniform Resource Name (URN) or Uniform Resource Locator (URL).</source>
          <target state="translated">Nazwa Uniform Resource URN lub adres URL (adres URL).</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>The return value, which represents a help file, is a URN or URL.</source>
          <target state="translated">Wartość zwracana, reprezentujący plik pomocy jest URN lub adresem URL.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>For example, the <ph id="ph1">`HelpLink`</ph> value could be:</source>
          <target state="translated">Na przykład <ph id="ph1">`HelpLink`</ph> wartość może być:</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</source>
          <target state="translated">"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>The following code example throws an <ph id="ph1">`Exception`</ph> that sets the <ph id="ph2">`HelpLink`</ph> property in its constructor and then catches the exception and displays <ph id="ph3">`HelpLink`</ph>.</source>
          <target state="translated">Poniższy kod przykładowy zgłasza <ph id="ph1">`Exception`</ph> stanowiąca <ph id="ph2">`HelpLink`</ph> właściwości w jego konstruktora, a następnie połowy wyjątek i wyświetla <ph id="ph3">`HelpLink`</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="P:System.Exception.HResult">
          <source>Gets or sets HRESULT, a coded numerical value that is assigned to a specific exception.</source>
          <target state="translated">Pobiera lub ustawia HRESULT, wartość liczbową kodowane, przypisane do określonego wyjątku.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The HRESULT value.</source>
          <target state="translated">Wartość HRESULT.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>HRESULT is a 32-bit value, divided into three different fields: a severity code, a facility code, and an error code.</source>
          <target state="translated">HRESULT jest 32-bitową wartość podzielone na trzy różne pola: kod ważność, kod zakładzie i kod błędu.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The severity code indicates whether the return value represents information, warning, or error.</source>
          <target state="translated">Kod ważność wskazuje, czy zwracana wartość reprezentuje informacje, ostrzeżenia lub błędu.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The facility code identifies the area of the system responsible for the error.</source>
          <target state="translated">Kod obiektu identyfikuje obszar systemem odpowiedzialnym za błąd.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The error code is a unique number that is assigned to represent the exception.</source>
          <target state="translated">Kod błędu to unikatowy numer przypisany do reprezentowania wyjątek.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>Each exception is mapped to a distinct HRESULT.</source>
          <target state="translated">Każdy wyjątek jest zamapowana na różne HRESULT.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>When managed code throws an exception, the runtime passes the HRESULT to the COM client.</source>
          <target state="translated">Gdy kod zarządzany zgłasza wyjątek, środowisko uruchomieniowe przekazuje HRESULT do klient modelu COM.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>When unmanaged code returns an error, the HRESULT is converted to an exception, which is then thrown by the runtime.</source>
          <target state="translated">Po powrocie z kodem niezarządzanym błąd HRESULT jest konwertowana na wyjątek, który następnie jest generowany przez środowisko uruchomieniowe.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>For information about HRESULT values and their corresponding .NET Framework exceptions, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">Aby uzyskać informacje o wartości HRESULT i ich odpowiednich wyjątków .NET Framework, zobacz <bpt id="p1">[</bpt>porady: mapy wyników HRESULT i wyjątków<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>See <bpt id="p1">[</bpt>Common HRESULT Values<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)</ept> in the Windows documentation for a list of the values you are most likely to encounter.</source>
          <target state="translated">Zobacz <bpt id="p1">[</bpt>wspólne wartości HRESULT<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)</ept> w dokumentacji systemu Windows lista wartości jest najczęściej spotykane.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Exception.HResult%2A&gt;</ph> property's setter is protected, whereas its getter is public.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Exception.HResult%2A&gt;</ph> metody ustawiającej właściwości jest chroniony, jest publicznej metody pobierającej.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>In previous versions of the .NET Framework, both getter and setter are protected.</source>
          <target state="translated">W poprzednich wersjach programu .NET Framework metody pobierającej i ustawiającej są chronione.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The following code example defines a derived <ph id="ph1">`Exception`</ph> class that sets the <ph id="ph2">`HResult`</ph> property to a custom value in its constructor.</source>
          <target state="translated">Poniższy przykładowy kod definiuje pochodnego <ph id="ph1">`Exception`</ph> klasy, która ustawia <ph id="ph2">`HResult`</ph> właściwości niestandardowej wartości w jego konstruktora.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="P:System.Exception.InnerException">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instance that caused the current exception.</source>
          <target state="translated">Pobiera <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> wystąpienia, który spowodował bieżącego wyjątku.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>An object that describes the error that caused the current exception.</source>
          <target state="translated">Obiekt, który opisuje błąd, który spowodował bieżącego wyjątku.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The <ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> property returns the same value as was passed into the <ph id="ph2">&lt;see cref="M:System.Exception.#ctor(System.String,System.Exception)" /&gt;</ph> constructor, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the inner exception value was not supplied to the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> Właściwość zwraca tę samą wartość, ponieważ został przekazany <ph id="ph2">&lt;see cref="M:System.Exception.#ctor(System.String,System.Exception)" /&gt;</ph> konstruktora, lub <ph id="ph3">&lt;see langword="null" /&gt;</ph> Jeśli wartości wyjątku wewnętrznego nie został dostarczony do konstruktora.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>This property is read-only.</source>
          <target state="translated">Ta właściwość jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>When an exception <ph id="ph1">`X`</ph> is thrown as a direct result of a previous exception <ph id="ph2">`Y`</ph>, the <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property of <ph id="ph4">`X`</ph> should contain a reference to <ph id="ph5">`Y`</ph>.</source>
          <target state="translated">Jeśli wyjątek <ph id="ph1">`X`</ph> jest zgłaszany jako bezpośrednio w wyniku poprzedniego wyjątku <ph id="ph2">`Y`</ph>, <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> właściwość <ph id="ph4">`X`</ph> powinien zawierać odwołanie do <ph id="ph5">`Y`</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>Use the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property to obtain the set of exceptions that led to the current exception.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> właściwości, aby uzyskać zestaw wyjątki, które doprowadziły do bieżącego wyjątku.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>You can create a new exception that catches an earlier exception.</source>
          <target state="translated">Możesz utworzyć nowy wyjątek, który przechwytuje wcześniej wyjątek.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The code that handles the second exception can make use of the additional information from the earlier exception to handle the error more appropriately.</source>
          <target state="translated">Kod obsługi można wprowadzać drugi wyjątek użyć do obsługi błędu odpowiedniej dodatkowych informacji z wcześniejszych wyjątku.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>Suppose that there is a function that reads a file and formats the data from that file.</source>
          <target state="translated">Załóżmy, że funkcja, która odczytuje plik i formatuje dane z tego pliku.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>In this example, as the code tries to read the file, an <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> is thrown.</source>
          <target state="translated">W tym przykładzie, jako kod próbuje odczytać pliku <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The function catches the <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> and throws a <ph id="ph2">&lt;xref:System.IO.FileNotFoundException&gt;</ph>.</source>
          <target state="translated">Funkcja przechwytuje <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> i zgłasza <ph id="ph2">&lt;xref:System.IO.FileNotFoundException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> could be saved in the <ph id="ph2">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph>, enabling the code that catches the <ph id="ph4">&lt;xref:System.IO.FileNotFoundException&gt;</ph> to examine the cause of the initial error.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> Mogły zostać zapisane w <ph id="ph2">&lt;xref:System.Exception.InnerException%2A&gt;</ph> właściwość <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph>, włączanie kod, który przechwytuje <ph id="ph4">&lt;xref:System.IO.FileNotFoundException&gt;</ph> zbadać przyczynę błędu początkowej.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property, which holds a reference to the inner exception, is set upon initialization of the exception object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> Ustawiono właściwość, która zawiera odwołanie do wyjątek wewnętrzny, po zainicjowaniu obiektu wyjątku.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The following example demonstrates throwing and catching an exception that references an inner exception.</source>
          <target state="translated">W poniższym przykładzie pokazano zgłaszanie i przechwytywanie wyjątku, który odwołuje się do wyjątek wewnętrzny.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="P:System.Exception.Message">
          <source>Gets a message that describes the current exception.</source>
          <target state="translated">Pobiera komunikat opisujący bieżący wyjątek.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The error message that explains the reason for the exception, or an empty string ("").</source>
          <target state="translated">Komunikat o błędzie opisujący przyczynę wyjątek lub ciąg pusty ("").</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Error messages target the developer who is handling the exception.</source>
          <target state="translated">Komunikaty o błędach docelowe projektanta, który obsługuje wyjątek.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The text of the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property should completely describe the error and, when possible, should also explain how to correct the error.</source>
          <target state="translated">Tekst <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> właściwości należy całkowicie opisu błędu i, jeśli to możliwe, należy również wyjaśniono, jak poprawić ten błąd.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Top-level exception handlers may display the message to end-users, so you should ensure that it is grammatically correct and that each sentence of the message ends with a period.</source>
          <target state="translated">Programy obsługi wyjątków najwyższego poziomu mogą być wyświetlane wiadomości dla użytkowników końcowych, dlatego należy upewnić się, czy jest gramatycznie poprawny i czy każdego zdania wiadomości kończy się kropką.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Do not use question marks or exclamation points.</source>
          <target state="translated">Nie używaj znaków zapytania lub wykrzykniki.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>If your application uses localized exception messages, you should ensure that they are accurately translated.</source>
          <target state="translated">Jeśli aplikacja używa komunikaty o wyjątkach zlokalizowanego, należy upewnić się, że dokładnie translacji.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Do not disclose sensitive information in exception messages without checking for the appropriate permissions.</source>
          <target state="translated">Nie wyjawiać poufnych informacji w komunikatach wyjątek bez sprawdzania pod kątem odpowiednich uprawnień.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The value of the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property is included in the information returned by <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph>.The <ph id="ph3">&lt;xref:System.Exception.Message%2A&gt;</ph> property is set only when creating an <ph id="ph4">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> właściwość jest dołączona informacje zwracane przez <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph>. <ph id="ph3">&lt;xref:System.Exception.Message%2A&gt;</ph> Właściwość jest ustawiona tylko wtedy, gdy tworzenie <ph id="ph4">&lt;xref:System.Exception&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>If no message was supplied to the constructor for the current instance, the system supplies a default message that is formatted using the current system culture.</source>
          <target state="translated">Jeśli żaden komunikat nie podano konstruktora dla bieżącego wystąpienia, system udostępnia wiadomość domyślną sformatowany przy użyciu bieżącego ustawienia kulturowego systemu.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Windows Runtime and <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></source>
          <target state="translated">Środowisko wykonawcze systemu Windows i <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> and <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the fidelity of error messages from exceptions that are propagated from Windows Runtime types and members that are not part of the .NET Framework is improved.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> i <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, Lepsza dokładność komunikaty o błędach z wyjątków, które zostały przeniesione z typów środowiska wykonawczego systemu Windows i elementów członkowskich, które nie są częścią programu .NET Framework.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>In particular, exception messages from Visual C++ component extensions (C++/CX) are now propagated back into .NET Framework <ph id="ph1">&lt;xref:System.Exception&gt;</ph> objects.</source>
          <target state="translated">W szczególności komunikaty wyjątku z rozszerzenia składników dla programu Visual C++ (C + +/ CX) są teraz propagowane do .NET Framework <ph id="ph1">&lt;xref:System.Exception&gt;</ph> obiektów.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The following code example throws and then catches an <ph id="ph1">&lt;xref:System.Exception&gt;</ph> exception and displays the exception's text message using the <ph id="ph2">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">Poniższy przykład kodu zgłasza wyjątek, a następnie przechwytuje <ph id="ph1">&lt;xref:System.Exception&gt;</ph> wyjątek i wyświetla tekst wyjątku komunikatów przy użyciu <ph id="ph2">&lt;xref:System.Exception.Message%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>If you throw an exception from a property, and you need to refer in the text of <ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> to the property argument that you set or get, use "value" as the name of the property argument.</source>
          <target state="translated">Jeśli zgłoszenie wyjątku z właściwością i trzeba odwoływać się w tekście <ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> do argumentu właściwość, która ustawiać ani pobierać, użyj "value" jako nazwa argumentu właściwości.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The <ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> property is overridden in classes that require control over message content or format.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> Właściwość nie zostanie zastąpiona klas, które wymagają kontroli nad formatu lub zawartość komunikatu.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Application code typically accesses this property when it needs to display information about an exception that has been caught.</source>
          <target state="translated">Kod aplikacji zwykle uzyskuje dostęp do tej właściwości kiedy zachodzi potrzeba wyświetlać informacje na temat wyjątek został przechwycony.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The error message should be localized.</source>
          <target state="translated">Komunikat o błędzie powinien być zlokalizowany.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="E:System.Exception.SerializeObjectState">
          <source>Occurs when an exception is serialized to create an exception state object that contains serialized data about the exception.</source>
          <target state="translated">Występuje, gdy wyjątek jest serializowany można utworzyć obiektu stanu wyjątek, który zawiera seryjnych danych o wyjątku.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The exception state object implements the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> interface.</source>
          <target state="translated">Obiekt stanu wyjątek implementuje <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>When the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event is subscribed to, the exception is deserialized and created as an empty exception.</source>
          <target state="translated">Gdy <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> zdarzeń jest subskrybowana w usłudze, wyjątek jest deserializacji i utworzone jako wyjątek puste.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The exception's constructor is not run, and the exception state is also deserialized.</source>
          <target state="translated">Konstruktor wyjątku nie jest uruchamiane, a stan wyjątku jest również deserializacji.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A&gt;</ph> callback method of the exception state object is then notified so that it can push deserialized data into the empty exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A&gt;</ph> Metody wywołania zwrotnego obiektu stanu wyjątek następnie powiadomienie, aby go umieścić zdeserializowany danych do pustego wyjątku.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event enables transparent exception types to serialize and deserialize exception data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> Zdarzeń umożliwia typów wyjątków przezroczysty do serializacji i deserializacji wyjątku.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>Transparent code can execute commands within the bounds of the permission set it is operating within, but cannot execute, call, derive from, or contain critical code.</source>
          <target state="translated">Kod o przezroczystym można wykonywać polecenia w granicach zestaw uprawnień, który działa wewnątrz, ale nie może wykonać, wywołania, pochodzi z ani zawierać kodu krytycznego.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>If the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event is not subscribed to, deserialization occurs as usual using the <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> zdarzeń nie ma subskrypcji, deserializacji występuje w zwykły sposób za pomocą <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> konstruktora.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>Typically, a handler for the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event is added in the exception's constructor to provide for its serialization.</source>
          <target state="translated">Zazwyczaj obsługi dla <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> zdarzeń jest dodawany w Konstruktorze wyjątek, aby zapewnić jego serializacji.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>But because the constructor is not executed when the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event handler executes, serializing a deserialized exception can throw a <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationException&gt;</ph> exception when you try to deserialize the exception.</source>
          <target state="translated">Ale ponieważ konstruktora nie jest wykonywane, kiedy <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> wykonuje program obsługi zdarzeń, serializacji zdeserializowany wyjątku może zgłosić <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationException&gt;</ph> wyjątek podczas próby deserializacji wyjątek.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>To avoid this, you should also add the handler for the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event in the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Aby tego uniknąć, należy również dodać obsługę programu <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> zdarzenia w <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>See the Examples section for an illustration.</source>
          <target state="translated">W sekcji Przykłady ilustracji.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The following example defines a <ph id="ph1">`BadDivisionException`</ph> that handles the <ph id="ph2">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event.</source>
          <target state="translated">W poniższym przykładzie zdefiniowano <ph id="ph1">`BadDivisionException`</ph> obsługująca <ph id="ph2">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> zdarzeń.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>It also contains a state object, which is a nested structure named <ph id="ph1">`BadDivisionExceptionState`</ph> that implements the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> interface.</source>
          <target state="translated">Zawiera także obiektu stanu, który jest zagnieżdżoną struktury o nazwie <ph id="ph1">`BadDivisionExceptionState`</ph> implementującej <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The <ph id="ph1">`BadDivisionException`</ph> exception is thrown when a floating-point division by zero occurs.</source>
          <target state="translated"><ph id="ph1">`BadDivisionException`</ph> Wyjątek po wystąpieniu Zmiennoprzecinkowe dzielenie przez zero.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>During the first division by zero, the example instantiates a <ph id="ph1">`BadDivisionException`</ph> object, serializes it, and throws the exception.</source>
          <target state="translated">Podczas pierwszego dzielenie przez zero, tworzy przykładzie <ph id="ph1">`BadDivisionException`</ph> obiekt, jego serializuje i zgłasza wyjątek.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>When subsequent divisions by zero occur, the example deserializes the  previously serialized object, reserializes it, and throws the exception.</source>
          <target state="translated">Gdy występują kolejnych podziałów przez zero, przykładzie deserializuje wcześniej Zserializowany obiekt, reserializes go i zgłasza wyjątek.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>To provide for object serialization, deserialization, reserialization, and deserialization, the example adds the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event handler both in the <ph id="ph2">`BadDivisionException`</ph> class constructor and in the <ph id="ph3">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">Aby zapewnić serializacji obiektu, deserializacji reserialization i deserializacji, w przykładzie dodano <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> obsługi zdarzeń zarówno w <ph id="ph2">`BadDivisionException`</ph> konstruktora klasy i w <ph id="ph3">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> implementacji.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>If this event is subscribed to and used, all derived types that follow in the inheritance hierarchy must implement the same serialization mechanism.</source>
          <target state="translated">Jeśli to zdarzenie jest subskrybowana i używany, wszystkie typy pochodne, które należy wykonać w hierarchii dziedziczenia musi implementować ten sam mechanizm serializacji.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Exception.Source">
          <source>Gets or sets the name of the application or the object that causes the error.</source>
          <target state="translated">Pobiera lub ustawia nazwę aplikacji lub obiekt, który powoduje błąd.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Source">
          <source>The name of the application or the object that causes the error.</source>
          <target state="translated">Nazwa aplikacji lub obiekt, który powoduje błąd.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Source">
          <source>If the <ph id="ph1">&lt;xref:System.Exception.Source%2A&gt;</ph> property is not set explicitly, the runtime automatically sets it to the name of the assembly in which the exception originated.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Exception.Source%2A&gt;</ph> właściwość nie jest jawnie ustawiona, środowisko uruchomieniowe automatycznie ustawia ją na nazwę zestawu, w którym wyjątek pochodzi.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Source">
          <source>The following example throws an <ph id="ph1">`Exception`</ph> that sets the <ph id="ph2">`Source`</ph> property in its constructor and then catches the exception and displays <ph id="ph3">`Source`</ph>.</source>
          <target state="translated">Poniższy przykład zwraca <ph id="ph1">`Exception`</ph> stanowiąca <ph id="ph2">`Source`</ph> właściwości w jego konstruktora, a następnie połowy wyjątek i wyświetla <ph id="ph3">`Source`</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="P:System.Exception.Source">
          <source>The object must be a runtime <ph id="ph1">&lt;see cref="N:System.Reflection" /&gt;</ph> object</source>
          <target state="translated">Obiekt musi być środowisko uruchomieniowe <ph id="ph1">&lt;see cref="N:System.Reflection" /&gt;</ph> obiektu</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="P:System.Exception.StackTrace">
          <source>Gets a string representation of the immediate frames on the call stack.</source>
          <target state="translated">Pobiera reprezentację ciągu natychmiastowego ramek na stosie wywołań.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>A string that describes the immediate frames of the call stack.</source>
          <target state="translated">Ciąg opisujący natychmiastowego ramki stosu wywołań.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The execution stack keeps track of all the methods that are in execution at a given instant.</source>
          <target state="translated">Stos wykonywania przechowuje informacje o wszystkie metody, które są w danej chwili podczas wykonywania.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>A trace of the method calls is called a stack trace.</source>
          <target state="translated">Śledzenia wywołań metoda jest wywoływana ślad stosu.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The stack trace listing provides a way to follow the call stack to the line number in the method where the exception occurs.</source>
          <target state="translated">Lista śledzenia stosu umożliwia wykonaj stosu wywołań do numeru wiersza w metodzie, gdzie występuje wyjątek.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The <ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> property returns the frames of the call stack that originate at the location where the exception was thrown.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> Właściwość zwraca ramki stosu wywołań, które pochodzi z lokalizacji, w której wystąpił wyjątek.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>You can obtain information about additional frames in the call stack by creating a new instance of the <ph id="ph1">&lt;xref:System.Diagnostics.StackTrace?displayProperty=nameWithType&gt;</ph> class and using its <ph id="ph2">&lt;xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Informacje na temat dodatkowych ramek na stosie wywołań można uzyskać, tworząc nowe wystąpienie klasy <ph id="ph1">&lt;xref:System.Diagnostics.StackTrace?displayProperty=nameWithType&gt;</ph> klasy i przy użyciu jego <ph id="ph2">&lt;xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The common language runtime (CLR) updates the stack trace whenever an exception is thrown in application code (by using the <ph id="ph1">`throw`</ph> keyword).</source>
          <target state="translated">Środowisko uruchomieniowe języka wspólnego (CLR) aktualizuje ślad stosu zawsze, gdy wyjątek w kodzie aplikacji (przy użyciu <ph id="ph1">`throw`</ph> — słowo kluczowe).</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>If the exception was rethrown in a method that is different than the method where it was originally thrown, the stack trace contains both the location in the method where the exception was originally thrown, and the location in the method where the exception was rethrown.</source>
          <target state="translated">Jeśli wyjątek został zgłoszony w metodzie, który jest inny niż metody, gdzie został początkowo zgłoszony, ślad stosu zawiera zarówno w metodzie w lokalizacji, w którym pierwotnie został zgłoszony wyjątek, jak i w metodzie w lokalizacji, w którym wyjątek zgłoszony.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>If the exception is thrown, and later rethrown, in the same method, the stack trace only contains the location where the exception was rethrown and does not include the location where the exception was originally thrown.</source>
          <target state="translated">Jeśli zgłoszony wyjątek i później zgłoszony w tej samej metody, ślad stosu zawiera tylko lokalizacji, w którym wyjątek został zgłoszony i nie ma lokalizacji, w którym pierwotnie został zgłoszony wyjątek.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The <ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> property may not report as many method calls as expected because of code transformations, such as inlining, that occur during optimization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> Właściwości nie może zgłaszać dowolną liczbę wywołań metody zgodnie z oczekiwaniami ze względu na kod przekształcenia, takie jak ze śródwierszowaniem, która występuje podczas optymalizacji.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The following code example throws an <ph id="ph1">`Exception`</ph> and then catches it and displays a stack trace using the <ph id="ph2">`StackTrace`</ph> property.</source>
          <target state="translated">Poniższy kod przykładowy zgłasza <ph id="ph1">`Exception`</ph> przechwytuje go i wyświetla śledzenia stosu przy użyciu <ph id="ph2">`StackTrace`</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The <ph id="ph1">&lt;see langword="StackTrace" /&gt;</ph> property is overridden in classes that require control over the stack trace content or format.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="StackTrace" /&gt;</ph> Właściwość nie zostanie zastąpiona klas, które wymagają kontroli nad zawartości śledzenia stosu lub format.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>By default, the stack trace is captured immediately before an exception object is thrown.</source>
          <target state="translated">Domyślnie ślad stosu jest przechwytywany natychmiast, zanim zostanie zgłoszony wyjątek obiektu.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>Use <ph id="ph1">&lt;see cref="P:System.Environment.StackTrace" /&gt;</ph> to get stack trace information when no exception is being thrown.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;see cref="P:System.Environment.StackTrace" /&gt;</ph> Aby uzyskać informacje śledzenia stosu, gdy żaden wyjątek został zgłoszony.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="P:System.Exception.TargetSite">
          <source>Gets the method that throws the current exception.</source>
          <target state="translated">Pobiera metodę bieżący wyjątek.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that threw the current exception.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> Który zwrócił bieżącego wyjątku.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>If the method that throws this exception is not available and the stack trace is not a null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), <ph id="ph2">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> obtains the method from the stack trace.</source>
          <target state="translated">Jeśli metoda, która zgłasza wyjątek nie jest dostępny i śledzenie stosu nie jest odwołanie o wartości null (<ph id="ph1">`Nothing`</ph> w języku Visual Basic), <ph id="ph2">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> uzyskuje dostęp do metody z ślad stosu.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>If the stack trace is a null reference, <ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> also returns a null reference.</source>
          <target state="translated">Jeśli ślad stosu jest odwołanie o wartości null, <ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> również zwraca odwołanie o wartości null.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>The <ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> property may not accurately report the name of the method in which an exception was thrown if the exception handler handles an exception across application domain boundaries.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> Właściwości nie może zgłaszać dokładnie nazwę metody, w którym został zgłoszony wyjątek, jeśli program obsługi wyjątku obsługuje wyjątek poza granice domeny aplikacji.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>The following code example throws an <ph id="ph1">`Exception`</ph> and then catches it and displays the originating method using the <ph id="ph2">`TargetSite`</ph> property.</source>
          <target state="translated">Poniższy kod przykładowy zgłasza <ph id="ph1">`Exception`</ph> przechwytuje go i wyświetla źródłowego przy użyciu metody <ph id="ph2">`TargetSite`</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Exception.ToString">
          <source>Creates and returns a string representation of the current exception.</source>
          <target state="translated">Tworzy i zwraca reprezentację ciągu bieżącego wyjątku.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Exception.ToString">
          <source>A string representation of the current exception.</source>
          <target state="translated">Reprezentacja ciągu bieżącego wyjątku.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source><ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> returns a representation of the current exception that is intended to be understood by humans.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> Zwraca reprezentację bieżący wyjątek, który ma być rozpoznawany przez człowieka.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>Where the exception contains culture-sensitive data, the string representation returned by <ph id="ph1">`ToString`</ph> is required to take into account the current system culture.</source>
          <target state="translated">W przypadku, gdy wyjątek zawiera dane zależne od kultury, reprezentacja ciągu zwrócony przez <ph id="ph1">`ToString`</ph> należy wziąć pod uwagę bieżące ustawienia kulturowe systemu.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>Although there are no exact requirements for the format of the returned string, it should attempt to reflect the value of the object as perceived by the user.</source>
          <target state="translated">Mimo że nie istnieją dokładne wymagania formatu ciągu zwróconego, należy próbować odzwierciedlają wartość obiektu jako postrzegana przez użytkownika.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>The default implementation of <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> obtains the name of the class that threw the current exception, the message, the result of calling <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph> on the inner exception, and the result of calling <ph id="ph3">&lt;xref:System.Environment.StackTrace%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Domyślna implementacja <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> uzyskuje nazwę klasy, która zgłosiła bieżącego wyjątku, komunikat, w wyniku wywołania metody <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph> na wyjątek wewnętrzny, a w wyniku wywołania metody <ph id="ph3">&lt;xref:System.Environment.StackTrace%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>If any of these members is <ph id="ph1">`null`</ph>, its value is not included in the returned string.</source>
          <target state="translated">Jeśli dowolny z tych elementów członkowskich jest <ph id="ph1">`null`</ph>, jego wartość nie jest uwzględniona w zwracany ciąg.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>If there is no error message or if it is an empty string (""), then no error message is returned.</source>
          <target state="translated">Jeśli nie ma błędów lub jest pustym ciągiem (""), zwracana jest żaden komunikat o błędzie.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>The name of the inner exception and the stack trace are returned only if they are not <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Nazwa wyjątek wewnętrzny i ślad stosu są zwracane tylko wtedy, gdy nie są one <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ta metoda zastępuje <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>The following example causes an exception and displays the result of calling <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> on that exception.</source>
          <target state="translated">Poniższy przykład powoduje zgłoszenie wyjątku i wyświetla wyniku wywołania metody <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> na tym wyjątku.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>Note that the <ph id="ph1">&lt;xref:System.Exception.ToString%2A?displayProperty=nameWithType&gt;</ph> method is called implicitly when the Exception class instance appears in the argument list of the <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Należy pamiętać, że <ph id="ph1">&lt;xref:System.Exception.ToString%2A?displayProperty=nameWithType&gt;</ph> metoda jest wywoływana niejawnie, gdy wystąpienie klasy wyjątku pojawi się na liście argumentów <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
<Type Name="Exception" FullName="System.Exception">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3cd7feda3f45d855645a0e6ecb699bd9f871df9" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34254664" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje błędów występujących podczas wykonywania aplikacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest klasą bazową dla wszystkich wyjątków. Gdy wystąpi błąd, system lub aktualnie realizowanej aplikacji zgłasza przez Zgłaszanie wyjątku, który zawiera informacje o tym błędzie. Po jest zgłaszany wyjątek, jest to obsługiwane przez aplikację lub przez domyślną procedurę obsługi wyjątków.  
  
 W tej sekcji:  
  
 [Błędy i wyjątki](#Errors)   
 [Bloki try/catch](#TryCatch)   
 [Wyjątek typu funkcji](#Features)   
 [Właściwości klasy wyjątków](#Properties)   
 [Zagadnienia dotyczące wydajności](#Performance)   
 [Ponownego generowania wyjątku](#Rethrow)   
 [Wybieranie standardowe wyjątków](#Standard)   
 [Implementowanie niestandardowymi wyjątkami](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>Błędy i wyjątki  
 Z różnych powodów, mogą wystąpić błędy czasu wykonywania. Jednak nie wszystkie błędy powinny być traktowane jako wyjątki w kodzie. Poniżej przedstawiono niektóre kategorie błędy, które mogą wystąpić w czasie wykonywania i odpowiednie sposoby nie odpowiadają.  
  
-   **Błędy użycia.** Błąd użycia reprezentuje błąd w logice programu, który może spowodować wyjątek. Jednak powinny być kierowane błąd, nie za pomocą obsługi wyjątków, ale modyfikując nieprawidłowy kod. Na przykład zastępowania <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody w następującym przykładzie zakłada się, że `obj` argumentu musi zawsze mieć wartości null.  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <xref:System.NullReferenceException> Wyjątek, który powoduje podczas `obj` jest `null` mogą zostać usunięte przez zmodyfikowanie kodu źródłowego próba jawnie na wartość null przed wywołaniem <xref:System.Object.Equals%2A?displayProperty=nameWithType> zastępowania i ponowną kompilację. Poniżej przedstawiono przykład zawierający kod źródłowy poprawiony, który obsługuje `null` argumentu.  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     Zamiast korzystać z obsługi błędów użycia wyjątków, można użyć <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodę identyfikowania błędów użycia w kompilacjach do debugowania i <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> kompilacje metoda do użycia w wykrywaniu błędów zarówno debug i release. Aby uzyskać więcej informacji, zobacz [potwierdzenia w kod zarządzany](/visualstudio/debugger/assertions-in-managed-code).  
  
-   **Błędy programu.** Błąd programu jest błąd w czasie wykonywania, którego nie można uniknąć niekoniecznie pisanie kodu bez błędów.  
  
     W niektórych przypadkach błąd programu mogą uwzględniać warunek błędu oczekiwanych lub procedury. W takim przypadku można uniknąć, za pomocą obsługi wyjątków biznesowych w radzeniu sobie z powodu błędu programu, a zamiast tego spróbuj ponownie wykonać operację. Na przykład, jeśli użytkownik ma wprowadź datę w określonym formacie, można przeanalizować ciągu daty wywołując <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> metody, która zwraca <xref:System.Boolean> wartość, która wskazuje, czy operacja analizy zakończyło się pomyślnie, zamiast <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>— metoda, która zgłasza <xref:System.FormatException> wyjątek, jeśli nie można przekonwertować ciągu daty <xref:System.DateTime> wartość. Podobnie, jeśli użytkownik podejmuje próbę otwarcia pliku, który nie istnieje, można wywołać <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> , aby sprawdzić, czy plik istnieje i, jeśli nie, Monituj użytkownika, czy użytkownik chce go utworzyć.  
  
     W pozostałych przypadkach błąd programu odzwierciedla nieoczekiwany błąd, które mogą być obsługiwane w kodzie. Na przykład nawet jeśli została sprawdzona, aby upewnić się, że plik istnieje, jej mogą zostać usunięte przed, możesz otworzyć go lub jest uszkodzony. W takim przypadku próby otwarcia pliku przez utworzenie wystąpienia <xref:System.IO.StreamReader> obiektu lub wywoływania <xref:System.IO.File.Open%2A> metoda może generować <xref:System.IO.FileNotFoundException> wyjątku. W takich sytuacjach należy użyć obsługi wyjątków, aby odzyskać sprawność po błędzie.  
  
-   **Awarie systemu.** Awarii systemu jest błąd w czasie wykonywania, które nie mogą być obsługiwane programowo w znaczący sposób. Na przykład może zgłosić dowolnej metody <xref:System.OutOfMemoryException> wyjątek, jeśli nie można przydzielić pamięć jest środowisko uruchomieniowe języka wspólnego. Zwykle awarii systemu nie są obsługiwane przy użyciu obsługi wyjątków. Zamiast tego można użyć zdarzenia, takie jak <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> i Wywołaj <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> metody do rejestrowania informacji o wyjątku i powiadamia użytkownika o awarii, zanim aplikacja zakończy.  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Bloki try/catch  
 Środowisko uruchomieniowe języka wspólnego udostępnia model obsługi wyjątku, który jest oparta na reprezentację wyjątki jako obiekty i oddzielenie kodu programu i kodu do obsługi wyjątków `try` bloków i `catch` bloków. Może istnieć co najmniej jeden `catch` blokuje każdego przeznaczone do obsługi określonego typu wyjątku lub jeden blok wychwytywania bardziej konkretny wyjątek niż inny blok.  
  
 Jeśli aplikacja obsługuje wyjątków występujących podczas wykonywania blok kodu aplikacji, kodu musi zostać umieszczony w `try` instrukcji i nosi nazwę `try` bloku. Kod aplikacji, które obsługuje wyjątków zgłaszanych przez `try` blok jest umieszczony w obrębie `catch` instrukcji i nosi nazwę `catch` bloku. Zero lub więcej `catch` bloki są skojarzone z `try` bloku oraz każdy `catch` bloku obejmuje filtr typu, który określa typy obsługi wyjątków.  
  
 Gdy wystąpi wyjątek w `try` bloku, system wyszukuje skojarzony `catch` blokuje w kolejności ich występowania w kodzie aplikacji, lokalizując `catch` bloku, który obsługuje wyjątek. A `catch` blok obsługuje wyjątek typu `T` Jeśli Określa filtr typu bloku catch `T` lub dowolny typ `T` pochodną. Wyszukiwanie po znalezieniu pierwszy zatrzymania systemu `catch` bloku, który obsługuje wyjątek. Z tego powodu w kodzie aplikacji `catch` bloku, który obsługuje typ muszą zostać określone przed `catch` bloku obsługująca jego typów podstawowych, jak pokazano w następującym przykładzie w tej sekcji. Blok catch, która obsługuje `System.Exception` jest określony jako ostatni.  
  
 Jeśli żadna z `catch` bloki skojarzone z bieżącym `try` bloku obsługi wyjątków, a bieżący `try` bloku jest zagnieżdżone w innych `try` blokuje w bieżącym wywołaniu `catch` bloki skojarzone z następnej otaczającej `try` bloku są przeszukiwane. Jeśli nie `catch` bloku wyjątek zostanie znaleziony, system wyszukuje poprzednie poziomów zagnieżdżenia w bieżącym wywołaniu. Jeśli nie `catch` zablokować dla wyjątek znajduje się w bieżącym wywołaniu wyjątek jest przekazywany w górę stosu wywołań i poprzedniej ramki stosu jest wyszukiwany `catch` bloku, który obsługuje wyjątek. Wyszukiwanie stos wywołań będzie kontynuowane aż do obsługi wyjątku lub istnieje ma więcej ramek na stosie wywołań. Po osiągnięciu górnej części stosu wywołań nie `catch` blok, który obsługuje wyjątek domyślny program obsługi wyjątku obsługuje go i zakończy aplikacji.  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>Funkcje typu wyjątku  
 Typy wyjątków obsługuje następujące funkcje:  
  
-   Czytelny dla człowieka tekst, który opisuje błąd. Po wystąpieniu wyjątku, środowisko uruchomieniowe sprawia, że wiadomość SMS poinformować użytkownika charakteru błędu i zasugerować akcji do rozwiązania problemu. Ta wiadomość tekstowa jest przechowywana w <xref:System.Exception.Message%2A> właściwości obiekt wyjątku. Podczas tworzenia obiektu wyjątku można przekazać ciąg tekstowy do konstruktora opisujący szczegóły tego określonego wyjątku. Jeśli nie błąd komunikat podano argumentu do konstruktora, używany jest domyślny komunikat o błędzie. Aby uzyskać więcej informacji, zobacz <xref:System.Exception.Message%2A> właściwości.  
  
-   Stan stos wywołań, gdy wyjątek został zgłoszony. <xref:System.Exception.StackTrace%2A> Właściwość niesie ślad stosu, który może służyć do określenia, gdzie występuje błąd w kodzie. Ślad stosu wymieniono wywoływane metody i numery wierszy w pliku źródłowym, w którym wywołań.  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>Właściwości klasy wyjątku  
 <xref:System.Exception> Klasy zawiera wiele właściwości, które ułatwia identyfikację lokalizacji kodu, typ pliku pomocy i przyczynę wyjątek: <xref:System.Exception.StackTrace%2A>, <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>, <xref:System.Exception.HelpLink%2A>, <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, i <xref:System.Exception.Data%2A>.  
  
 Gdy istnieje przyczynowego między co najmniej dwa wyjątki, <xref:System.Exception.InnerException%2A> właściwość przechowuje te informacje. Wyjątek zewnętrzny jest generowany w odpowiedzi na ten wyjątek wewnętrzny. Kod obsługujący Wyjątek zewnętrzny umożliwia bardziej odpowiednią obsługę błąd informacji z wcześniej wyjątek wewnętrzny. Dodatkowe informacje o wyjątku mogą być przechowywane jako kolekcja par klucz/wartość w <xref:System.Exception.Data%2A> właściwości.  
  
 Ciąg z komunikatem o przekazywany do konstruktora podczas tworzenia obiektu wyjątku powinien być zlokalizowany i plik zasobów mogą być dostarczane za pomocą <xref:System.Resources.ResourceManager> klasy. Aby uzyskać więcej informacji na temat zlokalizowanych zasobów, zobacz [tworzenie zestawów satelickich](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) i [pakowanie i wdrażanie zasobów](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) tematów.  
  
 Aby przyznać użytkownikowi o dodatkowe informacje o dlaczego wystąpił wyjątek <xref:System.Exception.HelpLink%2A> właściwości może zawierać adres URL (lub URN) do pliku pomocy.  
  
 <xref:System.Exception> COR_E_EXCEPTION HRESULT, która ma wartość 0x80131500 używa klasy.  
  
 Aby uzyskać listę początkowe wartości właściwości dla wystąpienia <xref:System.Exception> , zobacz <xref:System.Exception.%23ctor%2A> konstruktorów.  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Wyrzucanie lub Obsługa wyjątku zużywa znaczną ilość zasobów systemowych i czasu wykonywania. Zgłaszanie wyjątków tylko do obsługi naprawdę nadzwyczajne warunki, nie obsługi zdarzeń przewidywalne lub Sterowanie przepływem. Na przykład w niektórych przypadkach, takich jak Jeśli projektujesz biblioteki klas, jest uzasadnione zgłosić wyjątek, jeśli argument metody jest nieprawidłowy, ponieważ oczekuje metodę można wywołać z prawidłowe parametry. Argument nieprawidłową metodę, jeśli nie jest wynikiem błędu użycia oznacza, że coś nadzwyczajne wystąpił. Z drugiej strony nie zgłosić wyjątek, jeśli dane wejściowe użytkownika jest nieprawidłowy, ponieważ można oczekiwać, że od czasu do czasu wprowadzenia nieprawidłowe dane. Zamiast tego udostępniają mechanizm ponawiania, więc użytkownik może wprowadzić prawidłowe wartości wejściowe. Nie należy używać wyjątków do obsługi błędów użycia. Zamiast tego należy użyć [potwierdzenia](/visualstudio/debugger/assertions-in-managed-code) Aby zidentyfikować i poprawić błędy użycia.  
  
 Ponadto nie zgłosić wyjątek, gdy kod powrotu jest wystarczające; Nie można konwertować kod powrotny wyjątek; czy nie rutynowo catch wyjątku, ją zignorować i następnie kontynuować przetwarzanie.  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>Ponownego generowania wyjątku  
 W wielu przypadkach program obsługi wyjątku po prostu chce przekazać wyjątek do obiektu wywołującego. Najczęstszą przyczyną tego błędu w:  
  
-   Biblioteka klas, który z kolei powoduje błąd wywołania metody w bibliotece klas programu .NET Framework lub innych bibliotek klas.  
  
-   Aplikacja lub biblioteki, który napotkał wyjątek krytyczny. Obsługa wyjątków zalogować wyjątek i ponowne zgłoszenie wyjątku.  
  
 Zalecanym sposobem do ponownego zgłoszenia wyjątku jest po prostu użyć [throw](~/docs/csharp/language-reference/keywords/throw.md) instrukcji w języku C# i [Throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) instrukcji w języku Visual Basic bez uwzględniania wyrażenia. Dzięki temu zachowywanie wszystkie informacje stosu wywołań, jeśli wyjątek jest propagowana do obiektu wywołującego. Ilustruje to poniższy przykład. Metodę rozszerzenie ciąg `FindOccurrences`, opakowuje co najmniej jednego wywołania <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> bez weryfikowania jej argumenty wcześniej.  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 Obiekt wywołujący wywołuje `FindOccurrences` dwa razy. W wywołaniu drugi `FindOccurrences`, przekazuje obiekt wywołujący `null` jako ciąg wyszukiwania, które przypadków <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metodę, aby zgłosić <xref:System.ArgumentNullException> wyjątku. Ten wyjątek jest obsługiwany przez `FindOccurrences` — metoda i z powrotem przekazany do obiektu wywołującego. Ponieważ instrukcji throw jest używana z Brak wyrażenia, dane wyjściowe w przykładzie przedstawiono zachowywanie stosu wywołań.  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 Natomiast jeśli ponownie wyjątku używając  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 Instrukcja, stos wywołań pełne nie są zachowywane i przykładzie powoduje wygenerowanie następujących danych wyjściowych:  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 Nieco bardziej skomplikowane alternatywą jest zgłoszenie wyjątku nowy i zachować informacje stosu wywołań pierwotny wyjątek w wyjątku wewnętrznym. Obiekt wywołujący można użyć nowego wyjątek <xref:System.Exception.InnerException%2A> właściwości do pobrania ramki stosu i inne informacje o pierwotny wyjątek. W takim przypadku instrukcji throw jest:  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 Kod użytkownika, który obsługuje wyjątek ma pamiętać, że <xref:System.Exception.InnerException%2A> właściwość zawiera informacje o pierwotny wyjątek, jak pokazano w poniższych obsługi wyjątków.  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>Wybieranie standardowych wyjątków  
 Jeśli ma zostać zgłoszony wyjątek, można jej użyć istniejącego typu wyjątku w programie .NET Framework zamiast Implementowanie niestandardowego wyjątku. Należy używać typu wyjątku standardowe tych dwóch warunkach:  
  
-   Są Zgłaszanie wyjątku, który jest spowodowany przez błąd użycia (oznacza to błąd w logice programu wprowadzone przez projektanta, który wywołuje metodę). Zazwyczaj należy spowoduje zgłoszenie wyjątku takich jak <xref:System.ArgumentException>, <xref:System.ArgumentNullException>, <xref:System.InvalidOperationException>, lub <xref:System.NotSupportedException>. Ciąg, który podasz do konstruktora obiektu wyjątek podczas tworzenia wystąpienia obiektu wyjątek powinien opisano błąd, dzięki czemu deweloper może go rozwiązać. Aby uzyskać więcej informacji, zobacz <xref:System.Exception.Message%2A> właściwości.  
  
-   Czy obsługa błędu, który można przekazane do elementu wywołującego z istniejących wyjątek .NET Framework. Powinien zgłosić wyjątek najdalszych pochodnych możliwe. Na przykład, jeśli metoda wymaga argumentu być prawidłowym elementem członkowskim typu wyliczeniowego, powinien zgłosić <xref:System.ComponentModel.InvalidEnumArgumentException> (najbardziej pochodnej klasy) zamiast <xref:System.ArgumentException>.  
  
 W poniższej tabeli wymieniono typowe typów wyjątków i warunków, w których spowoduje zgłoszenie je.  
  
|Wyjątek|Warunek|  
|---------------|---------------|  
|<xref:System.ArgumentException>|Argument inną niż null, która została przekazana do metody jest nieprawidłowy.|  
|<xref:System.ArgumentNullException>|Argument przekazywany do metody jest `null`.|  
|<xref:System.ArgumentOutOfRangeException>|Argument jest spoza zakresu prawidłowych wartości.|  
|<xref:System.IO.DirectoryNotFoundException>|Część ścieżki katalogu jest nieprawidłowy.|  
|<xref:System.DivideByZeroException>|Mianownik w całkowitą lub <xref:System.Decimal> operacji dzielenia wynosi zero.|  
|<xref:System.IO.DriveNotFoundException>|Dysk jest niedostępny lub nie istnieje.|  
|<xref:System.IO.FileNotFoundException>|Plik nie istnieje.|  
|<xref:System.FormatException>|Wartość nie jest w odpowiednim formacie, który ma zostać przekonwertowany z ciągu za pomocą metody konwersji, takich jak `Parse`.|  
|<xref:System.IndexOutOfRangeException>|Indeks jest poza granicami tablicą lub kolekcją.|  
|<xref:System.InvalidOperationException>|Wywołanie metody jest nieprawidłowy w bieżącym stanie obiektu.|  
|<xref:System.Collections.Generic.KeyNotFoundException>|Nie można odnaleźć określonego klucza do uzyskiwania dostępu do elementu członkowskiego w kolekcji.|  
|<xref:System.NotImplementedException>|Metoda lub operacja nie jest zaimplementowana.|  
|<xref:System.NotSupportedException>|Metoda lub operacja nie jest obsługiwana.|  
|<xref:System.ObjectDisposedException>|Operacja jest wykonywana na obiekcie, który został usunięty.|  
|<xref:System.OverflowException>|Działania arytmetyczne, rzutowania lub konwersji spowodowało przepełnienie.|  
|<xref:System.IO.PathTooLongException>|Ścieżka lub nazwa pliku przekracza maksymalną długość zdefiniowana w systemie.|  
|<xref:System.PlatformNotSupportedException>|Operacja nie jest obsługiwana na bieżącej platformie.|  
|<xref:System.RankException>|Ze złą liczbę wymiarów tablicy jest przekazywany do metody.|  
|<xref:System.TimeoutException>|Upłynął czas przydzielony na wykonanie operacji.|  
|<xref:System.UriFormatException>|Nieprawidłowy identyfikator URI (Uniform Resource) jest używany.|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>Implementowanie wyjątków niestandardowych  
 Używanie istniejącej wyjątek .NET Framework do obsługi warunek błędu nie jest w następujących przypadkach odpowiednie:  
  
-   Jeśli wyjątek odzwierciedla błąd unikatowy programu, które nie może być mapowane na istniejące wyjątek .NET Framework.  
  
-   Jeśli wyjątek wymaga obsługi, który różni się od obsługi, który jest odpowiedni dla istniejącego wyjątek .NET Framework lub wyjątek musi rozróżniane z podobnych wyjątku. Na przykład, jeśli Generowanie <xref:System.ArgumentOutOfRangeException> wyjątek podczas analizowania reprezentację liczbową ciąg, który jest poza zakresem typu całkowitego docelowej, czy nie ma być używany ten sam wyjątek dla błędu, który powoduje wywołujący nie podano odpowiednie wartości ograniczeniami podczas wywoływania metody.  
  
 <xref:System.Exception> Klasa jest klasą bazową dla wszystkich wyjątków w programie .NET Framework. Wiele klas pochodnych polegać na zachowanie dziedziczone elementy członkowskie <xref:System.Exception> klasy; nie zastępuj członków <xref:System.Exception>, ani czy definiują żadnych unikatowych elementów członkowskich.  
  
 Aby zdefiniować klasy wyjątku:  
  
1.  Definiowanie klasy, która dziedziczy <xref:System.Exception>. Jeśli to konieczne, zdefiniuj żadnych unikatowych elementów członkowskich klasy potrzebne dodatkowe informacje o wyjątku. Na przykład <xref:System.ArgumentException> klasa zawiera <xref:System.ArgumentException.ParamName%2A> właściwość, która określa nazwę parametru, którego argument spowodował wyjątek, i <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> zawiera właściwość <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> właściwość, która wskazuje interwał limitu czasu.  
  
2.  W razie potrzeby należy zastąpić wszystkie dziedziczone elementy członkowskie funkcje, których chcesz zmieniać ani modyfikować. Należy pamiętać, że większość istniejących pochodnej klasy <xref:System.Exception> nie zastępują zachowanie dziedziczone elementy członkowskie.  
  
3.  Określić, czy obiekt niestandardowego wyjątku jest możliwy do serializacji. Serializacja umożliwia zapisanie informacji o wyjątku i pozwala na informacje o wyjątku być współużytkowane przez serwer i klienta serwera proxy w kontekście usług zdalnych. Aby obiekt wyjątku do serializacji, oznacz go z <xref:System.SerializableAttribute> atrybutu.  
  
4.  Definiowanie konstruktora klasy wyjątku. Zazwyczaj klasy wyjątków mają co najmniej jeden z następujących konstruktorów:  
  
    -   <xref:System.Exception.%23ctor>, które są używane wartości domyślne można zainicjować właściwości nowy obiekt wyjątku.  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>, która inicjuje nowy obiekt wyjątku z powodu określonego błędu.  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, która inicjuje nowy obiekt wyjątku z komunikatu i wewnętrzny wyjątek określonego błędu.  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, która jest `protected` Konstruktor, który inicjuje nowy obiekt wyjątku z serializacji danych. Ten konstruktor powinien implementować Jeśli wybrano możliwy do serializacji obiektu wyjątku.  
  
 Poniższy przykład przedstawia użycie klasy niestandardowej wyjątku. Definiuje `NotPrimeException` wyjątek zgłaszany, gdy klient próbuje pobrać sekwencji liczb pierwszych określając początkowy numer, który nie jest podstawowym. Wyjątek definiuje nową właściwość `NonPrime`, która zwraca z systemem innym niż — pierwsze numer, który spowodował wyjątek. Oprócz wykonania chronionych konstruktora ani konstruktora z <xref:System.Runtime.Serialization.SerializationInfo> i <xref:System.Runtime.Serialization.StreamingContext> parametry w celu serializacji, `NotPrimeException` klasa definiuje trzy dodatkowe konstruktorów do obsługi `NonPrime` właściwości.  Każdy Konstruktor wywołuje konstruktor klasy podstawowej, oprócz zachowania programu liczba firmy z systemem innym niż pierwsza wartość. `NotPrimeException` Klasy również jest oznaczony atrybutem <xref:System.SerializableAttribute> atrybutu.  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator` Pokazano w poniższym przykładzie klasa używa sito Eratosthenes do obliczenia sekwencji liczb pierwszych od 2 do limitu określonego przez klienta w wywołaniu dla jego konstruktora klasy. `GetPrimesFrom` Metoda zwraca wszystkie liczb pierwszych, które są większe niż lub równa określonej dolną granicę, ale zgłasza `NotPrimeException` jeśli że dolna granica nie jest liczba pierwsza.  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 Poniższy przykład powoduje, że dwa wywołań `GetPrimesFrom` metody z nie liczby pierwsze, z których jedna przecina granice domeny aplikacji. W obu przypadkach wyjątek jest generowany i pomyślnie obsługiwane kodu klienta.  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Środowisko wykonawcze systemu Windows i [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 W [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] dla [!INCLUDE[win8](~/includes/win8-md.md)], niektóre informacje o wyjątku jest zwykle utracone w przypadku, gdy wyjątek zostanie przekazane za pomocą ramki stosu platformy .NET. Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)] i [!INCLUDE[win81](~/includes/win81-md.md)], środowisko uruchomieniowe języka wspólnego w dalszym ciągu używa oryginalnej <xref:System.Exception> obiekt, który został zgłoszony, chyba że ten wyjątek został zmodyfikowany w ramce stosu platformy .NET.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `catch` bloku, który jest zdefiniowany w celu obsługi <xref:System.ArithmeticException> błędy. To `catch` również zablokować połowy <xref:System.DivideByZeroException> błędy, ponieważ <xref:System.DivideByZeroException> pochodzi z <xref:System.ArithmeticException> i ma nie `catch` bloku jawnie zdefiniowany dla <xref:System.DivideByZeroException> błędy.  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwość nowego wystąpienia dostarczony przez system komunikatu opisem błędu bierze pod uwagę bieżące ustawienia kulturowe systemu.  
  
 Klasy pochodne powinien zapewnić tym domyślnego konstruktora. W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Exception>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Zlokalizowany opis dostarczany przez system.|  
  
   
  
## Examples  
 Poniższy przykład kodu pochodzi `Exception` używającą wstępnie zdefiniowanych wiadomości. Kod przedstawia użycie konstruktora bez parametrów dla klasy pochodnej i podstawowym `Exception` klasy.  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który opisuje błąd.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy z powodu określonego błędu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwość nowego wystąpienia przy użyciu `message` parametru. Jeśli `message` parametr jest `null`, jest taka sama jak wywołanie <xref:System.Exception.%23ctor%2A> konstruktora.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Exception>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
   
  
## Examples  
 Poniższy przykład kodu pochodzi `Exception` dla określonego warunku. Kod przedstawia użycie Konstruktor, który pobiera komunikat określonym funkcję wywołującą jako parametr, dla klasy pochodnej i podstawowym `Exception` klasy.  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Zawierający dane zserializowanego obiektu dotyczące zgłaszanego wyjątku.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> Zawierający informacje kontekstowe dotyczące źródła lub miejsca docelowego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> z zserializowanymi danymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana podczas deserializacji do odtworzenia obiektu wyjątku przesyłanego za pomocą strumienia. Aby uzyskać więcej informacji, zobacz [XML i serializacji SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje pochodnego serializacji `Exception` klasy. Kod wymusza błąd dzielenia przez 0, a następnie tworzy wystąpienie klasy pochodnej wyjątków za pomocą (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) konstruktora. Kod serializuje wystąpienie do pliku, deserializuje plik do nowego wyjątek, który zgłasza, a następnie przechwytuje i wyświetla dane wyjątku.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Nazwa klasy jest <see langword="null" /> lub <see cref="P:System.Exception.HResult" /> wynosi zero (0).</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat o błędzie wyjaśniający przyczynę wyjątku.</param>
        <param name="innerException">Wyjątek będący przyczyną bieżącego wyjątku lub odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), jeśli jest określony żaden wyjątek wewnętrzny.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> z określonego komunikatu o błędzie i odwołania do wyjątek wewnętrzny będący przyczyną tego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek zgłaszany bezpośrednio w wyniku poprzedniego wyjątku powinien zawierać odwołanie do poprzedniego wyjątku we <xref:System.Exception.InnerException%2A> właściwości. <xref:System.Exception.InnerException%2A> Właściwość zwraca tę samą wartość, która została przekazana do konstruktora lub odwołanie o wartości null (`Nothing` w języku Visual Basic) Jeśli <xref:System.Exception.InnerException%2A> właściwości nie dostarcza do konstruktora wartości wyjątku wewnętrznego.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Exception>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie do wewnętrznego wyjątku.|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
   
  
## Examples  
 Poniższy przykład kodu pochodzi `Exception` dla określonego warunku. Kod przedstawia użycie konstruktora, który przyjmuje wiadomości i wyjątek wewnętrzny jako parametry dla klasy pochodnej i podstawowym `Exception` klasy.  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję par klucz/wartość, które znajdują się dodatkowe zdefiniowane przez użytkownika informacje o wyjątku.</summary>
        <value>Obiekt, który implementuje <see cref="T:System.Collections.IDictionary" /> interfejsu i zawiera kolekcję par klucz/wartość zdefiniowane przez użytkownika. Wartością domyślną jest pusta kolekcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Collections.IDictionary?displayProperty=nameWithType> obiektu zwróconego przez <xref:System.Exception.Data%2A> właściwości do przechowywania i pobierania dodatkowe informacje dotyczące wyjątku. Informacje znajdują się w formie dowolnej liczby pary klucz wartość zdefiniowana przez użytkownika. Najważniejszym aspektem każdego pary klucza/wartości jest zwykle ciąg identyfikujący część wartości pary mogą być obiekty dowolnego typu.  
  
## <a name="keyvalue-pair-security"></a>Zabezpieczenia pary klucz/wartość  
 Pary klucz/wartość przechowywanych w kolekcji zwróconej przez <xref:System.Exception.Data%2A> właściwości nie są bezpieczne. Jeśli aplikacja wywołuje szereg zagnieżdżonych procedury, a każda procedura zawiera programy obsługi wyjątków, wynikowy stosu wywołań zawiera hierarchię te programy obsługi wyjątków. Jeśli procedura niższego poziomu zgłasza wyjątek, wszelkie obsługi wyjątków wyższego poziomu w hierarchii stosu wywołań można odczytać i/lub zmodyfikować pary klucz/wartość przechowywanych w kolekcji przez inne obsługi wyjątków. Oznacza to, że należy zagwarantować dane w pary klucz wartość nie jest poufne i że aplikacja będzie działać prawidłowo, jeśli informacje w pary klucz wartość są uszkodzone.  
  
## <a name="key-conflicts"></a>Konflikty klucza  
 Konflikt klucza występuje, gdy programy obsługi wyjątków różnych określić ten sam klucz dostępu parę klucza i wartości do. Tworzenie aplikacji, ponieważ konsekwencją konflikt klucza jest programy obsługi wyjątków niższego poziomu mogą przypadkowo może komunikować się z wyższego poziomu obsługi wyjątków, czy ta komunikacja może spowodować błędy niewielkie program, należy zachować ostrożność. Jednak w przypadku ostrożność służy konfliktów kluczy w celu zwiększenia aplikacji.  
  
## <a name="avoiding-key-conflicts"></a>Unikanie konfliktów klucza  
 Aby uniknąć konfliktów kluczy przyjmowanie konwencji nazewnictwa do wygenerowania unikatowy kluczy dla pary klucz wartość. Na przykład konwencji nazewnictwa może dać klucz, który składa się z nazwy rozdzielonym aplikacji, metody, która zawiera dodatkowe informacje dotyczące pary i unikatowy identyfikator.  
  
 Załóżmy, że dwóch aplikacji o nazwie produktów i dostawców, każda ma metodę o nazwie sprzedaży. Metoda sprzedaży w aplikacji produktów zawiera numeru identyfikacyjnego (magazynową jednostki lub jednostki SKU) produktu. Metoda sprzedaży w aplikacji dostawcy udostępnia numer identyfikacyjny lub identyfikator SID dostawcy. W rezultacie konwencji nazewnictwa w tym przykładzie daje klucze, "Products.Sales.SKU" i "Suppliers.Sales.SID".  
  
## <a name="exploiting-key-conflicts"></a>Wykorzystanie konfliktów klucza  
 Wykorzystać konfliktów kluczy przy użyciu obecności co najmniej jeden klucz specjalnych, wstępnie ustalane do kontrolowania przetwarzania. Załóżmy scenariusz, najwyższy program obsługi wyjątku poziomu w hierarchii stosu wywołań przechwytuje wszystkie wyjątki zgłaszane przez programy obsługi wyjątków niższego poziomu. Jeśli para klucza i wartości, przy użyciu specjalnego klucza istnieje, obsługa wyjątków ogólnych formatuje pozostałych pary klucz wartość w <xref:System.Collections.IDictionary> obiektu w jakiś sposób niestandardowych; w przeciwnym razie pozostałych pary klucz wartość są sformatowane w normalnym sposób.  
  
 Teraz załóżmy, w innym scenariuszu obsługi wyjątków na każdym poziomie hierarchii stosu wywołań przechwytuje wyjątków zgłaszanych przez dalej obsługi wyjątków niższego poziomu. Ponadto każdy program obsługi wyjątku zna kolekcji zwróconej przez <xref:System.Exception.Data%2A> właściwość zawiera zbiór pary klucz wartość, które są dostępne z wstępnie ustalane zestawu kluczy.  
  
 Każdy program obsługi wyjątku używa wstępnie ustalane zestaw kluczy zaktualizować składnik wartości odpowiednich pary klucz wartość z użyciem informacji specyficznych dla programu obsługi wyjątków. Po zakończeniu procesu aktualizacji program obsługi wyjątku zgłasza wyjątek do następnego wyższego poziomu obsługi wyjątków. Ponadto obsługa najwyższego poziomu wyjątków uzyskuje dostęp do pary klucz wartość i wyświetla informacje skonsolidowanych aktualizacji z obsługi wyjątków niższego poziomu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak dodać i pobrać za pomocą informacji <xref:System.Exception.Data%2A> właściwości.  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Exception" /> czyli przyczynę jeden lub więcej kolejnych wyjątków.</summary>
        <returns>Pierwszy wyjątek w łańcuchu wyjątków. Jeśli <see cref="P:System.Exception.InnerException" /> właściwości bieżącego wyjątku jest odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), ta właściwość zwraca bieżącego wyjątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Łańcuch wyjątków zawiera zestaw wyjątków tak, aby każdy w łańcuchu wyjątek bezpośrednio z powodu wyjątku, do którego odwołuje się jego `InnerException` właściwości. Dla danego łańcucha może istnieć dokładnie jeden wyjątek, który jest główną przyczynę wszystkie wyjątki w łańcuchu. Ten wyjątek nosi nazwę podstawową wyjątek i jego `InnerException` właściwość zawsze zawiera odwołanie o wartości null.  
  
 Wszystkie wyjątki w łańcuchu wyjątków `GetBaseException` metoda musi zwracać ten sam obiekt (wyjątek podstawowej).  
  
 Użyj `GetBaseException` metody, aby znaleźć przyczynę wyjątek, ale nie są informacje dotyczące wyjątków, które mogły wystąpić między bieżący wyjątek i pierwszy wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu definiuje dwie pochodnych `Exception` klasy. Wymusza wyjątek, a następnie generuje go ponownie z każdym z klasy pochodnej. Kod pokazano sposób użycia `GetBaseException` metoda pobierania pierwotny wyjątek.  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="GetBaseException" /> Metoda zostanie przesłonięta w klasach, które wymagają kontrolę nad zawartością wyjątku lub format.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Zawierający dane zserializowanego obiektu dotyczące zgłaszanego wyjątku.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> Zawierający informacje kontekstowe dotyczące źródła lub miejsca docelowego.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> informacje o wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` Ustawia <xref:System.Runtime.Serialization.SerializationInfo> ze wszystkimi danymi obiektu wyjątków przeznaczone do serializacji. Podczas deserializacji, wyjątek jest odtworzonych z `SerializationInfo` przesyłane przez strumień.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje pochodnego serializacji `Exception` klasa implementująca `GetObjectData`, co czyni drobne zmiany do dwóch właściwości i następnie wywołania podstawowym klasy do wykonywania serializacji. Przykład wymusza błąd dzielenia przez 0, a następnie tworzy wystąpienia pochodne wyjątku. Kod serializuje wystąpienie do pliku, deserializuje plik do nowego wyjątek, który zgłasza, a następnie przechwytuje i wyświetla dane wyjątku.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> Parametr jest odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ środowiska uruchomieniowego bieżącego wystąpienia.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje typ środowiska uruchomieniowego dokładne bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.GetType%2A> Metoda istnieje obsługuje infrastrukturę programu .NET Framework i wewnętrznie wywołuje metodę podstawową, <xref:System.Object.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia łącze do pliku Pomocy skojarzonych z tym wyjątkiem.</summary>
        <value>Nazwa Uniform Resource URN lub adres URL (adres URL).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana, reprezentujący plik pomocy jest URN lub adresem URL. Na przykład `HelpLink` wartość może być:  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 Poniższy kod przykładowy zgłasza `Exception` stanowiąca `HelpLink` właściwości w jego konstruktora, a następnie połowy wyjątek i wyświetla `HelpLink`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia HRESULT, wartość liczbową kodowane, przypisane do określonego wyjątku.</summary>
        <value>Wartość HRESULT.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT jest 32-bitową wartość podzielone na trzy różne pola: kod ważność, kod zakładzie i kod błędu. Kod ważność wskazuje, czy zwracana wartość reprezentuje informacje, ostrzeżenia lub błędu. Kod obiektu identyfikuje obszar systemem odpowiedzialnym za błąd. Kod błędu to unikatowy numer przypisany do reprezentowania wyjątek. Każdy wyjątek jest zamapowana na różne HRESULT. Gdy kod zarządzany zgłasza wyjątek, środowisko uruchomieniowe przekazuje HRESULT do klient modelu COM. Po powrocie z kodem niezarządzanym błąd HRESULT jest konwertowana na wyjątek, który następnie jest generowany przez środowisko uruchomieniowe. Aby uzyskać informacje o wartości HRESULT i ich odpowiednich wyjątków .NET Framework, zobacz [porady: mapy wyników HRESULT i wyjątków](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md). Zobacz [wspólne wartości HRESULT](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) w dokumentacji systemu Windows lista wartości jest najczęściej spotykane.  
  
 Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Exception.HResult%2A> metody ustawiającej właściwości jest chroniony, jest publicznej metody pobierającej.  W poprzednich wersjach programu .NET Framework metody pobierającej i ustawiającej są chronione.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje pochodnego `Exception` klasy, która ustawia `HResult` właściwości niestandardowej wartości w jego konstruktora.  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Exception" /> wystąpienia, który spowodował bieżącego wyjątku.</summary>
        <value>Obiekt, który opisuje błąd, który spowodował bieżącego wyjątku. <see cref="P:System.Exception.InnerException" /> Właściwość zwraca tę samą wartość, ponieważ został przekazany <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> konstruktora, lub <see langword="null" /> Jeśli wartości wyjątku wewnętrznego nie został dostarczony do konstruktora. Ta właściwość jest tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wyjątek `X` jest zgłaszany jako bezpośrednio w wyniku poprzedniego wyjątku `Y`, <xref:System.Exception.InnerException%2A> właściwość `X` powinien zawierać odwołanie do `Y`.  
  
 Użyj <xref:System.Exception.InnerException%2A> właściwości, aby uzyskać zestaw wyjątki, które doprowadziły do bieżącego wyjątku.  
  
 Możesz utworzyć nowy wyjątek, który przechwytuje wcześniej wyjątek. Kod obsługi można wprowadzać drugi wyjątek użyć do obsługi błędu odpowiedniej dodatkowych informacji z wcześniejszych wyjątku.  
  
 Załóżmy, że funkcja, która odczytuje plik i formatuje dane z tego pliku. W tym przykładzie, jako kod próbuje odczytać pliku <xref:System.IO.IOException> jest generowany. Funkcja przechwytuje <xref:System.IO.IOException> i zgłasza <xref:System.IO.FileNotFoundException>. <xref:System.IO.IOException> Mogły zostać zapisane w <xref:System.Exception.InnerException%2A> właściwość <xref:System.IO.FileNotFoundException>, włączanie kod, który przechwytuje <xref:System.IO.FileNotFoundException> zbadać przyczynę błędu początkowej.  
  
 <xref:System.Exception.InnerException%2A> Ustawiono właściwość, która zawiera odwołanie do wyjątek wewnętrzny, po zainicjowaniu obiektu wyjątku.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano zgłaszanie i przechwytywanie wyjątku, który odwołuje się do wyjątek wewnętrzny.  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera komunikat opisujący bieżący wyjątek.</summary>
        <value>Komunikat o błędzie opisujący przyczynę wyjątek lub ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikaty o błędach docelowe projektanta, który obsługuje wyjątek. Tekst <xref:System.Exception.Message%2A> właściwości należy całkowicie opisu błędu i, jeśli to możliwe, należy również wyjaśniono, jak poprawić ten błąd. Programy obsługi wyjątków najwyższego poziomu mogą być wyświetlane wiadomości dla użytkowników końcowych, dlatego należy upewnić się, czy jest gramatycznie poprawny i czy każdego zdania wiadomości kończy się kropką. Nie używaj znaków zapytania lub wykrzykniki. Jeśli aplikacja używa komunikaty o wyjątkach zlokalizowanego, należy upewnić się, że dokładnie translacji.  
  
> [!IMPORTANT]
>  Nie wyjawiać poufnych informacji w komunikatach wyjątek bez sprawdzania pod kątem odpowiednich uprawnień.  
  
 Wartość <xref:System.Exception.Message%2A> właściwość jest dołączona informacje zwracane przez <xref:System.Exception.ToString%2A>. <xref:System.Exception.Message%2A> Właściwość jest ustawiona tylko wtedy, gdy tworzenie <xref:System.Exception>. Jeśli żaden komunikat nie podano konstruktora dla bieżącego wystąpienia, system udostępnia wiadomość domyślną sformatowany przy użyciu bieżącego ustawienia kulturowego systemu.  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Środowisko wykonawcze systemu Windows i [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)] i [!INCLUDE[win81](~/includes/win81-md.md)], Lepsza dokładność komunikaty o błędach z wyjątków, które zostały przeniesione z typów środowiska wykonawczego systemu Windows i elementów członkowskich, które nie są częścią programu .NET Framework. W szczególności komunikaty wyjątku z rozszerzenia składników dla programu Visual C++ (C + +/ CX) są teraz propagowane do .NET Framework <xref:System.Exception> obiektów.  
  
   
  
## Examples  
 Poniższy przykład kodu zgłasza wyjątek, a następnie przechwytuje <xref:System.Exception> wyjątek i wyświetla tekst wyjątku komunikatów przy użyciu <xref:System.Exception.Message%2A> właściwości.
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli zgłoszenie wyjątku z właściwością i trzeba odwoływać się w tekście <see cref="P:System.Exception.Message" /> do argumentu właściwość, która ustawiać ani pobierać, użyj "value" jako nazwa argumentu właściwości.</para>
        </block>
        <block subset="none" type="overrides">
          <para>
            <see cref="P:System.Exception.Message" /> Właściwość nie zostanie zastąpiona klas, które wymagają kontroli nad formatu lub zawartość komunikatu. Kod aplikacji zwykle uzyskuje dostęp do tej właściwości kiedy zachodzi potrzeba wyświetlać informacje na temat wyjątek został przechwycony.  Komunikat o błędzie powinien być lokalizowany.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek jest serializowany można utworzyć obiektu stanu wyjątek, który zawiera seryjnych danych o wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt stanu wyjątek implementuje <xref:System.Runtime.Serialization.ISafeSerializationData> interfejsu.  
  
 Gdy <xref:System.Exception.SerializeObjectState> zdarzeń jest subskrybowana w usłudze, wyjątek jest deserializacji i utworzone jako wyjątek puste. Konstruktor wyjątku nie jest uruchamiane, a stan wyjątku jest również deserializacji. <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> Metody wywołania zwrotnego obiektu stanu wyjątek następnie powiadomienie, aby go umieścić zdeserializowany danych do pustego wyjątku.  
  
 <xref:System.Exception.SerializeObjectState> Zdarzeń umożliwia typów wyjątków przezroczysty do serializacji i deserializacji wyjątku. Kod o przezroczystym można wykonywać polecenia w granicach zestaw uprawnień, który działa wewnątrz, ale nie może wykonać, wywołania, pochodzi z ani zawierać kodu krytycznego.  
  
 Jeśli <xref:System.Exception.SerializeObjectState> zdarzeń nie ma subskrypcji, deserializacji występuje w zwykły sposób za pomocą <xref:System.Exception.%23ctor%2A> konstruktora.  
  
 Zazwyczaj obsługi dla <xref:System.Exception.SerializeObjectState> zdarzeń jest dodawany w Konstruktorze wyjątek, aby zapewnić jego serializacji. Ale ponieważ konstruktora nie jest wykonywane, kiedy <xref:System.Exception.SerializeObjectState> wykonuje program obsługi zdarzeń, serializacji zdeserializowany wyjątku może zgłosić <xref:System.Runtime.Serialization.SerializationException> wyjątek podczas próby deserializacji wyjątek. Aby tego uniknąć, należy również dodać obsługę programu <xref:System.Exception.SerializeObjectState> zdarzenia w <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> metody. W sekcji Przykłady ilustracji.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `BadDivisionException` obsługująca <xref:System.Exception.SerializeObjectState> zdarzeń. Zawiera także obiektu stanu, który jest zagnieżdżoną struktury o nazwie `BadDivisionExceptionState` implementującej <xref:System.Runtime.Serialization.ISafeSerializationData> interfejsu.  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException` Wyjątek po wystąpieniu Zmiennoprzecinkowe dzielenie przez zero. Podczas pierwszego dzielenie przez zero, tworzy przykładzie `BadDivisionException` obiekt, jego serializuje i zgłasza wyjątek. Gdy występują kolejnych podziałów przez zero, przykładzie deserializuje wcześniej Zserializowany obiekt, reserializes go i zgłasza wyjątek. Aby zapewnić serializacji obiektu, deserializacji reserialization i deserializacji, w przykładzie dodano <xref:System.Exception.SerializeObjectState> obsługi zdarzeń zarówno w `BadDivisionException` konstruktora klasy i w <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> implementacji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli to zdarzenie jest subskrybowana i używany, wszystkie typy pochodne, które należy wykonać w hierarchii dziedziczenia musi implementować ten sam mechanizm serializacji.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę aplikacji lub obiekt, który powoduje błąd.</summary>
        <value>Nazwa aplikacji lub obiekt, który powoduje błąd.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Exception.Source%2A> właściwość nie jest jawnie ustawiona, środowisko uruchomieniowe automatycznie ustawia ją na nazwę zestawu, w którym wyjątek pochodzi.  
  
   
  
## Examples  
 Poniższy przykład zwraca `Exception` stanowiąca `Source` właściwości w jego konstruktora, a następnie połowy wyjątek i wyświetla `Source`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Obiekt musi być środowisko uruchomieniowe <see cref="N:System.Reflection" /> obiektu</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera reprezentację ciągu natychmiastowego ramek na stosie wywołań.</summary>
        <value>Ciąg opisujący natychmiastowego ramki stosu wywołań.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stos wykonywania przechowuje informacje o wszystkie metody, które są w danej chwili podczas wykonywania. Śledzenia wywołań metoda jest wywoływana ślad stosu. Lista śledzenia stosu umożliwia wykonaj stosu wywołań do numeru wiersza w metodzie, gdzie występuje wyjątek.  
  
 <xref:System.Exception.StackTrace%2A> Właściwość zwraca ramki stosu wywołań, które pochodzi z lokalizacji, w której wystąpił wyjątek. Informacje na temat dodatkowych ramek na stosie wywołań można uzyskać, tworząc nowe wystąpienie klasy <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> klasy i przy użyciu jego <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> metody.  
  
 Środowisko uruchomieniowe języka wspólnego (CLR) aktualizuje ślad stosu zawsze, gdy wyjątek w kodzie aplikacji (przy użyciu `throw` — słowo kluczowe). Jeśli wyjątek został zgłoszony w metodzie, który jest inny niż metody, gdzie został początkowo zgłoszony, ślad stosu zawiera zarówno w metodzie w lokalizacji, w którym pierwotnie został zgłoszony wyjątek, jak i w metodzie w lokalizacji, w którym wyjątek zgłoszony. Jeśli zgłoszony wyjątek i później zgłoszony w tej samej metody, ślad stosu zawiera tylko lokalizacji, w którym wyjątek został zgłoszony i nie ma lokalizacji, w którym pierwotnie został zgłoszony wyjątek.  
  
 <xref:System.Exception.StackTrace%2A> Właściwości nie może zgłaszać dowolną liczbę wywołań metody zgodnie z oczekiwaniami ze względu na kod przekształcenia, takie jak ze śródwierszowaniem, która występuje podczas optymalizacji.  
  
   
  
## Examples  
 Poniższy kod przykładowy zgłasza `Exception` przechwytuje go i wyświetla śledzenia stosu przy użyciu `StackTrace` właściwości.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="StackTrace" /> Właściwość nie zostanie zastąpiona klas, które wymagają kontroli nad zawartości śledzenia stosu lub format.  Domyślnie ślad stosu jest przechwytywany natychmiast, zanim zostanie zgłoszony wyjątek obiektu. Użyj <see cref="P:System.Environment.StackTrace" /> Aby uzyskać informacje śledzenia stosu, gdy żaden wyjątek został zgłoszony.</para>
        </block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę bieżący wyjątek.</summary>
        <value>
          <see cref="T:System.Reflection.MethodBase" /> Który zwrócił bieżącego wyjątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda, która zgłasza wyjątek nie jest dostępny i śledzenie stosu nie jest odwołanie o wartości null (`Nothing` w języku Visual Basic), <xref:System.Exception.TargetSite%2A> uzyskuje dostęp do metody z ślad stosu. Jeśli ślad stosu jest odwołanie o wartości null, <xref:System.Exception.TargetSite%2A> również zwraca odwołanie o wartości null.  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A> Właściwości nie może zgłaszać dokładnie nazwę metody, w którym został zgłoszony wyjątek, jeśli program obsługi wyjątku obsługuje wyjątek poza granice domeny aplikacji.  
  
   
  
## Examples  
 Poniższy kod przykładowy zgłasza `Exception` przechwytuje go i wyświetla źródłowego przy użyciu metody `TargetSite` właściwości.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca reprezentację ciągu bieżącego wyjątku.</summary>
        <returns>Reprezentacja ciągu bieżącego wyjątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> Zwraca reprezentację bieżący wyjątek, który ma być rozpoznawany przez człowieka. W przypadku, gdy wyjątek zawiera dane zależne od kultury, reprezentacja ciągu zwrócony przez `ToString` należy wziąć pod uwagę bieżące ustawienia kulturowe systemu. Mimo że nie istnieją dokładne wymagania formatu ciągu zwróconego, należy próbować odzwierciedlają wartość obiektu jako postrzegana przez użytkownika.  
  
 Domyślna implementacja <xref:System.Exception.ToString%2A> uzyskuje nazwę klasy, która zgłosiła bieżącego wyjątku, komunikat, w wyniku wywołania metody <xref:System.Exception.ToString%2A> na wyjątek wewnętrzny, a w wyniku wywołania metody <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>. Jeśli dowolny z tych elementów członkowskich jest `null`, jego wartość nie jest uwzględniona w zwracany ciąg.  
  
 Jeśli nie ma błędów lub jest pustym ciągiem (""), zwracana jest żaden komunikat o błędzie. Nazwa wyjątek wewnętrzny i ślad stosu są zwracane tylko wtedy, gdy nie są one `null`.  
  
 Ta metoda zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład powoduje zgłoszenie wyjątku i wyświetla wyniku wywołania metody <xref:System.Exception.ToString%2A> na tym wyjątku. Należy pamiętać, że <xref:System.Exception.ToString%2A?displayProperty=nameWithType> metoda jest wywoływana niejawnie, gdy wystąpienie klasy wyjątku pojawi się na liście argumentów <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody.  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
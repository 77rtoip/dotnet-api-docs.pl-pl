<Type Name="Exception" FullName="System.Exception">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b6a46021d01fcc2206f04fdf15d59bcb4950f7f0" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39917881" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje błędy występujące podczas wykonywania aplikacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest klasą bazową dla wszystkich wyjątków. Gdy wystąpi błąd, system lub aktualnie realizowanej aplikacji zgłasza go, zostanie zgłoszony wyjątek, który zawiera informacje o tym błędzie. Po jest zgłaszany wyjątek, jest to obsługiwane przez aplikację lub przez domyślny program obsługi wyjątku.  
  
 W tej sekcji:  
  
 [Błędy i wyjątki](#Errors)   
 [Bloki try/catch](#TryCatch)   
 [Funkcje typu wyjątku](#Features)   
 [Właściwości klasy wyjątku](#Properties)   
 [Zagadnienia dotyczące wydajności](#Performance)   
 [Ponownie zostanie zgłoszony wyjątek](#Rethrow)   
 [Wybieranie standardowych wyjątków](#Standard)   
 [Implementowanie wyjątków niestandardowych](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>Błędy i wyjątki  
 Błędy czasu wykonywania może wystąpić z różnych powodów. Jednak nie wszystkie błędy powinny być traktowane jako wyjątki w kodzie. Poniżej przedstawiono niektóre kategorie błędy, które mogą wystąpić w czasie wykonywania i odpowiednie sposoby Reaguj na nie.  
  
-   **Błędy użycia.** Błąd użycia reprezentuje błąd w logice programu, który może spowodować wyjątek. Jednak błąd powinny być kierowane nie przy użyciu obsługi wyjątków, ale modyfikując nieprawidłowy kod. Na przykład zastępowania metody <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody w poniższym przykładzie założono, że `obj` argument zawsze musi być inna niż null.  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <xref:System.NullReferenceException> Wyjątek, który powoduje podczas `obj` jest `null` można wyeliminować, modyfikując kod źródłowy do testowania jawne wartości null, przed wywołaniem <xref:System.Object.Equals%2A?displayProperty=nameWithType> przesłonięć i ponowną kompilację. Poniższy przykład zawiera kod źródłowy poprawiony, która obsługuje `null` argumentu.  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     Zamiast korzystać z obsługi błędów użycia wyjątków, można użyć <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodę, aby zidentyfikować błędy użycia w kompilacjach do debugowania i <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> tworzy metodę, aby zidentyfikować błędy użycia zarówno w przypadku debugowania, jak i wydania. Aby uzyskać więcej informacji, zobacz [potwierdzenia w kodzie zarządzany](/visualstudio/debugger/assertions-in-managed-code).  
  
-   **Błędy programu.** Błąd programu jest błąd w czasie wykonywania, które nie zawsze można uniknąć przez napisanie kodu wolny od błędów.  
  
     W niektórych przypadkach błąd programu mogą uwzględniać warunek błędu oczekiwanych lub procedury. W takim przypadku można Unikaj używania wyjątków do czynienia z powodu błędu programu i zamiast tego spróbuj ponownie wykonać operację. Na przykład, jeśli użytkownik jest szacowany jako danych wejściowych na datę w określonym formacie, można przeanalizować ciąg daty, wywołując <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> metody, która zwraca <xref:System.Boolean> wartość, która wskazuje, czy operacja analizy zakończyło się pomyślnie, zamiast <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>metody, która zgłasza <xref:System.FormatException> wyjątek, jeśli nie można przekonwertować ciągu daty <xref:System.DateTime> wartość. Podobnie, jeśli użytkownik próbuje otworzyć plik, który nie istnieje, można wywołać <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> metodę sprawdzania, czy plik istnieje, a jeśli nie, Monituj użytkownika, czy użytkownik chce, aby go utworzyć.  
  
     W innych przypadkach błąd programu odzwierciedla nieoczekiwany błąd, który mogą być obsługiwane w kodzie. Na przykład nawet jeśli została sprawdzona, aby upewnić się, że plik istnieje, jego mogą zostać usunięte przed możesz go otworzyć, lub może on być uszkodzony. W takim przypadku próby otwarcia pliku przez utworzenie wystąpienia <xref:System.IO.StreamReader> obiektu lub wywoływania <xref:System.IO.File.Open%2A> metoda może zgłaszać <xref:System.IO.FileNotFoundException> wyjątku. W takich przypadkach należy użyć obsługi wyjątków, aby odzyskać sprawność po błędzie.  
  
-   **Awarie systemu.** Awaria systemu jest błąd w czasie wykonywania, które nie mogą być obsługiwane programowo w znaczący sposób. Na przykład, każda metoda może zgłosić <xref:System.OutOfMemoryException> wyjątek, jeśli środowisko uruchomieniowe języka wspólnego nie może przydzielić więcej pamięci. Zazwyczaj awarie systemu nie są obsługiwane przy użyciu obsługi wyjątków. Zamiast tego można użyć zdarzenia, takie jak <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> i wywołać <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> metodę, aby rejestrować informacje o wyjątku i powiadamia użytkownika o awarii, zanim aplikacja zakończy.  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Bloki try/catch  
 Środowisko uruchomieniowe języka wspólnego udostępnia model obsługi wyjątków, który jest oparty na reprezentację wyjątki jako obiekty i oddzielenie kodu programu i kodu do obsługi wyjątków `try` bloków i `catch` bloków. Może istnieć jeden lub więcej `catch` blokuje każde jest zaprojektowane do obsługi określonego typu wyjątku lub jeden blok umożliwiający bardziej konkretny wyjątek niż innego bloku catch.  
  
 Jeśli aplikacja obsługuje wyjątki, które występują podczas wykonywania bloku kodu aplikacji, kod musi być umieszczony w `try` instrukcji i jest wywoływana `try` bloku. Kod aplikacji, który obsługuje wyjątki wyrzucane przez `try` bloku znajduje się w obrębie `catch` instrukcji i jest wywoływana `catch` bloku. Zero lub więcej `catch` bloki są skojarzone z `try` bloku oraz każdy `catch` blokowe operacje dołączania filtr typu, który określa typ obsługi wyjątków.  
  
 Gdy wystąpi wyjątek w `try` bloku, system przeszukuje skojarzonego `catch` bloków w kolejności, są wyświetlane w kodzie aplikacji, lokalizując `catch` blok, który obsługuje wyjątek. A `catch` blok obsługuje wyjątek typu `T` Jeśli filtr typu bloku catch Określa `T` lub dowolny typ, który `T` pochodzi od klasy. Wyszukiwanie po znajdzie pierwszy zatrzymania systemu `catch` blok, który obsługuje wyjątek. Z tego powodu w kodzie aplikacji `catch` blok, który obsługuje typ muszą zostać określone przed `catch` blok, który obsługuje jej typów podstawowych, jak pokazano w przykładzie poniżej w tej sekcji. W bloku catch, który obsługuje `System.Exception` jest określony jako ostatni.  
  
 Jeśli żadna z `catch` bloki skojarzone z bieżącym `try` bloku obsługi wyjątków i bieżący `try` bloku jest zagnieżdżony w innych `try` bloków w bieżącym wywołaniu `catch` bloki skojarzone z następnego otaczający `try` bloku są przeszukiwane. Jeśli nie `catch` bloku, dla wyjątku zostanie znaleziony, system wyszukuje poprzednie poziomów zagnieżdżenia w bieżącym wywołaniu. Jeśli nie `catch` blokowania, dla wyjątku znajduje się w bieżącym wywołaniu, wyjątek jest przekazywany w górę stosu wywołań i poprzedniej ramki stosu są wyszukiwane `catch` blok, który obsługuje wyjątek. Wyszukiwanie stos wywołań jest kontynuowane aż do obsługi wyjątku lub ma więcej ramek istnieje w stosie wywołań. W przypadku osiągnięcia góra stosu wywołań bez znajdowanie `catch` blok, który obsługuje wyjątek, domyślny program obsługi wyjątku obsługuje je i kończy działanie aplikacji.  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>Funkcje typu wyjątku  
 Typy wyjątków obsługuje następujące funkcje:  
  
-   Czytelny dla człowieka tekst, który opisuje błąd. Gdy wystąpi wyjątek, środowisko wykonawcze zapewnia dostępne, aby poinformować użytkownika charakter błędu i sugerująca akcji wiadomość SMS w celu rozwiązania problemu. Ta wiadomość SMS jest przechowywany w <xref:System.Exception.Message%2A> własności obiektu wyjątku. Podczas tworzenia obiektu wyjątku do konstruktora, aby opisywać szczegóły tego określonego wyjątku można przekazać ciągu tekstowego. Jeśli nie dostarczono żadnego argumentu komunikat o błędzie do konstruktora, jest używany domyślny komunikat o błędzie. Aby uzyskać więcej informacji, zobacz <xref:System.Exception.Message%2A> właściwości.  
  
-   Stan w stosie wywołań gdy wyjątek został zgłoszony. <xref:System.Exception.StackTrace%2A> Właściwość niesie ze sobą ślad stosu, który może służyć do określenia, gdzie występuje błąd w kodzie. Ślad stosu Wyświetla listę wszystkich wywoływanych metod i numery wierszy w pliku źródłowym, gdzie wywołań.  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>Właściwości klasy wyjątku  
 <xref:System.Exception> Klasa zawiera wiele właściwości, które pomagają identyfikować lokalizacji kodu, typ, plik pomocy i przyczyny, dla wyjątku: <xref:System.Exception.StackTrace%2A>, <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>, <xref:System.Exception.HelpLink%2A>, <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, i <xref:System.Exception.Data%2A>.  
  
 Gdy przyczynowego istnieje między co najmniej dwa wyjątki, <xref:System.Exception.InnerException%2A> właściwość przechowuje te informacje. Wyjątek zewnętrzny jest zgłaszany w odpowiedzi na ten wyjątek wewnętrzny. Kod, który obsługuje wyjątek zewnętrzny umożliwia obsłużenie błędu więcej informacji z wcześniej wyjątek wewnętrzny. Dodatkowe informacje o wyjątku, mogą być przechowywane jako kolekcja par klucz/wartość w <xref:System.Exception.Data%2A> właściwości.  
  
 Ciąg komunikatu o błędzie, który jest przekazywany do konstruktora podczas tworzenia obiektu wyjątku powinien być zlokalizowany i mogą być dostarczane z pliku zasobów za pomocą <xref:System.Resources.ResourceManager> klasy. Aby uzyskać więcej informacji na temat zlokalizowane zasoby, zobacz [tworzenie zestawów satelickich](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) i [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) tematów.  
  
 Aby przyznać użytkownikowi rozbudowane informacje na temat przyczyny wystąpienia wyjątku <xref:System.Exception.HelpLink%2A> właściwość może zawierać adres URL (lub URN) do pliku pomocy.  
  
 <xref:System.Exception> COR_E_EXCEPTION HRESULT, która ma wartość 0x80131500 korzysta z klasy.  
  
 Aby uzyskać listę początkowe wartości właściwości wystąpienia <xref:System.Exception> klasy, zobacz <xref:System.Exception.%23ctor%2A> konstruktorów.  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Zgłaszanie lub Obsługa wyjątku zajmuje znaczną ilość zasobów systemowych i czasu wykonywania. Zgłaszają wyjątki, tylko do obsługi naprawdę nadzwyczajne warunków, aby nie obsługiwać zdarzenia przewidywalne lub Sterowanie przepływem. Na przykład w niektórych przypadkach, takich jak kiedy tworzysz bibliotekę klas jest uzasadnione zgłosić wyjątek, jeśli argument metody jest nieprawidłowy, ponieważ oczekujesz, że metoda wywoływana przy użyciu prawidłowych parametrów. Argument nieprawidłowa metoda, jeśli nie jest wynikiem błędu użycia, oznacza, że coś nadzwyczajne wystąpiło. Z drugiej strony nie zgłosić wyjątek, jeśli dane wejściowe użytkownika jest nieprawidłowy, ponieważ można oczekiwać, że użytkowników od czasu do czasu podania nieprawidłowych danych. Zamiast tego zapewniają mechanizm ponawiania prób, dzięki czemu użytkownicy mogą wprowadzać prawidłowych danych wejściowych. Nie należy używać wyjątków do obsługi błędów użycia. Zamiast tego należy użyć [potwierdzenia](/visualstudio/debugger/assertions-in-managed-code) Aby zidentyfikować i rozwiązać błędy użycia.  
  
 Ponadto zgłasza wyjątku, gdy kod powrotny jest wystarczające; Nie można konwertować kod powrotny wyjątek; i czy nie rutynowo catch wyjątku, go zignorować, a następnie kontynuować przetwarzanie.  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>Ponownie zostanie zgłoszony wyjątek  
 W wielu przypadkach program obsługi wyjątku chce po prostu przekazać wyjątek do obiektu wywołującego. Najczęstszą przyczyną tego błędu w:  
  
-   Biblioteka klas, które z kolei opakowuje wywołania metody w bibliotece klas programu .NET Framework lub inne biblioteki klas.  
  
-   Aplikacja lub bibliotekę, która napotkał wyjątek krytyczny. Program obsługi wyjątków można zarejestruje wyjątek i ponownie zgłosić wyjątek.  
  
 Zalecanym sposobem ponownie zgłosić wyjątek jest po prostu użyć [throw](~/docs/csharp/language-reference/keywords/throw.md) instrukcji w języku C# i [Throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) instrukcji w języku Visual Basic, bez uwzględniania wyrażenia. Daje to gwarancję, że wszystkie informacje stosu wywołań jest zachowywana, gdy wyjątek jest propagowany do obiektu wywołującego. Ilustruje to poniższy przykład. Parametry metody rozszerzenia, `FindOccurrences`, opakowuje wywołania co najmniej jeden <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> bez uprzedniego sprawdzania poprawności argumentów.  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 Następnie wywołuje obiekt wywołujący `FindOccurrences` dwa razy. W drugim wywołaniu `FindOccurrences`, obiekt wywołujący przekazuje `null` jako ciąg wyszukiwania, które przypadki <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metodę, aby zgłosić <xref:System.ArgumentNullException> wyjątku. Ten wyjątek jest obsługiwany przez `FindOccurrences` metody i ponownie przekazana do obiektu wywołującego. Ponieważ instrukcji "throw" jest używana z Brak wyrażenia, wynika z przykładu pokazuje, że stos wywołań jest zachowywany.  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 Natomiast jeśli wyjątek jest ponownie zgłaszany przy użyciu  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 Instrukcja pełny stos wywołań nie są zachowywane, a przykład wygeneruje następujące wyniki:  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 Alternatywa nieco bardziej skomplikowane jest nowy wyjątku i zachować informacje stosu wywołań oryginalnego wyjątku w wyjątek wewnętrzny. Obiekt wywołujący można następnie użyć nowy wyjątek <xref:System.Exception.InnerException%2A> właściwość służąca do pobierania ramki stosu i inne informacje o oryginalnego wyjątku. W tym przypadku jest instrukcji "throw":  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 Kod użytkownika, który obsługuje wyjątek ma poinformować, że <xref:System.Exception.InnerException%2A> właściwość zawiera informacje o oryginalnego wyjątku, tak jak pokazano w poniższym obsługi wyjątków.  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>Wybieranie standardowych wyjątków  
 Jeśli masz zgłosić wyjątek, często służy istniejącego typu wyjątku w .NET Framework, a nie Implementowanie niestandardowego wyjątku. Należy korzystać z typu Standardowy wyjątek w ramach tych dwóch warunków:  
  
-   Czy zostanie zgłoszony wyjątek, który jest spowodowany przez błąd użycia (oznacza to błąd w logice programu przez dewelopera, który wywołuje metodę). Zazwyczaj spowoduje zgłoszenie wyjątku takich jak <xref:System.ArgumentException>, <xref:System.ArgumentNullException>, <xref:System.InvalidOperationException>, lub <xref:System.NotSupportedException>. Ciąg, który podasz konstruktora obiektu wyjątku, podczas tworzenia wystąpienia obiektu wyjątku powinna opisywać błąd, dzięki czemu deweloper może go naprawić. Aby uzyskać więcej informacji, zobacz <xref:System.Exception.Message%2A> właściwości.  
  
-   Czy obsługa błąd, który może być przekazywane do obiektu wywołującego, z wyjątkiem istniejących .NET Framework. Należy zgłosić wyjątek najbardziej pochodnej, która jest możliwe. Na przykład, jeśli metoda wymaga argumentu jest prawidłowym elementem członkowskim typu wyliczeniowego, powinien zgłaszać <xref:System.ComponentModel.InvalidEnumArgumentException> (najbardziej pochodnej klasy), a nie <xref:System.ArgumentException>.  
  
 W poniższej tabeli wymieniono typowe typy wyjątków i warunki, na których będzie zgłaszają je.  
  
|Wyjątek|Warunek|  
|---------------|---------------|  
|<xref:System.ArgumentException>|Argument inną niż null, który jest przekazywany do metody jest nieprawidłowy.|  
|<xref:System.ArgumentNullException>|Argument, który jest przekazywany do metody jest `null`.|  
|<xref:System.ArgumentOutOfRangeException>|Argument jest poza zakresem prawidłowych wartości.|  
|<xref:System.IO.DirectoryNotFoundException>|Część ścieżki katalogu jest nieprawidłowy.|  
|<xref:System.DivideByZeroException>|Denominator w liczbą całkowitą lub <xref:System.Decimal> operacji dzielenia wynosi zero.|  
|<xref:System.IO.DriveNotFoundException>|Dysk jest niedostępny lub nie istnieje.|  
|<xref:System.IO.FileNotFoundException>|Plik nie istnieje.|  
|<xref:System.FormatException>|Wartość nie jest w odpowiednim formacie, który ma zostać przekonwertowany z ciągu za pomocą metody konwersji, takie jak `Parse`.|  
|<xref:System.IndexOutOfRangeException>|Indeks jest poza granicami tablicy lub kolekcji.|  
|<xref:System.InvalidOperationException>|Wywołanie metody jest nieprawidłowy w bieżącym stanie obiektu.|  
|<xref:System.Collections.Generic.KeyNotFoundException>|Nie można odnaleźć określonego klucza do uzyskiwania dostępu do elementu członkowskiego w kolekcji.|  
|<xref:System.NotImplementedException>|Metoda lub operacja nie jest zaimplementowana.|  
|<xref:System.NotSupportedException>|Metoda lub operacja nie jest obsługiwana.|  
|<xref:System.ObjectDisposedException>|Operacja jest wykonywana na obiekt, który został usunięty.|  
|<xref:System.OverflowException>|Operacje arytmetyczne, rzutowania lub konwersji operacja powoduje przepełnienie.|  
|<xref:System.IO.PathTooLongException>|Nazwa pliku lub ścieżki przekracza maksymalną długość zdefiniowaną przez system.|  
|<xref:System.PlatformNotSupportedException>|Operacja nie jest obsługiwana na bieżącej platformie.|  
|<xref:System.RankException>|Tablica z nieprawidłową liczbą wymiarów jest przekazywany do metody.|  
|<xref:System.TimeoutException>|Przedział czasu przydzielony na wykonanie operacji wygasł.|  
|<xref:System.UriFormatException>|Nieprawidłowy identyfikator (URI) jest używany.|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>Implementowanie wyjątków niestandardowych  
 Przy użyciu istniejących wyjątek .NET Framework do obsługi warunek błędu nie jest w następujących przypadkach odpowiednia:  
  
-   Gdy wyjątek odzwierciedla błąd unikatowy program, który nie może być mapowana na istniejące wyjątek .NET Framework.  
  
-   Gdy wyjątek wymaga obsługi, który różni się od obsługi, który jest odpowiedni dla istniejących wyjątek .NET Framework lub wyjątku, musi rozróżniane z podobnych wyjątku. Na przykład, jeśli Generowanie <xref:System.ArgumentOutOfRangeException> wyjątek podczas analizowania reprezentację liczbową ciąg, który znajduje się poza zakresem typu całkowitego docelowej, nie chcesz używać ten sam wyjątek wystąpił błąd powstały na skutek obiekt wywołujący nie podano odpowiednie wartości ograniczone podczas wywoływania metody.  
  
 <xref:System.Exception> Klasa jest klasą bazową wszystkich wyjątków w programie .NET Framework. Wiele klas pochodnych opierają się na zachowaniu dziedziczonych członków <xref:System.Exception> klasy; nie zastępowały one członkowie <xref:System.Exception>, ani nie mogą określać żadnych unikatowych elementów członkowskich.  
  
 Aby zdefiniować własne klasy wyjątku:  
  
1.  Definiowanie klasy, która dziedziczy po elemencie <xref:System.Exception>. Jeśli to konieczne, należy zdefiniować żadnych unikatowych elementów członkowskich wymagane przez klasy, aby podać dodatkowe informacje o wyjątku. Na przykład <xref:System.ArgumentException> klasa zawiera <xref:System.ArgumentException.ParamName%2A> właściwość, która określa nazwę parametru, którego argument spowodował wyjątek, a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> zawiera właściwość <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> właściwość, która określa interwał limitu czasu.  
  
2.  Jeśli to konieczne, należy zastąpić wszystkie dziedziczone elementy członkowskie funkcji, których chcesz zmieniać ani modyfikować. Należy pamiętać, że większość istniejących pochodne klasy <xref:System.Exception> nie zastępują zachowanie dziedziczone elementy członkowskie.  
  
3.  Ustal, czy obiekt niestandardowy wyjątek jest możliwy do serializacji. Serializacja umożliwia zapisanie informacji o wyjątku i pozwala na informacje o wyjątku współdzielonych przez pracowników i serwera proxy klienta w kontekście usług zdalnych. Aby obiekt wyjątku serializacji, oznacz go za pomocą <xref:System.SerializableAttribute> atrybutu.  
  
4.  Zdefiniuj Konstruktory klasy wyjątku. Zazwyczaj klasy wyjątków mają co najmniej jedną z następujących konstruktorów:  
  
    -   <xref:System.Exception.%23ctor>, który używa domyślnych wartości do zainicjowania właściwości nowy obiekt wyjątku.  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>, która inicjuje nowy obiekt wyjątku z określonym komunikatem o błędzie.  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, która inicjuje nowy obiekt wyjątku z określonego błędu wiadomości i wewnętrzny wyjątek.  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, która jest `protected` danych serializowanych na fragmenty Konstruktor, który inicjuje nowy obiekt wyjątku. Ten konstruktor powinien implementować, jeśli wybrano możliwy do serializacji obiektu wyjątku.  
  
 Poniższy przykład ilustruje użycie klasy niestandardowy wyjątek. Definiuje `NotPrimeException` wyjątek, który jest zgłaszany, gdy klient próbuje pobrać sekwencję liczb pierwszych, określając początkowy numer, który nie jest podstawowym. Wyjątek definiuje nową właściwość `NonPrime`, która zwraca innych niż prime numer który spowodował wyjątek. Oprócz wykonania chroniony konstruktor bez parametrów i konstruktora z <xref:System.Runtime.Serialization.SerializationInfo> i <xref:System.Runtime.Serialization.StreamingContext> parametry w celu serializacji, `NotPrimeException` klasa definiuje trzy konstruktory dodatkowe do obsługi `NonPrime` właściwości.  Każdy Konstruktor wywołuje konstruktora klasy bazowej, oprócz zachowania wartości z innych niż liczba pierwsza. `NotPrimeException` Klasy, również jest oznaczona za pomocą <xref:System.SerializableAttribute> atrybutu.  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator` Pokazano w poniższym przykładzie klasa używa nazwanego sitem Eratostenesa do obliczania sekwencji liczb pierwszych od 2 do limitu określonego przez klienta w wywołaniu do jej konstruktora klasy. `GetPrimesFrom` Metoda zwraca wszystkie liczby pierwsze, które są większe niż lub równa określonej dolną granicę, ale zgłasza `NotPrimeException` Jeśli tego dolną granicę nie jest liczba pierwsza.  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 Poniższy przykład wykonuje dwa wywołania `GetPrimesFrom` metody przy użyciu innego niż liczb pierwszych, z których jedna przekracza granice domen aplikacji. W obu przypadkach wyjątek jest generowany i pomyślnie obsłużony w kodzie klienta.  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows Runtime i [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 W [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] dla [!INCLUDE[win8](~/includes/win8-md.md)], niektóre informacje o wyjątku jest zazwyczaj utracone w przypadku, gdy wyjątek jest propagowany przez ramek stosu — .NET Framework. Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)] i [!INCLUDE[win81](~/includes/win81-md.md)], środowisko uruchomieniowe języka wspólnego w dalszym ciągu używa oryginalny <xref:System.Exception> obiektu, który został zgłoszony, chyba że ten wyjątek został zmodyfikowany w ramce stosu — .NET Framework.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `catch` blok, który jest zdefiniowany w celu obsługi <xref:System.ArithmeticException> błędy. To `catch` również zablokować połowy <xref:System.DivideByZeroException> błędy, ponieważ <xref:System.DivideByZeroException> pochodzi od klasy <xref:System.ArithmeticException> i ma nie `catch` jawnie określony dla bloku <xref:System.DivideByZeroException> błędy.  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwości nowego wystąpienia dostarczane przez system komunikatu, opisujący błąd i uwzględnia bieżącej kultury systemu.  
  
 Wszystkie klasy pochodne powinny dostarczyć ten konstruktor domyślny. W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Exception>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Zlokalizowany opis dostarczany przez system.|  
  
   
  
## Examples  
 Poniższy przykładowy kod pochodzi `Exception` , który używa wstępnie zdefiniowaną wiadomość. Demonstruje użycie konstruktora bez parametrów dla klasy pochodnej, a podstawą `Exception` klasy.  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który opisuje błąd.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy przy użyciu określonego komunikatu o błędzie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwości nowego wystąpienia przy użyciu `message` parametru. Jeśli `message` parametr jest `null`, to jest taka sama, co wywołanie metody <xref:System.Exception.%23ctor%2A> konstruktora.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Exception>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
   
  
## Examples  
 Poniższy przykładowy kod pochodzi `Exception` dla określonego warunku. Przykład demonstruje użycie konstruktora przyjmującego komunikat określony przez obiekt wywołujący jako parametru, zarówno w klasie pochodnej, jak i w bazie `Exception` klasy.  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Zawierający dane zserializowanego obiektu dotyczące zgłaszanego wyjątku.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> Zawierający informacje kontekstowe o źródle lub miejscu docelowym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy z serializowanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana podczas deserializacji do odtworzenia obiektu wyjątku przesyłanego za pomocą strumienia. Aby uzyskać więcej informacji, zobacz [XML oraz serializacji protokołu SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
   
  
## Examples  
 Poniższy kod definiuje pochodnej serializacji `Exception` klasy. Kod wymusza błąd dzielenie przez 0, a następnie tworzy wystąpienie klasy pochodnej wyjątków za pomocą (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) konstruktora. Kod wykonuje serializację wystąpień z plikiem, deserializuje pliku do nowy wyjątek wyniku weryfikacji zgłasza wyjątek, a następnie przechwytuje i wyświetla dane o wyjątkach.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Nazwa klasy jest <see langword="null" /> lub <see cref="P:System.Exception.HResult" /> wynosi zero (0).</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat o błędzie wyjaśniający przyczynę wyjątku.</param>
        <param name="innerException">Wyjątek będący przyczyną bieżącego wyjątku lub odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), jeśli jest określony żaden wyjątek wewnętrzny.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Exception" /> klasy przy użyciu określonego komunikatu o błędzie i odwołania do wewnętrznego wyjątku, który jest przyczyną tego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek generowany jako bezpośredni wynik poprzedniego wyjątku powinien zawierać odwołanie do poprzedniego wyjątku we <xref:System.Exception.InnerException%2A> właściwości. <xref:System.Exception.InnerException%2A> Właściwość zwraca taką samą wartość, która jest przekazywana do konstruktora, lub odwołanie o wartości null (`Nothing` w języku Visual Basic) jeżeli <xref:System.Exception.InnerException%2A> nie dostarcza wartości wewnętrznego wyjątku do konstruktora.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Exception>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie do wewnętrznego wyjątku.|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
   
  
## Examples  
 Poniższy przykładowy kod pochodzi `Exception` dla określonego warunku. Przykład demonstruje użycie konstruktora przyjmującego komunikat i wyjątek wewnętrzny, jako parametry, zarówno w klasie pochodnej, jak i w bazie `Exception` klasy.  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję par klucz/wartość, które zawierają dodatkowe informacje zdefiniowane przez użytkownika o wyjątku.</summary>
        <value>Obiekt, który implementuje <see cref="T:System.Collections.IDictionary" /> interfejs i zawiera kolekcję par klucz/wartość zdefiniowanych przez użytkownika. Wartością domyślną jest pusta kolekcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Collections.IDictionary?displayProperty=nameWithType> obiektu zwróconego przez <xref:System.Exception.Data%2A> właściwość, aby przechowywać i pobierać informacje dodatkowe, które są odpowiednie do wyjątku. Informacje są w formularzu dowolną liczbę par klucz/wartość zdefiniowanych przez użytkownika. Kluczowym elementem każdej pary klucz/wartość jest zazwyczaj ciąg identyfikujący składnik wartości pary mogą być dowolnego typu obiektu.  
  
## <a name="keyvalue-pair-security"></a>Zabezpieczenia pary klucz/wartość  
 Pary klucz/wartość przechowywana w kolekcji zwróconej przez <xref:System.Exception.Data%2A> właściwości nie są bezpieczne. Jeśli Twoja aplikacja wywołuje szereg zagnieżdżonych procedury, a każda procedura zawiera obsługi wyjątków, wynikowy stos wywołań zawiera hierarchię tych programów obsługi wyjątków. Jeśli procedura niższego poziomu zgłasza wyjątek, wszystkie obsługi wyjątków wyższego poziomu w hierarchii stos wywołań może odczytywać i/lub zmodyfikować pary klucz/wartość przechowywanych w kolekcji przez inne obsługi wyjątków. Oznacza to, że musisz gwarantować, że informacje zawarte w pary klucz/wartość nie jest poufne i że aplikacja będzie działać prawidłowo Jeśli informacje zawarte w pary klucz/wartość jest uszkodzony.  
  
## <a name="key-conflicts"></a>Konflikty klucza  
 Konflikt klucza występuje, gdy programy obsługi wyjątków różnych określić ten sam klucz dostępu jest parą klucz/wartość do. Tworzenie aplikacji, ponieważ konsekwencją konflikt klucza jest, że programy obsługi wyjątków niższego poziomu przypadkowo mogą komunikować się z wyższego poziomu obsługi wyjątków, a ta komunikacja może spowodować błędy subtelne programu, należy zachować ostrożność. Jednak w przypadku należy zachować ostrożność umożliwia konfliktów klucza ulepszanie aplikacji.  
  
## <a name="avoiding-key-conflicts"></a>Unikanie konfliktów klucza  
 Przyjęcie konwencji nazewnictwa do generowania unikatowego klucza dla pary klucz/wartość, aby uniknąć konfliktów klucza. Na przykład konwencji nazewnictwa może przynieść klucza, który składa się z nazwą rozdzielanego kropką aplikacji, metody, która zawiera dodatkowe informacje dotyczące pary i unikatowy identyfikator.  
  
 Załóżmy, że dwie aplikacje o nazwie produktów i dostawców, każda ma metodę o nazwie sprzedaży. Metoda sprzedaży w aplikacji produktów zawiera numer identyfikacyjny (magazynową lub jednostki SKU) produktu. Metoda sprzedaży w aplikacji dostawcy zawiera numer identyfikacyjny lub identyfikator SID dostawcy. W związku z tym konwencji nazewnictwa, w tym przykładzie daje kluczy "Products.Sales.SKU" i "Suppliers.Sales.SID".  
  
## <a name="exploiting-key-conflicts"></a>Wykorzystanie konfliktów klucza  
 Wykorzystanie konfliktów klucza przy użyciu obecności co najmniej jeden klucz specjalną, wstępnie ustalane do kontrolowania przetwarzania. Załóżmy scenariusz, najwyższego poziomu obsługi wyjątków w hierarchii stosu wywołań przechwytuje wszystkie wyjątki generowane przez programy obsługi wyjątków niższego poziomu. Jeśli istnieje para klucza i wartości, przy użyciu specjalnego klucza, program obsługi wyjątków wyższego poziomu formatuje pozostałe pary klucz/wartość w <xref:System.Collections.IDictionary> obiektu w jakiś sposób niestandardowych; w przeciwnym razie pozostałe pary klucz/wartość są formatowane w normalny sposób.  
  
 Teraz załóżmy, w innym scenariuszu program obsługi wyjątków, na każdym poziomie hierarchii stosu wywołań przechwytuje wyjątek zgłoszony przez kolejna procedura obsługi wyjątków niższego poziomu. Ponadto każdy program obsługi wyjątków zna zbiorze zwróconym przez <xref:System.Exception.Data%2A> właściwość zawiera zestaw pary klucz/wartość, które mogą być udostępniane za pomocą wstępnie ustalane zestawu kluczy.  
  
 Każdy program obsługi wyjątków używa wstępnie ustalane zestawu kluczy do aktualizacji składnik wartości w odpowiednich pary klucz/wartość przy użyciu informacji specyficznych dla tego programu obsługi wyjątków. Po zakończeniu procesu aktualizacji program obsługi wyjątków zgłasza wyjątek do następnego wyższego poziomu obsługi wyjątków. Na koniec najwyższego poziomu obsługi wyjątków uzyskuje dostęp do pary klucz/wartość i wyświetla informacje o aktualizacji skonsolidowanego z całej obsługi wyjątku z niższego poziomu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodawanie i pobieranie informacji za pomocą <xref:System.Exception.Data%2A> właściwości.  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Exception" /> czyli główną przyczynę jeden lub kilka kolejnych wyjątków.</summary>
        <returns>Pierwszy wyjątek w łańcuchu wyjątków. Jeśli <see cref="P:System.Exception.InnerException" /> właściwość bieżący wyjątek jest odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), ta właściwość zwraca bieżący wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Łańcuch wyjątków zawiera zestaw wyjątków tak, aby każdy w łańcuchu wyjątek bezpośrednio z powodu wyjątku, do którego odwołuje się jego `InnerException` właściwości. Dla danego łańcucha może istnieć dokładnie jeden wyjątek, który jest główną przyczynę wszystkie wyjątki w łańcuchu. Wyjątek ten jest nazywany wyjątek podstawowy i jego `InnerException` właściwość zawsze zawiera odwołanie o wartości null.  
  
 Dla wszystkich wyjątków w łańcuchu wyjątków `GetBaseException` metoda musi zwracać ten sam obiekt (podstawowy wyjątek).  
  
 Użyj `GetBaseException` metody, gdy chcesz znaleźć przyczynę wyjątku, ale nie potrzebujących informacji dotyczących wyjątków, które mogły wystąpić między bieżący wyjątek i pierwszy wyjątek.  
  
   
  
## Examples  
 Poniższy kod definiuje dwa pochodne `Exception` klasy. Jego wymusza wyjątek, a następnie go generuje ponownie z każdą z klas pochodnych. Kod pokazuje użycie klasy `GetBaseException` metodę, aby pobrać oryginalnego wyjątku.  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="GetBaseException" /> Metoda zostanie przesłonięta w klasach, które wymagają kontroli nad wyjątek zawartość lub format.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Zawierający dane zserializowanego obiektu dotyczące zgłaszanego wyjątku.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> Zawierający informacje kontekstowe o źródle lub miejscu docelowym.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> przy użyciu informacji o wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` Ustawia <xref:System.Runtime.Serialization.SerializationInfo> ze wszystkimi danymi obiekt wyjątku, przeznaczony dla serializacji. Podczas deserializacji, wyjątek jest odtworzonych z `SerializationInfo` przesyłanego w strumieniu.  
  
   
  
## Examples  
 Poniższy kod definiuje pochodnej serializacji `Exception` klasę, która implementuje `GetObjectData`, co sprawia, że drobne zmiany do dwie właściwości, a następnie wywołania, klasy bazowej, aby wykonać serializacji. Przykład wymusza błąd dzielenie przez 0, a następnie tworzy wystąpienie klasy pochodnej wyjątek. Kod wykonuje serializację wystąpień z plikiem, deserializuje pliku do nowy wyjątek wyniku weryfikacji zgłasza wyjątek, a następnie przechwytuje i wyświetla dane o wyjątkach.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> Parametr to odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ środowiska uruchomieniowego bieżącego wystąpienia.</summary>
        <returns>Element <see cref="T:System.Type" /> obiektu, który reprezentuje typ dokładnego czasu wykonywania bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.GetType%2A> Metoda istnieje obsługuje infrastrukturę .NET Framework i wewnętrznie wywołuje metodę podstawową, <xref:System.Object.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia łącze, aby plik pomocy skojarzony z tym wyjątkiem.</summary>
        <value>Nazwa zasobu jednolite (URN) lub adres URL (adres URL).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana, który reprezentuje plik pomocy, jest adres URL lub URN. Na przykład `HelpLink` może to być:  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 Poniższy kod zgłasza przykład `Exception` określająca `HelpLink` właściwości w jego konstruktorze, a następnie połowy wyjątek i wyświetla `HelpLink`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość HRESULT, kodowane wartość liczbową, która jest przypisana do określonego wyjątku.</summary>
        <value>Wartość HRESULT.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość HRESULT jest 32-bitową wartość podzielone na trzy różne pola: kod ważność, kod funkcji i kod błędu. Kod ważności Określa, czy zwracana wartość reprezentuje informacje, ostrzeżenia lub błędu. Kod funkcji identyfikuje obszaru systemem odpowiedzialnym za błąd. Kod błędu to unikatowy numer, który jest przypisany do reprezentowania wyjątku. Każdy wyjątek jest zamapowana na różne HRESULT. Gdy zarządzany kod zgłasza wyjątek, środowisko uruchomieniowe przekazuje HRESULT do klient modelu COM. Po powrocie z kodem niezarządzanym błąd HRESULT jest konwertowana na wyjątek, który następnie jest generowany w czasie wykonywania. Aby uzyskać informacje o wartości HRESULT i ich odpowiednie wyjątki .NET Framework, zobacz [jak: Mapa wyników HRESULT i wyjątków](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md). Zobacz [typowe wartości HRESULT](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) w dokumentacji programu Windows listę wartości, możesz z największym prawdopodobieństwem mogą wystąpić.  
  
 Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Exception.HResult%2A> właściwości metody ustawiającej są chronione, natomiast pobierającej nie jest publiczny.  W poprzednich wersjach programu .NET Framework zarówno metodę getter i setter są chronione.  
  
   
  
## Examples  
 Poniższy kod definiuje pochodnej `Exception` klasy, która ustawia `HResult` właściwości niestandardowej wartości w jego konstruktorze.  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Exception" /> wystąpienia, który spowodował bieżący wyjątek.</summary>
        <value>Obiekt, który opisuje błąd, który spowodował bieżący wyjątek. <see cref="P:System.Exception.InnerException" /> Właściwość zwraca taką samą wartość jak została przekazana do <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> konstruktora, lub <see langword="null" /> Jeśli nie podano wartości wewnętrznego wyjątku do konstruktora. Ta właściwość jest tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyjątek `X` jest generowany jako bezpośredni wynik poprzedniego wyjątku `Y`, <xref:System.Exception.InnerException%2A> właściwość `X` powinien zawierać odwołanie do `Y`.  
  
 Użyj <xref:System.Exception.InnerException%2A> właściwości, aby uzyskać zestaw wyjątków, które doprowadziły do bieżącego wyjątku.  
  
 Możesz utworzyć nowy wyjątek, który wyłapuje wyjątek wcześniej. Kod, że uchwyty, wprowadzić drugi wyjątek umożliwia dodatkowych informacji z wcześniejszych wyjątek bardziej odpowiednio obsłużyć błąd.  
  
 Załóżmy, że funkcja, która odczytuje plik i formatuje dane z tego pliku. W tym przykładzie jako kod próbuje odczytać pliku <xref:System.IO.IOException> zgłaszany. Funkcja przechwytuje <xref:System.IO.IOException> i zgłasza <xref:System.IO.FileNotFoundException>. <xref:System.IO.IOException> Mogły zostać zapisane w <xref:System.Exception.InnerException%2A> właściwość <xref:System.IO.FileNotFoundException>, umożliwiając kod, który przechwytuje <xref:System.IO.FileNotFoundException> zbadać przyczynę błędu początkowej.  
  
 <xref:System.Exception.InnerException%2A> Ustawiono właściwość, która zawiera odwołanie do wewnętrznego wyjątku, po zainicjowaniu obiektu wyjątku.  
  
   
  
## Examples  
 Poniższy przykład ilustruje zgłaszania i przechwytywania wyjątek, który odwołuje się do wyjątku wewnętrznego.  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera komunikat, który opisuje bieżący wyjątek.</summary>
        <value>Komunikat o błędzie wyjaśniający przyczynę wyjątku lub ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikaty o błędach przeznaczone dla deweloperów, który jest obsługa wyjątku. Tekst <xref:System.Exception.Message%2A> właściwość całkowicie powinna opisywać błąd i, jeśli to możliwe, należy również wyjaśniają, jak do naprawienia błędu. Programy obsługi wyjątków najwyższego poziomu mogą być wyświetlane komunikat do użytkowników końcowych, dlatego należy upewnić się, że jest poprawnych gramatycznie i że każde zdanie wiadomości kończy się kropką. Nie należy używać znaków zapytania lub wykrzykniki. Jeśli aplikacja używa komunikaty o wyjątkach zlokalizowane, należy upewnić się, że dokładnie translacji.  
  
> [!IMPORTANT]
>  Nie ujawniaj poufnych informacji w komunikaty o wyjątkach bez sprawdzania pod kątem odpowiednich uprawnień.  
  
 Wartość <xref:System.Exception.Message%2A> uwzględniono informacje zwrócone przez właściwość <xref:System.Exception.ToString%2A>. <xref:System.Exception.Message%2A> Właściwość jest ustawiona tylko wtedy, gdy tworzenie <xref:System.Exception>. Jeśli żaden komunikat nie został dostarczony do konstruktora dla bieżącego wystąpienia, system zawiera wiadomość domyślną, która jest formatowana przy użyciu bieżącej kultury systemu.  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows Runtime i [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)] i [!INCLUDE[win81](~/includes/win81-md.md)], Lepsza wierności komunikaty o błędach z wyjątków, które zostały przeniesione z typami środowiska wykonawczego Windows i elementów członkowskich, które nie są częścią programu .NET Framework. W szczególności wyjątek komunikaty z rozszerzeniami składnika środowiska Visual C++ (C + +/ CX) są teraz propagowane do .NET Framework <xref:System.Exception> obiektów.  
  
   
  
## Examples  
 Poniższy kod zgłasza wyjątek, a następnie przechwytuje <xref:System.Exception> wyjątek i wyświetla tekst wyjątku komunikat przy użyciu <xref:System.Exception.Message%2A> właściwości.
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli zgłoszenie wyjątku z właściwością, a także musisz odwołać się w tekście <see cref="P:System.Exception.Message" /> właściwości argumentu, który set lub get, użyj "value" jako nazwy właściwości argumentu.</para>
        </block>
        <block subset="none" type="overrides">
          <para>
            <see cref="P:System.Exception.Message" /> Właściwość nie zostanie zastąpiona w klasach, które wymagają kontroli nad format lub zawartość komunikatu. Kod aplikacji zwykle uzyskuje dostęp do tej właściwości kiedy zachodzi potrzeba wyświetlenia informacji na temat wyjątek, który został przechwycony.  Komunikat o błędzie powinien być zlokalizowany.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek jest serializowana. Aby utworzyć obiekt stan wyjątku, który zawiera serializowane dane o wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt stanu wyjątek implementuje <xref:System.Runtime.Serialization.ISafeSerializationData> interfejsu.  
  
 Gdy <xref:System.Exception.SerializeObjectState> subskrybuje zdarzenia, wyjątek jest przeprowadzona i utworzony jako pusty wyjątek. Konstruktor tego wyjątku nie jest uruchamiane, a stan wyjątku jest również przeprowadzona. <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> Metody wywołania zwrotnego stanu obiektu wyjątku następnie zostanie powiadomiony, tak, aby go można wypchnąć danych zdeserializowany do pustego wyjątku.  
  
 <xref:System.Exception.SerializeObjectState> Zdarzeń umożliwia typów wyjątków przezroczyste do serializacji i deserializacji danych wyjątku. Kod o przezroczystym można wykonywać polecenia w granicach zestawu uprawnień, który działa wewnątrz, ale nie można wykonać, wywołania, pochodzi od lub zawierać kodu krytycznego.  
  
 Jeśli <xref:System.Exception.SerializeObjectState> zdarzeń nie jest subskrybentem, deserializacji występuje w zwykły sposób przy użyciu <xref:System.Exception.%23ctor%2A> konstruktora.  
  
 Zazwyczaj procedury obsługi dla <xref:System.Exception.SerializeObjectState> zdarzenie zostanie dodany do konstruktora wyjątków w celu zapewnienia jego serializacji. Ale ponieważ Konstruktor nie jest wykonana przy <xref:System.Exception.SerializeObjectState> wykonuje procedury obsługi zdarzeń, serializowania zdeserializowana wyjątek może zgłosić <xref:System.Runtime.Serialization.SerializationException> wyjątek podczas próby deserializacji wyjątku. Aby tego uniknąć, należy również dodać program obsługi dla <xref:System.Exception.SerializeObjectState> zdarzenia w <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> metody. Zobacz sekcję przykłady ilustrację.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `BadDivisionException` obsługująca <xref:System.Exception.SerializeObjectState> zdarzeń. Zawiera również obiekt stanu, który jest zagnieżdżoną struktury o nazwie `BadDivisionExceptionState` implementującej <xref:System.Runtime.Serialization.ISafeSerializationData> interfejsu.  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException` Wyjątek jest zgłaszany, gdy występuje Zmiennoprzecinkowe dzielenie przez zero. Podczas pierwszego dzielenie przez zero, tworzy przykład `BadDivisionException` obiektu serializuje go i zgłasza wyjątek. Po wystąpieniu kolejnych podziałów przez zero, przykład deserializuje wcześniej Zserializowany obiekt reserializes go i zgłasza wyjątek. Aby zapewnić odpowiedzialność za serializację obiektu, deserializacji, reserialization i deserializacji, w przykładzie dodano <xref:System.Exception.SerializeObjectState> programu obsługi zdarzeń zarówno w `BadDivisionException` konstruktora klasy i w <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> implementacji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli to zdarzenie jest subskrybowania i używania, wszystkie typy pochodne, które należy wykonać w hierarchii dziedziczenia musi implementować ten sam mechanizm serializacji.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę aplikacji lub obiekt, który powoduje błąd.</summary>
        <value>Nazwa aplikacji lub obiekt, który powoduje błąd.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Exception.Source%2A> właściwość nie została jawnie ustawiona, środowisko wykonawcze automatycznie ustawia jego nazwa zestawu, w którym wyjątek pochodzi.  
  
   
  
## Examples  
 Poniższy przykład generuje `Exception` określająca `Source` właściwości w jego konstruktorze, a następnie połowy wyjątek i wyświetla `Source`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Obiekt musi być środowisko uruchomieniowe <see cref="N:System.Reflection" /> obiektu</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera reprezentację ciągu natychmiastowego ramek na stosie wywołań.</summary>
        <value>Ciąg, który opisuje natychmiastowego ramki stosu wywołań.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stos wykonywania przechowuje informacje o wszystkich metod, które są wykonywane w danej chwili. Śledzenie wywołań metody jest wywoływana ślad stosu. Lista śledzenia stosu zapewnia sposób wykonaj stos wywołań do numeru wiersza w metodzie, gdzie występuje wyjątek.  
  
 <xref:System.Exception.StackTrace%2A> Właściwość zwraca ramki stosu wywołań, które pochodzi z lokalizacji, w którym został zgłoszony wyjątek. Możesz uzyskać informacje na temat dodatkowych ramek na stosie wywołań, tworząc nowe wystąpienie klasy <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> klasy i używanie jej <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> metody.  
  
 Środowisko uruchomieniowe języka wspólnego (CLR) aktualizuje ślad stosu, zawsze wtedy, gdy wyjątek jest zgłaszany w kodzie aplikacji (przy użyciu `throw` — słowo kluczowe). Jeśli wyjątek był zgłaszany ponownie w metodzie, która jest inna niż metody, gdzie pierwotnie został zgłoszony, ślad stosu zawiera zarówno w metodzie w lokalizacji, w którym pierwotnie został zgłoszony wyjątek, jak i w metodzie w lokalizacji, w którym wyjątek zgłaszany ponownie. Jeśli wyjątek jest generowany i później ponownie zgłaszany, w tej samej metody, ślad stosu zawiera tylko lokalizacji, w którym wyjątek był zgłaszany ponownie i nie ma lokalizacji, w którym pierwotnie został zgłoszony wyjątek.  
  
 <xref:System.Exception.StackTrace%2A> Właściwości mogą nie zgłaszać dowolną liczbę wywołań metod, zgodnie z oczekiwaniami z powodu kodu transformacji, takie jak wbudowanie, które występują podczas tej optymalizacji.  
  
   
  
## Examples  
 Poniższy kod zgłasza przykład `Exception` go przechwycił i wyświetla ślad stosu przy użyciu `StackTrace` właściwości.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="StackTrace" /> Właściwość nie zostanie zastąpiona w klasach, które wymagają kontroli nad stosu śledzenia zawartość lub format.  Domyślnie ślad stosu są przechwytywane natychmiast, zanim zostanie zgłoszony obiekt wyjątku. Użyj <see cref="P:System.Environment.StackTrace" /> Aby uzyskać informacje o śladzie stosu, gdy jest zgłaszany żaden wyjątek.</para>
        </block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę, która bieżący wyjątek.</summary>
        <value>
          <see cref="T:System.Reflection.MethodBase" /> Zgłosił, bieżący wyjątek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda, która zgłasza ten wyjątek nie jest dostępny i ślad stosu nie jest odwołanie o wartości null (`Nothing` w języku Visual Basic), <xref:System.Exception.TargetSite%2A> uzyskuje metody ślad stosu. Jeśli ślad stosu jest odwołanie o wartości null, <xref:System.Exception.TargetSite%2A> również zwraca odwołanie o wartości null.  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A> Właściwość nie może precyzyjnie nazwę metody, w którym został zgłoszony wyjątek, jeśli program obsługi wyjątku obsługuje wyjątek poza granice domeny aplikacji.  
  
   
  
## Examples  
 Poniższy kod zgłasza przykład `Exception` go przechwycił i Wyświetla źródłowy przy użyciu metody `TargetSite` właściwości.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca reprezentację ciągu bieżącego wyjątku.</summary>
        <returns>Reprezentacja ciągu bieżącego wyjątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> Zwraca reprezentację bieżącego wyjątku, który ma być zrozumiała dla ludzi. W przypadku, gdy wyjątek zawiera dane wrażliwe na ustawienia kulturowe, reprezentacja ciągu zwracane przez `ToString` jest wymagany do uwzględnienia bieżącej kultury systemu. Mimo że nie istnieją wymagania dokładny format zwracanego ciągu, należy próbować odzwierciedlać wartość obiektu jako postrzegany przez użytkownika.  
  
 Domyślna implementacja klasy <xref:System.Exception.ToString%2A> uzyskuje nazwę klasy, która zgłosiła bieżącego wyjątku, wiadomość, w wyniku wywołania metody <xref:System.Exception.ToString%2A> na wewnętrzny wyjątek, a w wyniku wywołania metody <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>. W przypadku spełnienia któregoś z tych elementów członkowskich `null`, jego wartość nie jest uwzględniona w zwracanym ciągu.  
  
 Jeśli nie ma błędów lub jest pustym ciągiem (""), zwracana jest bez komunikatu o błędzie. Nazwa wewnętrznego wyjątku i ślad stosu są zwracane tylko wtedy, gdy nie są one `null`.  
  
 Ta metoda zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład powoduje wyjątek i wyświetla wynik wywołania metody <xref:System.Exception.ToString%2A> na ten wyjątek. Należy pamiętać, że <xref:System.Exception.ToString%2A?displayProperty=nameWithType> metoda jest wywoływana niejawnie, gdy wystąpienie klasy wyjątku pojawi się na liście argumentów <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody.  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>